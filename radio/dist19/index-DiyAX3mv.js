function iy(d) {
  return d && d.__esModule && Object.prototype.hasOwnProperty.call(d, "default") ? d.default : d;
}
var ky = { exports: {} }, um = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var s0;
function t1() {
  if (s0) return um;
  s0 = 1;
  var d = Symbol.for("react.transitional.element"), o = Symbol.for("react.fragment");
  function m(b, M, z) {
    var S = null;
    if (z !== void 0 && (S = "" + z), M.key !== void 0 && (S = "" + M.key), "key" in M) {
      z = {};
      for (var u in M)
        u !== "key" && (z[u] = M[u]);
    } else z = M;
    return M = z.ref, {
      $$typeof: d,
      type: b,
      key: S,
      ref: M !== void 0 ? M : null,
      props: z
    };
  }
  return um.Fragment = o, um.jsx = m, um.jsxs = m, um;
}
var o0;
function i1() {
  return o0 || (o0 = 1, ky.exports = t1()), ky.exports;
}
var Se = i1(), Ry = { exports: {} }, gi = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l0;
function n1() {
  if (l0) return gi;
  l0 = 1;
  var d = Symbol.for("react.transitional.element"), o = Symbol.for("react.portal"), m = Symbol.for("react.fragment"), b = Symbol.for("react.strict_mode"), M = Symbol.for("react.profiler"), z = Symbol.for("react.consumer"), S = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), O = Symbol.for("react.suspense"), U = Symbol.for("react.memo"), K = Symbol.for("react.lazy"), ae = Symbol.for("react.activity"), he = Symbol.iterator;
  function J(fe) {
    return fe === null || typeof fe != "object" ? null : (fe = he && fe[he] || fe["@@iterator"], typeof fe == "function" ? fe : null);
  }
  var ke = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, qe = Object.assign, ft = {};
  function ht(fe, Ue, et) {
    this.props = fe, this.context = Ue, this.refs = ft, this.updater = et || ke;
  }
  ht.prototype.isReactComponent = {}, ht.prototype.setState = function(fe, Ue) {
    if (typeof fe != "object" && typeof fe != "function" && fe != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, fe, Ue, "setState");
  }, ht.prototype.forceUpdate = function(fe) {
    this.updater.enqueueForceUpdate(this, fe, "forceUpdate");
  };
  function it() {
  }
  it.prototype = ht.prototype;
  function nt(fe, Ue, et) {
    this.props = fe, this.context = Ue, this.refs = ft, this.updater = et || ke;
  }
  var De = nt.prototype = new it();
  De.constructor = nt, qe(De, ht.prototype), De.isPureReactComponent = !0;
  var Re = Array.isArray;
  function $e() {
  }
  var rt = { H: null, A: null, T: null, S: null }, wt = Object.prototype.hasOwnProperty;
  function Ht(fe, Ue, et) {
    var dt = et.ref;
    return {
      $$typeof: d,
      type: fe,
      key: Ue,
      ref: dt !== void 0 ? dt : null,
      props: et
    };
  }
  function Dt(fe, Ue) {
    return Ht(fe.type, Ue, fe.props);
  }
  function Xt(fe) {
    return typeof fe == "object" && fe !== null && fe.$$typeof === d;
  }
  function pi(fe) {
    var Ue = { "=": "=0", ":": "=2" };
    return "$" + fe.replace(/[=:]/g, function(et) {
      return Ue[et];
    });
  }
  var vn = /\/+/g;
  function Cn(fe, Ue) {
    return typeof fe == "object" && fe !== null && fe.key != null ? pi("" + fe.key) : Ue.toString(36);
  }
  function zn(fe) {
    switch (fe.status) {
      case "fulfilled":
        return fe.value;
      case "rejected":
        throw fe.reason;
      default:
        switch (typeof fe.status == "string" ? fe.then($e, $e) : (fe.status = "pending", fe.then(
          function(Ue) {
            fe.status === "pending" && (fe.status = "fulfilled", fe.value = Ue);
          },
          function(Ue) {
            fe.status === "pending" && (fe.status = "rejected", fe.reason = Ue);
          }
        )), fe.status) {
          case "fulfilled":
            return fe.value;
          case "rejected":
            throw fe.reason;
        }
    }
    throw fe;
  }
  function He(fe, Ue, et, dt, Pt) {
    var Vt = typeof fe;
    (Vt === "undefined" || Vt === "boolean") && (fe = null);
    var si = !1;
    if (fe === null) si = !0;
    else
      switch (Vt) {
        case "bigint":
        case "string":
        case "number":
          si = !0;
          break;
        case "object":
          switch (fe.$$typeof) {
            case d:
            case o:
              si = !0;
              break;
            case K:
              return si = fe._init, He(
                si(fe._payload),
                Ue,
                et,
                dt,
                Pt
              );
          }
      }
    if (si)
      return Pt = Pt(fe), si = dt === "" ? "." + Cn(fe, 0) : dt, Re(Pt) ? (et = "", si != null && (et = si.replace(vn, "$&/") + "/"), He(Pt, Ue, et, "", function(Ta) {
        return Ta;
      })) : Pt != null && (Xt(Pt) && (Pt = Dt(
        Pt,
        et + (Pt.key == null || fe && fe.key === Pt.key ? "" : ("" + Pt.key).replace(
          vn,
          "$&/"
        ) + "/") + si
      )), Ue.push(Pt)), 1;
    si = 0;
    var Ii = dt === "" ? "." : dt + ":";
    if (Re(fe))
      for (var xi = 0; xi < fe.length; xi++)
        dt = fe[xi], Vt = Ii + Cn(dt, xi), si += He(
          dt,
          Ue,
          et,
          Vt,
          Pt
        );
    else if (xi = J(fe), typeof xi == "function")
      for (fe = xi.call(fe), xi = 0; !(dt = fe.next()).done; )
        dt = dt.value, Vt = Ii + Cn(dt, xi++), si += He(
          dt,
          Ue,
          et,
          Vt,
          Pt
        );
    else if (Vt === "object") {
      if (typeof fe.then == "function")
        return He(
          zn(fe),
          Ue,
          et,
          dt,
          Pt
        );
      throw Ue = String(fe), Error(
        "Objects are not valid as a React child (found: " + (Ue === "[object Object]" ? "object with keys {" + Object.keys(fe).join(", ") + "}" : Ue) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return si;
  }
  function vt(fe, Ue, et) {
    if (fe == null) return fe;
    var dt = [], Pt = 0;
    return He(fe, dt, "", "", function(Vt) {
      return Ue.call(et, Vt, Pt++);
    }), dt;
  }
  function Gt(fe) {
    if (fe._status === -1) {
      var Ue = fe._result;
      Ue = Ue(), Ue.then(
        function(et) {
          (fe._status === 0 || fe._status === -1) && (fe._status = 1, fe._result = et);
        },
        function(et) {
          (fe._status === 0 || fe._status === -1) && (fe._status = 2, fe._result = et);
        }
      ), fe._status === -1 && (fe._status = 0, fe._result = Ue);
    }
    if (fe._status === 1) return fe._result.default;
    throw fe._result;
  }
  var at = typeof reportError == "function" ? reportError : function(fe) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var Ue = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof fe == "object" && fe !== null && typeof fe.message == "string" ? String(fe.message) : String(fe),
        error: fe
      });
      if (!window.dispatchEvent(Ue)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", fe);
      return;
    }
    console.error(fe);
  }, Et = {
    map: vt,
    forEach: function(fe, Ue, et) {
      vt(
        fe,
        function() {
          Ue.apply(this, arguments);
        },
        et
      );
    },
    count: function(fe) {
      var Ue = 0;
      return vt(fe, function() {
        Ue++;
      }), Ue;
    },
    toArray: function(fe) {
      return vt(fe, function(Ue) {
        return Ue;
      }) || [];
    },
    only: function(fe) {
      if (!Xt(fe))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return fe;
    }
  };
  return gi.Activity = ae, gi.Children = Et, gi.Component = ht, gi.Fragment = m, gi.Profiler = M, gi.PureComponent = nt, gi.StrictMode = b, gi.Suspense = O, gi.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = rt, gi.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(fe) {
      return rt.H.useMemoCache(fe);
    }
  }, gi.cache = function(fe) {
    return function() {
      return fe.apply(null, arguments);
    };
  }, gi.cacheSignal = function() {
    return null;
  }, gi.cloneElement = function(fe, Ue, et) {
    if (fe == null)
      throw Error(
        "The argument must be a React element, but you passed " + fe + "."
      );
    var dt = qe({}, fe.props), Pt = fe.key;
    if (Ue != null)
      for (Vt in Ue.key !== void 0 && (Pt = "" + Ue.key), Ue)
        !wt.call(Ue, Vt) || Vt === "key" || Vt === "__self" || Vt === "__source" || Vt === "ref" && Ue.ref === void 0 || (dt[Vt] = Ue[Vt]);
    var Vt = arguments.length - 2;
    if (Vt === 1) dt.children = et;
    else if (1 < Vt) {
      for (var si = Array(Vt), Ii = 0; Ii < Vt; Ii++)
        si[Ii] = arguments[Ii + 2];
      dt.children = si;
    }
    return Ht(fe.type, Pt, dt);
  }, gi.createContext = function(fe) {
    return fe = {
      $$typeof: S,
      _currentValue: fe,
      _currentValue2: fe,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, fe.Provider = fe, fe.Consumer = {
      $$typeof: z,
      _context: fe
    }, fe;
  }, gi.createElement = function(fe, Ue, et) {
    var dt, Pt = {}, Vt = null;
    if (Ue != null)
      for (dt in Ue.key !== void 0 && (Vt = "" + Ue.key), Ue)
        wt.call(Ue, dt) && dt !== "key" && dt !== "__self" && dt !== "__source" && (Pt[dt] = Ue[dt]);
    var si = arguments.length - 2;
    if (si === 1) Pt.children = et;
    else if (1 < si) {
      for (var Ii = Array(si), xi = 0; xi < si; xi++)
        Ii[xi] = arguments[xi + 2];
      Pt.children = Ii;
    }
    if (fe && fe.defaultProps)
      for (dt in si = fe.defaultProps, si)
        Pt[dt] === void 0 && (Pt[dt] = si[dt]);
    return Ht(fe, Vt, Pt);
  }, gi.createRef = function() {
    return { current: null };
  }, gi.forwardRef = function(fe) {
    return { $$typeof: u, render: fe };
  }, gi.isValidElement = Xt, gi.lazy = function(fe) {
    return {
      $$typeof: K,
      _payload: { _status: -1, _result: fe },
      _init: Gt
    };
  }, gi.memo = function(fe, Ue) {
    return {
      $$typeof: U,
      type: fe,
      compare: Ue === void 0 ? null : Ue
    };
  }, gi.startTransition = function(fe) {
    var Ue = rt.T, et = {};
    rt.T = et;
    try {
      var dt = fe(), Pt = rt.S;
      Pt !== null && Pt(et, dt), typeof dt == "object" && dt !== null && typeof dt.then == "function" && dt.then($e, at);
    } catch (Vt) {
      at(Vt);
    } finally {
      Ue !== null && et.types !== null && (Ue.types = et.types), rt.T = Ue;
    }
  }, gi.unstable_useCacheRefresh = function() {
    return rt.H.useCacheRefresh();
  }, gi.use = function(fe) {
    return rt.H.use(fe);
  }, gi.useActionState = function(fe, Ue, et) {
    return rt.H.useActionState(fe, Ue, et);
  }, gi.useCallback = function(fe, Ue) {
    return rt.H.useCallback(fe, Ue);
  }, gi.useContext = function(fe) {
    return rt.H.useContext(fe);
  }, gi.useDebugValue = function() {
  }, gi.useDeferredValue = function(fe, Ue) {
    return rt.H.useDeferredValue(fe, Ue);
  }, gi.useEffect = function(fe, Ue) {
    return rt.H.useEffect(fe, Ue);
  }, gi.useEffectEvent = function(fe) {
    return rt.H.useEffectEvent(fe);
  }, gi.useId = function() {
    return rt.H.useId();
  }, gi.useImperativeHandle = function(fe, Ue, et) {
    return rt.H.useImperativeHandle(fe, Ue, et);
  }, gi.useInsertionEffect = function(fe, Ue) {
    return rt.H.useInsertionEffect(fe, Ue);
  }, gi.useLayoutEffect = function(fe, Ue) {
    return rt.H.useLayoutEffect(fe, Ue);
  }, gi.useMemo = function(fe, Ue) {
    return rt.H.useMemo(fe, Ue);
  }, gi.useOptimistic = function(fe, Ue) {
    return rt.H.useOptimistic(fe, Ue);
  }, gi.useReducer = function(fe, Ue, et) {
    return rt.H.useReducer(fe, Ue, et);
  }, gi.useRef = function(fe) {
    return rt.H.useRef(fe);
  }, gi.useState = function(fe) {
    return rt.H.useState(fe);
  }, gi.useSyncExternalStore = function(fe, Ue, et) {
    return rt.H.useSyncExternalStore(
      fe,
      Ue,
      et
    );
  }, gi.useTransition = function() {
    return rt.H.useTransition();
  }, gi.version = "19.2.0", gi;
}
var u0;
function k_() {
  return u0 || (u0 = 1, Ry.exports = n1()), Ry.exports;
}
var ei = k_();
const Eu = /* @__PURE__ */ iy(ei);
var Dy = { exports: {} }, cm = {}, Ly = { exports: {} }, Oy = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var c0;
function a1() {
  return c0 || (c0 = 1, (function(d) {
    function o(He, vt) {
      var Gt = He.length;
      He.push(vt);
      e: for (; 0 < Gt; ) {
        var at = Gt - 1 >>> 1, Et = He[at];
        if (0 < M(Et, vt))
          He[at] = vt, He[Gt] = Et, Gt = at;
        else break e;
      }
    }
    function m(He) {
      return He.length === 0 ? null : He[0];
    }
    function b(He) {
      if (He.length === 0) return null;
      var vt = He[0], Gt = He.pop();
      if (Gt !== vt) {
        He[0] = Gt;
        e: for (var at = 0, Et = He.length, fe = Et >>> 1; at < fe; ) {
          var Ue = 2 * (at + 1) - 1, et = He[Ue], dt = Ue + 1, Pt = He[dt];
          if (0 > M(et, Gt))
            dt < Et && 0 > M(Pt, et) ? (He[at] = Pt, He[dt] = Gt, at = dt) : (He[at] = et, He[Ue] = Gt, at = Ue);
          else if (dt < Et && 0 > M(Pt, Gt))
            He[at] = Pt, He[dt] = Gt, at = dt;
          else break e;
        }
      }
      return vt;
    }
    function M(He, vt) {
      var Gt = He.sortIndex - vt.sortIndex;
      return Gt !== 0 ? Gt : He.id - vt.id;
    }
    if (d.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var z = performance;
      d.unstable_now = function() {
        return z.now();
      };
    } else {
      var S = Date, u = S.now();
      d.unstable_now = function() {
        return S.now() - u;
      };
    }
    var O = [], U = [], K = 1, ae = null, he = 3, J = !1, ke = !1, qe = !1, ft = !1, ht = typeof setTimeout == "function" ? setTimeout : null, it = typeof clearTimeout == "function" ? clearTimeout : null, nt = typeof setImmediate < "u" ? setImmediate : null;
    function De(He) {
      for (var vt = m(U); vt !== null; ) {
        if (vt.callback === null) b(U);
        else if (vt.startTime <= He)
          b(U), vt.sortIndex = vt.expirationTime, o(O, vt);
        else break;
        vt = m(U);
      }
    }
    function Re(He) {
      if (qe = !1, De(He), !ke)
        if (m(O) !== null)
          ke = !0, $e || ($e = !0, pi());
        else {
          var vt = m(U);
          vt !== null && zn(Re, vt.startTime - He);
        }
    }
    var $e = !1, rt = -1, wt = 5, Ht = -1;
    function Dt() {
      return ft ? !0 : !(d.unstable_now() - Ht < wt);
    }
    function Xt() {
      if (ft = !1, $e) {
        var He = d.unstable_now();
        Ht = He;
        var vt = !0;
        try {
          e: {
            ke = !1, qe && (qe = !1, it(rt), rt = -1), J = !0;
            var Gt = he;
            try {
              t: {
                for (De(He), ae = m(O); ae !== null && !(ae.expirationTime > He && Dt()); ) {
                  var at = ae.callback;
                  if (typeof at == "function") {
                    ae.callback = null, he = ae.priorityLevel;
                    var Et = at(
                      ae.expirationTime <= He
                    );
                    if (He = d.unstable_now(), typeof Et == "function") {
                      ae.callback = Et, De(He), vt = !0;
                      break t;
                    }
                    ae === m(O) && b(O), De(He);
                  } else b(O);
                  ae = m(O);
                }
                if (ae !== null) vt = !0;
                else {
                  var fe = m(U);
                  fe !== null && zn(
                    Re,
                    fe.startTime - He
                  ), vt = !1;
                }
              }
              break e;
            } finally {
              ae = null, he = Gt, J = !1;
            }
            vt = void 0;
          }
        } finally {
          vt ? pi() : $e = !1;
        }
      }
    }
    var pi;
    if (typeof nt == "function")
      pi = function() {
        nt(Xt);
      };
    else if (typeof MessageChannel < "u") {
      var vn = new MessageChannel(), Cn = vn.port2;
      vn.port1.onmessage = Xt, pi = function() {
        Cn.postMessage(null);
      };
    } else
      pi = function() {
        ht(Xt, 0);
      };
    function zn(He, vt) {
      rt = ht(function() {
        He(d.unstable_now());
      }, vt);
    }
    d.unstable_IdlePriority = 5, d.unstable_ImmediatePriority = 1, d.unstable_LowPriority = 4, d.unstable_NormalPriority = 3, d.unstable_Profiling = null, d.unstable_UserBlockingPriority = 2, d.unstable_cancelCallback = function(He) {
      He.callback = null;
    }, d.unstable_forceFrameRate = function(He) {
      0 > He || 125 < He ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : wt = 0 < He ? Math.floor(1e3 / He) : 5;
    }, d.unstable_getCurrentPriorityLevel = function() {
      return he;
    }, d.unstable_next = function(He) {
      switch (he) {
        case 1:
        case 2:
        case 3:
          var vt = 3;
          break;
        default:
          vt = he;
      }
      var Gt = he;
      he = vt;
      try {
        return He();
      } finally {
        he = Gt;
      }
    }, d.unstable_requestPaint = function() {
      ft = !0;
    }, d.unstable_runWithPriority = function(He, vt) {
      switch (He) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          He = 3;
      }
      var Gt = he;
      he = He;
      try {
        return vt();
      } finally {
        he = Gt;
      }
    }, d.unstable_scheduleCallback = function(He, vt, Gt) {
      var at = d.unstable_now();
      switch (typeof Gt == "object" && Gt !== null ? (Gt = Gt.delay, Gt = typeof Gt == "number" && 0 < Gt ? at + Gt : at) : Gt = at, He) {
        case 1:
          var Et = -1;
          break;
        case 2:
          Et = 250;
          break;
        case 5:
          Et = 1073741823;
          break;
        case 4:
          Et = 1e4;
          break;
        default:
          Et = 5e3;
      }
      return Et = Gt + Et, He = {
        id: K++,
        callback: vt,
        priorityLevel: He,
        startTime: Gt,
        expirationTime: Et,
        sortIndex: -1
      }, Gt > at ? (He.sortIndex = Gt, o(U, He), m(O) === null && He === m(U) && (qe ? (it(rt), rt = -1) : qe = !0, zn(Re, Gt - at))) : (He.sortIndex = Et, o(O, He), ke || J || (ke = !0, $e || ($e = !0, pi()))), He;
    }, d.unstable_shouldYield = Dt, d.unstable_wrapCallback = function(He) {
      var vt = he;
      return function() {
        var Gt = he;
        he = vt;
        try {
          return He.apply(this, arguments);
        } finally {
          he = Gt;
        }
      };
    };
  })(Oy)), Oy;
}
var h0;
function r1() {
  return h0 || (h0 = 1, Ly.exports = a1()), Ly.exports;
}
var By = { exports: {} }, Hr = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var d0;
function s1() {
  if (d0) return Hr;
  d0 = 1;
  var d = k_();
  function o(O) {
    var U = "https://react.dev/errors/" + O;
    if (1 < arguments.length) {
      U += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var K = 2; K < arguments.length; K++)
        U += "&args[]=" + encodeURIComponent(arguments[K]);
    }
    return "Minified React error #" + O + "; visit " + U + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function m() {
  }
  var b = {
    d: {
      f: m,
      r: function() {
        throw Error(o(522));
      },
      D: m,
      C: m,
      L: m,
      m,
      X: m,
      S: m,
      M: m
    },
    p: 0,
    findDOMNode: null
  }, M = Symbol.for("react.portal");
  function z(O, U, K) {
    var ae = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: M,
      key: ae == null ? null : "" + ae,
      children: O,
      containerInfo: U,
      implementation: K
    };
  }
  var S = d.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function u(O, U) {
    if (O === "font") return "";
    if (typeof U == "string")
      return U === "use-credentials" ? U : "";
  }
  return Hr.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = b, Hr.createPortal = function(O, U) {
    var K = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!U || U.nodeType !== 1 && U.nodeType !== 9 && U.nodeType !== 11)
      throw Error(o(299));
    return z(O, U, null, K);
  }, Hr.flushSync = function(O) {
    var U = S.T, K = b.p;
    try {
      if (S.T = null, b.p = 2, O) return O();
    } finally {
      S.T = U, b.p = K, b.d.f();
    }
  }, Hr.preconnect = function(O, U) {
    typeof O == "string" && (U ? (U = U.crossOrigin, U = typeof U == "string" ? U === "use-credentials" ? U : "" : void 0) : U = null, b.d.C(O, U));
  }, Hr.prefetchDNS = function(O) {
    typeof O == "string" && b.d.D(O);
  }, Hr.preinit = function(O, U) {
    if (typeof O == "string" && U && typeof U.as == "string") {
      var K = U.as, ae = u(K, U.crossOrigin), he = typeof U.integrity == "string" ? U.integrity : void 0, J = typeof U.fetchPriority == "string" ? U.fetchPriority : void 0;
      K === "style" ? b.d.S(
        O,
        typeof U.precedence == "string" ? U.precedence : void 0,
        {
          crossOrigin: ae,
          integrity: he,
          fetchPriority: J
        }
      ) : K === "script" && b.d.X(O, {
        crossOrigin: ae,
        integrity: he,
        fetchPriority: J,
        nonce: typeof U.nonce == "string" ? U.nonce : void 0
      });
    }
  }, Hr.preinitModule = function(O, U) {
    if (typeof O == "string")
      if (typeof U == "object" && U !== null) {
        if (U.as == null || U.as === "script") {
          var K = u(
            U.as,
            U.crossOrigin
          );
          b.d.M(O, {
            crossOrigin: K,
            integrity: typeof U.integrity == "string" ? U.integrity : void 0,
            nonce: typeof U.nonce == "string" ? U.nonce : void 0
          });
        }
      } else U == null && b.d.M(O);
  }, Hr.preload = function(O, U) {
    if (typeof O == "string" && typeof U == "object" && U !== null && typeof U.as == "string") {
      var K = U.as, ae = u(K, U.crossOrigin);
      b.d.L(O, K, {
        crossOrigin: ae,
        integrity: typeof U.integrity == "string" ? U.integrity : void 0,
        nonce: typeof U.nonce == "string" ? U.nonce : void 0,
        type: typeof U.type == "string" ? U.type : void 0,
        fetchPriority: typeof U.fetchPriority == "string" ? U.fetchPriority : void 0,
        referrerPolicy: typeof U.referrerPolicy == "string" ? U.referrerPolicy : void 0,
        imageSrcSet: typeof U.imageSrcSet == "string" ? U.imageSrcSet : void 0,
        imageSizes: typeof U.imageSizes == "string" ? U.imageSizes : void 0,
        media: typeof U.media == "string" ? U.media : void 0
      });
    }
  }, Hr.preloadModule = function(O, U) {
    if (typeof O == "string")
      if (U) {
        var K = u(U.as, U.crossOrigin);
        b.d.m(O, {
          as: typeof U.as == "string" && U.as !== "script" ? U.as : void 0,
          crossOrigin: K,
          integrity: typeof U.integrity == "string" ? U.integrity : void 0
        });
      } else b.d.m(O);
  }, Hr.requestFormReset = function(O) {
    b.d.r(O);
  }, Hr.unstable_batchedUpdates = function(O, U) {
    return O(U);
  }, Hr.useFormState = function(O, U, K) {
    return S.H.useFormState(O, U, K);
  }, Hr.useFormStatus = function() {
    return S.H.useHostTransitionStatus();
  }, Hr.version = "19.2.0", Hr;
}
var p0;
function o1() {
  if (p0) return By.exports;
  p0 = 1;
  function d() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(d);
      } catch (o) {
        console.error(o);
      }
  }
  return d(), By.exports = s1(), By.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f0;
function l1() {
  if (f0) return cm;
  f0 = 1;
  var d = r1(), o = k_(), m = o1();
  function b(i) {
    var s = "https://react.dev/errors/" + i;
    if (1 < arguments.length) {
      s += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var h = 2; h < arguments.length; h++)
        s += "&args[]=" + encodeURIComponent(arguments[h]);
    }
    return "Minified React error #" + i + "; visit " + s + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function M(i) {
    return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11);
  }
  function z(i) {
    var s = i, h = i;
    if (i.alternate) for (; s.return; ) s = s.return;
    else {
      i = s;
      do
        s = i, (s.flags & 4098) !== 0 && (h = s.return), i = s.return;
      while (i);
    }
    return s.tag === 3 ? h : null;
  }
  function S(i) {
    if (i.tag === 13) {
      var s = i.memoizedState;
      if (s === null && (i = i.alternate, i !== null && (s = i.memoizedState)), s !== null) return s.dehydrated;
    }
    return null;
  }
  function u(i) {
    if (i.tag === 31) {
      var s = i.memoizedState;
      if (s === null && (i = i.alternate, i !== null && (s = i.memoizedState)), s !== null) return s.dehydrated;
    }
    return null;
  }
  function O(i) {
    if (z(i) !== i)
      throw Error(b(188));
  }
  function U(i) {
    var s = i.alternate;
    if (!s) {
      if (s = z(i), s === null) throw Error(b(188));
      return s !== i ? null : i;
    }
    for (var h = i, g = s; ; ) {
      var A = h.return;
      if (A === null) break;
      var I = A.alternate;
      if (I === null) {
        if (g = A.return, g !== null) {
          h = g;
          continue;
        }
        break;
      }
      if (A.child === I.child) {
        for (I = A.child; I; ) {
          if (I === h) return O(A), i;
          if (I === g) return O(A), s;
          I = I.sibling;
        }
        throw Error(b(188));
      }
      if (h.return !== g.return) h = A, g = I;
      else {
        for (var F = !1, W = A.child; W; ) {
          if (W === h) {
            F = !0, h = A, g = I;
            break;
          }
          if (W === g) {
            F = !0, g = A, h = I;
            break;
          }
          W = W.sibling;
        }
        if (!F) {
          for (W = I.child; W; ) {
            if (W === h) {
              F = !0, h = I, g = A;
              break;
            }
            if (W === g) {
              F = !0, g = I, h = A;
              break;
            }
            W = W.sibling;
          }
          if (!F) throw Error(b(189));
        }
      }
      if (h.alternate !== g) throw Error(b(190));
    }
    if (h.tag !== 3) throw Error(b(188));
    return h.stateNode.current === h ? i : s;
  }
  function K(i) {
    var s = i.tag;
    if (s === 5 || s === 26 || s === 27 || s === 6) return i;
    for (i = i.child; i !== null; ) {
      if (s = K(i), s !== null) return s;
      i = i.sibling;
    }
    return null;
  }
  var ae = Object.assign, he = Symbol.for("react.element"), J = Symbol.for("react.transitional.element"), ke = Symbol.for("react.portal"), qe = Symbol.for("react.fragment"), ft = Symbol.for("react.strict_mode"), ht = Symbol.for("react.profiler"), it = Symbol.for("react.consumer"), nt = Symbol.for("react.context"), De = Symbol.for("react.forward_ref"), Re = Symbol.for("react.suspense"), $e = Symbol.for("react.suspense_list"), rt = Symbol.for("react.memo"), wt = Symbol.for("react.lazy"), Ht = Symbol.for("react.activity"), Dt = Symbol.for("react.memo_cache_sentinel"), Xt = Symbol.iterator;
  function pi(i) {
    return i === null || typeof i != "object" ? null : (i = Xt && i[Xt] || i["@@iterator"], typeof i == "function" ? i : null);
  }
  var vn = Symbol.for("react.client.reference");
  function Cn(i) {
    if (i == null) return null;
    if (typeof i == "function")
      return i.$$typeof === vn ? null : i.displayName || i.name || null;
    if (typeof i == "string") return i;
    switch (i) {
      case qe:
        return "Fragment";
      case ht:
        return "Profiler";
      case ft:
        return "StrictMode";
      case Re:
        return "Suspense";
      case $e:
        return "SuspenseList";
      case Ht:
        return "Activity";
    }
    if (typeof i == "object")
      switch (i.$$typeof) {
        case ke:
          return "Portal";
        case nt:
          return i.displayName || "Context";
        case it:
          return (i._context.displayName || "Context") + ".Consumer";
        case De:
          var s = i.render;
          return i = i.displayName, i || (i = s.displayName || s.name || "", i = i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"), i;
        case rt:
          return s = i.displayName || null, s !== null ? s : Cn(i.type) || "Memo";
        case wt:
          s = i._payload, i = i._init;
          try {
            return Cn(i(s));
          } catch {
          }
      }
    return null;
  }
  var zn = Array.isArray, He = o.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, vt = m.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Gt = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, at = [], Et = -1;
  function fe(i) {
    return { current: i };
  }
  function Ue(i) {
    0 > Et || (i.current = at[Et], at[Et] = null, Et--);
  }
  function et(i, s) {
    Et++, at[Et] = i.current, i.current = s;
  }
  var dt = fe(null), Pt = fe(null), Vt = fe(null), si = fe(null);
  function Ii(i, s) {
    switch (et(Vt, s), et(Pt, i), et(dt, null), s.nodeType) {
      case 9:
      case 11:
        i = (i = s.documentElement) && (i = i.namespaceURI) ? yd(i) : 0;
        break;
      default:
        if (i = s.tagName, s = s.namespaceURI)
          s = yd(s), i = _d(s, i);
        else
          switch (i) {
            case "svg":
              i = 1;
              break;
            case "math":
              i = 2;
              break;
            default:
              i = 0;
          }
    }
    Ue(dt), et(dt, i);
  }
  function xi() {
    Ue(dt), Ue(Pt), Ue(Vt);
  }
  function Ta(i) {
    i.memoizedState !== null && et(si, i);
    var s = dt.current, h = _d(s, i.type);
    s !== h && (et(Pt, i), et(dt, h));
  }
  function bi(i) {
    Pt.current === i && (Ue(dt), Ue(Pt)), si.current === i && (Ue(si), li._currentValue = Gt);
  }
  var oa, an;
  function $i(i) {
    if (oa === void 0)
      try {
        throw Error();
      } catch (h) {
        var s = h.stack.trim().match(/\n( *(at )?)/);
        oa = s && s[1] || "", an = -1 < h.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < h.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + oa + i + an;
  }
  var ma = !1;
  function dr(i, s) {
    if (!i || ma) return "";
    ma = !0;
    var h = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var g = {
        DetermineComponentFrameRoot: function() {
          try {
            if (s) {
              var Ke = function() {
                throw Error();
              };
              if (Object.defineProperty(Ke.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(Ke, []);
                } catch (Ve) {
                  var Ne = Ve;
                }
                Reflect.construct(i, [], Ke);
              } else {
                try {
                  Ke.call();
                } catch (Ve) {
                  Ne = Ve;
                }
                i.call(Ke.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (Ve) {
                Ne = Ve;
              }
              (Ke = i()) && typeof Ke.catch == "function" && Ke.catch(function() {
              });
            }
          } catch (Ve) {
            if (Ve && Ne && typeof Ve.stack == "string")
              return [Ve.stack, Ne.stack];
          }
          return [null, null];
        }
      };
      g.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var A = Object.getOwnPropertyDescriptor(
        g.DetermineComponentFrameRoot,
        "name"
      );
      A && A.configurable && Object.defineProperty(
        g.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var I = g.DetermineComponentFrameRoot(), F = I[0], W = I[1];
      if (F && W) {
        var _e = F.split(`
`), Be = W.split(`
`);
        for (A = g = 0; g < _e.length && !_e[g].includes("DetermineComponentFrameRoot"); )
          g++;
        for (; A < Be.length && !Be[A].includes(
          "DetermineComponentFrameRoot"
        ); )
          A++;
        if (g === _e.length || A === Be.length)
          for (g = _e.length - 1, A = Be.length - 1; 1 <= g && 0 <= A && _e[g] !== Be[A]; )
            A--;
        for (; 1 <= g && 0 <= A; g--, A--)
          if (_e[g] !== Be[A]) {
            if (g !== 1 || A !== 1)
              do
                if (g--, A--, 0 > A || _e[g] !== Be[A]) {
                  var Ze = `
` + _e[g].replace(" at new ", " at ");
                  return i.displayName && Ze.includes("<anonymous>") && (Ze = Ze.replace("<anonymous>", i.displayName)), Ze;
                }
              while (1 <= g && 0 <= A);
            break;
          }
      }
    } finally {
      ma = !1, Error.prepareStackTrace = h;
    }
    return (h = i ? i.displayName || i.name : "") ? $i(h) : "";
  }
  function Xa(i, s) {
    switch (i.tag) {
      case 26:
      case 27:
      case 5:
        return $i(i.type);
      case 16:
        return $i("Lazy");
      case 13:
        return i.child !== s && s !== null ? $i("Suspense Fallback") : $i("Suspense");
      case 19:
        return $i("SuspenseList");
      case 0:
      case 15:
        return dr(i.type, !1);
      case 11:
        return dr(i.type.render, !1);
      case 1:
        return dr(i.type, !0);
      case 31:
        return $i("Activity");
      default:
        return "";
    }
  }
  function Ya(i) {
    try {
      var s = "", h = null;
      do
        s += Xa(i, h), h = i, i = i.return;
      while (i);
      return s;
    } catch (g) {
      return `
Error generating stack: ` + g.message + `
` + g.stack;
    }
  }
  var pr = Object.prototype.hasOwnProperty, Os = d.unstable_scheduleCallback, Xr = d.unstable_cancelCallback, Yr = d.unstable_shouldYield, ho = d.unstable_requestPaint, Yn = d.unstable_now, po = d.unstable_getCurrentPriorityLevel, Bs = d.unstable_ImmediatePriority, Ns = d.unstable_UserBlockingPriority, js = d.unstable_NormalPriority, be = d.unstable_LowPriority, H = d.unstable_IdlePriority, Y = d.log, Q = d.unstable_setDisableYieldValue, le = null, me = null;
  function ve(i) {
    if (typeof Y == "function" && Q(i), me && typeof me.setStrictMode == "function")
      try {
        me.setStrictMode(le, i);
      } catch {
      }
  }
  var Ee = Math.clz32 ? Math.clz32 : tt, Te = Math.log, Ge = Math.LN2;
  function tt(i) {
    return i >>>= 0, i === 0 ? 32 : 31 - (Te(i) / Ge | 0) | 0;
  }
  var Ye = 256, Mt = 262144, Ae = 4194304;
  function qt(i) {
    var s = i & 42;
    if (s !== 0) return s;
    switch (i & -i) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return i & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return i & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return i;
    }
  }
  function ri(i, s, h) {
    var g = i.pendingLanes;
    if (g === 0) return 0;
    var A = 0, I = i.suspendedLanes, F = i.pingedLanes;
    i = i.warmLanes;
    var W = g & 134217727;
    return W !== 0 ? (g = W & ~I, g !== 0 ? A = qt(g) : (F &= W, F !== 0 ? A = qt(F) : h || (h = W & ~i, h !== 0 && (A = qt(h))))) : (W = g & ~I, W !== 0 ? A = qt(W) : F !== 0 ? A = qt(F) : h || (h = g & ~i, h !== 0 && (A = qt(h)))), A === 0 ? 0 : s !== 0 && s !== A && (s & I) === 0 && (I = A & -A, h = s & -s, I >= h || I === 32 && (h & 4194048) !== 0) ? s : A;
  }
  function It(i, s) {
    return (i.pendingLanes & ~(i.suspendedLanes & ~i.pingedLanes) & s) === 0;
  }
  function ti(i, s) {
    switch (i) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return s + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return s + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Yi() {
    var i = Ae;
    return Ae <<= 1, (Ae & 62914560) === 0 && (Ae = 4194304), i;
  }
  function Pn(i) {
    for (var s = [], h = 0; 31 > h; h++) s.push(i);
    return s;
  }
  function xn(i, s) {
    i.pendingLanes |= s, s !== 268435456 && (i.suspendedLanes = 0, i.pingedLanes = 0, i.warmLanes = 0);
  }
  function In(i, s, h, g, A, I) {
    var F = i.pendingLanes;
    i.pendingLanes = h, i.suspendedLanes = 0, i.pingedLanes = 0, i.warmLanes = 0, i.expiredLanes &= h, i.entangledLanes &= h, i.errorRecoveryDisabledLanes &= h, i.shellSuspendCounter = 0;
    var W = i.entanglements, _e = i.expirationTimes, Be = i.hiddenUpdates;
    for (h = F & ~h; 0 < h; ) {
      var Ze = 31 - Ee(h), Ke = 1 << Ze;
      W[Ze] = 0, _e[Ze] = -1;
      var Ne = Be[Ze];
      if (Ne !== null)
        for (Be[Ze] = null, Ze = 0; Ze < Ne.length; Ze++) {
          var Ve = Ne[Ze];
          Ve !== null && (Ve.lane &= -536870913);
        }
      h &= ~Ke;
    }
    g !== 0 && ci(i, g, 0), I !== 0 && A === 0 && i.tag !== 0 && (i.suspendedLanes |= I & ~(F & ~s));
  }
  function ci(i, s, h) {
    i.pendingLanes |= s, i.suspendedLanes &= ~s;
    var g = 31 - Ee(s);
    i.entangledLanes |= s, i.entanglements[g] = i.entanglements[g] | 1073741824 | h & 261930;
  }
  function _i(i, s) {
    var h = i.entangledLanes |= s;
    for (i = i.entanglements; h; ) {
      var g = 31 - Ee(h), A = 1 << g;
      A & s | i[g] & s && (i[g] |= s), h &= ~A;
    }
  }
  function kn(i, s) {
    var h = s & -s;
    return h = (h & 42) !== 0 ? 1 : ot(h), (h & (i.suspendedLanes | s)) !== 0 ? 0 : h;
  }
  function ot(i) {
    switch (i) {
      case 2:
        i = 1;
        break;
      case 8:
        i = 4;
        break;
      case 32:
        i = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        i = 128;
        break;
      case 268435456:
        i = 134217728;
        break;
      default:
        i = 0;
    }
    return i;
  }
  function la(i) {
    return i &= -i, 2 < i ? 8 < i ? (i & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function dn() {
    var i = vt.p;
    return i !== 0 ? i : (i = window.event, i === void 0 ? 32 : ra(i.type));
  }
  function Us(i, s) {
    var h = vt.p;
    try {
      return vt.p = i, s();
    } finally {
      vt.p = h;
    }
  }
  var fr = Math.random().toString(36).slice(2), st = "__reactFiber$" + fr, Zt = "__reactProps$" + fr, Jt = "__reactContainer$" + fr, Kn = "__reactEvents$" + fr, al = "__reactListeners$" + fr, fo = "__reactHandles$" + fr, ii = "__reactResources$" + fr, mo = "__reactMarker$" + fr;
  function ss(i) {
    delete i[st], delete i[Zt], delete i[Kn], delete i[al], delete i[fo];
  }
  function Fs(i) {
    var s = i[st];
    if (s) return s;
    for (var h = i.parentNode; h; ) {
      if (s = h[Jt] || h[st]) {
        if (h = s.alternate, s.child !== null || h !== null && h.child !== null)
          for (i = bd(i); i !== null; ) {
            if (h = i[st]) return h;
            i = bd(i);
          }
        return s;
      }
      i = h, h = i.parentNode;
    }
    return null;
  }
  function Ba(i) {
    if (i = i[st] || i[Jt]) {
      var s = i.tag;
      if (s === 5 || s === 6 || s === 13 || s === 31 || s === 26 || s === 27 || s === 3)
        return i;
    }
    return null;
  }
  function os(i) {
    var s = i.tag;
    if (s === 5 || s === 26 || s === 27 || s === 6) return i.stateNode;
    throw Error(b(33));
  }
  function Qi(i) {
    var s = i[ii];
    return s || (s = i[ii] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), s;
  }
  function Rn(i) {
    i[mo] = !0;
  }
  var Na = /* @__PURE__ */ new Set(), Hi = {};
  function go(i, s) {
    ls(i, s), ls(i + "Capture", s);
  }
  function ls(i, s) {
    for (Hi[i] = s, i = 0; i < s.length; i++)
      Na.add(s[i]);
  }
  var Mh = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), Vs = {}, qs = {};
  function Ah(i) {
    return pr.call(qs, i) ? !0 : pr.call(Vs, i) ? !1 : Mh.test(i) ? qs[i] = !0 : (Vs[i] = !0, !1);
  }
  function ku(i, s, h) {
    if (Ah(s))
      if (h === null) i.removeAttribute(s);
      else {
        switch (typeof h) {
          case "undefined":
          case "function":
          case "symbol":
            i.removeAttribute(s);
            return;
          case "boolean":
            var g = s.toLowerCase().slice(0, 5);
            if (g !== "data-" && g !== "aria-") {
              i.removeAttribute(s);
              return;
            }
        }
        i.setAttribute(s, "" + h);
      }
  }
  function Ru(i, s, h) {
    if (h === null) i.removeAttribute(s);
    else {
      switch (typeof h) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          i.removeAttribute(s);
          return;
      }
      i.setAttribute(s, "" + h);
    }
  }
  function Ka(i, s, h, g) {
    if (g === null) i.removeAttribute(h);
    else {
      switch (typeof g) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          i.removeAttribute(h);
          return;
      }
      i.setAttributeNS(s, h, "" + g);
    }
  }
  function mr(i) {
    switch (typeof i) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return i;
      case "object":
        return i;
      default:
        return "";
    }
  }
  function qd(i) {
    var s = i.type;
    return (i = i.nodeName) && i.toLowerCase() === "input" && (s === "checkbox" || s === "radio");
  }
  function nf(i, s, h) {
    var g = Object.getOwnPropertyDescriptor(
      i.constructor.prototype,
      s
    );
    if (!i.hasOwnProperty(s) && typeof g < "u" && typeof g.get == "function" && typeof g.set == "function") {
      var A = g.get, I = g.set;
      return Object.defineProperty(i, s, {
        configurable: !0,
        get: function() {
          return A.call(this);
        },
        set: function(F) {
          h = "" + F, I.call(this, F);
        }
      }), Object.defineProperty(i, s, {
        enumerable: g.enumerable
      }), {
        getValue: function() {
          return h;
        },
        setValue: function(F) {
          h = "" + F;
        },
        stopTracking: function() {
          i._valueTracker = null, delete i[s];
        }
      };
    }
  }
  function Eh(i) {
    if (!i._valueTracker) {
      var s = qd(i) ? "checked" : "value";
      i._valueTracker = nf(
        i,
        s,
        "" + i[s]
      );
    }
  }
  function Rc(i) {
    if (!i) return !1;
    var s = i._valueTracker;
    if (!s) return !0;
    var h = s.getValue(), g = "";
    return i && (g = qd(i) ? i.checked ? "true" : "false" : i.value), i = g, i !== h ? (s.setValue(i), !0) : !1;
  }
  function Gs(i) {
    if (i = i || (typeof document < "u" ? document : void 0), typeof i > "u") return null;
    try {
      return i.activeElement || i.body;
    } catch {
      return i.body;
    }
  }
  var Ch = /[\n"\\]/g;
  function Wa(i) {
    return i.replace(
      Ch,
      function(s) {
        return "\\" + s.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function yo(i, s, h, g, A, I, F, W) {
    i.name = "", F != null && typeof F != "function" && typeof F != "symbol" && typeof F != "boolean" ? i.type = F : i.removeAttribute("type"), s != null ? F === "number" ? (s === 0 && i.value === "" || i.value != s) && (i.value = "" + mr(s)) : i.value !== "" + mr(s) && (i.value = "" + mr(s)) : F !== "submit" && F !== "reset" || i.removeAttribute("value"), s != null ? Du(i, F, mr(s)) : h != null ? Du(i, F, mr(h)) : g != null && i.removeAttribute("value"), A == null && I != null && (i.defaultChecked = !!I), A != null && (i.checked = A && typeof A != "function" && typeof A != "symbol"), W != null && typeof W != "function" && typeof W != "symbol" && typeof W != "boolean" ? i.name = "" + mr(W) : i.removeAttribute("name");
  }
  function Dc(i, s, h, g, A, I, F, W) {
    if (I != null && typeof I != "function" && typeof I != "symbol" && typeof I != "boolean" && (i.type = I), s != null || h != null) {
      if (!(I !== "submit" && I !== "reset" || s != null)) {
        Eh(i);
        return;
      }
      h = h != null ? "" + mr(h) : "", s = s != null ? "" + mr(s) : h, W || s === i.value || (i.value = s), i.defaultValue = s;
    }
    g = g ?? A, g = typeof g != "function" && typeof g != "symbol" && !!g, i.checked = W ? i.checked : !!g, i.defaultChecked = !!g, F != null && typeof F != "function" && typeof F != "symbol" && typeof F != "boolean" && (i.name = F), Eh(i);
  }
  function Du(i, s, h) {
    s === "number" && Gs(i.ownerDocument) === i || i.defaultValue === "" + h || (i.defaultValue = "" + h);
  }
  function Fl(i, s, h, g) {
    if (i = i.options, s) {
      s = {};
      for (var A = 0; A < h.length; A++)
        s["$" + h[A]] = !0;
      for (h = 0; h < i.length; h++)
        A = s.hasOwnProperty("$" + i[h].value), i[h].selected !== A && (i[h].selected = A), A && g && (i[h].defaultSelected = !0);
    } else {
      for (h = "" + mr(h), s = null, A = 0; A < i.length; A++) {
        if (i[A].value === h) {
          i[A].selected = !0, g && (i[A].defaultSelected = !0);
          return;
        }
        s !== null || i[A].disabled || (s = i[A]);
      }
      s !== null && (s.selected = !0);
    }
  }
  function rl(i, s, h) {
    if (s != null && (s = "" + mr(s), s !== i.value && (i.value = s), h == null)) {
      i.defaultValue !== s && (i.defaultValue = s);
      return;
    }
    i.defaultValue = h != null ? "" + mr(h) : "";
  }
  function Vl(i, s, h, g) {
    if (s == null) {
      if (g != null) {
        if (h != null) throw Error(b(92));
        if (zn(g)) {
          if (1 < g.length) throw Error(b(93));
          g = g[0];
        }
        h = g;
      }
      h == null && (h = ""), s = h;
    }
    h = mr(s), i.defaultValue = h, g = i.textContent, g === h && g !== "" && g !== null && (i.value = g), Eh(i);
  }
  function Ma(i, s) {
    if (s) {
      var h = i.firstChild;
      if (h && h === i.lastChild && h.nodeType === 3) {
        h.nodeValue = s;
        return;
      }
    }
    i.textContent = s;
  }
  var hi = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function _o(i, s, h) {
    var g = s.indexOf("--") === 0;
    h == null || typeof h == "boolean" || h === "" ? g ? i.setProperty(s, "") : s === "float" ? i.cssFloat = "" : i[s] = "" : g ? i.setProperty(s, h) : typeof h != "number" || h === 0 || hi.has(s) ? s === "float" ? i.cssFloat = h : i[s] = ("" + h).trim() : i[s] = h + "px";
  }
  function Zs(i, s, h) {
    if (s != null && typeof s != "object")
      throw Error(b(62));
    if (i = i.style, h != null) {
      for (var g in h)
        !h.hasOwnProperty(g) || s != null && s.hasOwnProperty(g) || (g.indexOf("--") === 0 ? i.setProperty(g, "") : g === "float" ? i.cssFloat = "" : i[g] = "");
      for (var A in s)
        g = s[A], s.hasOwnProperty(A) && h[A] !== g && _o(i, A, g);
    } else
      for (var I in s)
        s.hasOwnProperty(I) && _o(i, I, s[I]);
  }
  function Kr(i) {
    if (i.indexOf("-") === -1) return !1;
    switch (i) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var sl = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), di = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function us(i) {
    return di.test("" + i) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : i;
  }
  function Rr() {
  }
  var ql = null;
  function ga(i) {
    return i = i.target || i.srcElement || window, i.correspondingUseElement && (i = i.correspondingUseElement), i.nodeType === 3 ? i.parentNode : i;
  }
  var bn = null, Vn = null;
  function Dn(i) {
    var s = Ba(i);
    if (s && (i = s.stateNode)) {
      var h = i[Zt] || null;
      e: switch (i = s.stateNode, s.type) {
        case "input":
          if (yo(
            i,
            h.value,
            h.defaultValue,
            h.defaultValue,
            h.checked,
            h.defaultChecked,
            h.type,
            h.name
          ), s = h.name, h.type === "radio" && s != null) {
            for (h = i; h.parentNode; ) h = h.parentNode;
            for (h = h.querySelectorAll(
              'input[name="' + Wa(
                "" + s
              ) + '"][type="radio"]'
            ), s = 0; s < h.length; s++) {
              var g = h[s];
              if (g !== i && g.form === i.form) {
                var A = g[Zt] || null;
                if (!A) throw Error(b(90));
                yo(
                  g,
                  A.value,
                  A.defaultValue,
                  A.defaultValue,
                  A.checked,
                  A.defaultChecked,
                  A.type,
                  A.name
                );
              }
            }
            for (s = 0; s < h.length; s++)
              g = h[s], g.form === i.form && Rc(g);
          }
          break e;
        case "textarea":
          rl(i, h.value, h.defaultValue);
          break e;
        case "select":
          s = h.value, s != null && Fl(i, !!h.multiple, s, !1);
      }
    }
  }
  var Ui = !1;
  function zh(i, s, h) {
    if (Ui) return i(s, h);
    Ui = !0;
    try {
      var g = i(s);
      return g;
    } finally {
      if (Ui = !1, (bn !== null || Vn !== null) && (Sc(), bn && (s = bn, i = Vn, Vn = bn = null, Dn(s), i)))
        for (s = 0; s < i.length; s++) Dn(i[s]);
    }
  }
  function Wn(i, s) {
    var h = i.stateNode;
    if (h === null) return null;
    var g = h[Zt] || null;
    if (g === null) return null;
    h = g[s];
    e: switch (s) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (g = !g.disabled) || (i = i.type, g = !(i === "button" || i === "input" || i === "select" || i === "textarea")), i = !g;
        break e;
      default:
        i = !1;
    }
    if (i) return null;
    if (h && typeof h != "function")
      throw Error(
        b(231, s, typeof h)
      );
    return h;
  }
  var Ln = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ua = !1;
  if (Ln)
    try {
      var Fi = {};
      Object.defineProperty(Fi, "passive", {
        get: function() {
          ua = !0;
        }
      }), window.addEventListener("test", Fi, Fi), window.removeEventListener("test", Fi, Fi);
    } catch {
      ua = !1;
    }
  var Ja = null, Ut = null, Wt = null;
  function cs() {
    if (Wt) return Wt;
    var i, s = Ut, h = s.length, g, A = "value" in Ja ? Ja.value : Ja.textContent, I = A.length;
    for (i = 0; i < h && s[i] === A[i]; i++) ;
    var F = h - i;
    for (g = 1; g <= F && s[h - g] === A[I - g]; g++) ;
    return Wt = A.slice(i, 1 < g ? 1 - g : void 0);
  }
  function fi(i) {
    var s = i.keyCode;
    return "charCode" in i ? (i = i.charCode, i === 0 && s === 13 && (i = 13)) : i = s, i === 10 && (i = 13), 32 <= i || i === 13 ? i : 0;
  }
  function Aa() {
    return !0;
  }
  function Wr() {
    return !1;
  }
  function wn(i) {
    function s(h, g, A, I, F) {
      this._reactName = h, this._targetInst = A, this.type = g, this.nativeEvent = I, this.target = F, this.currentTarget = null;
      for (var W in i)
        i.hasOwnProperty(W) && (h = i[W], this[W] = h ? h(I) : I[W]);
      return this.isDefaultPrevented = (I.defaultPrevented != null ? I.defaultPrevented : I.returnValue === !1) ? Aa : Wr, this.isPropagationStopped = Wr, this;
    }
    return ae(s.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var h = this.nativeEvent;
        h && (h.preventDefault ? h.preventDefault() : typeof h.returnValue != "unknown" && (h.returnValue = !1), this.isDefaultPrevented = Aa);
      },
      stopPropagation: function() {
        var h = this.nativeEvent;
        h && (h.stopPropagation ? h.stopPropagation() : typeof h.cancelBubble != "unknown" && (h.cancelBubble = !0), this.isPropagationStopped = Aa);
      },
      persist: function() {
      },
      isPersistent: Aa
    }), s;
  }
  var hs = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(i) {
      return i.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, Gl = wn(hs), ds = ae({}, hs, { view: 0, detail: 0 }), Lu = wn(ds), Zl, $l, vo, Qa = ae({}, ds, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: ll,
    button: 0,
    buttons: 0,
    relatedTarget: function(i) {
      return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget;
    },
    movementX: function(i) {
      return "movementX" in i ? i.movementX : (i !== vo && (vo && i.type === "mousemove" ? (Zl = i.screenX - vo.screenX, $l = i.screenY - vo.screenY) : $l = Zl = 0, vo = i), Zl);
    },
    movementY: function(i) {
      return "movementY" in i ? i.movementY : $l;
    }
  }), Jn = wn(Qa), Hl = ae({}, Qa, { dataTransfer: 0 }), Ou = wn(Hl), ol = ae({}, ds, { relatedTarget: 0 }), pn = wn(ol), Gd = ae({}, hs, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Bu = wn(Gd), Ph = ae({}, hs, {
    clipboardData: function(i) {
      return "clipboardData" in i ? i.clipboardData : window.clipboardData;
    }
  }), af = wn(Ph), Xl = ae({}, hs, { data: 0 }), ca = wn(Xl), Nu = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, ps = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, ju = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function Uu(i) {
    var s = this.nativeEvent;
    return s.getModifierState ? s.getModifierState(i) : (i = ju[i]) ? !!s[i] : !1;
  }
  function ll() {
    return Uu;
  }
  var Ea = ae({}, ds, {
    key: function(i) {
      if (i.key) {
        var s = Nu[i.key] || i.key;
        if (s !== "Unidentified") return s;
      }
      return i.type === "keypress" ? (i = fi(i), i === 13 ? "Enter" : String.fromCharCode(i)) : i.type === "keydown" || i.type === "keyup" ? ps[i.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: ll,
    charCode: function(i) {
      return i.type === "keypress" ? fi(i) : 0;
    },
    keyCode: function(i) {
      return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
    },
    which: function(i) {
      return i.type === "keypress" ? fi(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
    }
  }), Zd = wn(Ea), Lc = ae({}, Qa, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), $d = wn(Lc), Ih = ae({}, ds, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: ll
  }), rf = wn(Ih), sf = ae({}, hs, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Oc = wn(sf), kh = ae({}, Qa, {
    deltaX: function(i) {
      return "deltaX" in i ? i.deltaX : "wheelDeltaX" in i ? -i.wheelDeltaX : 0;
    },
    deltaY: function(i) {
      return "deltaY" in i ? i.deltaY : "wheelDeltaY" in i ? -i.wheelDeltaY : "wheelDelta" in i ? -i.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), ul = wn(kh), Rh = ae({}, hs, {
    newState: 0,
    oldState: 0
  }), Bc = wn(Rh), Jr = [9, 13, 27, 32], Dh = Ln && "CompositionEvent" in window, xo = null;
  Ln && "documentMode" in document && (xo = document.documentMode);
  var Fu = Ln && "TextEvent" in window && !xo, Yl = Ln && (!Dh || xo && 8 < xo && 11 >= xo), Hd = " ", Vu = !1;
  function Xd(i, s) {
    switch (i) {
      case "keyup":
        return Jr.indexOf(s.keyCode) !== -1;
      case "keydown":
        return s.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function bo(i) {
    return i = i.detail, typeof i == "object" && "data" in i ? i.data : null;
  }
  var cl = !1;
  function Lh(i, s) {
    switch (i) {
      case "compositionend":
        return bo(s);
      case "keypress":
        return s.which !== 32 ? null : (Vu = !0, Hd);
      case "textInput":
        return i = s.data, i === Hd && Vu ? null : i;
      default:
        return null;
    }
  }
  function of(i, s) {
    if (cl)
      return i === "compositionend" || !Dh && Xd(i, s) ? (i = cs(), Wt = Ut = Ja = null, cl = !1, i) : null;
    switch (i) {
      case "paste":
        return null;
      case "keypress":
        if (!(s.ctrlKey || s.altKey || s.metaKey) || s.ctrlKey && s.altKey) {
          if (s.char && 1 < s.char.length)
            return s.char;
          if (s.which) return String.fromCharCode(s.which);
        }
        return null;
      case "compositionend":
        return Yl && s.locale !== "ko" ? null : s.data;
      default:
        return null;
    }
  }
  var Yd = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Nc(i) {
    var s = i && i.nodeName && i.nodeName.toLowerCase();
    return s === "input" ? !!Yd[i.type] : s === "textarea";
  }
  function Oh(i, s, h, g) {
    bn ? Vn ? Vn.push(g) : Vn = [g] : bn = g, s = gd(s, "onChange"), 0 < s.length && (h = new Gl(
      "onChange",
      "change",
      null,
      h,
      g
    ), i.push({ event: h, listeners: s }));
  }
  var wo = null, Kl = null;
  function Kd(i) {
    Cp(i, 0);
  }
  function fs(i) {
    var s = os(i);
    if (Rc(s)) return i;
  }
  function jc(i, s) {
    if (i === "change") return s;
  }
  var Uc = !1;
  if (Ln) {
    var hl;
    if (Ln) {
      var Bh = "oninput" in document;
      if (!Bh) {
        var Wl = document.createElement("div");
        Wl.setAttribute("oninput", "return;"), Bh = typeof Wl.oninput == "function";
      }
      hl = Bh;
    } else hl = !1;
    Uc = hl && (!document.documentMode || 9 < document.documentMode);
  }
  function Nh() {
    wo && (wo.detachEvent("onpropertychange", Wd), Kl = wo = null);
  }
  function Wd(i) {
    if (i.propertyName === "value" && fs(Kl)) {
      var s = [];
      Oh(
        s,
        Kl,
        i,
        ga(i)
      ), zh(Kd, s);
    }
  }
  function Jd(i, s, h) {
    i === "focusin" ? (Nh(), wo = s, Kl = h, wo.attachEvent("onpropertychange", Wd)) : i === "focusout" && Nh();
  }
  function Qd(i) {
    if (i === "selectionchange" || i === "keyup" || i === "keydown")
      return fs(Kl);
  }
  function jh(i, s) {
    if (i === "click") return fs(s);
  }
  function Uh(i, s) {
    if (i === "input" || i === "change")
      return fs(s);
  }
  function ep(i, s) {
    return i === s && (i !== 0 || 1 / i === 1 / s) || i !== i && s !== s;
  }
  var Ca = typeof Object.is == "function" ? Object.is : ep;
  function gr(i, s) {
    if (Ca(i, s)) return !0;
    if (typeof i != "object" || i === null || typeof s != "object" || s === null)
      return !1;
    var h = Object.keys(i), g = Object.keys(s);
    if (h.length !== g.length) return !1;
    for (g = 0; g < h.length; g++) {
      var A = h[g];
      if (!pr.call(s, A) || !Ca(i[A], s[A]))
        return !1;
    }
    return !0;
  }
  function Ci(i) {
    for (; i && i.firstChild; ) i = i.firstChild;
    return i;
  }
  function Fc(i, s) {
    var h = Ci(i);
    i = 0;
    for (var g; h; ) {
      if (h.nodeType === 3) {
        if (g = i + h.textContent.length, i <= s && g >= s)
          return { node: h, offset: s - i };
        i = g;
      }
      e: {
        for (; h; ) {
          if (h.nextSibling) {
            h = h.nextSibling;
            break e;
          }
          h = h.parentNode;
        }
        h = void 0;
      }
      h = Ci(h);
    }
  }
  function Vc(i, s) {
    return i && s ? i === s ? !0 : i && i.nodeType === 3 ? !1 : s && s.nodeType === 3 ? Vc(i, s.parentNode) : "contains" in i ? i.contains(s) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(s) & 16) : !1 : !1;
  }
  function Fh(i) {
    i = i != null && i.ownerDocument != null && i.ownerDocument.defaultView != null ? i.ownerDocument.defaultView : window;
    for (var s = Gs(i.document); s instanceof i.HTMLIFrameElement; ) {
      try {
        var h = typeof s.contentWindow.location.href == "string";
      } catch {
        h = !1;
      }
      if (h) i = s.contentWindow;
      else break;
      s = Gs(i.document);
    }
    return s;
  }
  function qu(i) {
    var s = i && i.nodeName && i.nodeName.toLowerCase();
    return s && (s === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || s === "textarea" || i.contentEditable === "true");
  }
  var dl = Ln && "documentMode" in document && 11 >= document.documentMode, So = null, Vh = null, Gu = null, qh = !1;
  function tp(i, s, h) {
    var g = h.window === h ? h.document : h.nodeType === 9 ? h : h.ownerDocument;
    qh || So == null || So !== Gs(g) || (g = So, "selectionStart" in g && qu(g) ? g = { start: g.selectionStart, end: g.selectionEnd } : (g = (g.ownerDocument && g.ownerDocument.defaultView || window).getSelection(), g = {
      anchorNode: g.anchorNode,
      anchorOffset: g.anchorOffset,
      focusNode: g.focusNode,
      focusOffset: g.focusOffset
    }), Gu && gr(Gu, g) || (Gu = g, g = gd(Vh, "onSelect"), 0 < g.length && (s = new Gl(
      "onSelect",
      "select",
      null,
      s,
      h
    ), i.push({ event: s, listeners: g }), s.target = So)));
  }
  function To(i, s) {
    var h = {};
    return h[i.toLowerCase()] = s.toLowerCase(), h["Webkit" + i] = "webkit" + s, h["Moz" + i] = "moz" + s, h;
  }
  var Jl = {
    animationend: To("Animation", "AnimationEnd"),
    animationiteration: To("Animation", "AnimationIteration"),
    animationstart: To("Animation", "AnimationStart"),
    transitionrun: To("Transition", "TransitionRun"),
    transitionstart: To("Transition", "TransitionStart"),
    transitioncancel: To("Transition", "TransitionCancel"),
    transitionend: To("Transition", "TransitionEnd")
  }, qc = {}, Zu = {};
  Ln && (Zu = document.createElement("div").style, "AnimationEvent" in window || (delete Jl.animationend.animation, delete Jl.animationiteration.animation, delete Jl.animationstart.animation), "TransitionEvent" in window || delete Jl.transitionend.transition);
  function ms(i) {
    if (qc[i]) return qc[i];
    if (!Jl[i]) return i;
    var s = Jl[i], h;
    for (h in s)
      if (s.hasOwnProperty(h) && h in Zu)
        return qc[i] = s[h];
    return i;
  }
  var $u = ms("animationend"), Gc = ms("animationiteration"), Mo = ms("animationstart"), Hu = ms("transitionrun"), Ql = ms("transitionstart"), Dr = ms("transitioncancel"), Gh = ms("transitionend"), Zh = /* @__PURE__ */ new Map(), Xu = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Xu.push("scrollEnd");
  function ya(i, s) {
    Zh.set(i, s), go(s, [i]);
  }
  var pl = typeof reportError == "function" ? reportError : function(i) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var s = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof i == "object" && i !== null && typeof i.message == "string" ? String(i.message) : String(i),
        error: i
      });
      if (!window.dispatchEvent(s)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", i);
      return;
    }
    console.error(i);
  }, ja = [], gs = 0, eu = 0;
  function Yu() {
    for (var i = gs, s = eu = gs = 0; s < i; ) {
      var h = ja[s];
      ja[s++] = null;
      var g = ja[s];
      ja[s++] = null;
      var A = ja[s];
      ja[s++] = null;
      var I = ja[s];
      if (ja[s++] = null, g !== null && A !== null) {
        var F = g.pending;
        F === null ? A.next = A : (A.next = F.next, F.next = A), g.pending = A;
      }
      I !== 0 && Zc(h, A, I);
    }
  }
  function $s(i, s, h, g) {
    ja[gs++] = i, ja[gs++] = s, ja[gs++] = h, ja[gs++] = g, eu |= g, i.lanes |= g, i = i.alternate, i !== null && (i.lanes |= g);
  }
  function ys(i, s, h, g) {
    return $s(i, s, h, g), oi(i);
  }
  function Ao(i, s) {
    return $s(i, null, null, s), oi(i);
  }
  function Zc(i, s, h) {
    i.lanes |= h;
    var g = i.alternate;
    g !== null && (g.lanes |= h);
    for (var A = !1, I = i.return; I !== null; )
      I.childLanes |= h, g = I.alternate, g !== null && (g.childLanes |= h), I.tag === 22 && (i = I.stateNode, i === null || i._visibility & 1 || (A = !0)), i = I, I = I.return;
    return i.tag === 3 ? (I = i.stateNode, A && s !== null && (A = 31 - Ee(h), i = I.hiddenUpdates, g = i[A], g === null ? i[A] = [s] : g.push(s), s.lane = h | 536870912), I) : null;
  }
  function oi(i) {
    if (50 < cd)
      throw cd = 0, Uf = null, Error(b(185));
    for (var s = i.return; s !== null; )
      i = s, s = i.return;
    return i.tag === 3 ? i.stateNode : null;
  }
  var _s = {};
  function lf(i, s, h, g) {
    this.tag = i, this.key = h, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = s, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = g, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function er(i, s, h, g) {
    return new lf(i, s, h, g);
  }
  function vs(i) {
    return i = i.prototype, !(!i || !i.isReactComponent);
  }
  function xs(i, s) {
    var h = i.alternate;
    return h === null ? (h = er(
      i.tag,
      s,
      i.key,
      i.mode
    ), h.elementType = i.elementType, h.type = i.type, h.stateNode = i.stateNode, h.alternate = i, i.alternate = h) : (h.pendingProps = s, h.type = i.type, h.flags = 0, h.subtreeFlags = 0, h.deletions = null), h.flags = i.flags & 65011712, h.childLanes = i.childLanes, h.lanes = i.lanes, h.child = i.child, h.memoizedProps = i.memoizedProps, h.memoizedState = i.memoizedState, h.updateQueue = i.updateQueue, s = i.dependencies, h.dependencies = s === null ? null : { lanes: s.lanes, firstContext: s.firstContext }, h.sibling = i.sibling, h.index = i.index, h.ref = i.ref, h.refCleanup = i.refCleanup, h;
  }
  function ip(i, s) {
    i.flags &= 65011714;
    var h = i.alternate;
    return h === null ? (i.childLanes = 0, i.lanes = s, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = h.childLanes, i.lanes = h.lanes, i.child = h.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = h.memoizedProps, i.memoizedState = h.memoizedState, i.updateQueue = h.updateQueue, i.type = h.type, s = h.dependencies, i.dependencies = s === null ? null : {
      lanes: s.lanes,
      firstContext: s.firstContext
    }), i;
  }
  function Ku(i, s, h, g, A, I) {
    var F = 0;
    if (g = i, typeof i == "function") vs(i) && (F = 1);
    else if (typeof i == "string")
      F = yt(
        i,
        h,
        dt.current
      ) ? 26 : i === "html" || i === "head" || i === "body" ? 27 : 5;
    else
      e: switch (i) {
        case Ht:
          return i = er(31, h, s, A), i.elementType = Ht, i.lanes = I, i;
        case qe:
          return fl(h.children, A, I, s);
        case ft:
          F = 8, A |= 24;
          break;
        case ht:
          return i = er(12, h, s, A | 2), i.elementType = ht, i.lanes = I, i;
        case Re:
          return i = er(13, h, s, A), i.elementType = Re, i.lanes = I, i;
        case $e:
          return i = er(19, h, s, A), i.elementType = $e, i.lanes = I, i;
        default:
          if (typeof i == "object" && i !== null)
            switch (i.$$typeof) {
              case nt:
                F = 10;
                break e;
              case it:
                F = 9;
                break e;
              case De:
                F = 11;
                break e;
              case rt:
                F = 14;
                break e;
              case wt:
                F = 16, g = null;
                break e;
            }
          F = 29, h = Error(
            b(130, i === null ? "null" : typeof i, "")
          ), g = null;
      }
    return s = er(F, h, s, A), s.elementType = i, s.type = g, s.lanes = I, s;
  }
  function fl(i, s, h, g) {
    return i = er(7, i, g, s), i.lanes = h, i;
  }
  function Wu(i, s, h) {
    return i = er(6, i, null, s), i.lanes = h, i;
  }
  function Ju(i) {
    var s = er(18, null, null, 0);
    return s.stateNode = i, s;
  }
  function ml(i, s, h) {
    return s = er(
      4,
      i.children !== null ? i.children : [],
      i.key,
      s
    ), s.lanes = h, s.stateNode = {
      containerInfo: i.containerInfo,
      pendingChildren: null,
      implementation: i.implementation
    }, s;
  }
  var tu = /* @__PURE__ */ new WeakMap();
  function tr(i, s) {
    if (typeof i == "object" && i !== null) {
      var h = tu.get(i);
      return h !== void 0 ? h : (s = {
        value: i,
        source: s,
        stack: Ya(s)
      }, tu.set(i, s), s);
    }
    return {
      value: i,
      source: s,
      stack: Ya(s)
    };
  }
  var gl = [], bs = 0, Eo = null, Hs = 0, Ua = [], ir = 0, nr = null, Lr = 1, yr = "";
  function Fa(i, s) {
    gl[bs++] = Hs, gl[bs++] = Eo, Eo = i, Hs = s;
  }
  function $c(i, s, h) {
    Ua[ir++] = Lr, Ua[ir++] = yr, Ua[ir++] = nr, nr = i;
    var g = Lr;
    i = yr;
    var A = 32 - Ee(g) - 1;
    g &= ~(1 << A), h += 1;
    var I = 32 - Ee(s) + A;
    if (30 < I) {
      var F = A - A % 5;
      I = (g & (1 << F) - 1).toString(32), g >>= F, A -= F, Lr = 1 << 32 - Ee(s) + A | h << A | g, yr = I + i;
    } else
      Lr = 1 << I | h << A | g, yr = i;
  }
  function Hc(i) {
    i.return !== null && (Fa(i, 1), $c(i, 1, 0));
  }
  function Xc(i) {
    for (; i === Eo; )
      Eo = gl[--bs], gl[bs] = null, Hs = gl[--bs], gl[bs] = null;
    for (; i === nr; )
      nr = Ua[--ir], Ua[ir] = null, yr = Ua[--ir], Ua[ir] = null, Lr = Ua[--ir], Ua[ir] = null;
  }
  function Qu(i, s) {
    Ua[ir++] = Lr, Ua[ir++] = yr, Ua[ir++] = nr, Lr = s.id, yr = s.overflow, nr = i;
  }
  var Qn = null, ln = null, wi = !1, Vi = null, On = !1, ar = Error(b(519));
  function Qr(i) {
    var s = Error(
      b(
        418,
        1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
        ""
      )
    );
    throw yl(tr(s, i)), ar;
  }
  function iu(i) {
    var s = i.stateNode, h = i.type, g = i.memoizedProps;
    switch (s[st] = i, s[Zt] = g, h) {
      case "dialog":
        Ai("cancel", s), Ai("close", s);
        break;
      case "iframe":
      case "object":
      case "embed":
        Ai("load", s);
        break;
      case "video":
      case "audio":
        for (h = 0; h < kl.length; h++)
          Ai(kl[h], s);
        break;
      case "source":
        Ai("error", s);
        break;
      case "img":
      case "image":
      case "link":
        Ai("error", s), Ai("load", s);
        break;
      case "details":
        Ai("toggle", s);
        break;
      case "input":
        Ai("invalid", s), Dc(
          s,
          g.value,
          g.defaultValue,
          g.checked,
          g.defaultChecked,
          g.type,
          g.name,
          !0
        );
        break;
      case "select":
        Ai("invalid", s);
        break;
      case "textarea":
        Ai("invalid", s), Vl(s, g.value, g.defaultValue, g.children);
    }
    h = g.children, typeof h != "string" && typeof h != "number" && typeof h != "bigint" || s.textContent === "" + h || g.suppressHydrationWarning === !0 || im(s.textContent, h) ? (g.popover != null && (Ai("beforetoggle", s), Ai("toggle", s)), g.onScroll != null && Ai("scroll", s), g.onScrollEnd != null && Ai("scrollend", s), g.onClick != null && (s.onclick = Rr), s = !0) : s = !1, s || Qr(i, !0);
  }
  function $h(i) {
    for (Qn = i.return; Qn; )
      switch (Qn.tag) {
        case 5:
        case 31:
        case 13:
          On = !1;
          return;
        case 27:
        case 3:
          On = !0;
          return;
        default:
          Qn = Qn.return;
      }
  }
  function Or(i) {
    if (i !== Qn) return !1;
    if (!wi) return $h(i), wi = !0, !1;
    var s = i.tag, h;
    if ((h = s !== 3 && s !== 27) && ((h = s === 5) && (h = i.type, h = !(h !== "form" && h !== "button") || am(i.type, i.memoizedProps)), h = !h), h && ln && Qr(i), $h(i), s === 13) {
      if (i = i.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(b(317));
      ln = Bp(i);
    } else if (s === 31) {
      if (i = i.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(b(317));
      ln = Bp(i);
    } else
      s === 27 ? (s = ln, Ho(i.type) ? (i = Op, Op = null, ln = i) : ln = s) : ln = Qn ? qr(i.stateNode.nextSibling) : null;
    return !0;
  }
  function ws() {
    ln = Qn = null, wi = !1;
  }
  function es() {
    var i = Vi;
    return i !== null && (Er === null ? Er = i : Er.push.apply(
      Er,
      i
    ), Vi = null), i;
  }
  function yl(i) {
    Vi === null ? Vi = [i] : Vi.push(i);
  }
  var Yc = fe(null), Co = null, Ss = null;
  function Xs(i, s, h) {
    et(Yc, s._currentValue), s._currentValue = h;
  }
  function Ts(i) {
    i._currentValue = Yc.current, Ue(Yc);
  }
  function _r(i, s, h) {
    for (; i !== null; ) {
      var g = i.alternate;
      if ((i.childLanes & s) !== s ? (i.childLanes |= s, g !== null && (g.childLanes |= s)) : g !== null && (g.childLanes & s) !== s && (g.childLanes |= s), i === h) break;
      i = i.return;
    }
  }
  function zo(i, s, h, g) {
    var A = i.child;
    for (A !== null && (A.return = i); A !== null; ) {
      var I = A.dependencies;
      if (I !== null) {
        var F = A.child;
        I = I.firstContext;
        e: for (; I !== null; ) {
          var W = I;
          I = A;
          for (var _e = 0; _e < s.length; _e++)
            if (W.context === s[_e]) {
              I.lanes |= h, W = I.alternate, W !== null && (W.lanes |= h), _r(
                I.return,
                h,
                i
              ), g || (F = null);
              break e;
            }
          I = W.next;
        }
      } else if (A.tag === 18) {
        if (F = A.return, F === null) throw Error(b(341));
        F.lanes |= h, I = F.alternate, I !== null && (I.lanes |= h), _r(F, h, i), F = null;
      } else F = A.child;
      if (F !== null) F.return = A;
      else
        for (F = A; F !== null; ) {
          if (F === i) {
            F = null;
            break;
          }
          if (A = F.sibling, A !== null) {
            A.return = F.return, F = A;
            break;
          }
          F = F.return;
        }
      A = F;
    }
  }
  function ea(i, s, h, g) {
    i = null;
    for (var A = s, I = !1; A !== null; ) {
      if (!I) {
        if ((A.flags & 524288) !== 0) I = !0;
        else if ((A.flags & 262144) !== 0) break;
      }
      if (A.tag === 10) {
        var F = A.alternate;
        if (F === null) throw Error(b(387));
        if (F = F.memoizedProps, F !== null) {
          var W = A.type;
          Ca(A.pendingProps.value, F.value) || (i !== null ? i.push(W) : i = [W]);
        }
      } else if (A === si.current) {
        if (F = A.alternate, F === null) throw Error(b(387));
        F.memoizedState.memoizedState !== A.memoizedState.memoizedState && (i !== null ? i.push(li) : i = [li]);
      }
      A = A.return;
    }
    i !== null && zo(
      s,
      i,
      h,
      g
    ), s.flags |= 262144;
  }
  function Ys(i) {
    for (i = i.firstContext; i !== null; ) {
      if (!Ca(
        i.context._currentValue,
        i.memoizedValue
      ))
        return !0;
      i = i.next;
    }
    return !1;
  }
  function Ks(i) {
    Co = i, Ss = null, i = i.dependencies, i !== null && (i.firstContext = null);
  }
  function ha(i) {
    return _l(Co, i);
  }
  function ec(i, s) {
    return Co === null && Ks(i), _l(i, s);
  }
  function _l(i, s) {
    var h = s._currentValue;
    if (s = { context: s, memoizedValue: h, next: null }, Ss === null) {
      if (i === null) throw Error(b(308));
      Ss = s, i.dependencies = { lanes: 0, firstContext: s }, i.flags |= 524288;
    } else Ss = Ss.next = s;
    return h;
  }
  var Hh = typeof AbortController < "u" ? AbortController : function() {
    var i = [], s = this.signal = {
      aborted: !1,
      addEventListener: function(h, g) {
        i.push(g);
      }
    };
    this.abort = function() {
      s.aborted = !0, i.forEach(function(h) {
        return h();
      });
    };
  }, nu = d.unstable_scheduleCallback, np = d.unstable_NormalPriority, ki = {
    $$typeof: nt,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function vr() {
    return {
      controller: new Hh(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function Ms(i) {
    i.refCount--, i.refCount === 0 && nu(np, function() {
      i.controller.abort();
    });
  }
  var Va = null, Po = 0, au = 0, As = null;
  function uf(i, s) {
    if (Va === null) {
      var h = Va = [];
      Po = 0, au = $o(), As = {
        status: "pending",
        value: void 0,
        then: function(g) {
          h.push(g);
        }
      };
    }
    return Po++, s.then(ap, ap), s;
  }
  function ap() {
    if (--Po === 0 && Va !== null) {
      As !== null && (As.status = "fulfilled");
      var i = Va;
      Va = null, au = 0, As = null;
      for (var s = 0; s < i.length; s++) (0, i[s])();
    }
  }
  function tc(i, s) {
    var h = [], g = {
      status: "pending",
      value: null,
      reason: null,
      then: function(A) {
        h.push(A);
      }
    };
    return i.then(
      function() {
        g.status = "fulfilled", g.value = s;
        for (var A = 0; A < h.length; A++) (0, h[A])(s);
      },
      function(A) {
        for (g.status = "rejected", g.reason = A, A = 0; A < h.length; A++)
          (0, h[A])(void 0);
      }
    ), g;
  }
  var ru = He.S;
  He.S = function(i, s) {
    wc = Yn(), typeof s == "object" && s !== null && typeof s.then == "function" && uf(i, s), ru !== null && ru(i, s);
  };
  var _a = fe(null);
  function xt() {
    var i = _a.current;
    return i !== null ? i : sn.pooledCache;
  }
  function su(i, s) {
    s === null ? et(_a, _a.current) : et(_a, s.pool);
  }
  function ic() {
    var i = xt();
    return i === null ? null : { parent: ki._currentValue, pool: i };
  }
  var Io = Error(b(460)), ko = Error(b(474)), Es = Error(b(542)), vl = { then: function() {
  } };
  function mi(i) {
    return i = i.status, i === "fulfilled" || i === "rejected";
  }
  function nc(i, s, h) {
    switch (h = i[h], h === void 0 ? i.push(s) : h !== s && (s.then(Rr, Rr), s = h), s.status) {
      case "fulfilled":
        return s.value;
      case "rejected":
        throw i = s.reason, Xh(i), i;
      default:
        if (typeof s.status == "string") s.then(Rr, Rr);
        else {
          if (i = sn, i !== null && 100 < i.shellSuspendCounter)
            throw Error(b(482));
          i = s, i.status = "pending", i.then(
            function(g) {
              if (s.status === "pending") {
                var A = s;
                A.status = "fulfilled", A.value = g;
              }
            },
            function(g) {
              if (s.status === "pending") {
                var A = s;
                A.status = "rejected", A.reason = g;
              }
            }
          );
        }
        switch (s.status) {
          case "fulfilled":
            return s.value;
          case "rejected":
            throw i = s.reason, Xh(i), i;
        }
        throw Cs = s, Io;
    }
  }
  function xl(i) {
    try {
      var s = i._init;
      return s(i._payload);
    } catch (h) {
      throw h !== null && typeof h == "object" && typeof h.then == "function" ? (Cs = h, Io) : h;
    }
  }
  var Cs = null;
  function rp() {
    if (Cs === null) throw Error(b(459));
    var i = Cs;
    return Cs = null, i;
  }
  function Xh(i) {
    if (i === Io || i === Es)
      throw Error(b(483));
  }
  var Ro = null, bl = 0;
  function ac(i) {
    var s = bl;
    return bl += 1, Ro === null && (Ro = []), nc(Ro, i, s);
  }
  function ou(i, s) {
    s = s.props.ref, i.ref = s !== void 0 ? s : null;
  }
  function lu(i, s) {
    throw s.$$typeof === he ? Error(b(525)) : (i = Object.prototype.toString.call(s), Error(
      b(
        31,
        i === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : i
      )
    ));
  }
  function Yh(i) {
    function s(Ce, Me) {
      if (i) {
        var je = Ce.deletions;
        je === null ? (Ce.deletions = [Me], Ce.flags |= 16) : je.push(Me);
      }
    }
    function h(Ce, Me) {
      if (!i) return null;
      for (; Me !== null; )
        s(Ce, Me), Me = Me.sibling;
      return null;
    }
    function g(Ce) {
      for (var Me = /* @__PURE__ */ new Map(); Ce !== null; )
        Ce.key !== null ? Me.set(Ce.key, Ce) : Me.set(Ce.index, Ce), Ce = Ce.sibling;
      return Me;
    }
    function A(Ce, Me) {
      return Ce = xs(Ce, Me), Ce.index = 0, Ce.sibling = null, Ce;
    }
    function I(Ce, Me, je) {
      return Ce.index = je, i ? (je = Ce.alternate, je !== null ? (je = je.index, je < Me ? (Ce.flags |= 67108866, Me) : je) : (Ce.flags |= 67108866, Me)) : (Ce.flags |= 1048576, Me);
    }
    function F(Ce) {
      return i && Ce.alternate === null && (Ce.flags |= 67108866), Ce;
    }
    function W(Ce, Me, je, Qe) {
      return Me === null || Me.tag !== 6 ? (Me = Wu(je, Ce.mode, Qe), Me.return = Ce, Me) : (Me = A(Me, je), Me.return = Ce, Me);
    }
    function _e(Ce, Me, je, Qe) {
      var Yt = je.type;
      return Yt === qe ? Ze(
        Ce,
        Me,
        je.props.children,
        Qe,
        je.key
      ) : Me !== null && (Me.elementType === Yt || typeof Yt == "object" && Yt !== null && Yt.$$typeof === wt && xl(Yt) === Me.type) ? (Me = A(Me, je.props), ou(Me, je), Me.return = Ce, Me) : (Me = Ku(
        je.type,
        je.key,
        je.props,
        null,
        Ce.mode,
        Qe
      ), ou(Me, je), Me.return = Ce, Me);
    }
    function Be(Ce, Me, je, Qe) {
      return Me === null || Me.tag !== 4 || Me.stateNode.containerInfo !== je.containerInfo || Me.stateNode.implementation !== je.implementation ? (Me = ml(je, Ce.mode, Qe), Me.return = Ce, Me) : (Me = A(Me, je.children || []), Me.return = Ce, Me);
    }
    function Ze(Ce, Me, je, Qe, Yt) {
      return Me === null || Me.tag !== 7 ? (Me = fl(
        je,
        Ce.mode,
        Qe,
        Yt
      ), Me.return = Ce, Me) : (Me = A(Me, je), Me.return = Ce, Me);
    }
    function Ke(Ce, Me, je) {
      if (typeof Me == "string" && Me !== "" || typeof Me == "number" || typeof Me == "bigint")
        return Me = Wu(
          "" + Me,
          Ce.mode,
          je
        ), Me.return = Ce, Me;
      if (typeof Me == "object" && Me !== null) {
        switch (Me.$$typeof) {
          case J:
            return je = Ku(
              Me.type,
              Me.key,
              Me.props,
              null,
              Ce.mode,
              je
            ), ou(je, Me), je.return = Ce, je;
          case ke:
            return Me = ml(
              Me,
              Ce.mode,
              je
            ), Me.return = Ce, Me;
          case wt:
            return Me = xl(Me), Ke(Ce, Me, je);
        }
        if (zn(Me) || pi(Me))
          return Me = fl(
            Me,
            Ce.mode,
            je,
            null
          ), Me.return = Ce, Me;
        if (typeof Me.then == "function")
          return Ke(Ce, ac(Me), je);
        if (Me.$$typeof === nt)
          return Ke(
            Ce,
            ec(Ce, Me),
            je
          );
        lu(Ce, Me);
      }
      return null;
    }
    function Ne(Ce, Me, je, Qe) {
      var Yt = Me !== null ? Me.key : null;
      if (typeof je == "string" && je !== "" || typeof je == "number" || typeof je == "bigint")
        return Yt !== null ? null : W(Ce, Me, "" + je, Qe);
      if (typeof je == "object" && je !== null) {
        switch (je.$$typeof) {
          case J:
            return je.key === Yt ? _e(Ce, Me, je, Qe) : null;
          case ke:
            return je.key === Yt ? Be(Ce, Me, je, Qe) : null;
          case wt:
            return je = xl(je), Ne(Ce, Me, je, Qe);
        }
        if (zn(je) || pi(je))
          return Yt !== null ? null : Ze(Ce, Me, je, Qe, null);
        if (typeof je.then == "function")
          return Ne(
            Ce,
            Me,
            ac(je),
            Qe
          );
        if (je.$$typeof === nt)
          return Ne(
            Ce,
            Me,
            ec(Ce, je),
            Qe
          );
        lu(Ce, je);
      }
      return null;
    }
    function Ve(Ce, Me, je, Qe, Yt) {
      if (typeof Qe == "string" && Qe !== "" || typeof Qe == "number" || typeof Qe == "bigint")
        return Ce = Ce.get(je) || null, W(Me, Ce, "" + Qe, Yt);
      if (typeof Qe == "object" && Qe !== null) {
        switch (Qe.$$typeof) {
          case J:
            return Ce = Ce.get(
              Qe.key === null ? je : Qe.key
            ) || null, _e(Me, Ce, Qe, Yt);
          case ke:
            return Ce = Ce.get(
              Qe.key === null ? je : Qe.key
            ) || null, Be(Me, Ce, Qe, Yt);
          case wt:
            return Qe = xl(Qe), Ve(
              Ce,
              Me,
              je,
              Qe,
              Yt
            );
        }
        if (zn(Qe) || pi(Qe))
          return Ce = Ce.get(je) || null, Ze(Me, Ce, Qe, Yt, null);
        if (typeof Qe.then == "function")
          return Ve(
            Ce,
            Me,
            je,
            ac(Qe),
            Yt
          );
        if (Qe.$$typeof === nt)
          return Ve(
            Ce,
            Me,
            je,
            ec(Me, Qe),
            Yt
          );
        lu(Me, Qe);
      }
      return null;
    }
    function zt(Ce, Me, je, Qe) {
      for (var Yt = null, Wi = null, Ft = Me, Si = Me = 0, Oi = null; Ft !== null && Si < je.length; Si++) {
        Ft.index > Si ? (Oi = Ft, Ft = null) : Oi = Ft.sibling;
        var Ji = Ne(
          Ce,
          Ft,
          je[Si],
          Qe
        );
        if (Ji === null) {
          Ft === null && (Ft = Oi);
          break;
        }
        i && Ft && Ji.alternate === null && s(Ce, Ft), Me = I(Ji, Me, Si), Wi === null ? Yt = Ji : Wi.sibling = Ji, Wi = Ji, Ft = Oi;
      }
      if (Si === je.length)
        return h(Ce, Ft), wi && Fa(Ce, Si), Yt;
      if (Ft === null) {
        for (; Si < je.length; Si++)
          Ft = Ke(Ce, je[Si], Qe), Ft !== null && (Me = I(
            Ft,
            Me,
            Si
          ), Wi === null ? Yt = Ft : Wi.sibling = Ft, Wi = Ft);
        return wi && Fa(Ce, Si), Yt;
      }
      for (Ft = g(Ft); Si < je.length; Si++)
        Oi = Ve(
          Ft,
          Ce,
          Si,
          je[Si],
          Qe
        ), Oi !== null && (i && Oi.alternate !== null && Ft.delete(
          Oi.key === null ? Si : Oi.key
        ), Me = I(
          Oi,
          Me,
          Si
        ), Wi === null ? Yt = Oi : Wi.sibling = Oi, Wi = Oi);
      return i && Ft.forEach(function(vh) {
        return s(Ce, vh);
      }), wi && Fa(Ce, Si), Yt;
    }
    function Nt(Ce, Me, je, Qe) {
      if (je == null) throw Error(b(151));
      for (var Yt = null, Wi = null, Ft = Me, Si = Me = 0, Oi = null, Ji = je.next(); Ft !== null && !Ji.done; Si++, Ji = je.next()) {
        Ft.index > Si ? (Oi = Ft, Ft = null) : Oi = Ft.sibling;
        var vh = Ne(Ce, Ft, Ji.value, Qe);
        if (vh === null) {
          Ft === null && (Ft = Oi);
          break;
        }
        i && Ft && vh.alternate === null && s(Ce, Ft), Me = I(vh, Me, Si), Wi === null ? Yt = vh : Wi.sibling = vh, Wi = vh, Ft = Oi;
      }
      if (Ji.done)
        return h(Ce, Ft), wi && Fa(Ce, Si), Yt;
      if (Ft === null) {
        for (; !Ji.done; Si++, Ji = je.next())
          Ji = Ke(Ce, Ji.value, Qe), Ji !== null && (Me = I(Ji, Me, Si), Wi === null ? Yt = Ji : Wi.sibling = Ji, Wi = Ji);
        return wi && Fa(Ce, Si), Yt;
      }
      for (Ft = g(Ft); !Ji.done; Si++, Ji = je.next())
        Ji = Ve(Ft, Ce, Si, Ji.value, Qe), Ji !== null && (i && Ji.alternate !== null && Ft.delete(Ji.key === null ? Si : Ji.key), Me = I(Ji, Me, Si), Wi === null ? Yt = Ji : Wi.sibling = Ji, Wi = Ji);
      return i && Ft.forEach(function(e1) {
        return s(Ce, e1);
      }), wi && Fa(Ce, Si), Yt;
    }
    function _n(Ce, Me, je, Qe) {
      if (typeof je == "object" && je !== null && je.type === qe && je.key === null && (je = je.props.children), typeof je == "object" && je !== null) {
        switch (je.$$typeof) {
          case J:
            e: {
              for (var Yt = je.key; Me !== null; ) {
                if (Me.key === Yt) {
                  if (Yt = je.type, Yt === qe) {
                    if (Me.tag === 7) {
                      h(
                        Ce,
                        Me.sibling
                      ), Qe = A(
                        Me,
                        je.props.children
                      ), Qe.return = Ce, Ce = Qe;
                      break e;
                    }
                  } else if (Me.elementType === Yt || typeof Yt == "object" && Yt !== null && Yt.$$typeof === wt && xl(Yt) === Me.type) {
                    h(
                      Ce,
                      Me.sibling
                    ), Qe = A(Me, je.props), ou(Qe, je), Qe.return = Ce, Ce = Qe;
                    break e;
                  }
                  h(Ce, Me);
                  break;
                } else s(Ce, Me);
                Me = Me.sibling;
              }
              je.type === qe ? (Qe = fl(
                je.props.children,
                Ce.mode,
                Qe,
                je.key
              ), Qe.return = Ce, Ce = Qe) : (Qe = Ku(
                je.type,
                je.key,
                je.props,
                null,
                Ce.mode,
                Qe
              ), ou(Qe, je), Qe.return = Ce, Ce = Qe);
            }
            return F(Ce);
          case ke:
            e: {
              for (Yt = je.key; Me !== null; ) {
                if (Me.key === Yt)
                  if (Me.tag === 4 && Me.stateNode.containerInfo === je.containerInfo && Me.stateNode.implementation === je.implementation) {
                    h(
                      Ce,
                      Me.sibling
                    ), Qe = A(Me, je.children || []), Qe.return = Ce, Ce = Qe;
                    break e;
                  } else {
                    h(Ce, Me);
                    break;
                  }
                else s(Ce, Me);
                Me = Me.sibling;
              }
              Qe = ml(je, Ce.mode, Qe), Qe.return = Ce, Ce = Qe;
            }
            return F(Ce);
          case wt:
            return je = xl(je), _n(
              Ce,
              Me,
              je,
              Qe
            );
        }
        if (zn(je))
          return zt(
            Ce,
            Me,
            je,
            Qe
          );
        if (pi(je)) {
          if (Yt = pi(je), typeof Yt != "function") throw Error(b(150));
          return je = Yt.call(je), Nt(
            Ce,
            Me,
            je,
            Qe
          );
        }
        if (typeof je.then == "function")
          return _n(
            Ce,
            Me,
            ac(je),
            Qe
          );
        if (je.$$typeof === nt)
          return _n(
            Ce,
            Me,
            ec(Ce, je),
            Qe
          );
        lu(Ce, je);
      }
      return typeof je == "string" && je !== "" || typeof je == "number" || typeof je == "bigint" ? (je = "" + je, Me !== null && Me.tag === 6 ? (h(Ce, Me.sibling), Qe = A(Me, je), Qe.return = Ce, Ce = Qe) : (h(Ce, Me), Qe = Wu(je, Ce.mode, Qe), Qe.return = Ce, Ce = Qe), F(Ce)) : h(Ce, Me);
    }
    return function(Ce, Me, je, Qe) {
      try {
        bl = 0;
        var Yt = _n(
          Ce,
          Me,
          je,
          Qe
        );
        return Ro = null, Yt;
      } catch (Ft) {
        if (Ft === Io || Ft === Es) throw Ft;
        var Wi = er(29, Ft, null, Ce.mode);
        return Wi.lanes = Qe, Wi.return = Ce, Wi;
      } finally {
      }
    };
  }
  var Do = Yh(!0), Br = Yh(!1), Li = !1;
  function Lo(i) {
    i.updateQueue = {
      baseState: i.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function rc(i, s) {
    i = i.updateQueue, s.updateQueue === i && (s.updateQueue = {
      baseState: i.baseState,
      firstBaseUpdate: i.firstBaseUpdate,
      lastBaseUpdate: i.lastBaseUpdate,
      shared: i.shared,
      callbacks: null
    });
  }
  function Ws(i) {
    return { lane: i, tag: 0, payload: null, callback: null, next: null };
  }
  function zs(i, s, h) {
    var g = i.updateQueue;
    if (g === null) return null;
    if (g = g.shared, (ji & 2) !== 0) {
      var A = g.pending;
      return A === null ? s.next = s : (s.next = A.next, A.next = s), g.pending = s, s = oi(i), Zc(i, null, h), s;
    }
    return $s(i, g, s, h), oi(i);
  }
  function wl(i, s, h) {
    if (s = s.updateQueue, s !== null && (s = s.shared, (h & 4194048) !== 0)) {
      var g = s.lanes;
      g &= i.pendingLanes, h |= g, s.lanes = h, _i(i, h);
    }
  }
  function Kc(i, s) {
    var h = i.updateQueue, g = i.alternate;
    if (g !== null && (g = g.updateQueue, h === g)) {
      var A = null, I = null;
      if (h = h.firstBaseUpdate, h !== null) {
        do {
          var F = {
            lane: h.lane,
            tag: h.tag,
            payload: h.payload,
            callback: null,
            next: null
          };
          I === null ? A = I = F : I = I.next = F, h = h.next;
        } while (h !== null);
        I === null ? A = I = s : I = I.next = s;
      } else A = I = s;
      h = {
        baseState: g.baseState,
        firstBaseUpdate: A,
        lastBaseUpdate: I,
        shared: g.shared,
        callbacks: g.callbacks
      }, i.updateQueue = h;
      return;
    }
    i = h.lastBaseUpdate, i === null ? h.firstBaseUpdate = s : i.next = s, h.lastBaseUpdate = s;
  }
  var Nr = !1;
  function Oo() {
    if (Nr) {
      var i = As;
      if (i !== null) throw i;
    }
  }
  function Tt(i, s, h, g) {
    Nr = !1;
    var A = i.updateQueue;
    Li = !1;
    var I = A.firstBaseUpdate, F = A.lastBaseUpdate, W = A.shared.pending;
    if (W !== null) {
      A.shared.pending = null;
      var _e = W, Be = _e.next;
      _e.next = null, F === null ? I = Be : F.next = Be, F = _e;
      var Ze = i.alternate;
      Ze !== null && (Ze = Ze.updateQueue, W = Ze.lastBaseUpdate, W !== F && (W === null ? Ze.firstBaseUpdate = Be : W.next = Be, Ze.lastBaseUpdate = _e));
    }
    if (I !== null) {
      var Ke = A.baseState;
      F = 0, Ze = Be = _e = null, W = I;
      do {
        var Ne = W.lane & -536870913, Ve = Ne !== W.lane;
        if (Ve ? (Pi & Ne) === Ne : (g & Ne) === Ne) {
          Ne !== 0 && Ne === au && (Nr = !0), Ze !== null && (Ze = Ze.next = {
            lane: 0,
            tag: W.tag,
            payload: W.payload,
            callback: null,
            next: null
          });
          e: {
            var zt = i, Nt = W;
            Ne = s;
            var _n = h;
            switch (Nt.tag) {
              case 1:
                if (zt = Nt.payload, typeof zt == "function") {
                  Ke = zt.call(_n, Ke, Ne);
                  break e;
                }
                Ke = zt;
                break e;
              case 3:
                zt.flags = zt.flags & -65537 | 128;
              case 0:
                if (zt = Nt.payload, Ne = typeof zt == "function" ? zt.call(_n, Ke, Ne) : zt, Ne == null) break e;
                Ke = ae({}, Ke, Ne);
                break e;
              case 2:
                Li = !0;
            }
          }
          Ne = W.callback, Ne !== null && (i.flags |= 64, Ve && (i.flags |= 8192), Ve = A.callbacks, Ve === null ? A.callbacks = [Ne] : Ve.push(Ne));
        } else
          Ve = {
            lane: Ne,
            tag: W.tag,
            payload: W.payload,
            callback: W.callback,
            next: null
          }, Ze === null ? (Be = Ze = Ve, _e = Ke) : Ze = Ze.next = Ve, F |= Ne;
        if (W = W.next, W === null) {
          if (W = A.shared.pending, W === null)
            break;
          Ve = W, W = Ve.next, Ve.next = null, A.lastBaseUpdate = Ve, A.shared.pending = null;
        }
      } while (!0);
      Ze === null && (_e = Ke), A.baseState = _e, A.firstBaseUpdate = Be, A.lastBaseUpdate = Ze, I === null && (A.shared.lanes = 0), Cl |= F, i.lanes = F, i.memoizedState = Ke;
    }
  }
  function Ot(i, s) {
    if (typeof i != "function")
      throw Error(b(191, i));
    i.call(s);
  }
  function sc(i, s) {
    var h = i.callbacks;
    if (h !== null)
      for (i.callbacks = null, i = 0; i < h.length; i++)
        Ot(h[i], s);
  }
  var xr = fe(null), Sl = fe(0);
  function za(i, s) {
    i = El, et(Sl, i), et(xr, s), El = i | s.baseLanes;
  }
  function Wc() {
    et(Sl, El), et(xr, xr.current);
  }
  function rr() {
    El = Sl.current, Ue(xr), Ue(Sl);
  }
  var br = fe(null), Pa = null;
  function Ti(i) {
    var s = i.alternate;
    et(Sn, Sn.current & 1), et(br, i), Pa === null && (s === null || xr.current !== null || s.memoizedState !== null) && (Pa = i);
  }
  function fn(i) {
    et(Sn, Sn.current), et(br, i), Pa === null && (Pa = i);
  }
  function oc(i) {
    i.tag === 22 ? (et(Sn, Sn.current), et(br, i), Pa === null && (Pa = i)) : wr();
  }
  function wr() {
    et(Sn, Sn.current), et(br, br.current);
  }
  function da(i) {
    Ue(br), Pa === i && (Pa = null), Ue(Sn);
  }
  var Sn = fe(0);
  function Js(i) {
    for (var s = i; s !== null; ) {
      if (s.tag === 13) {
        var h = s.memoizedState;
        if (h !== null && (h = h.dehydrated, h === null || vd(h) || Lp(h)))
          return s;
      } else if (s.tag === 19 && (s.memoizedProps.revealOrder === "forwards" || s.memoizedProps.revealOrder === "backwards" || s.memoizedProps.revealOrder === "unstable_legacy-backwards" || s.memoizedProps.revealOrder === "together")) {
        if ((s.flags & 128) !== 0) return s;
      } else if (s.child !== null) {
        s.child.return = s, s = s.child;
        continue;
      }
      if (s === i) break;
      for (; s.sibling === null; ) {
        if (s.return === null || s.return === i) return null;
        s = s.return;
      }
      s.sibling.return = s.return, s = s.sibling;
    }
    return null;
  }
  var qa = 0, ni = null, Bi = null, rn = null, uu = !1, Bo = !1, Ps = !1, cu = 0, y = 0, e = null, r = 0;
  function c() {
    throw Error(b(321));
  }
  function f(i, s) {
    if (s === null) return !1;
    for (var h = 0; h < s.length && h < i.length; h++)
      if (!Ca(i[h], s[h])) return !1;
    return !0;
  }
  function _(i, s, h, g, A, I) {
    return qa = I, ni = s, s.memoizedState = null, s.updateQueue = null, s.lanes = 0, He.H = i === null || i.memoizedState === null ? hf : df, Ps = !1, I = h(g, A), Ps = !1, Bo && (I = C(
      s,
      h,
      g,
      A
    )), w(i), I;
  }
  function w(i) {
    He.H = cc;
    var s = Bi !== null && Bi.next !== null;
    if (qa = 0, rn = Bi = ni = null, uu = !1, y = 0, e = null, s) throw Error(b(300));
    i === null || ia || (i = i.dependencies, i !== null && Ys(i) && (ia = !0));
  }
  function C(i, s, h, g) {
    ni = i;
    var A = 0;
    do {
      if (Bo && (e = null), y = 0, Bo = !1, 25 <= A) throw Error(b(301));
      if (A += 1, rn = Bi = null, i.updateQueue != null) {
        var I = i.updateQueue;
        I.lastEffect = null, I.events = null, I.stores = null, I.memoCache != null && (I.memoCache.index = 0);
      }
      He.H = pf, I = s(h, g);
    } while (Bo);
    return I;
  }
  function P() {
    var i = He.H, s = i.useState()[0];
    return s = typeof s.then == "function" ? ie(s) : s, i = i.useState()[0], (Bi !== null ? Bi.memoizedState : null) !== i && (ni.flags |= 1024), s;
  }
  function R() {
    var i = cu !== 0;
    return cu = 0, i;
  }
  function L(i, s, h) {
    s.updateQueue = i.updateQueue, s.flags &= -2053, i.lanes &= ~h;
  }
  function j(i) {
    if (uu) {
      for (i = i.memoizedState; i !== null; ) {
        var s = i.queue;
        s !== null && (s.pending = null), i = i.next;
      }
      uu = !1;
    }
    qa = 0, rn = Bi = ni = null, Bo = !1, y = cu = 0, e = null;
  }
  function B() {
    var i = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return rn === null ? ni.memoizedState = rn = i : rn = rn.next = i, rn;
  }
  function V() {
    if (Bi === null) {
      var i = ni.alternate;
      i = i !== null ? i.memoizedState : null;
    } else i = Bi.next;
    var s = rn === null ? ni.memoizedState : rn.next;
    if (s !== null)
      rn = s, Bi = i;
    else {
      if (i === null)
        throw ni.alternate === null ? Error(b(467)) : Error(b(310));
      Bi = i, i = {
        memoizedState: Bi.memoizedState,
        baseState: Bi.baseState,
        baseQueue: Bi.baseQueue,
        queue: Bi.queue,
        next: null
      }, rn === null ? ni.memoizedState = rn = i : rn = rn.next = i;
    }
    return rn;
  }
  function $() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function ie(i) {
    var s = y;
    return y += 1, e === null && (e = []), i = nc(e, i, s), s = ni, (rn === null ? s.memoizedState : rn.next) === null && (s = s.alternate, He.H = s === null || s.memoizedState === null ? hf : df), i;
  }
  function te(i) {
    if (i !== null && typeof i == "object") {
      if (typeof i.then == "function") return ie(i);
      if (i.$$typeof === nt) return ha(i);
    }
    throw Error(b(438, String(i)));
  }
  function ne(i) {
    var s = null, h = ni.updateQueue;
    if (h !== null && (s = h.memoCache), s == null) {
      var g = ni.alternate;
      g !== null && (g = g.updateQueue, g !== null && (g = g.memoCache, g != null && (s = {
        data: g.data.map(function(A) {
          return A.slice();
        }),
        index: 0
      })));
    }
    if (s == null && (s = { data: [], index: 0 }), h === null && (h = $(), ni.updateQueue = h), h.memoCache = s, h = s.data[s.index], h === void 0)
      for (h = s.data[s.index] = Array(i), g = 0; g < i; g++)
        h[g] = Dt;
    return s.index++, h;
  }
  function re(i, s) {
    return typeof s == "function" ? s(i) : s;
  }
  function ce(i) {
    var s = V();
    return oe(s, Bi, i);
  }
  function oe(i, s, h) {
    var g = i.queue;
    if (g === null) throw Error(b(311));
    g.lastRenderedReducer = h;
    var A = i.baseQueue, I = g.pending;
    if (I !== null) {
      if (A !== null) {
        var F = A.next;
        A.next = I.next, I.next = F;
      }
      s.baseQueue = A = I, g.pending = null;
    }
    if (I = i.baseState, A === null) i.memoizedState = I;
    else {
      s = A.next;
      var W = F = null, _e = null, Be = s, Ze = !1;
      do {
        var Ke = Be.lane & -536870913;
        if (Ke !== Be.lane ? (Pi & Ke) === Ke : (qa & Ke) === Ke) {
          var Ne = Be.revertLane;
          if (Ne === 0)
            _e !== null && (_e = _e.next = {
              lane: 0,
              revertLane: 0,
              gesture: null,
              action: Be.action,
              hasEagerState: Be.hasEagerState,
              eagerState: Be.eagerState,
              next: null
            }), Ke === au && (Ze = !0);
          else if ((qa & Ne) === Ne) {
            Be = Be.next, Ne === au && (Ze = !0);
            continue;
          } else
            Ke = {
              lane: 0,
              revertLane: Be.revertLane,
              gesture: null,
              action: Be.action,
              hasEagerState: Be.hasEagerState,
              eagerState: Be.eagerState,
              next: null
            }, _e === null ? (W = _e = Ke, F = I) : _e = _e.next = Ke, ni.lanes |= Ne, Cl |= Ne;
          Ke = Be.action, Ps && h(I, Ke), I = Be.hasEagerState ? Be.eagerState : h(I, Ke);
        } else
          Ne = {
            lane: Ke,
            revertLane: Be.revertLane,
            gesture: Be.gesture,
            action: Be.action,
            hasEagerState: Be.hasEagerState,
            eagerState: Be.eagerState,
            next: null
          }, _e === null ? (W = _e = Ne, F = I) : _e = _e.next = Ne, ni.lanes |= Ke, Cl |= Ke;
        Be = Be.next;
      } while (Be !== null && Be !== s);
      if (_e === null ? F = I : _e.next = W, !Ca(I, i.memoizedState) && (ia = !0, Ze && (h = As, h !== null)))
        throw h;
      i.memoizedState = I, i.baseState = F, i.baseQueue = _e, g.lastRenderedState = I;
    }
    return A === null && (g.lanes = 0), [i.memoizedState, g.dispatch];
  }
  function pe(i) {
    var s = V(), h = s.queue;
    if (h === null) throw Error(b(311));
    h.lastRenderedReducer = i;
    var g = h.dispatch, A = h.pending, I = s.memoizedState;
    if (A !== null) {
      h.pending = null;
      var F = A = A.next;
      do
        I = i(I, F.action), F = F.next;
      while (F !== A);
      Ca(I, s.memoizedState) || (ia = !0), s.memoizedState = I, s.baseQueue === null && (s.baseState = I), h.lastRenderedState = I;
    }
    return [I, g];
  }
  function ye(i, s, h) {
    var g = ni, A = V(), I = wi;
    if (I) {
      if (h === void 0) throw Error(b(407));
      h = h();
    } else h = s();
    var F = !Ca(
      (Bi || A).memoizedState,
      h
    );
    if (F && (A.memoizedState = h, ia = !0), A = A.queue, Is(Oe.bind(null, g, A, i), [
      i
    ]), A.getSnapshot !== s || F || rn !== null && rn.memoizedState.tag & 1) {
      if (g.flags |= 2048, gn(
        9,
        { destroy: void 0 },
        we.bind(
          null,
          g,
          A,
          h,
          s
        ),
        null
      ), sn === null) throw Error(b(349));
      I || (qa & 127) !== 0 || ue(g, s, h);
    }
    return h;
  }
  function ue(i, s, h) {
    i.flags |= 16384, i = { getSnapshot: s, value: h }, s = ni.updateQueue, s === null ? (s = $(), ni.updateQueue = s, s.stores = [i]) : (h = s.stores, h === null ? s.stores = [i] : h.push(i));
  }
  function we(i, s, h, g) {
    s.value = h, s.getSnapshot = g, ze(s) && Pe(i);
  }
  function Oe(i, s, h) {
    return h(function() {
      ze(s) && Pe(i);
    });
  }
  function ze(i) {
    var s = i.getSnapshot;
    i = i.value;
    try {
      var h = s();
      return !Ca(i, h);
    } catch {
      return !0;
    }
  }
  function Pe(i) {
    var s = Ao(i, 2);
    s !== null && ur(s, i, 2);
  }
  function Le(i) {
    var s = B();
    if (typeof i == "function") {
      var h = i;
      if (i = h(), Ps) {
        ve(!0);
        try {
          h();
        } finally {
          ve(!1);
        }
      }
    }
    return s.memoizedState = s.baseState = i, s.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: re,
      lastRenderedState: i
    }, s;
  }
  function lt(i, s, h, g) {
    return i.baseState = h, oe(
      i,
      Bi,
      typeof g == "function" ? g : re
    );
  }
  function ct(i, s, h, g, A) {
    if (Fr(i)) throw Error(b(485));
    if (i = s.action, i !== null) {
      var I = {
        payload: A,
        action: i,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(F) {
          I.listeners.push(F);
        }
      };
      He.T !== null ? h(!0) : I.isTransition = !1, g(I), h = s.pending, h === null ? (I.next = s.pending = I, We(s, I)) : (I.next = h.next, s.pending = h.next = I);
    }
  }
  function We(i, s) {
    var h = s.action, g = s.payload, A = i.state;
    if (s.isTransition) {
      var I = He.T, F = {};
      He.T = F;
      try {
        var W = h(A, g), _e = He.S;
        _e !== null && _e(F, W), At(i, s, W);
      } catch (Be) {
        zi(i, s, Be);
      } finally {
        I !== null && F.types !== null && (I.types = F.types), He.T = I;
      }
    } else
      try {
        I = h(A, g), At(i, s, I);
      } catch (Be) {
        zi(i, s, Be);
      }
  }
  function At(i, s, h) {
    h !== null && typeof h == "object" && typeof h.then == "function" ? h.then(
      function(g) {
        ai(i, s, g);
      },
      function(g) {
        return zi(i, s, g);
      }
    ) : ai(i, s, h);
  }
  function ai(i, s, h) {
    s.status = "fulfilled", s.value = h, qi(s), i.state = h, s = i.pending, s !== null && (h = s.next, h === s ? i.pending = null : (h = h.next, s.next = h, We(i, h)));
  }
  function zi(i, s, h) {
    var g = i.pending;
    if (i.pending = null, g !== null) {
      g = g.next;
      do
        s.status = "rejected", s.reason = h, qi(s), s = s.next;
      while (s !== g);
    }
    i.action = null;
  }
  function qi(i) {
    i = i.listeners;
    for (var s = 0; s < i.length; s++) (0, i[s])();
  }
  function Ni(i, s) {
    return s;
  }
  function un(i, s) {
    if (wi) {
      var h = sn.formState;
      if (h !== null) {
        e: {
          var g = ni;
          if (wi) {
            if (ln) {
              t: {
                for (var A = ln, I = On; A.nodeType !== 8; ) {
                  if (!I) {
                    A = null;
                    break t;
                  }
                  if (A = qr(
                    A.nextSibling
                  ), A === null) {
                    A = null;
                    break t;
                  }
                }
                I = A.data, A = I === "F!" || I === "F" ? A : null;
              }
              if (A) {
                ln = qr(
                  A.nextSibling
                ), g = A.data === "F!";
                break e;
              }
            }
            Qr(g);
          }
          g = !1;
        }
        g && (s = h[0]);
      }
    }
    return h = B(), h.memoizedState = h.baseState = s, g = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Ni,
      lastRenderedState: s
    }, h.queue = g, h = uc.bind(
      null,
      ni,
      g
    ), g.dispatch = h, g = Le(!1), I = Ds.bind(
      null,
      ni,
      !1,
      g.queue
    ), g = B(), A = {
      state: s,
      dispatch: null,
      action: i,
      pending: null
    }, g.queue = A, h = ct.bind(
      null,
      ni,
      A,
      I,
      h
    ), A.dispatch = h, g.memoizedState = i, [s, h, !1];
  }
  function mn(i) {
    var s = V();
    return Qt(s, Bi, i);
  }
  function Qt(i, s, h) {
    if (s = oe(
      i,
      s,
      Ni
    )[0], i = ce(re)[0], typeof s == "object" && s !== null && typeof s.then == "function")
      try {
        var g = ie(s);
      } catch (F) {
        throw F === Io ? Es : F;
      }
    else g = s;
    s = V();
    var A = s.queue, I = A.dispatch;
    return h !== s.memoizedState && (ni.flags |= 2048, gn(
      9,
      { destroy: void 0 },
      Xi.bind(null, A, h),
      null
    )), [g, I, i];
  }
  function Xi(i, s) {
    i.action = s;
  }
  function Bn(i) {
    var s = V(), h = Bi;
    if (h !== null)
      return Qt(s, h, i);
    V(), s = s.memoizedState, h = V();
    var g = h.queue.dispatch;
    return h.memoizedState = i, [s, g, !1];
  }
  function gn(i, s, h, g) {
    return i = { tag: i, create: h, deps: g, inst: s, next: null }, s = ni.updateQueue, s === null && (s = $(), ni.updateQueue = s), h = s.lastEffect, h === null ? s.lastEffect = i.next = i : (g = h.next, h.next = i, i.next = g, s.lastEffect = i), i;
  }
  function ta() {
    return V().memoizedState;
  }
  function pa(i, s, h, g) {
    var A = B();
    ni.flags |= i, A.memoizedState = gn(
      1 | s,
      { destroy: void 0 },
      h,
      g === void 0 ? null : g
    );
  }
  function sr(i, s, h, g) {
    var A = V();
    g = g === void 0 ? null : g;
    var I = A.memoizedState.inst;
    Bi !== null && g !== null && f(g, Bi.memoizedState.deps) ? A.memoizedState = gn(s, I, h, g) : (ni.flags |= i, A.memoizedState = gn(
      1 | s,
      I,
      h,
      g
    ));
  }
  function Qs(i, s) {
    pa(8390656, 8, i, s);
  }
  function Is(i, s) {
    sr(2048, 8, i, s);
  }
  function hu(i) {
    ni.flags |= 4;
    var s = ni.updateQueue;
    if (s === null)
      s = $(), ni.updateQueue = s, s.events = [i];
    else {
      var h = s.events;
      h === null ? s.events = [i] : h.push(i);
    }
  }
  function Tl(i) {
    var s = V().memoizedState;
    return hu({ ref: s, nextImpl: i }), function() {
      if ((ji & 2) !== 0) throw Error(b(440));
      return s.impl.apply(void 0, arguments);
    };
  }
  function No(i, s) {
    return sr(4, 2, i, s);
  }
  function jo(i, s) {
    return sr(4, 4, i, s);
  }
  function Ga(i, s) {
    if (typeof s == "function") {
      i = i();
      var h = s(i);
      return function() {
        typeof h == "function" ? h() : s(null);
      };
    }
    if (s != null)
      return i = i(), s.current = i, function() {
        s.current = null;
      };
  }
  function jr(i, s, h) {
    h = h != null ? h.concat([i]) : null, sr(4, 4, Ga.bind(null, s, i), h);
  }
  function va() {
  }
  function eo(i, s) {
    var h = V();
    s = s === void 0 ? null : s;
    var g = h.memoizedState;
    return s !== null && f(s, g[1]) ? g[0] : (h.memoizedState = [i, s], i);
  }
  function Nn(i, s) {
    var h = V();
    s = s === void 0 ? null : s;
    var g = h.memoizedState;
    if (s !== null && f(s, g[1]))
      return g[0];
    if (g = i(), Ps) {
      ve(!0);
      try {
        i();
      } finally {
        ve(!1);
      }
    }
    return h.memoizedState = [g, s], g;
  }
  function jn(i, s, h) {
    return h === void 0 || (qa & 1073741824) !== 0 && (Pi & 261930) === 0 ? i.memoizedState = s : (i.memoizedState = h, i = Ff(), ni.lanes |= i, Cl |= i, h);
  }
  function Sr(i, s, h, g) {
    return Ca(h, s) ? h : xr.current !== null ? (i = jn(i, h, g), Ca(i, s) || (ia = !0), i) : (qa & 42) === 0 || (qa & 1073741824) !== 0 && (Pi & 261930) === 0 ? (ia = !0, i.memoizedState = h) : (i = Ff(), ni.lanes |= i, Cl |= i, s);
  }
  function Un(i, s, h, g, A) {
    var I = vt.p;
    vt.p = I !== 0 && 8 > I ? I : 8;
    var F = He.T, W = {};
    He.T = W, Ds(i, !1, s, h);
    try {
      var _e = A(), Be = He.S;
      if (Be !== null && Be(W, _e), _e !== null && typeof _e == "object" && typeof _e.then == "function") {
        var Ze = tc(
          _e,
          g
        );
        Fo(
          i,
          s,
          Ze,
          is(i)
        );
      } else
        Fo(
          i,
          s,
          g,
          is(i)
        );
    } catch (Ke) {
      Fo(
        i,
        s,
        { then: function() {
        }, status: "rejected", reason: Ke },
        is()
      );
    } finally {
      vt.p = I, F !== null && W.types !== null && (F.types = W.types), He.T = F;
    }
  }
  function lc() {
  }
  function Uo(i, s, h, g) {
    if (i.tag !== 5) throw Error(b(476));
    var A = ks(i).queue;
    Un(
      i,
      A,
      s,
      Gt,
      h === null ? lc : function() {
        return Ur(i), h(g);
      }
    );
  }
  function ks(i) {
    var s = i.memoizedState;
    if (s !== null) return s;
    s = {
      memoizedState: Gt,
      baseState: Gt,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: re,
        lastRenderedState: Gt
      },
      next: null
    };
    var h = {};
    return s.next = {
      memoizedState: h,
      baseState: h,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: re,
        lastRenderedState: h
      },
      next: null
    }, i.memoizedState = s, i = i.alternate, i !== null && (i.memoizedState = s), s;
  }
  function Ur(i) {
    var s = ks(i);
    s.next === null && (s = i.alternate.memoizedState), Fo(
      i,
      s.next.queue,
      {},
      is()
    );
  }
  function Rs() {
    return ha(li);
  }
  function Kh() {
    return V().memoizedState;
  }
  function or() {
    return V().memoizedState;
  }
  function sp(i) {
    for (var s = i.return; s !== null; ) {
      switch (s.tag) {
        case 24:
        case 3:
          var h = is();
          i = Ws(h);
          var g = zs(s, i, h);
          g !== null && (ur(g, s, h), wl(g, s, h)), s = { cache: vr() }, i.payload = s;
          return;
      }
      s = s.return;
    }
  }
  function Wh(i, s, h) {
    var g = is();
    h = {
      lane: g,
      revertLane: 0,
      gesture: null,
      action: h,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Fr(i) ? cf(s, h) : (h = ys(i, s, h, g), h !== null && (ur(h, i, g), Bm(h, s, g)));
  }
  function uc(i, s, h) {
    var g = is();
    Fo(i, s, h, g);
  }
  function Fo(i, s, h, g) {
    var A = {
      lane: g,
      revertLane: 0,
      gesture: null,
      action: h,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (Fr(i)) cf(s, A);
    else {
      var I = i.alternate;
      if (i.lanes === 0 && (I === null || I.lanes === 0) && (I = s.lastRenderedReducer, I !== null))
        try {
          var F = s.lastRenderedState, W = I(F, h);
          if (A.hasEagerState = !0, A.eagerState = W, Ca(W, F))
            return $s(i, s, A, 0), sn === null && Yu(), !1;
        } catch {
        } finally {
        }
      if (h = ys(i, s, A, g), h !== null)
        return ur(h, i, g), Bm(h, s, g), !0;
    }
    return !1;
  }
  function Ds(i, s, h, g) {
    if (g = {
      lane: 2,
      revertLane: $o(),
      gesture: null,
      action: g,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Fr(i)) {
      if (s) throw Error(b(479));
    } else
      s = ys(
        i,
        h,
        g,
        2
      ), s !== null && ur(s, i, 2);
  }
  function Fr(i) {
    var s = i.alternate;
    return i === ni || s !== null && s === ni;
  }
  function cf(i, s) {
    Bo = uu = !0;
    var h = i.pending;
    h === null ? s.next = s : (s.next = h.next, h.next = s), i.pending = s;
  }
  function Bm(i, s, h) {
    if ((h & 4194048) !== 0) {
      var g = s.lanes;
      g &= i.pendingLanes, h |= g, s.lanes = h, _i(i, h);
    }
  }
  var cc = {
    readContext: ha,
    use: te,
    useCallback: c,
    useContext: c,
    useEffect: c,
    useImperativeHandle: c,
    useLayoutEffect: c,
    useInsertionEffect: c,
    useMemo: c,
    useReducer: c,
    useRef: c,
    useState: c,
    useDebugValue: c,
    useDeferredValue: c,
    useTransition: c,
    useSyncExternalStore: c,
    useId: c,
    useHostTransitionStatus: c,
    useFormState: c,
    useActionState: c,
    useOptimistic: c,
    useMemoCache: c,
    useCacheRefresh: c
  };
  cc.useEffectEvent = c;
  var hf = {
    readContext: ha,
    use: te,
    useCallback: function(i, s) {
      return B().memoizedState = [
        i,
        s === void 0 ? null : s
      ], i;
    },
    useContext: ha,
    useEffect: Qs,
    useImperativeHandle: function(i, s, h) {
      h = h != null ? h.concat([i]) : null, pa(
        4194308,
        4,
        Ga.bind(null, s, i),
        h
      );
    },
    useLayoutEffect: function(i, s) {
      return pa(4194308, 4, i, s);
    },
    useInsertionEffect: function(i, s) {
      pa(4, 2, i, s);
    },
    useMemo: function(i, s) {
      var h = B();
      s = s === void 0 ? null : s;
      var g = i();
      if (Ps) {
        ve(!0);
        try {
          i();
        } finally {
          ve(!1);
        }
      }
      return h.memoizedState = [g, s], g;
    },
    useReducer: function(i, s, h) {
      var g = B();
      if (h !== void 0) {
        var A = h(s);
        if (Ps) {
          ve(!0);
          try {
            h(s);
          } finally {
            ve(!1);
          }
        }
      } else A = s;
      return g.memoizedState = g.baseState = A, i = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: i,
        lastRenderedState: A
      }, g.queue = i, i = i.dispatch = Wh.bind(
        null,
        ni,
        i
      ), [g.memoizedState, i];
    },
    useRef: function(i) {
      var s = B();
      return i = { current: i }, s.memoizedState = i;
    },
    useState: function(i) {
      i = Le(i);
      var s = i.queue, h = uc.bind(null, ni, s);
      return s.dispatch = h, [i.memoizedState, h];
    },
    useDebugValue: va,
    useDeferredValue: function(i, s) {
      var h = B();
      return jn(h, i, s);
    },
    useTransition: function() {
      var i = Le(!1);
      return i = Un.bind(
        null,
        ni,
        i.queue,
        !0,
        !1
      ), B().memoizedState = i, [!1, i];
    },
    useSyncExternalStore: function(i, s, h) {
      var g = ni, A = B();
      if (wi) {
        if (h === void 0)
          throw Error(b(407));
        h = h();
      } else {
        if (h = s(), sn === null)
          throw Error(b(349));
        (Pi & 127) !== 0 || ue(g, s, h);
      }
      A.memoizedState = h;
      var I = { value: h, getSnapshot: s };
      return A.queue = I, Qs(Oe.bind(null, g, I, i), [
        i
      ]), g.flags |= 2048, gn(
        9,
        { destroy: void 0 },
        we.bind(
          null,
          g,
          I,
          h,
          s
        ),
        null
      ), h;
    },
    useId: function() {
      var i = B(), s = sn.identifierPrefix;
      if (wi) {
        var h = yr, g = Lr;
        h = (g & ~(1 << 32 - Ee(g) - 1)).toString(32) + h, s = "_" + s + "R_" + h, h = cu++, 0 < h && (s += "H" + h.toString(32)), s += "_";
      } else
        h = r++, s = "_" + s + "r_" + h.toString(32) + "_";
      return i.memoizedState = s;
    },
    useHostTransitionStatus: Rs,
    useFormState: un,
    useActionState: un,
    useOptimistic: function(i) {
      var s = B();
      s.memoizedState = s.baseState = i;
      var h = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return s.queue = h, s = Ds.bind(
        null,
        ni,
        !0,
        h
      ), h.dispatch = s, [i, s];
    },
    useMemoCache: ne,
    useCacheRefresh: function() {
      return B().memoizedState = sp.bind(
        null,
        ni
      );
    },
    useEffectEvent: function(i) {
      var s = B(), h = { impl: i };
      return s.memoizedState = h, function() {
        if ((ji & 2) !== 0)
          throw Error(b(440));
        return h.impl.apply(void 0, arguments);
      };
    }
  }, df = {
    readContext: ha,
    use: te,
    useCallback: eo,
    useContext: ha,
    useEffect: Is,
    useImperativeHandle: jr,
    useInsertionEffect: No,
    useLayoutEffect: jo,
    useMemo: Nn,
    useReducer: ce,
    useRef: ta,
    useState: function() {
      return ce(re);
    },
    useDebugValue: va,
    useDeferredValue: function(i, s) {
      var h = V();
      return Sr(
        h,
        Bi.memoizedState,
        i,
        s
      );
    },
    useTransition: function() {
      var i = ce(re)[0], s = V().memoizedState;
      return [
        typeof i == "boolean" ? i : ie(i),
        s
      ];
    },
    useSyncExternalStore: ye,
    useId: Kh,
    useHostTransitionStatus: Rs,
    useFormState: mn,
    useActionState: mn,
    useOptimistic: function(i, s) {
      var h = V();
      return lt(h, Bi, i, s);
    },
    useMemoCache: ne,
    useCacheRefresh: or
  };
  df.useEffectEvent = Tl;
  var pf = {
    readContext: ha,
    use: te,
    useCallback: eo,
    useContext: ha,
    useEffect: Is,
    useImperativeHandle: jr,
    useInsertionEffect: No,
    useLayoutEffect: jo,
    useMemo: Nn,
    useReducer: pe,
    useRef: ta,
    useState: function() {
      return pe(re);
    },
    useDebugValue: va,
    useDeferredValue: function(i, s) {
      var h = V();
      return Bi === null ? jn(h, i, s) : Sr(
        h,
        Bi.memoizedState,
        i,
        s
      );
    },
    useTransition: function() {
      var i = pe(re)[0], s = V().memoizedState;
      return [
        typeof i == "boolean" ? i : ie(i),
        s
      ];
    },
    useSyncExternalStore: ye,
    useId: Kh,
    useHostTransitionStatus: Rs,
    useFormState: Bn,
    useActionState: Bn,
    useOptimistic: function(i, s) {
      var h = V();
      return Bi !== null ? lt(h, Bi, i, s) : (h.baseState = i, [i, h.queue.dispatch]);
    },
    useMemoCache: ne,
    useCacheRefresh: or
  };
  pf.useEffectEvent = Tl;
  function ff(i, s, h, g) {
    s = i.memoizedState, h = h(g, s), h = h == null ? s : ae({}, s, h), i.memoizedState = h, i.lanes === 0 && (i.updateQueue.baseState = h);
  }
  var Jh = {
    enqueueSetState: function(i, s, h) {
      i = i._reactInternals;
      var g = is(), A = Ws(g);
      A.payload = s, h != null && (A.callback = h), s = zs(i, A, g), s !== null && (ur(s, i, g), wl(s, i, g));
    },
    enqueueReplaceState: function(i, s, h) {
      i = i._reactInternals;
      var g = is(), A = Ws(g);
      A.tag = 1, A.payload = s, h != null && (A.callback = h), s = zs(i, A, g), s !== null && (ur(s, i, g), wl(s, i, g));
    },
    enqueueForceUpdate: function(i, s) {
      i = i._reactInternals;
      var h = is(), g = Ws(h);
      g.tag = 2, s != null && (g.callback = s), s = zs(i, g, h), s !== null && (ur(s, i, h), wl(s, i, h));
    }
  };
  function Nm(i, s, h, g, A, I, F) {
    return i = i.stateNode, typeof i.shouldComponentUpdate == "function" ? i.shouldComponentUpdate(g, I, F) : s.prototype && s.prototype.isPureReactComponent ? !gr(h, g) || !gr(A, I) : !0;
  }
  function op(i, s, h, g) {
    i = s.state, typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps(h, g), typeof s.UNSAFE_componentWillReceiveProps == "function" && s.UNSAFE_componentWillReceiveProps(h, g), s.state !== i && Jh.enqueueReplaceState(s, s.state, null);
  }
  function du(i, s) {
    var h = s;
    if ("ref" in s) {
      h = {};
      for (var g in s)
        g !== "ref" && (h[g] = s[g]);
    }
    if (i = i.defaultProps) {
      h === s && (h = ae({}, h));
      for (var A in i)
        h[A] === void 0 && (h[A] = i[A]);
    }
    return h;
  }
  function mf(i) {
    pl(i);
  }
  function hc(i) {
    console.error(i);
  }
  function jm(i) {
    pl(i);
  }
  function pu(i, s) {
    try {
      var h = i.onUncaughtError;
      h(s.value, { componentStack: s.stack });
    } catch (g) {
      setTimeout(function() {
        throw g;
      });
    }
  }
  function Qh(i, s, h) {
    try {
      var g = i.onCaughtError;
      g(h.value, {
        componentStack: h.stack,
        errorBoundary: s.tag === 1 ? s.stateNode : null
      });
    } catch (A) {
      setTimeout(function() {
        throw A;
      });
    }
  }
  function Jc(i, s, h) {
    return h = Ws(h), h.tag = 3, h.payload = { element: null }, h.callback = function() {
      pu(i, s);
    }, h;
  }
  function gf(i) {
    return i = Ws(i), i.tag = 3, i;
  }
  function yf(i, s, h, g) {
    var A = h.type.getDerivedStateFromError;
    if (typeof A == "function") {
      var I = g.value;
      i.payload = function() {
        return A(I);
      }, i.callback = function() {
        Qh(s, h, g);
      };
    }
    var F = h.stateNode;
    F !== null && typeof F.componentDidCatch == "function" && (i.callback = function() {
      Qh(s, h, g), typeof A != "function" && (gu === null ? gu = /* @__PURE__ */ new Set([this]) : gu.add(this));
      var W = g.stack;
      this.componentDidCatch(g.value, {
        componentStack: W !== null ? W : ""
      });
    });
  }
  function vy(i, s, h, g, A) {
    if (h.flags |= 32768, g !== null && typeof g == "object" && typeof g.then == "function") {
      if (s = h.alternate, s !== null && ea(
        s,
        h,
        A,
        !0
      ), h = br.current, h !== null) {
        switch (h.tag) {
          case 31:
          case 13:
            return Pa === null ? dd() : h.alternate === null && qn === 0 && (qn = 3), h.flags &= -257, h.flags |= 65536, h.lanes = A, g === vl ? h.flags |= 16384 : (s = h.updateQueue, s === null ? h.updateQueue = /* @__PURE__ */ new Set([g]) : s.add(g), fd(i, g, A)), !1;
          case 22:
            return h.flags |= 65536, g === vl ? h.flags |= 16384 : (s = h.updateQueue, s === null ? (s = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([g])
            }, h.updateQueue = s) : (h = s.retryQueue, h === null ? s.retryQueue = /* @__PURE__ */ new Set([g]) : h.add(g)), fd(i, g, A)), !1;
        }
        throw Error(b(435, h.tag));
      }
      return fd(i, g, A), dd(), !1;
    }
    if (wi)
      return s = br.current, s !== null ? ((s.flags & 65536) === 0 && (s.flags |= 256), s.flags |= 65536, s.lanes = A, g !== ar && (i = Error(b(422), { cause: g }), yl(tr(i, h)))) : (g !== ar && (s = Error(b(423), {
        cause: g
      }), yl(
        tr(s, h)
      )), i = i.current.alternate, i.flags |= 65536, A &= -A, i.lanes |= A, g = tr(g, h), A = Jc(
        i.stateNode,
        g,
        A
      ), Kc(i, A), qn !== 4 && (qn = 2)), !1;
    var I = Error(b(520), { cause: g });
    if (I = tr(I, h), bc === null ? bc = [I] : bc.push(I), qn !== 4 && (qn = 2), s === null) return !0;
    g = tr(g, h), h = s;
    do {
      switch (h.tag) {
        case 3:
          return h.flags |= 65536, i = A & -A, h.lanes |= i, i = Jc(h.stateNode, g, i), Kc(h, i), !1;
        case 1:
          if (s = h.type, I = h.stateNode, (h.flags & 128) === 0 && (typeof s.getDerivedStateFromError == "function" || I !== null && typeof I.componentDidCatch == "function" && (gu === null || !gu.has(I))))
            return h.flags |= 65536, A &= -A, h.lanes |= A, A = gf(A), yf(
              A,
              i,
              h,
              g
            ), Kc(h, A), !1;
      }
      h = h.return;
    } while (h !== null);
    return !1;
  }
  var _f = Error(b(461)), ia = !1;
  function Ia(i, s, h, g) {
    s.child = i === null ? Br(s, null, h, g) : Do(
      s,
      i.child,
      h,
      g
    );
  }
  function vf(i, s, h, g, A) {
    h = h.render;
    var I = s.ref;
    if ("ref" in g) {
      var F = {};
      for (var W in g)
        W !== "ref" && (F[W] = g[W]);
    } else F = g;
    return Ks(s), g = _(
      i,
      s,
      h,
      F,
      I,
      A
    ), W = R(), i !== null && !ia ? (L(i, s, A), Tr(i, s, A)) : (wi && W && Hc(s), s.flags |= 1, Ia(i, s, g, A), s.child);
  }
  function Um(i, s, h, g, A) {
    if (i === null) {
      var I = h.type;
      return typeof I == "function" && !vs(I) && I.defaultProps === void 0 && h.compare === null ? (s.tag = 15, s.type = I, lp(
        i,
        s,
        I,
        g,
        A
      )) : (i = Ku(
        h.type,
        null,
        g,
        s,
        s.mode,
        A
      ), i.ref = s.ref, i.return = s, s.child = i);
    }
    if (I = i.child, !pc(i, A)) {
      var F = I.memoizedProps;
      if (h = h.compare, h = h !== null ? h : gr, h(F, g) && i.ref === s.ref)
        return Tr(i, s, A);
    }
    return s.flags |= 1, i = xs(I, g), i.ref = s.ref, i.return = s, s.child = i;
  }
  function lp(i, s, h, g, A) {
    if (i !== null) {
      var I = i.memoizedProps;
      if (gr(I, g) && i.ref === s.ref)
        if (ia = !1, s.pendingProps = g = I, pc(i, A))
          (i.flags & 131072) !== 0 && (ia = !0);
        else
          return s.lanes = i.lanes, Tr(i, s, A);
    }
    return cp(
      i,
      s,
      h,
      g,
      A
    );
  }
  function xf(i, s, h, g) {
    var A = g.children, I = i !== null ? i.memoizedState : null;
    if (i === null && s.stateNode === null && (s.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), g.mode === "hidden") {
      if ((s.flags & 128) !== 0) {
        if (I = I !== null ? I.baseLanes | h : h, i !== null) {
          for (g = s.child = i.child, A = 0; g !== null; )
            A = A | g.lanes | g.childLanes, g = g.sibling;
          g = A & ~I;
        } else g = 0, s.child = null;
        return Qc(
          i,
          s,
          I,
          h,
          g
        );
      }
      if ((h & 536870912) !== 0)
        s.memoizedState = { baseLanes: 0, cachePool: null }, i !== null && su(
          s,
          I !== null ? I.cachePool : null
        ), I !== null ? za(s, I) : Wc(), oc(s);
      else
        return g = s.lanes = 536870912, Qc(
          i,
          s,
          I !== null ? I.baseLanes | h : h,
          h,
          g
        );
    } else
      I !== null ? (su(s, I.cachePool), za(s, I), wr(), s.memoizedState = null) : (i !== null && su(s, null), Wc(), wr());
    return Ia(i, s, A, h), s.child;
  }
  function dc(i, s) {
    return i !== null && i.tag === 22 || s.stateNode !== null || (s.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), s.sibling;
  }
  function Qc(i, s, h, g, A) {
    var I = xt();
    return I = I === null ? null : { parent: ki._currentValue, pool: I }, s.memoizedState = {
      baseLanes: h,
      cachePool: I
    }, i !== null && su(s, null), Wc(), oc(s), i !== null && ea(i, s, g, !0), s.childLanes = A, null;
  }
  function ka(i, s) {
    return s = dp(
      { mode: s.mode, children: s.children },
      i.mode
    ), s.ref = i.ref, i.child = s, s.return = i, s;
  }
  function bf(i, s, h) {
    return Do(s, i.child, null, h), i = ka(s, s.pendingProps), i.flags |= 2, da(s), s.memoizedState = null, i;
  }
  function wf(i, s, h) {
    var g = s.pendingProps, A = (s.flags & 128) !== 0;
    if (s.flags &= -129, i === null) {
      if (wi) {
        if (g.mode === "hidden")
          return i = ka(s, g), s.lanes = 536870912, dc(null, i);
        if (fn(s), (i = ln) ? (i = Dp(
          i,
          On
        ), i = i !== null && i.data === "&" ? i : null, i !== null && (s.memoizedState = {
          dehydrated: i,
          treeContext: nr !== null ? { id: Lr, overflow: yr } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, h = Ju(i), h.return = s, s.child = h, Qn = s, ln = null)) : i = null, i === null) throw Qr(s);
        return s.lanes = 536870912, null;
      }
      return ka(s, g);
    }
    var I = i.memoizedState;
    if (I !== null) {
      var F = I.dehydrated;
      if (fn(s), A)
        if (s.flags & 256)
          s.flags &= -257, s = bf(
            i,
            s,
            h
          );
        else if (s.memoizedState !== null)
          s.child = i.child, s.flags |= 128, s = null;
        else throw Error(b(558));
      else if (ia || ea(i, s, h, !1), A = (h & i.childLanes) !== 0, ia || A) {
        if (g = sn, g !== null && (F = kn(g, h), F !== 0 && F !== I.retryLane))
          throw I.retryLane = F, Ao(i, F), ur(g, i, F), _f;
        dd(), s = bf(
          i,
          s,
          h
        );
      } else
        i = I.treeContext, ln = qr(F.nextSibling), Qn = s, wi = !0, Vi = null, On = !1, i !== null && Qu(s, i), s = ka(s, g), s.flags |= 4096;
      return s;
    }
    return i = xs(i.child, {
      mode: g.mode,
      children: g.children
    }), i.ref = s.ref, s.child = i, i.return = s, i;
  }
  function up(i, s) {
    var h = s.ref;
    if (h === null)
      i !== null && i.ref !== null && (s.flags |= 4194816);
    else {
      if (typeof h != "function" && typeof h != "object")
        throw Error(b(284));
      (i === null || i.ref !== h) && (s.flags |= 4194816);
    }
  }
  function cp(i, s, h, g, A) {
    return Ks(s), h = _(
      i,
      s,
      h,
      g,
      void 0,
      A
    ), g = R(), i !== null && !ia ? (L(i, s, A), Tr(i, s, A)) : (wi && g && Hc(s), s.flags |= 1, Ia(i, s, h, A), s.child);
  }
  function Fm(i, s, h, g, A, I) {
    return Ks(s), s.updateQueue = null, h = C(
      s,
      g,
      h,
      A
    ), w(i), g = R(), i !== null && !ia ? (L(i, s, I), Tr(i, s, I)) : (wi && g && Hc(s), s.flags |= 1, Ia(i, s, h, I), s.child);
  }
  function Vm(i, s, h, g, A) {
    if (Ks(s), s.stateNode === null) {
      var I = _s, F = h.contextType;
      typeof F == "object" && F !== null && (I = ha(F)), I = new h(g, I), s.memoizedState = I.state !== null && I.state !== void 0 ? I.state : null, I.updater = Jh, s.stateNode = I, I._reactInternals = s, I = s.stateNode, I.props = g, I.state = s.memoizedState, I.refs = {}, Lo(s), F = h.contextType, I.context = typeof F == "object" && F !== null ? ha(F) : _s, I.state = s.memoizedState, F = h.getDerivedStateFromProps, typeof F == "function" && (ff(
        s,
        h,
        F,
        g
      ), I.state = s.memoizedState), typeof h.getDerivedStateFromProps == "function" || typeof I.getSnapshotBeforeUpdate == "function" || typeof I.UNSAFE_componentWillMount != "function" && typeof I.componentWillMount != "function" || (F = I.state, typeof I.componentWillMount == "function" && I.componentWillMount(), typeof I.UNSAFE_componentWillMount == "function" && I.UNSAFE_componentWillMount(), F !== I.state && Jh.enqueueReplaceState(I, I.state, null), Tt(s, g, I, A), Oo(), I.state = s.memoizedState), typeof I.componentDidMount == "function" && (s.flags |= 4194308), g = !0;
    } else if (i === null) {
      I = s.stateNode;
      var W = s.memoizedProps, _e = du(h, W);
      I.props = _e;
      var Be = I.context, Ze = h.contextType;
      F = _s, typeof Ze == "object" && Ze !== null && (F = ha(Ze));
      var Ke = h.getDerivedStateFromProps;
      Ze = typeof Ke == "function" || typeof I.getSnapshotBeforeUpdate == "function", W = s.pendingProps !== W, Ze || typeof I.UNSAFE_componentWillReceiveProps != "function" && typeof I.componentWillReceiveProps != "function" || (W || Be !== F) && op(
        s,
        I,
        g,
        F
      ), Li = !1;
      var Ne = s.memoizedState;
      I.state = Ne, Tt(s, g, I, A), Oo(), Be = s.memoizedState, W || Ne !== Be || Li ? (typeof Ke == "function" && (ff(
        s,
        h,
        Ke,
        g
      ), Be = s.memoizedState), (_e = Li || Nm(
        s,
        h,
        _e,
        g,
        Ne,
        Be,
        F
      )) ? (Ze || typeof I.UNSAFE_componentWillMount != "function" && typeof I.componentWillMount != "function" || (typeof I.componentWillMount == "function" && I.componentWillMount(), typeof I.UNSAFE_componentWillMount == "function" && I.UNSAFE_componentWillMount()), typeof I.componentDidMount == "function" && (s.flags |= 4194308)) : (typeof I.componentDidMount == "function" && (s.flags |= 4194308), s.memoizedProps = g, s.memoizedState = Be), I.props = g, I.state = Be, I.context = F, g = _e) : (typeof I.componentDidMount == "function" && (s.flags |= 4194308), g = !1);
    } else {
      I = s.stateNode, rc(i, s), F = s.memoizedProps, Ze = du(h, F), I.props = Ze, Ke = s.pendingProps, Ne = I.context, Be = h.contextType, _e = _s, typeof Be == "object" && Be !== null && (_e = ha(Be)), W = h.getDerivedStateFromProps, (Be = typeof W == "function" || typeof I.getSnapshotBeforeUpdate == "function") || typeof I.UNSAFE_componentWillReceiveProps != "function" && typeof I.componentWillReceiveProps != "function" || (F !== Ke || Ne !== _e) && op(
        s,
        I,
        g,
        _e
      ), Li = !1, Ne = s.memoizedState, I.state = Ne, Tt(s, g, I, A), Oo();
      var Ve = s.memoizedState;
      F !== Ke || Ne !== Ve || Li || i !== null && i.dependencies !== null && Ys(i.dependencies) ? (typeof W == "function" && (ff(
        s,
        h,
        W,
        g
      ), Ve = s.memoizedState), (Ze = Li || Nm(
        s,
        h,
        Ze,
        g,
        Ne,
        Ve,
        _e
      ) || i !== null && i.dependencies !== null && Ys(i.dependencies)) ? (Be || typeof I.UNSAFE_componentWillUpdate != "function" && typeof I.componentWillUpdate != "function" || (typeof I.componentWillUpdate == "function" && I.componentWillUpdate(g, Ve, _e), typeof I.UNSAFE_componentWillUpdate == "function" && I.UNSAFE_componentWillUpdate(
        g,
        Ve,
        _e
      )), typeof I.componentDidUpdate == "function" && (s.flags |= 4), typeof I.getSnapshotBeforeUpdate == "function" && (s.flags |= 1024)) : (typeof I.componentDidUpdate != "function" || F === i.memoizedProps && Ne === i.memoizedState || (s.flags |= 4), typeof I.getSnapshotBeforeUpdate != "function" || F === i.memoizedProps && Ne === i.memoizedState || (s.flags |= 1024), s.memoizedProps = g, s.memoizedState = Ve), I.props = g, I.state = Ve, I.context = _e, g = Ze) : (typeof I.componentDidUpdate != "function" || F === i.memoizedProps && Ne === i.memoizedState || (s.flags |= 4), typeof I.getSnapshotBeforeUpdate != "function" || F === i.memoizedProps && Ne === i.memoizedState || (s.flags |= 1024), g = !1);
    }
    return I = g, up(i, s), g = (s.flags & 128) !== 0, I || g ? (I = s.stateNode, h = g && typeof h.getDerivedStateFromError != "function" ? null : I.render(), s.flags |= 1, i !== null && g ? (s.child = Do(
      s,
      i.child,
      null,
      A
    ), s.child = Do(
      s,
      null,
      h,
      A
    )) : Ia(i, s, h, A), s.memoizedState = I.state, i = s.child) : i = Tr(
      i,
      s,
      A
    ), i;
  }
  function Sf(i, s, h, g) {
    return ws(), s.flags |= 256, Ia(i, s, h, g), s.child;
  }
  var Tf = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function ed(i) {
    return { baseLanes: i, cachePool: ic() };
  }
  function hp(i, s, h) {
    return i = i !== null ? i.childLanes & ~h : 0, s && (i |= Za), i;
  }
  function Mf(i, s, h) {
    var g = s.pendingProps, A = !1, I = (s.flags & 128) !== 0, F;
    if ((F = I) || (F = i !== null && i.memoizedState === null ? !1 : (Sn.current & 2) !== 0), F && (A = !0, s.flags &= -129), F = (s.flags & 32) !== 0, s.flags &= -33, i === null) {
      if (wi) {
        if (A ? Ti(s) : wr(), (i = ln) ? (i = Dp(
          i,
          On
        ), i = i !== null && i.data !== "&" ? i : null, i !== null && (s.memoizedState = {
          dehydrated: i,
          treeContext: nr !== null ? { id: Lr, overflow: yr } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, h = Ju(i), h.return = s, s.child = h, Qn = s, ln = null)) : i = null, i === null) throw Qr(s);
        return Lp(i) ? s.lanes = 32 : s.lanes = 536870912, null;
      }
      var W = g.children;
      return g = g.fallback, A ? (wr(), A = s.mode, W = dp(
        { mode: "hidden", children: W },
        A
      ), g = fl(
        g,
        A,
        h,
        null
      ), W.return = s, g.return = s, W.sibling = g, s.child = W, g = s.child, g.memoizedState = ed(h), g.childLanes = hp(
        i,
        F,
        h
      ), s.memoizedState = Tf, dc(null, g)) : (Ti(s), Af(s, W));
    }
    var _e = i.memoizedState;
    if (_e !== null && (W = _e.dehydrated, W !== null)) {
      if (I)
        s.flags & 256 ? (Ti(s), s.flags &= -257, s = Ef(
          i,
          s,
          h
        )) : s.memoizedState !== null ? (wr(), s.child = i.child, s.flags |= 128, s = null) : (wr(), W = g.fallback, A = s.mode, g = dp(
          { mode: "visible", children: g.children },
          A
        ), W = fl(
          W,
          A,
          h,
          null
        ), W.flags |= 2, g.return = s, W.return = s, g.sibling = W, s.child = g, Do(
          s,
          i.child,
          null,
          h
        ), g = s.child, g.memoizedState = ed(h), g.childLanes = hp(
          i,
          F,
          h
        ), s.memoizedState = Tf, s = dc(null, g));
      else if (Ti(s), Lp(W)) {
        if (F = W.nextSibling && W.nextSibling.dataset, F) var Be = F.dgst;
        F = Be, g = Error(b(419)), g.stack = "", g.digest = F, yl({ value: g, source: null, stack: null }), s = Ef(
          i,
          s,
          h
        );
      } else if (ia || ea(i, s, h, !1), F = (h & i.childLanes) !== 0, ia || F) {
        if (F = sn, F !== null && (g = kn(F, h), g !== 0 && g !== _e.retryLane))
          throw _e.retryLane = g, Ao(i, g), ur(F, i, g), _f;
        vd(W) || dd(), s = Ef(
          i,
          s,
          h
        );
      } else
        vd(W) ? (s.flags |= 192, s.child = i.child, s = null) : (i = _e.treeContext, ln = qr(
          W.nextSibling
        ), Qn = s, wi = !0, Vi = null, On = !1, i !== null && Qu(s, i), s = Af(
          s,
          g.children
        ), s.flags |= 4096);
      return s;
    }
    return A ? (wr(), W = g.fallback, A = s.mode, _e = i.child, Be = _e.sibling, g = xs(_e, {
      mode: "hidden",
      children: g.children
    }), g.subtreeFlags = _e.subtreeFlags & 65011712, Be !== null ? W = xs(
      Be,
      W
    ) : (W = fl(
      W,
      A,
      h,
      null
    ), W.flags |= 2), W.return = s, g.return = s, g.sibling = W, s.child = g, dc(null, g), g = s.child, W = i.child.memoizedState, W === null ? W = ed(h) : (A = W.cachePool, A !== null ? (_e = ki._currentValue, A = A.parent !== _e ? { parent: _e, pool: _e } : A) : A = ic(), W = {
      baseLanes: W.baseLanes | h,
      cachePool: A
    }), g.memoizedState = W, g.childLanes = hp(
      i,
      F,
      h
    ), s.memoizedState = Tf, dc(i.child, g)) : (Ti(s), h = i.child, i = h.sibling, h = xs(h, {
      mode: "visible",
      children: g.children
    }), h.return = s, h.sibling = null, i !== null && (F = s.deletions, F === null ? (s.deletions = [i], s.flags |= 16) : F.push(i)), s.child = h, s.memoizedState = null, h);
  }
  function Af(i, s) {
    return s = dp(
      { mode: "visible", children: s },
      i.mode
    ), s.return = i, i.child = s;
  }
  function dp(i, s) {
    return i = er(22, i, null, s), i.lanes = 0, i;
  }
  function Ef(i, s, h) {
    return Do(s, i.child, null, h), i = Af(
      s,
      s.pendingProps.children
    ), i.flags |= 2, s.memoizedState = null, i;
  }
  function pp(i, s, h) {
    i.lanes |= s;
    var g = i.alternate;
    g !== null && (g.lanes |= s), _r(i.return, s, h);
  }
  function td(i, s, h, g, A, I) {
    var F = i.memoizedState;
    F === null ? i.memoizedState = {
      isBackwards: s,
      rendering: null,
      renderingStartTime: 0,
      last: g,
      tail: h,
      tailMode: A,
      treeForkCount: I
    } : (F.isBackwards = s, F.rendering = null, F.renderingStartTime = 0, F.last = g, F.tail = h, F.tailMode = A, F.treeForkCount = I);
  }
  function Cf(i, s, h) {
    var g = s.pendingProps, A = g.revealOrder, I = g.tail;
    g = g.children;
    var F = Sn.current, W = (F & 2) !== 0;
    if (W ? (F = F & 1 | 2, s.flags |= 128) : F &= 1, et(Sn, F), Ia(i, s, g, h), g = wi ? Hs : 0, !W && i !== null && (i.flags & 128) !== 0)
      e: for (i = s.child; i !== null; ) {
        if (i.tag === 13)
          i.memoizedState !== null && pp(i, h, s);
        else if (i.tag === 19)
          pp(i, h, s);
        else if (i.child !== null) {
          i.child.return = i, i = i.child;
          continue;
        }
        if (i === s) break e;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === s)
            break e;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
    switch (A) {
      case "forwards":
        for (h = s.child, A = null; h !== null; )
          i = h.alternate, i !== null && Js(i) === null && (A = h), h = h.sibling;
        h = A, h === null ? (A = s.child, s.child = null) : (A = h.sibling, h.sibling = null), td(
          s,
          !1,
          A,
          h,
          I,
          g
        );
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (h = null, A = s.child, s.child = null; A !== null; ) {
          if (i = A.alternate, i !== null && Js(i) === null) {
            s.child = A;
            break;
          }
          i = A.sibling, A.sibling = h, h = A, A = i;
        }
        td(
          s,
          !0,
          h,
          null,
          I,
          g
        );
        break;
      case "together":
        td(
          s,
          !1,
          null,
          null,
          void 0,
          g
        );
        break;
      default:
        s.memoizedState = null;
    }
    return s.child;
  }
  function Tr(i, s, h) {
    if (i !== null && (s.dependencies = i.dependencies), Cl |= s.lanes, (h & s.childLanes) === 0)
      if (i !== null) {
        if (ea(
          i,
          s,
          h,
          !1
        ), (h & s.childLanes) === 0)
          return null;
      } else return null;
    if (i !== null && s.child !== i.child)
      throw Error(b(153));
    if (s.child !== null) {
      for (i = s.child, h = xs(i, i.pendingProps), s.child = h, h.return = s; i.sibling !== null; )
        i = i.sibling, h = h.sibling = xs(i, i.pendingProps), h.return = s;
      h.sibling = null;
    }
    return s.child;
  }
  function pc(i, s) {
    return (i.lanes & s) !== 0 ? !0 : (i = i.dependencies, !!(i !== null && Ys(i)));
  }
  function xy(i, s, h) {
    switch (s.tag) {
      case 3:
        Ii(s, s.stateNode.containerInfo), Xs(s, ki, i.memoizedState.cache), ws();
        break;
      case 27:
      case 5:
        Ta(s);
        break;
      case 4:
        Ii(s, s.stateNode.containerInfo);
        break;
      case 10:
        Xs(
          s,
          s.type,
          s.memoizedProps.value
        );
        break;
      case 31:
        if (s.memoizedState !== null)
          return s.flags |= 128, fn(s), null;
        break;
      case 13:
        var g = s.memoizedState;
        if (g !== null)
          return g.dehydrated !== null ? (Ti(s), s.flags |= 128, null) : (h & s.child.childLanes) !== 0 ? Mf(i, s, h) : (Ti(s), i = Tr(
            i,
            s,
            h
          ), i !== null ? i.sibling : null);
        Ti(s);
        break;
      case 19:
        var A = (i.flags & 128) !== 0;
        if (g = (h & s.childLanes) !== 0, g || (ea(
          i,
          s,
          h,
          !1
        ), g = (h & s.childLanes) !== 0), A) {
          if (g)
            return Cf(
              i,
              s,
              h
            );
          s.flags |= 128;
        }
        if (A = s.memoizedState, A !== null && (A.rendering = null, A.tail = null, A.lastEffect = null), et(Sn, Sn.current), g) break;
        return null;
      case 22:
        return s.lanes = 0, xf(
          i,
          s,
          h,
          s.pendingProps
        );
      case 24:
        Xs(s, ki, i.memoizedState.cache);
    }
    return Tr(i, s, h);
  }
  function qm(i, s, h) {
    if (i !== null)
      if (i.memoizedProps !== s.pendingProps)
        ia = !0;
      else {
        if (!pc(i, h) && (s.flags & 128) === 0)
          return ia = !1, xy(
            i,
            s,
            h
          );
        ia = (i.flags & 131072) !== 0;
      }
    else
      ia = !1, wi && (s.flags & 1048576) !== 0 && $c(s, Hs, s.index);
    switch (s.lanes = 0, s.tag) {
      case 16:
        e: {
          var g = s.pendingProps;
          if (i = xl(s.elementType), s.type = i, typeof i == "function")
            vs(i) ? (g = du(i, g), s.tag = 1, s = Vm(
              null,
              s,
              i,
              g,
              h
            )) : (s.tag = 0, s = cp(
              null,
              s,
              i,
              g,
              h
            ));
          else {
            if (i != null) {
              var A = i.$$typeof;
              if (A === De) {
                s.tag = 11, s = vf(
                  null,
                  s,
                  i,
                  g,
                  h
                );
                break e;
              } else if (A === rt) {
                s.tag = 14, s = Um(
                  null,
                  s,
                  i,
                  g,
                  h
                );
                break e;
              }
            }
            throw s = Cn(i) || i, Error(b(306, s, ""));
          }
        }
        return s;
      case 0:
        return cp(
          i,
          s,
          s.type,
          s.pendingProps,
          h
        );
      case 1:
        return g = s.type, A = du(
          g,
          s.pendingProps
        ), Vm(
          i,
          s,
          g,
          A,
          h
        );
      case 3:
        e: {
          if (Ii(
            s,
            s.stateNode.containerInfo
          ), i === null) throw Error(b(387));
          g = s.pendingProps;
          var I = s.memoizedState;
          A = I.element, rc(i, s), Tt(s, g, null, h);
          var F = s.memoizedState;
          if (g = F.cache, Xs(s, ki, g), g !== I.cache && zo(
            s,
            [ki],
            h,
            !0
          ), Oo(), g = F.element, I.isDehydrated)
            if (I = {
              element: g,
              isDehydrated: !1,
              cache: F.cache
            }, s.updateQueue.baseState = I, s.memoizedState = I, s.flags & 256) {
              s = Sf(
                i,
                s,
                g,
                h
              );
              break e;
            } else if (g !== A) {
              A = tr(
                Error(b(424)),
                s
              ), yl(A), s = Sf(
                i,
                s,
                g,
                h
              );
              break e;
            } else {
              switch (i = s.stateNode.containerInfo, i.nodeType) {
                case 9:
                  i = i.body;
                  break;
                default:
                  i = i.nodeName === "HTML" ? i.ownerDocument.body : i;
              }
              for (ln = qr(i.firstChild), Qn = s, wi = !0, Vi = null, On = !0, h = Br(
                s,
                null,
                g,
                h
              ), s.child = h; h; )
                h.flags = h.flags & -3 | 4096, h = h.sibling;
            }
          else {
            if (ws(), g === A) {
              s = Tr(
                i,
                s,
                h
              );
              break e;
            }
            Ia(i, s, g, h);
          }
          s = s.child;
        }
        return s;
      case 26:
        return up(i, s), i === null ? (h = q(
          s.type,
          null,
          s.pendingProps,
          null
        )) ? s.memoizedState = h : wi || (h = s.type, i = s.pendingProps, g = Ac(
          Vt.current
        ).createElement(h), g[st] = s, g[Zt] = i, $a(g, h, i), Rn(g), s.stateNode = g) : s.memoizedState = q(
          s.type,
          i.memoizedProps,
          s.pendingProps,
          i.memoizedState
        ), null;
      case 27:
        return Ta(s), i === null && wi && (g = s.stateNode = mh(
          s.type,
          s.pendingProps,
          Vt.current
        ), Qn = s, On = !0, A = ln, Ho(s.type) ? (Op = A, ln = qr(g.firstChild)) : ln = A), Ia(
          i,
          s,
          s.pendingProps.children,
          h
        ), up(i, s), i === null && (s.flags |= 4194304), s.child;
      case 5:
        return i === null && wi && ((A = g = ln) && (g = Py(
          g,
          s.type,
          s.pendingProps,
          On
        ), g !== null ? (s.stateNode = g, Qn = s, ln = qr(g.firstChild), On = !1, A = !0) : A = !1), A || Qr(s)), Ta(s), A = s.type, I = s.pendingProps, F = i !== null ? i.memoizedProps : null, g = I.children, am(A, I) ? g = null : F !== null && am(A, F) && (s.flags |= 32), s.memoizedState !== null && (A = _(
          i,
          s,
          P,
          null,
          null,
          h
        ), li._currentValue = A), up(i, s), Ia(i, s, g, h), s.child;
      case 6:
        return i === null && wi && ((i = h = ln) && (h = Sg(
          h,
          s.pendingProps,
          On
        ), h !== null ? (s.stateNode = h, Qn = s, ln = null, i = !0) : i = !1), i || Qr(s)), null;
      case 13:
        return Mf(i, s, h);
      case 4:
        return Ii(
          s,
          s.stateNode.containerInfo
        ), g = s.pendingProps, i === null ? s.child = Do(
          s,
          null,
          g,
          h
        ) : Ia(i, s, g, h), s.child;
      case 11:
        return vf(
          i,
          s,
          s.type,
          s.pendingProps,
          h
        );
      case 7:
        return Ia(
          i,
          s,
          s.pendingProps,
          h
        ), s.child;
      case 8:
        return Ia(
          i,
          s,
          s.pendingProps.children,
          h
        ), s.child;
      case 12:
        return Ia(
          i,
          s,
          s.pendingProps.children,
          h
        ), s.child;
      case 10:
        return g = s.pendingProps, Xs(s, s.type, g.value), Ia(i, s, g.children, h), s.child;
      case 9:
        return A = s.type._context, g = s.pendingProps.children, Ks(s), A = ha(A), g = g(A), s.flags |= 1, Ia(i, s, g, h), s.child;
      case 14:
        return Um(
          i,
          s,
          s.type,
          s.pendingProps,
          h
        );
      case 15:
        return lp(
          i,
          s,
          s.type,
          s.pendingProps,
          h
        );
      case 19:
        return Cf(i, s, h);
      case 31:
        return wf(i, s, h);
      case 22:
        return xf(
          i,
          s,
          h,
          s.pendingProps
        );
      case 24:
        return Ks(s), g = ha(ki), i === null ? (A = xt(), A === null && (A = sn, I = vr(), A.pooledCache = I, I.refCount++, I !== null && (A.pooledCacheLanes |= h), A = I), s.memoizedState = { parent: g, cache: A }, Lo(s), Xs(s, ki, A)) : ((i.lanes & h) !== 0 && (rc(i, s), Tt(s, null, null, h), Oo()), A = i.memoizedState, I = s.memoizedState, A.parent !== g ? (A = { parent: g, cache: g }, s.memoizedState = A, s.lanes === 0 && (s.memoizedState = s.updateQueue.baseState = A), Xs(s, ki, g)) : (g = I.cache, Xs(s, ki, g), g !== A.cache && zo(
          s,
          [ki],
          h,
          !0
        ))), Ia(
          i,
          s,
          s.pendingProps.children,
          h
        ), s.child;
      case 29:
        throw s.pendingProps;
    }
    throw Error(b(156, s.tag));
  }
  function Ml(i) {
    i.flags |= 4;
  }
  function zf(i, s, h, g, A) {
    if ((s = (i.mode & 32) !== 0) && (s = !1), s) {
      if (i.flags |= 16777216, (A & 335544128) === A)
        if (i.stateNode.complete) i.flags |= 8192;
        else if (qf()) i.flags |= 8192;
        else
          throw Cs = vl, ko;
    } else i.flags &= -16777217;
  }
  function Gm(i, s) {
    if (s.type !== "stylesheet" || (s.state.loading & 4) !== 0)
      i.flags &= -16777217;
    else if (i.flags |= 16777216, !kt(s))
      if (qf()) i.flags |= 8192;
      else
        throw Cs = vl, ko;
  }
  function fp(i, s) {
    s !== null && (i.flags |= 4), i.flags & 16384 && (s = i.tag !== 22 ? Yi() : 536870912, i.lanes |= s, Tn |= s);
  }
  function id(i, s) {
    if (!wi)
      switch (i.tailMode) {
        case "hidden":
          s = i.tail;
          for (var h = null; s !== null; )
            s.alternate !== null && (h = s), s = s.sibling;
          h === null ? i.tail = null : h.sibling = null;
          break;
        case "collapsed":
          h = i.tail;
          for (var g = null; h !== null; )
            h.alternate !== null && (g = h), h = h.sibling;
          g === null ? s || i.tail === null ? i.tail = null : i.tail.sibling = null : g.sibling = null;
      }
  }
  function cn(i) {
    var s = i.alternate !== null && i.alternate.child === i.child, h = 0, g = 0;
    if (s)
      for (var A = i.child; A !== null; )
        h |= A.lanes | A.childLanes, g |= A.subtreeFlags & 65011712, g |= A.flags & 65011712, A.return = i, A = A.sibling;
    else
      for (A = i.child; A !== null; )
        h |= A.lanes | A.childLanes, g |= A.subtreeFlags, g |= A.flags, A.return = i, A = A.sibling;
    return i.subtreeFlags |= g, i.childLanes = h, s;
  }
  function by(i, s, h) {
    var g = s.pendingProps;
    switch (Xc(s), s.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return cn(s), null;
      case 1:
        return cn(s), null;
      case 3:
        return h = s.stateNode, g = null, i !== null && (g = i.memoizedState.cache), s.memoizedState.cache !== g && (s.flags |= 2048), Ts(ki), xi(), h.pendingContext && (h.context = h.pendingContext, h.pendingContext = null), (i === null || i.child === null) && (Or(s) ? Ml(s) : i === null || i.memoizedState.isDehydrated && (s.flags & 256) === 0 || (s.flags |= 1024, es())), cn(s), null;
      case 26:
        var A = s.type, I = s.memoizedState;
        return i === null ? (Ml(s), I !== null ? (cn(s), Gm(s, I)) : (cn(s), zf(
          s,
          A,
          null,
          g,
          h
        ))) : I ? I !== i.memoizedState ? (Ml(s), cn(s), Gm(s, I)) : (cn(s), s.flags &= -16777217) : (i = i.memoizedProps, i !== g && Ml(s), cn(s), zf(
          s,
          A,
          i,
          g,
          h
        )), null;
      case 27:
        if (bi(s), h = Vt.current, A = s.type, i !== null && s.stateNode != null)
          i.memoizedProps !== g && Ml(s);
        else {
          if (!g) {
            if (s.stateNode === null)
              throw Error(b(166));
            return cn(s), null;
          }
          i = dt.current, Or(s) ? iu(s) : (i = mh(A, g, h), s.stateNode = i, Ml(s));
        }
        return cn(s), null;
      case 5:
        if (bi(s), A = s.type, i !== null && s.stateNode != null)
          i.memoizedProps !== g && Ml(s);
        else {
          if (!g) {
            if (s.stateNode === null)
              throw Error(b(166));
            return cn(s), null;
          }
          if (I = dt.current, Or(s))
            iu(s);
          else {
            var F = Ac(
              Vt.current
            );
            switch (I) {
              case 1:
                I = F.createElementNS(
                  "http://www.w3.org/2000/svg",
                  A
                );
                break;
              case 2:
                I = F.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  A
                );
                break;
              default:
                switch (A) {
                  case "svg":
                    I = F.createElementNS(
                      "http://www.w3.org/2000/svg",
                      A
                    );
                    break;
                  case "math":
                    I = F.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      A
                    );
                    break;
                  case "script":
                    I = F.createElement("div"), I.innerHTML = "<script><\/script>", I = I.removeChild(
                      I.firstChild
                    );
                    break;
                  case "select":
                    I = typeof g.is == "string" ? F.createElement("select", {
                      is: g.is
                    }) : F.createElement("select"), g.multiple ? I.multiple = !0 : g.size && (I.size = g.size);
                    break;
                  default:
                    I = typeof g.is == "string" ? F.createElement(A, { is: g.is }) : F.createElement(A);
                }
            }
            I[st] = s, I[Zt] = g;
            e: for (F = s.child; F !== null; ) {
              if (F.tag === 5 || F.tag === 6)
                I.appendChild(F.stateNode);
              else if (F.tag !== 4 && F.tag !== 27 && F.child !== null) {
                F.child.return = F, F = F.child;
                continue;
              }
              if (F === s) break e;
              for (; F.sibling === null; ) {
                if (F.return === null || F.return === s)
                  break e;
                F = F.return;
              }
              F.sibling.return = F.return, F = F.sibling;
            }
            s.stateNode = I;
            e: switch ($a(I, A, g), A) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                g = !!g.autoFocus;
                break e;
              case "img":
                g = !0;
                break e;
              default:
                g = !1;
            }
            g && Ml(s);
          }
        }
        return cn(s), zf(
          s,
          s.type,
          i === null ? null : i.memoizedProps,
          s.pendingProps,
          h
        ), null;
      case 6:
        if (i && s.stateNode != null)
          i.memoizedProps !== g && Ml(s);
        else {
          if (typeof g != "string" && s.stateNode === null)
            throw Error(b(166));
          if (i = Vt.current, Or(s)) {
            if (i = s.stateNode, h = s.memoizedProps, g = null, A = Qn, A !== null)
              switch (A.tag) {
                case 27:
                case 5:
                  g = A.memoizedProps;
              }
            i[st] = s, i = !!(i.nodeValue === h || g !== null && g.suppressHydrationWarning === !0 || im(i.nodeValue, h)), i || Qr(s, !0);
          } else
            i = Ac(i).createTextNode(
              g
            ), i[st] = s, s.stateNode = i;
        }
        return cn(s), null;
      case 31:
        if (h = s.memoizedState, i === null || i.memoizedState !== null) {
          if (g = Or(s), h !== null) {
            if (i === null) {
              if (!g) throw Error(b(318));
              if (i = s.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(b(557));
              i[st] = s;
            } else
              ws(), (s.flags & 128) === 0 && (s.memoizedState = null), s.flags |= 4;
            cn(s), i = !1;
          } else
            h = es(), i !== null && i.memoizedState !== null && (i.memoizedState.hydrationErrors = h), i = !0;
          if (!i)
            return s.flags & 256 ? (da(s), s) : (da(s), null);
          if ((s.flags & 128) !== 0)
            throw Error(b(558));
        }
        return cn(s), null;
      case 13:
        if (g = s.memoizedState, i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) {
          if (A = Or(s), g !== null && g.dehydrated !== null) {
            if (i === null) {
              if (!A) throw Error(b(318));
              if (A = s.memoizedState, A = A !== null ? A.dehydrated : null, !A) throw Error(b(317));
              A[st] = s;
            } else
              ws(), (s.flags & 128) === 0 && (s.memoizedState = null), s.flags |= 4;
            cn(s), A = !1;
          } else
            A = es(), i !== null && i.memoizedState !== null && (i.memoizedState.hydrationErrors = A), A = !0;
          if (!A)
            return s.flags & 256 ? (da(s), s) : (da(s), null);
        }
        return da(s), (s.flags & 128) !== 0 ? (s.lanes = h, s) : (h = g !== null, i = i !== null && i.memoizedState !== null, h && (g = s.child, A = null, g.alternate !== null && g.alternate.memoizedState !== null && g.alternate.memoizedState.cachePool !== null && (A = g.alternate.memoizedState.cachePool.pool), I = null, g.memoizedState !== null && g.memoizedState.cachePool !== null && (I = g.memoizedState.cachePool.pool), I !== A && (g.flags |= 2048)), h !== i && h && (s.child.flags |= 8192), fp(s, s.updateQueue), cn(s), null);
      case 4:
        return xi(), i === null && Mc(s.stateNode.containerInfo), cn(s), null;
      case 10:
        return Ts(s.type), cn(s), null;
      case 19:
        if (Ue(Sn), g = s.memoizedState, g === null) return cn(s), null;
        if (A = (s.flags & 128) !== 0, I = g.rendering, I === null)
          if (A) id(g, !1);
          else {
            if (qn !== 0 || i !== null && (i.flags & 128) !== 0)
              for (i = s.child; i !== null; ) {
                if (I = Js(i), I !== null) {
                  for (s.flags |= 128, id(g, !1), i = I.updateQueue, s.updateQueue = i, fp(s, i), s.subtreeFlags = 0, i = h, h = s.child; h !== null; )
                    ip(h, i), h = h.sibling;
                  return et(
                    Sn,
                    Sn.current & 1 | 2
                  ), wi && Fa(s, g.treeForkCount), s.child;
                }
                i = i.sibling;
              }
            g.tail !== null && Yn() > ud && (s.flags |= 128, A = !0, id(g, !1), s.lanes = 4194304);
          }
        else {
          if (!A)
            if (i = Js(I), i !== null) {
              if (s.flags |= 128, A = !0, i = i.updateQueue, s.updateQueue = i, fp(s, i), id(g, !0), g.tail === null && g.tailMode === "hidden" && !I.alternate && !wi)
                return cn(s), null;
            } else
              2 * Yn() - g.renderingStartTime > ud && h !== 536870912 && (s.flags |= 128, A = !0, id(g, !1), s.lanes = 4194304);
          g.isBackwards ? (I.sibling = s.child, s.child = I) : (i = g.last, i !== null ? i.sibling = I : s.child = I, g.last = I);
        }
        return g.tail !== null ? (i = g.tail, g.rendering = i, g.tail = i.sibling, g.renderingStartTime = Yn(), i.sibling = null, h = Sn.current, et(
          Sn,
          A ? h & 1 | 2 : h & 1
        ), wi && Fa(s, g.treeForkCount), i) : (cn(s), null);
      case 22:
      case 23:
        return da(s), rr(), g = s.memoizedState !== null, i !== null ? i.memoizedState !== null !== g && (s.flags |= 8192) : g && (s.flags |= 8192), g ? (h & 536870912) !== 0 && (s.flags & 128) === 0 && (cn(s), s.subtreeFlags & 6 && (s.flags |= 8192)) : cn(s), h = s.updateQueue, h !== null && fp(s, h.retryQueue), h = null, i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (h = i.memoizedState.cachePool.pool), g = null, s.memoizedState !== null && s.memoizedState.cachePool !== null && (g = s.memoizedState.cachePool.pool), g !== h && (s.flags |= 2048), i !== null && Ue(_a), null;
      case 24:
        return h = null, i !== null && (h = i.memoizedState.cache), s.memoizedState.cache !== h && (s.flags |= 2048), Ts(ki), cn(s), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(b(156, s.tag));
  }
  function Zm(i, s) {
    switch (Xc(s), s.tag) {
      case 1:
        return i = s.flags, i & 65536 ? (s.flags = i & -65537 | 128, s) : null;
      case 3:
        return Ts(ki), xi(), i = s.flags, (i & 65536) !== 0 && (i & 128) === 0 ? (s.flags = i & -65537 | 128, s) : null;
      case 26:
      case 27:
      case 5:
        return bi(s), null;
      case 31:
        if (s.memoizedState !== null) {
          if (da(s), s.alternate === null)
            throw Error(b(340));
          ws();
        }
        return i = s.flags, i & 65536 ? (s.flags = i & -65537 | 128, s) : null;
      case 13:
        if (da(s), i = s.memoizedState, i !== null && i.dehydrated !== null) {
          if (s.alternate === null)
            throw Error(b(340));
          ws();
        }
        return i = s.flags, i & 65536 ? (s.flags = i & -65537 | 128, s) : null;
      case 19:
        return Ue(Sn), null;
      case 4:
        return xi(), null;
      case 10:
        return Ts(s.type), null;
      case 22:
      case 23:
        return da(s), rr(), i !== null && Ue(_a), i = s.flags, i & 65536 ? (s.flags = i & -65537 | 128, s) : null;
      case 24:
        return Ts(ki), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function eh(i, s) {
    switch (Xc(s), s.tag) {
      case 3:
        Ts(ki), xi();
        break;
      case 26:
      case 27:
      case 5:
        bi(s);
        break;
      case 4:
        xi();
        break;
      case 31:
        s.memoizedState !== null && da(s);
        break;
      case 13:
        da(s);
        break;
      case 19:
        Ue(Sn);
        break;
      case 10:
        Ts(s.type);
        break;
      case 22:
      case 23:
        da(s), rr(), i !== null && Ue(_a);
        break;
      case 24:
        Ts(ki);
    }
  }
  function nd(i, s) {
    try {
      var h = s.updateQueue, g = h !== null ? h.lastEffect : null;
      if (g !== null) {
        var A = g.next;
        h = A;
        do {
          if ((h.tag & i) === i) {
            g = void 0;
            var I = h.create, F = h.inst;
            g = I(), F.destroy = g;
          }
          h = h.next;
        } while (h !== A);
      }
    } catch (W) {
      Gi(s, s.return, W);
    }
  }
  function Ki(i, s, h) {
    try {
      var g = s.updateQueue, A = g !== null ? g.lastEffect : null;
      if (A !== null) {
        var I = A.next;
        g = I;
        do {
          if ((g.tag & i) === i) {
            var F = g.inst, W = F.destroy;
            if (W !== void 0) {
              F.destroy = void 0, A = s;
              var _e = h, Be = W;
              try {
                Be();
              } catch (Ze) {
                Gi(
                  A,
                  _e,
                  Ze
                );
              }
            }
          }
          g = g.next;
        } while (g !== I);
      }
    } catch (Ze) {
      Gi(s, s.return, Ze);
    }
  }
  function fc(i) {
    var s = i.updateQueue;
    if (s !== null) {
      var h = i.stateNode;
      try {
        sc(s, h);
      } catch (g) {
        Gi(i, i.return, g);
      }
    }
  }
  function Pf(i, s, h) {
    h.props = du(
      i.type,
      i.memoizedProps
    ), h.state = i.memoizedState;
    try {
      h.componentWillUnmount();
    } catch (g) {
      Gi(i, s, g);
    }
  }
  function fu(i, s) {
    try {
      var h = i.ref;
      if (h !== null) {
        switch (i.tag) {
          case 26:
          case 27:
          case 5:
            var g = i.stateNode;
            break;
          case 30:
            g = i.stateNode;
            break;
          default:
            g = i.stateNode;
        }
        typeof h == "function" ? i.refCleanup = h(g) : h.current = g;
      }
    } catch (A) {
      Gi(i, s, A);
    }
  }
  function ts(i, s) {
    var h = i.ref, g = i.refCleanup;
    if (h !== null)
      if (typeof g == "function")
        try {
          g();
        } catch (A) {
          Gi(i, s, A);
        } finally {
          i.refCleanup = null, i = i.alternate, i != null && (i.refCleanup = null);
        }
      else if (typeof h == "function")
        try {
          h(null);
        } catch (A) {
          Gi(i, s, A);
        }
      else h.current = null;
  }
  function th(i) {
    var s = i.type, h = i.memoizedProps, g = i.stateNode;
    try {
      e: switch (s) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          h.autoFocus && g.focus();
          break e;
        case "img":
          h.src ? g.src = h.src : h.srcSet && (g.srcset = h.srcSet);
      }
    } catch (A) {
      Gi(i, i.return, A);
    }
  }
  function mp(i, s, h) {
    try {
      var g = i.stateNode;
      Cy(g, i.type, h, s), g[Zt] = s;
    } catch (A) {
      Gi(i, i.return, A);
    }
  }
  function If(i) {
    return i.tag === 5 || i.tag === 3 || i.tag === 26 || i.tag === 27 && Ho(i.type) || i.tag === 4;
  }
  function mc(i) {
    e: for (; ; ) {
      for (; i.sibling === null; ) {
        if (i.return === null || If(i.return)) return null;
        i = i.return;
      }
      for (i.sibling.return = i.return, i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18; ) {
        if (i.tag === 27 && Ho(i.type) || i.flags & 2 || i.child === null || i.tag === 4) continue e;
        i.child.return = i, i = i.child;
      }
      if (!(i.flags & 2)) return i.stateNode;
    }
  }
  function ad(i, s, h) {
    var g = i.tag;
    if (g === 5 || g === 6)
      i = i.stateNode, s ? (h.nodeType === 9 ? h.body : h.nodeName === "HTML" ? h.ownerDocument.body : h).insertBefore(i, s) : (s = h.nodeType === 9 ? h.body : h.nodeName === "HTML" ? h.ownerDocument.body : h, s.appendChild(i), h = h._reactRootContainer, h != null || s.onclick !== null || (s.onclick = Rr));
    else if (g !== 4 && (g === 27 && Ho(i.type) && (h = i.stateNode, s = null), i = i.child, i !== null))
      for (ad(i, s, h), i = i.sibling; i !== null; )
        ad(i, s, h), i = i.sibling;
  }
  function Al(i, s, h) {
    var g = i.tag;
    if (g === 5 || g === 6)
      i = i.stateNode, s ? h.insertBefore(i, s) : h.appendChild(i);
    else if (g !== 4 && (g === 27 && Ho(i.type) && (h = i.stateNode), i = i.child, i !== null))
      for (Al(i, s, h), i = i.sibling; i !== null; )
        Al(i, s, h), i = i.sibling;
  }
  function rd(i) {
    var s = i.stateNode, h = i.memoizedProps;
    try {
      for (var g = i.type, A = s.attributes; A.length; )
        s.removeAttributeNode(A[0]);
      $a(s, g, h), s[st] = i, s[Zt] = h;
    } catch (I) {
      Gi(i, i.return, I);
    }
  }
  var Vr = !1, An = !1, kf = !1, Rf = typeof WeakSet == "function" ? WeakSet : Set, En = null;
  function wy(i, s) {
    if (i = i.containerInfo, fh = Zn, i = Fh(i), qu(i)) {
      if ("selectionStart" in i)
        var h = {
          start: i.selectionStart,
          end: i.selectionEnd
        };
      else
        e: {
          h = (h = i.ownerDocument) && h.defaultView || window;
          var g = h.getSelection && h.getSelection();
          if (g && g.rangeCount !== 0) {
            h = g.anchorNode;
            var A = g.anchorOffset, I = g.focusNode;
            g = g.focusOffset;
            try {
              h.nodeType, I.nodeType;
            } catch {
              h = null;
              break e;
            }
            var F = 0, W = -1, _e = -1, Be = 0, Ze = 0, Ke = i, Ne = null;
            t: for (; ; ) {
              for (var Ve; Ke !== h || A !== 0 && Ke.nodeType !== 3 || (W = F + A), Ke !== I || g !== 0 && Ke.nodeType !== 3 || (_e = F + g), Ke.nodeType === 3 && (F += Ke.nodeValue.length), (Ve = Ke.firstChild) !== null; )
                Ne = Ke, Ke = Ve;
              for (; ; ) {
                if (Ke === i) break t;
                if (Ne === h && ++Be === A && (W = F), Ne === I && ++Ze === g && (_e = F), (Ve = Ke.nextSibling) !== null) break;
                Ke = Ne, Ne = Ke.parentNode;
              }
              Ke = Ve;
            }
            h = W === -1 || _e === -1 ? null : { start: W, end: _e };
          } else h = null;
        }
      h = h || { start: 0, end: 0 };
    } else h = null;
    for (Ip = { focusedElem: i, selectionRange: h }, Zn = !1, En = s; En !== null; )
      if (s = En, i = s.child, (s.subtreeFlags & 1028) !== 0 && i !== null)
        i.return = s, En = i;
      else
        for (; En !== null; ) {
          switch (s = En, I = s.alternate, i = s.flags, s.tag) {
            case 0:
              if ((i & 4) !== 0 && (i = s.updateQueue, i = i !== null ? i.events : null, i !== null))
                for (h = 0; h < i.length; h++)
                  A = i[h], A.ref.impl = A.nextImpl;
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((i & 1024) !== 0 && I !== null) {
                i = void 0, h = s, A = I.memoizedProps, I = I.memoizedState, g = h.stateNode;
                try {
                  var zt = du(
                    h.type,
                    A
                  );
                  i = g.getSnapshotBeforeUpdate(
                    zt,
                    I
                  ), g.__reactInternalSnapshotBeforeUpdate = i;
                } catch (Nt) {
                  Gi(
                    h,
                    h.return,
                    Nt
                  );
                }
              }
              break;
            case 3:
              if ((i & 1024) !== 0) {
                if (i = s.stateNode.containerInfo, h = i.nodeType, h === 9)
                  Rp(i);
                else if (h === 1)
                  switch (i.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      Rp(i);
                      break;
                    default:
                      i.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((i & 1024) !== 0) throw Error(b(163));
          }
          if (i = s.sibling, i !== null) {
            i.return = s.return, En = i;
            break;
          }
          En = s.return;
        }
  }
  function Df(i, s, h) {
    var g = h.flags;
    switch (h.tag) {
      case 0:
      case 11:
      case 15:
        qo(i, h), g & 4 && nd(5, h);
        break;
      case 1:
        if (qo(i, h), g & 4)
          if (i = h.stateNode, s === null)
            try {
              i.componentDidMount();
            } catch (F) {
              Gi(h, h.return, F);
            }
          else {
            var A = du(
              h.type,
              s.memoizedProps
            );
            s = s.memoizedState;
            try {
              i.componentDidUpdate(
                A,
                s,
                i.__reactInternalSnapshotBeforeUpdate
              );
            } catch (F) {
              Gi(
                h,
                h.return,
                F
              );
            }
          }
        g & 64 && fc(h), g & 512 && fu(h, h.return);
        break;
      case 3:
        if (qo(i, h), g & 64 && (i = h.updateQueue, i !== null)) {
          if (s = null, h.child !== null)
            switch (h.child.tag) {
              case 27:
              case 5:
                s = h.child.stateNode;
                break;
              case 1:
                s = h.child.stateNode;
            }
          try {
            sc(i, s);
          } catch (F) {
            Gi(h, h.return, F);
          }
        }
        break;
      case 27:
        s === null && g & 4 && rd(h);
      case 26:
      case 5:
        qo(i, h), s === null && g & 4 && th(h), g & 512 && fu(h, h.return);
        break;
      case 12:
        qo(i, h);
        break;
      case 31:
        qo(i, h), g & 4 && Hm(i, h);
        break;
      case 13:
        qo(i, h), g & 4 && Xm(i, h), g & 64 && (i = h.memoizedState, i !== null && (i = i.dehydrated, i !== null && (h = Kf.bind(
          null,
          h
        ), xd(i, h))));
        break;
      case 22:
        if (g = h.memoizedState !== null || Vr, !g) {
          s = s !== null && s.memoizedState !== null || An, A = Vr;
          var I = An;
          Vr = g, (An = s) && !I ? io(
            i,
            h,
            (h.subtreeFlags & 8772) !== 0
          ) : qo(i, h), Vr = A, An = I;
        }
        break;
      case 30:
        break;
      default:
        qo(i, h);
    }
  }
  function ih(i) {
    var s = i.alternate;
    s !== null && (i.alternate = null, ih(s)), i.child = null, i.deletions = null, i.sibling = null, i.tag === 5 && (s = i.stateNode, s !== null && ss(s)), i.stateNode = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null;
  }
  var yn = null, Mr = !1;
  function Vo(i, s, h) {
    for (h = h.child; h !== null; )
      $m(i, s, h), h = h.sibling;
  }
  function $m(i, s, h) {
    if (me && typeof me.onCommitFiberUnmount == "function")
      try {
        me.onCommitFiberUnmount(le, h);
      } catch {
      }
    switch (h.tag) {
      case 26:
        An || ts(h, s), Vo(
          i,
          s,
          h
        ), h.memoizedState ? h.memoizedState.count-- : h.stateNode && (h = h.stateNode, h.parentNode.removeChild(h));
        break;
      case 27:
        An || ts(h, s);
        var g = yn, A = Mr;
        Ho(h.type) && (yn = h.stateNode, Mr = !1), Vo(
          i,
          s,
          h
        ), Cc(h.stateNode), yn = g, Mr = A;
        break;
      case 5:
        An || ts(h, s);
      case 6:
        if (g = yn, A = Mr, yn = null, Vo(
          i,
          s,
          h
        ), yn = g, Mr = A, yn !== null)
          if (Mr)
            try {
              (yn.nodeType === 9 ? yn.body : yn.nodeName === "HTML" ? yn.ownerDocument.body : yn).removeChild(h.stateNode);
            } catch (I) {
              Gi(
                h,
                s,
                I
              );
            }
          else
            try {
              yn.removeChild(h.stateNode);
            } catch (I) {
              Gi(
                h,
                s,
                I
              );
            }
        break;
      case 18:
        yn !== null && (Mr ? (i = yn, wg(
          i.nodeType === 9 ? i.body : i.nodeName === "HTML" ? i.ownerDocument.body : i,
          h.stateNode
        ), $r(i)) : wg(yn, h.stateNode));
        break;
      case 4:
        g = yn, A = Mr, yn = h.stateNode.containerInfo, Mr = !0, Vo(
          i,
          s,
          h
        ), yn = g, Mr = A;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        Ki(2, h, s), An || Ki(4, h, s), Vo(
          i,
          s,
          h
        );
        break;
      case 1:
        An || (ts(h, s), g = h.stateNode, typeof g.componentWillUnmount == "function" && Pf(
          h,
          s,
          g
        )), Vo(
          i,
          s,
          h
        );
        break;
      case 21:
        Vo(
          i,
          s,
          h
        );
        break;
      case 22:
        An = (g = An) || h.memoizedState !== null, Vo(
          i,
          s,
          h
        ), An = g;
        break;
      default:
        Vo(
          i,
          s,
          h
        );
    }
  }
  function Hm(i, s) {
    if (s.memoizedState === null && (i = s.alternate, i !== null && (i = i.memoizedState, i !== null))) {
      i = i.dehydrated;
      try {
        $r(i);
      } catch (h) {
        Gi(s, s.return, h);
      }
    }
  }
  function Xm(i, s) {
    if (s.memoizedState === null && (i = s.alternate, i !== null && (i = i.memoizedState, i !== null && (i = i.dehydrated, i !== null))))
      try {
        $r(i);
      } catch (h) {
        Gi(s, s.return, h);
      }
  }
  function Sy(i) {
    switch (i.tag) {
      case 31:
      case 13:
      case 19:
        var s = i.stateNode;
        return s === null && (s = i.stateNode = new Rf()), s;
      case 22:
        return i = i.stateNode, s = i._retryCache, s === null && (s = i._retryCache = new Rf()), s;
      default:
        throw Error(b(435, i.tag));
    }
  }
  function gp(i, s) {
    var h = Sy(i);
    s.forEach(function(g) {
      if (!h.has(g)) {
        h.add(g);
        var A = hh.bind(null, i, g);
        g.then(A, A);
      }
    });
  }
  function xa(i, s) {
    var h = s.deletions;
    if (h !== null)
      for (var g = 0; g < h.length; g++) {
        var A = h[g], I = i, F = s, W = F;
        e: for (; W !== null; ) {
          switch (W.tag) {
            case 27:
              if (Ho(W.type)) {
                yn = W.stateNode, Mr = !1;
                break e;
              }
              break;
            case 5:
              yn = W.stateNode, Mr = !1;
              break e;
            case 3:
            case 4:
              yn = W.stateNode.containerInfo, Mr = !0;
              break e;
          }
          W = W.return;
        }
        if (yn === null) throw Error(b(160));
        $m(I, F, A), yn = null, Mr = !1, I = A.alternate, I !== null && (I.return = null), A.return = null;
      }
    if (s.subtreeFlags & 13886)
      for (s = s.child; s !== null; )
        Ym(s, i), s = s.sibling;
  }
  var to = null;
  function Ym(i, s) {
    var h = i.alternate, g = i.flags;
    switch (i.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        xa(s, i), Ar(i), g & 4 && (Ki(3, i, i.return), nd(3, i), Ki(5, i, i.return));
        break;
      case 1:
        xa(s, i), Ar(i), g & 512 && (An || h === null || ts(h, h.return)), g & 64 && Vr && (i = i.updateQueue, i !== null && (g = i.callbacks, g !== null && (h = i.shared.hiddenCallbacks, i.shared.hiddenCallbacks = h === null ? g : h.concat(g))));
        break;
      case 26:
        var A = to;
        if (xa(s, i), Ar(i), g & 512 && (An || h === null || ts(h, h.return)), g & 4) {
          var I = h !== null ? h.memoizedState : null;
          if (g = i.memoizedState, h === null)
            if (g === null)
              if (i.stateNode === null) {
                e: {
                  g = i.type, h = i.memoizedProps, A = A.ownerDocument || A;
                  t: switch (g) {
                    case "title":
                      I = A.getElementsByTagName("title")[0], (!I || I[mo] || I[st] || I.namespaceURI === "http://www.w3.org/2000/svg" || I.hasAttribute("itemprop")) && (I = A.createElement(g), A.head.insertBefore(
                        I,
                        A.querySelector("head > title")
                      )), $a(I, g, h), I[st] = i, Rn(I), g = I;
                      break e;
                    case "link":
                      var F = gt(
                        "link",
                        "href",
                        A
                      ).get(g + (h.href || ""));
                      if (F) {
                        for (var W = 0; W < F.length; W++)
                          if (I = F[W], I.getAttribute("href") === (h.href == null || h.href === "" ? null : h.href) && I.getAttribute("rel") === (h.rel == null ? null : h.rel) && I.getAttribute("title") === (h.title == null ? null : h.title) && I.getAttribute("crossorigin") === (h.crossOrigin == null ? null : h.crossOrigin)) {
                            F.splice(W, 1);
                            break t;
                          }
                      }
                      I = A.createElement(g), $a(I, g, h), A.head.appendChild(I);
                      break;
                    case "meta":
                      if (F = gt(
                        "meta",
                        "content",
                        A
                      ).get(g + (h.content || ""))) {
                        for (W = 0; W < F.length; W++)
                          if (I = F[W], I.getAttribute("content") === (h.content == null ? null : "" + h.content) && I.getAttribute("name") === (h.name == null ? null : h.name) && I.getAttribute("property") === (h.property == null ? null : h.property) && I.getAttribute("http-equiv") === (h.httpEquiv == null ? null : h.httpEquiv) && I.getAttribute("charset") === (h.charSet == null ? null : h.charSet)) {
                            F.splice(W, 1);
                            break t;
                          }
                      }
                      I = A.createElement(g), $a(I, g, h), A.head.appendChild(I);
                      break;
                    default:
                      throw Error(b(468, g));
                  }
                  I[st] = i, Rn(I), g = I;
                }
                i.stateNode = g;
              } else
                ut(
                  A,
                  i.type,
                  i.stateNode
                );
            else
              i.stateNode = de(
                A,
                g,
                i.memoizedProps
              );
          else
            I !== g ? (I === null ? h.stateNode !== null && (h = h.stateNode, h.parentNode.removeChild(h)) : I.count--, g === null ? ut(
              A,
              i.type,
              i.stateNode
            ) : de(
              A,
              g,
              i.memoizedProps
            )) : g === null && i.stateNode !== null && mp(
              i,
              i.memoizedProps,
              h.memoizedProps
            );
        }
        break;
      case 27:
        xa(s, i), Ar(i), g & 512 && (An || h === null || ts(h, h.return)), h !== null && g & 4 && mp(
          i,
          i.memoizedProps,
          h.memoizedProps
        );
        break;
      case 5:
        if (xa(s, i), Ar(i), g & 512 && (An || h === null || ts(h, h.return)), i.flags & 32) {
          A = i.stateNode;
          try {
            Ma(A, "");
          } catch (zt) {
            Gi(i, i.return, zt);
          }
        }
        g & 4 && i.stateNode != null && (A = i.memoizedProps, mp(
          i,
          A,
          h !== null ? h.memoizedProps : A
        )), g & 1024 && (kf = !0);
        break;
      case 6:
        if (xa(s, i), Ar(i), g & 4) {
          if (i.stateNode === null)
            throw Error(b(162));
          g = i.memoizedProps, h = i.stateNode;
          try {
            h.nodeValue = g;
          } catch (zt) {
            Gi(i, i.return, zt);
          }
        }
        break;
      case 3:
        if (Je = null, A = to, to = jp(s.containerInfo), xa(s, i), to = A, Ar(i), g & 4 && h !== null && h.memoizedState.isDehydrated)
          try {
            $r(s.containerInfo);
          } catch (zt) {
            Gi(i, i.return, zt);
          }
        kf && (kf = !1, Km(i));
        break;
      case 4:
        g = to, to = jp(
          i.stateNode.containerInfo
        ), xa(s, i), Ar(i), to = g;
        break;
      case 12:
        xa(s, i), Ar(i);
        break;
      case 31:
        xa(s, i), Ar(i), g & 4 && (g = i.updateQueue, g !== null && (i.updateQueue = null, gp(i, g)));
        break;
      case 13:
        xa(s, i), Ar(i), i.child.flags & 8192 && i.memoizedState !== null != (h !== null && h.memoizedState !== null) && (sh = Yn()), g & 4 && (g = i.updateQueue, g !== null && (i.updateQueue = null, gp(i, g)));
        break;
      case 22:
        A = i.memoizedState !== null;
        var _e = h !== null && h.memoizedState !== null, Be = Vr, Ze = An;
        if (Vr = Be || A, An = Ze || _e, xa(s, i), An = Ze, Vr = Be, Ar(i), g & 8192)
          e: for (s = i.stateNode, s._visibility = A ? s._visibility & -2 : s._visibility | 1, A && (h === null || _e || Vr || An || gc(i)), h = null, s = i; ; ) {
            if (s.tag === 5 || s.tag === 26) {
              if (h === null) {
                _e = h = s;
                try {
                  if (I = _e.stateNode, A)
                    F = I.style, typeof F.setProperty == "function" ? F.setProperty("display", "none", "important") : F.display = "none";
                  else {
                    W = _e.stateNode;
                    var Ke = _e.memoizedProps.style, Ne = Ke != null && Ke.hasOwnProperty("display") ? Ke.display : null;
                    W.style.display = Ne == null || typeof Ne == "boolean" ? "" : ("" + Ne).trim();
                  }
                } catch (zt) {
                  Gi(_e, _e.return, zt);
                }
              }
            } else if (s.tag === 6) {
              if (h === null) {
                _e = s;
                try {
                  _e.stateNode.nodeValue = A ? "" : _e.memoizedProps;
                } catch (zt) {
                  Gi(_e, _e.return, zt);
                }
              }
            } else if (s.tag === 18) {
              if (h === null) {
                _e = s;
                try {
                  var Ve = _e.stateNode;
                  A ? sm(Ve, !0) : sm(_e.stateNode, !1);
                } catch (zt) {
                  Gi(_e, _e.return, zt);
                }
              }
            } else if ((s.tag !== 22 && s.tag !== 23 || s.memoizedState === null || s === i) && s.child !== null) {
              s.child.return = s, s = s.child;
              continue;
            }
            if (s === i) break e;
            for (; s.sibling === null; ) {
              if (s.return === null || s.return === i) break e;
              h === s && (h = null), s = s.return;
            }
            h === s && (h = null), s.sibling.return = s.return, s = s.sibling;
          }
        g & 4 && (g = i.updateQueue, g !== null && (h = g.retryQueue, h !== null && (g.retryQueue = null, gp(i, h))));
        break;
      case 19:
        xa(s, i), Ar(i), g & 4 && (g = i.updateQueue, g !== null && (i.updateQueue = null, gp(i, g)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        xa(s, i), Ar(i);
    }
  }
  function Ar(i) {
    var s = i.flags;
    if (s & 2) {
      try {
        for (var h, g = i.return; g !== null; ) {
          if (If(g)) {
            h = g;
            break;
          }
          g = g.return;
        }
        if (h == null) throw Error(b(160));
        switch (h.tag) {
          case 27:
            var A = h.stateNode, I = mc(i);
            Al(i, I, A);
            break;
          case 5:
            var F = h.stateNode;
            h.flags & 32 && (Ma(F, ""), h.flags &= -33);
            var W = mc(i);
            Al(i, W, F);
            break;
          case 3:
          case 4:
            var _e = h.stateNode.containerInfo, Be = mc(i);
            ad(
              i,
              Be,
              _e
            );
            break;
          default:
            throw Error(b(161));
        }
      } catch (Ze) {
        Gi(i, i.return, Ze);
      }
      i.flags &= -3;
    }
    s & 4096 && (i.flags &= -4097);
  }
  function Km(i) {
    if (i.subtreeFlags & 1024)
      for (i = i.child; i !== null; ) {
        var s = i;
        Km(s), s.tag === 5 && s.flags & 1024 && s.stateNode.reset(), i = i.sibling;
      }
  }
  function qo(i, s) {
    if (s.subtreeFlags & 8772)
      for (s = s.child; s !== null; )
        Df(i, s.alternate, s), s = s.sibling;
  }
  function gc(i) {
    for (i = i.child; i !== null; ) {
      var s = i;
      switch (s.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ki(4, s, s.return), gc(s);
          break;
        case 1:
          ts(s, s.return);
          var h = s.stateNode;
          typeof h.componentWillUnmount == "function" && Pf(
            s,
            s.return,
            h
          ), gc(s);
          break;
        case 27:
          Cc(s.stateNode);
        case 26:
        case 5:
          ts(s, s.return), gc(s);
          break;
        case 22:
          s.memoizedState === null && gc(s);
          break;
        case 30:
          gc(s);
          break;
        default:
          gc(s);
      }
      i = i.sibling;
    }
  }
  function io(i, s, h) {
    for (h = h && (s.subtreeFlags & 8772) !== 0, s = s.child; s !== null; ) {
      var g = s.alternate, A = i, I = s, F = I.flags;
      switch (I.tag) {
        case 0:
        case 11:
        case 15:
          io(
            A,
            I,
            h
          ), nd(4, I);
          break;
        case 1:
          if (io(
            A,
            I,
            h
          ), g = I, A = g.stateNode, typeof A.componentDidMount == "function")
            try {
              A.componentDidMount();
            } catch (Be) {
              Gi(g, g.return, Be);
            }
          if (g = I, A = g.updateQueue, A !== null) {
            var W = g.stateNode;
            try {
              var _e = A.shared.hiddenCallbacks;
              if (_e !== null)
                for (A.shared.hiddenCallbacks = null, A = 0; A < _e.length; A++)
                  Ot(_e[A], W);
            } catch (Be) {
              Gi(g, g.return, Be);
            }
          }
          h && F & 64 && fc(I), fu(I, I.return);
          break;
        case 27:
          rd(I);
        case 26:
        case 5:
          io(
            A,
            I,
            h
          ), h && g === null && F & 4 && th(I), fu(I, I.return);
          break;
        case 12:
          io(
            A,
            I,
            h
          );
          break;
        case 31:
          io(
            A,
            I,
            h
          ), h && F & 4 && Hm(A, I);
          break;
        case 13:
          io(
            A,
            I,
            h
          ), h && F & 4 && Xm(A, I);
          break;
        case 22:
          I.memoizedState === null && io(
            A,
            I,
            h
          ), fu(I, I.return);
          break;
        case 30:
          break;
        default:
          io(
            A,
            I,
            h
          );
      }
      s = s.sibling;
    }
  }
  function yc(i, s) {
    var h = null;
    i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (h = i.memoizedState.cachePool.pool), i = null, s.memoizedState !== null && s.memoizedState.cachePool !== null && (i = s.memoizedState.cachePool.pool), i !== h && (i != null && i.refCount++, h != null && Ms(h));
  }
  function sd(i, s) {
    i = null, s.alternate !== null && (i = s.alternate.memoizedState.cache), s = s.memoizedState.cache, s !== i && (s.refCount++, i != null && Ms(i));
  }
  function no(i, s, h, g) {
    if (s.subtreeFlags & 10256)
      for (s = s.child; s !== null; )
        Wm(
          i,
          s,
          h,
          g
        ), s = s.sibling;
  }
  function Wm(i, s, h, g) {
    var A = s.flags;
    switch (s.tag) {
      case 0:
      case 11:
      case 15:
        no(
          i,
          s,
          h,
          g
        ), A & 2048 && nd(9, s);
        break;
      case 1:
        no(
          i,
          s,
          h,
          g
        );
        break;
      case 3:
        no(
          i,
          s,
          h,
          g
        ), A & 2048 && (i = null, s.alternate !== null && (i = s.alternate.memoizedState.cache), s = s.memoizedState.cache, s !== i && (s.refCount++, i != null && Ms(i)));
        break;
      case 12:
        if (A & 2048) {
          no(
            i,
            s,
            h,
            g
          ), i = s.stateNode;
          try {
            var I = s.memoizedProps, F = I.id, W = I.onPostCommit;
            typeof W == "function" && W(
              F,
              s.alternate === null ? "mount" : "update",
              i.passiveEffectDuration,
              -0
            );
          } catch (_e) {
            Gi(s, s.return, _e);
          }
        } else
          no(
            i,
            s,
            h,
            g
          );
        break;
      case 31:
        no(
          i,
          s,
          h,
          g
        );
        break;
      case 13:
        no(
          i,
          s,
          h,
          g
        );
        break;
      case 23:
        break;
      case 22:
        I = s.stateNode, F = s.alternate, s.memoizedState !== null ? I._visibility & 2 ? no(
          i,
          s,
          h,
          g
        ) : nh(i, s) : I._visibility & 2 ? no(
          i,
          s,
          h,
          g
        ) : (I._visibility |= 2, _c(
          i,
          s,
          h,
          g,
          (s.subtreeFlags & 10256) !== 0 || !1
        )), A & 2048 && yc(F, s);
        break;
      case 24:
        no(
          i,
          s,
          h,
          g
        ), A & 2048 && sd(s.alternate, s);
        break;
      default:
        no(
          i,
          s,
          h,
          g
        );
    }
  }
  function _c(i, s, h, g, A) {
    for (A = A && ((s.subtreeFlags & 10256) !== 0 || !1), s = s.child; s !== null; ) {
      var I = i, F = s, W = h, _e = g, Be = F.flags;
      switch (F.tag) {
        case 0:
        case 11:
        case 15:
          _c(
            I,
            F,
            W,
            _e,
            A
          ), nd(8, F);
          break;
        case 23:
          break;
        case 22:
          var Ze = F.stateNode;
          F.memoizedState !== null ? Ze._visibility & 2 ? _c(
            I,
            F,
            W,
            _e,
            A
          ) : nh(
            I,
            F
          ) : (Ze._visibility |= 2, _c(
            I,
            F,
            W,
            _e,
            A
          )), A && Be & 2048 && yc(
            F.alternate,
            F
          );
          break;
        case 24:
          _c(
            I,
            F,
            W,
            _e,
            A
          ), A && Be & 2048 && sd(F.alternate, F);
          break;
        default:
          _c(
            I,
            F,
            W,
            _e,
            A
          );
      }
      s = s.sibling;
    }
  }
  function nh(i, s) {
    if (s.subtreeFlags & 10256)
      for (s = s.child; s !== null; ) {
        var h = i, g = s, A = g.flags;
        switch (g.tag) {
          case 22:
            nh(h, g), A & 2048 && yc(
              g.alternate,
              g
            );
            break;
          case 24:
            nh(h, g), A & 2048 && sd(g.alternate, g);
            break;
          default:
            nh(h, g);
        }
        s = s.sibling;
      }
  }
  var od = 8192;
  function ah(i, s, h) {
    if (i.subtreeFlags & od)
      for (i = i.child; i !== null; )
        rh(
          i,
          s,
          h
        ), i = i.sibling;
  }
  function rh(i, s, h) {
    switch (i.tag) {
      case 26:
        ah(
          i,
          s,
          h
        ), i.flags & od && i.memoizedState !== null && mt(
          h,
          to,
          i.memoizedState,
          i.memoizedProps
        );
        break;
      case 5:
        ah(
          i,
          s,
          h
        );
        break;
      case 3:
      case 4:
        var g = to;
        to = jp(i.stateNode.containerInfo), ah(
          i,
          s,
          h
        ), to = g;
        break;
      case 22:
        i.memoizedState === null && (g = i.alternate, g !== null && g.memoizedState !== null ? (g = od, od = 16777216, ah(
          i,
          s,
          h
        ), od = g) : ah(
          i,
          s,
          h
        ));
        break;
      default:
        ah(
          i,
          s,
          h
        );
    }
  }
  function Lf(i) {
    var s = i.alternate;
    if (s !== null && (i = s.child, i !== null)) {
      s.child = null;
      do
        s = i.sibling, i.sibling = null, i = s;
      while (i !== null);
    }
  }
  function ld(i) {
    var s = i.deletions;
    if ((i.flags & 16) !== 0) {
      if (s !== null)
        for (var h = 0; h < s.length; h++) {
          var g = s[h];
          En = g, Qm(
            g,
            i
          );
        }
      Lf(i);
    }
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; )
        Jm(i), i = i.sibling;
  }
  function Jm(i) {
    switch (i.tag) {
      case 0:
      case 11:
      case 15:
        ld(i), i.flags & 2048 && Ki(9, i, i.return);
        break;
      case 3:
        ld(i);
        break;
      case 12:
        ld(i);
        break;
      case 22:
        var s = i.stateNode;
        i.memoizedState !== null && s._visibility & 2 && (i.return === null || i.return.tag !== 13) ? (s._visibility &= -3, yp(i)) : ld(i);
        break;
      default:
        ld(i);
    }
  }
  function yp(i) {
    var s = i.deletions;
    if ((i.flags & 16) !== 0) {
      if (s !== null)
        for (var h = 0; h < s.length; h++) {
          var g = s[h];
          En = g, Qm(
            g,
            i
          );
        }
      Lf(i);
    }
    for (i = i.child; i !== null; ) {
      switch (s = i, s.tag) {
        case 0:
        case 11:
        case 15:
          Ki(8, s, s.return), yp(s);
          break;
        case 22:
          h = s.stateNode, h._visibility & 2 && (h._visibility &= -3, yp(s));
          break;
        default:
          yp(s);
      }
      i = i.sibling;
    }
  }
  function Qm(i, s) {
    for (; En !== null; ) {
      var h = En;
      switch (h.tag) {
        case 0:
        case 11:
        case 15:
          Ki(8, h, s);
          break;
        case 23:
        case 22:
          if (h.memoizedState !== null && h.memoizedState.cachePool !== null) {
            var g = h.memoizedState.cachePool.pool;
            g != null && g.refCount++;
          }
          break;
        case 24:
          Ms(h.memoizedState.cache);
      }
      if (g = h.child, g !== null) g.return = h, En = g;
      else
        e: for (h = i; En !== null; ) {
          g = En;
          var A = g.sibling, I = g.return;
          if (ih(g), g === h) {
            En = null;
            break e;
          }
          if (A !== null) {
            A.return = I, En = A;
            break e;
          }
          En = I;
        }
    }
  }
  var Ty = {
    getCacheForType: function(i) {
      var s = ha(ki), h = s.data.get(i);
      return h === void 0 && (h = i(), s.data.set(i, h)), h;
    },
    cacheSignal: function() {
      return ha(ki).controller.signal;
    }
  }, eg = typeof WeakMap == "function" ? WeakMap : Map, ji = 0, sn = null, Mi = null, Pi = 0, en = 0, lr = null, mu = !1, vc = !1, Of = !1, El = 0, qn = 0, Cl = 0, xc = 0, Bf = 0, Za = 0, Tn = 0, bc = null, Er = null, _p = !1, sh = 0, wc = 0, ud = 1 / 0, vp = null, gu = null, ba = 0, yu = null, oh = null, zl = 0, Nf = 0, jf = null, tg = null, cd = 0, Uf = null;
  function is() {
    return (ji & 2) !== 0 && Pi !== 0 ? Pi & -Pi : He.T !== null ? $o() : dn();
  }
  function Ff() {
    if (Za === 0)
      if ((Pi & 536870912) === 0 || wi) {
        var i = Mt;
        Mt <<= 1, (Mt & 3932160) === 0 && (Mt = 262144), Za = i;
      } else Za = 536870912;
    return i = br.current, i !== null && (i.flags |= 32), Za;
  }
  function ur(i, s, h) {
    (i === sn && (en === 2 || en === 9) || i.cancelPendingCommit !== null) && (uh(i, 0), ns(
      i,
      Pi,
      Za,
      !1
    )), xn(i, h), ((ji & 2) === 0 || i !== sn) && (i === sn && ((ji & 2) === 0 && (xc |= h), qn === 4 && ns(
      i,
      Pi,
      Za,
      !1
    )), Zo(i));
  }
  function Vf(i, s, h) {
    if ((ji & 6) !== 0) throw Error(b(327));
    var g = !h && (s & 127) === 0 && (s & i.expiredLanes) === 0 || It(i, s), A = g ? $f(i, s) : xp(i, s, !0), I = g;
    do {
      if (A === 0) {
        vc && !g && ns(i, s, 0, !1);
        break;
      } else {
        if (h = i.current.alternate, I && !hd(h)) {
          A = xp(i, s, !1), I = !1;
          continue;
        }
        if (A === 2) {
          if (I = s, i.errorRecoveryDisabledLanes & I)
            var F = 0;
          else
            F = i.pendingLanes & -536870913, F = F !== 0 ? F : F & 536870912 ? 536870912 : 0;
          if (F !== 0) {
            s = F;
            e: {
              var W = i;
              A = bc;
              var _e = W.current.memoizedState.isDehydrated;
              if (_e && (uh(W, F).flags |= 256), F = xp(
                W,
                F,
                !1
              ), F !== 2) {
                if (Of && !_e) {
                  W.errorRecoveryDisabledLanes |= I, xc |= I, A = 4;
                  break e;
                }
                I = Er, Er = A, I !== null && (Er === null ? Er = I : Er.push.apply(
                  Er,
                  I
                ));
              }
              A = F;
            }
            if (I = !1, A !== 2) continue;
          }
        }
        if (A === 1) {
          uh(i, 0), ns(i, s, 0, !0);
          break;
        }
        e: {
          switch (g = i, I = A, I) {
            case 0:
            case 1:
              throw Error(b(345));
            case 4:
              if ((s & 4194048) !== s) break;
            case 6:
              ns(
                g,
                s,
                Za,
                !mu
              );
              break e;
            case 2:
              Er = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(b(329));
          }
          if ((s & 62914560) === s && (A = sh + 300 - Yn(), 10 < A)) {
            if (ns(
              g,
              s,
              Za,
              !mu
            ), ri(g, 0, !0) !== 0) break e;
            zl = s, g.timeoutHandle = Ec(
              Pl.bind(
                null,
                g,
                h,
                Er,
                vp,
                _p,
                s,
                Za,
                xc,
                Tn,
                mu,
                I,
                "Throttled",
                -0,
                0
              ),
              A
            );
            break e;
          }
          Pl(
            g,
            h,
            Er,
            vp,
            _p,
            s,
            Za,
            xc,
            Tn,
            mu,
            I,
            null,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Zo(i);
  }
  function Pl(i, s, h, g, A, I, F, W, _e, Be, Ze, Ke, Ne, Ve) {
    if (i.timeoutHandle = -1, Ke = s.subtreeFlags, Ke & 8192 || (Ke & 16785408) === 16785408) {
      Ke = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: !0,
        waitingForViewTransition: !1,
        unsuspend: Rr
      }, rh(
        s,
        I,
        Ke
      );
      var zt = (I & 62914560) === I ? sh - Yn() : (I & 4194048) === I ? wc - Yn() : 0;
      if (zt = Xe(
        Ke,
        zt
      ), zt !== null) {
        zl = I, i.cancelPendingCommit = zt(
          sg.bind(
            null,
            i,
            s,
            I,
            h,
            g,
            A,
            F,
            W,
            _e,
            Ze,
            Ke,
            null,
            Ne,
            Ve
          )
        ), ns(i, I, F, !Be);
        return;
      }
    }
    sg(
      i,
      s,
      I,
      h,
      g,
      A,
      F,
      W,
      _e
    );
  }
  function hd(i) {
    for (var s = i; ; ) {
      var h = s.tag;
      if ((h === 0 || h === 11 || h === 15) && s.flags & 16384 && (h = s.updateQueue, h !== null && (h = h.stores, h !== null)))
        for (var g = 0; g < h.length; g++) {
          var A = h[g], I = A.getSnapshot;
          A = A.value;
          try {
            if (!Ca(I(), A)) return !1;
          } catch {
            return !1;
          }
        }
      if (h = s.child, s.subtreeFlags & 16384 && h !== null)
        h.return = s, s = h;
      else {
        if (s === i) break;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === i) return !0;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
    }
    return !0;
  }
  function ns(i, s, h, g) {
    s &= ~Bf, s &= ~xc, i.suspendedLanes |= s, i.pingedLanes &= ~s, g && (i.warmLanes |= s), g = i.expirationTimes;
    for (var A = s; 0 < A; ) {
      var I = 31 - Ee(A), F = 1 << I;
      g[I] = -1, A &= ~F;
    }
    h !== 0 && ci(i, h, s);
  }
  function Sc() {
    return (ji & 6) === 0 ? (dh(0), !1) : !0;
  }
  function lh() {
    if (Mi !== null) {
      if (en === 0)
        var i = Mi.return;
      else
        i = Mi, Ss = Co = null, j(i), Ro = null, bl = 0, i = Mi;
      for (; i !== null; )
        eh(i.alternate, i), i = i.return;
      Mi = null;
    }
  }
  function uh(i, s) {
    var h = i.timeoutHandle;
    h !== -1 && (i.timeoutHandle = -1, Ra(h)), h = i.cancelPendingCommit, h !== null && (i.cancelPendingCommit = null, h()), zl = 0, lh(), sn = i, Mi = h = xs(i.current, null), Pi = s, en = 0, lr = null, mu = !1, vc = It(i, s), Of = !1, Tn = Za = Bf = xc = Cl = qn = 0, Er = bc = null, _p = !1, (s & 8) !== 0 && (s |= s & 32);
    var g = i.entangledLanes;
    if (g !== 0)
      for (i = i.entanglements, g &= s; 0 < g; ) {
        var A = 31 - Ee(g), I = 1 << A;
        s |= i[A], g &= ~I;
      }
    return El = s, Yu(), h;
  }
  function ig(i, s) {
    ni = null, He.H = cc, s === Io || s === Es ? (s = rp(), en = 3) : s === ko ? (s = rp(), en = 4) : en = s === _f ? 8 : s !== null && typeof s == "object" && typeof s.then == "function" ? 6 : 1, lr = s, Mi === null && (qn = 1, pu(
      i,
      tr(s, i.current)
    ));
  }
  function qf() {
    var i = br.current;
    return i === null ? !0 : (Pi & 4194048) === Pi ? Pa === null : (Pi & 62914560) === Pi || (Pi & 536870912) !== 0 ? i === Pa : !1;
  }
  function Gf() {
    var i = He.H;
    return He.H = cc, i === null ? cc : i;
  }
  function ng() {
    var i = He.A;
    return He.A = Ty, i;
  }
  function dd() {
    qn = 4, mu || (Pi & 4194048) !== Pi && br.current !== null || (vc = !0), (Cl & 134217727) === 0 && (xc & 134217727) === 0 || sn === null || ns(
      sn,
      Pi,
      Za,
      !1
    );
  }
  function xp(i, s, h) {
    var g = ji;
    ji |= 2;
    var A = Gf(), I = ng();
    (sn !== i || Pi !== s) && (vp = null, uh(i, s)), s = !1;
    var F = qn;
    e: do
      try {
        if (en !== 0 && Mi !== null) {
          var W = Mi, _e = lr;
          switch (en) {
            case 8:
              lh(), F = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              br.current === null && (s = !0);
              var Be = en;
              if (en = 0, lr = null, ch(i, W, _e, Be), h && vc) {
                F = 0;
                break e;
              }
              break;
            default:
              Be = en, en = 0, lr = null, ch(i, W, _e, Be);
          }
        }
        Zf(), F = qn;
        break;
      } catch (Ze) {
        ig(i, Ze);
      }
    while (!0);
    return s && i.shellSuspendCounter++, Ss = Co = null, ji = g, He.H = A, He.A = I, Mi === null && (sn = null, Pi = 0, Yu()), F;
  }
  function Zf() {
    for (; Mi !== null; ) Hf(Mi);
  }
  function $f(i, s) {
    var h = ji;
    ji |= 2;
    var g = Gf(), A = ng();
    sn !== i || Pi !== s ? (vp = null, ud = Yn() + 500, uh(i, s)) : vc = It(
      i,
      s
    );
    e: do
      try {
        if (en !== 0 && Mi !== null) {
          s = Mi;
          var I = lr;
          t: switch (en) {
            case 1:
              en = 0, lr = null, ch(i, s, I, 1);
              break;
            case 2:
            case 9:
              if (mi(I)) {
                en = 0, lr = null, ag(s);
                break;
              }
              s = function() {
                en !== 2 && en !== 9 || sn !== i || (en = 7), Zo(i);
              }, I.then(s, s);
              break e;
            case 3:
              en = 7;
              break e;
            case 4:
              en = 5;
              break e;
            case 7:
              mi(I) ? (en = 0, lr = null, ag(s)) : (en = 0, lr = null, ch(i, s, I, 7));
              break;
            case 5:
              var F = null;
              switch (Mi.tag) {
                case 26:
                  F = Mi.memoizedState;
                case 5:
                case 27:
                  var W = Mi;
                  if (F ? kt(F) : W.stateNode.complete) {
                    en = 0, lr = null;
                    var _e = W.sibling;
                    if (_e !== null) Mi = _e;
                    else {
                      var Be = W.return;
                      Be !== null ? (Mi = Be, bp(Be)) : Mi = null;
                    }
                    break t;
                  }
              }
              en = 0, lr = null, ch(i, s, I, 5);
              break;
            case 6:
              en = 0, lr = null, ch(i, s, I, 6);
              break;
            case 8:
              lh(), qn = 6;
              break e;
            default:
              throw Error(b(462));
          }
        }
        My();
        break;
      } catch (Ze) {
        ig(i, Ze);
      }
    while (!0);
    return Ss = Co = null, He.H = g, He.A = A, ji = h, Mi !== null ? 0 : (sn = null, Pi = 0, Yu(), qn);
  }
  function My() {
    for (; Mi !== null && !Yr(); )
      Hf(Mi);
  }
  function Hf(i) {
    var s = qm(i.alternate, i, El);
    i.memoizedProps = i.pendingProps, s === null ? bp(i) : Mi = s;
  }
  function ag(i) {
    var s = i, h = s.alternate;
    switch (s.tag) {
      case 15:
      case 0:
        s = Fm(
          h,
          s,
          s.pendingProps,
          s.type,
          void 0,
          Pi
        );
        break;
      case 11:
        s = Fm(
          h,
          s,
          s.pendingProps,
          s.type.render,
          s.ref,
          Pi
        );
        break;
      case 5:
        j(s);
      default:
        eh(h, s), s = Mi = ip(s, El), s = qm(h, s, El);
    }
    i.memoizedProps = i.pendingProps, s === null ? bp(i) : Mi = s;
  }
  function ch(i, s, h, g) {
    Ss = Co = null, j(s), Ro = null, bl = 0;
    var A = s.return;
    try {
      if (vy(
        i,
        A,
        s,
        h,
        Pi
      )) {
        qn = 1, pu(
          i,
          tr(h, i.current)
        ), Mi = null;
        return;
      }
    } catch (I) {
      if (A !== null) throw Mi = A, I;
      qn = 1, pu(
        i,
        tr(h, i.current)
      ), Mi = null;
      return;
    }
    s.flags & 32768 ? (wi || g === 1 ? i = !0 : vc || (Pi & 536870912) !== 0 ? i = !1 : (mu = i = !0, (g === 2 || g === 9 || g === 3 || g === 6) && (g = br.current, g !== null && g.tag === 13 && (g.flags |= 16384))), rg(s, i)) : bp(s);
  }
  function bp(i) {
    var s = i;
    do {
      if ((s.flags & 32768) !== 0) {
        rg(
          s,
          mu
        );
        return;
      }
      i = s.return;
      var h = by(
        s.alternate,
        s,
        El
      );
      if (h !== null) {
        Mi = h;
        return;
      }
      if (s = s.sibling, s !== null) {
        Mi = s;
        return;
      }
      Mi = s = i;
    } while (s !== null);
    qn === 0 && (qn = 5);
  }
  function rg(i, s) {
    do {
      var h = Zm(i.alternate, i);
      if (h !== null) {
        h.flags &= 32767, Mi = h;
        return;
      }
      if (h = i.return, h !== null && (h.flags |= 32768, h.subtreeFlags = 0, h.deletions = null), !s && (i = i.sibling, i !== null)) {
        Mi = i;
        return;
      }
      Mi = i = h;
    } while (i !== null);
    qn = 6, Mi = null;
  }
  function sg(i, s, h, g, A, I, F, W, _e) {
    i.cancelPendingCommit = null;
    do
      pd();
    while (ba !== 0);
    if ((ji & 6) !== 0) throw Error(b(327));
    if (s !== null) {
      if (s === i.current) throw Error(b(177));
      if (I = s.lanes | s.childLanes, I |= eu, In(
        i,
        h,
        I,
        F,
        W,
        _e
      ), i === sn && (Mi = sn = null, Pi = 0), oh = s, yu = i, zl = h, Nf = I, jf = A, tg = g, (s.subtreeFlags & 10256) !== 0 || (s.flags & 10256) !== 0 ? (i.callbackNode = null, i.callbackPriority = 0, lg(js, function() {
        return wp(), null;
      })) : (i.callbackNode = null, i.callbackPriority = 0), g = (s.flags & 13878) !== 0, (s.subtreeFlags & 13878) !== 0 || g) {
        g = He.T, He.T = null, A = vt.p, vt.p = 2, F = ji, ji |= 4;
        try {
          wy(i, s, h);
        } finally {
          ji = F, vt.p = A, He.T = g;
        }
      }
      ba = 1, Xf(), Yf(), Go();
    }
  }
  function Xf() {
    if (ba === 1) {
      ba = 0;
      var i = yu, s = oh, h = (s.flags & 13878) !== 0;
      if ((s.subtreeFlags & 13878) !== 0 || h) {
        h = He.T, He.T = null;
        var g = vt.p;
        vt.p = 2;
        var A = ji;
        ji |= 4;
        try {
          Ym(s, i);
          var I = Ip, F = Fh(i.containerInfo), W = I.focusedElem, _e = I.selectionRange;
          if (F !== W && W && W.ownerDocument && Vc(
            W.ownerDocument.documentElement,
            W
          )) {
            if (_e !== null && qu(W)) {
              var Be = _e.start, Ze = _e.end;
              if (Ze === void 0 && (Ze = Be), "selectionStart" in W)
                W.selectionStart = Be, W.selectionEnd = Math.min(
                  Ze,
                  W.value.length
                );
              else {
                var Ke = W.ownerDocument || document, Ne = Ke && Ke.defaultView || window;
                if (Ne.getSelection) {
                  var Ve = Ne.getSelection(), zt = W.textContent.length, Nt = Math.min(_e.start, zt), _n = _e.end === void 0 ? Nt : Math.min(_e.end, zt);
                  !Ve.extend && Nt > _n && (F = _n, _n = Nt, Nt = F);
                  var Ce = Fc(
                    W,
                    Nt
                  ), Me = Fc(
                    W,
                    _n
                  );
                  if (Ce && Me && (Ve.rangeCount !== 1 || Ve.anchorNode !== Ce.node || Ve.anchorOffset !== Ce.offset || Ve.focusNode !== Me.node || Ve.focusOffset !== Me.offset)) {
                    var je = Ke.createRange();
                    je.setStart(Ce.node, Ce.offset), Ve.removeAllRanges(), Nt > _n ? (Ve.addRange(je), Ve.extend(Me.node, Me.offset)) : (je.setEnd(Me.node, Me.offset), Ve.addRange(je));
                  }
                }
              }
            }
            for (Ke = [], Ve = W; Ve = Ve.parentNode; )
              Ve.nodeType === 1 && Ke.push({
                element: Ve,
                left: Ve.scrollLeft,
                top: Ve.scrollTop
              });
            for (typeof W.focus == "function" && W.focus(), W = 0; W < Ke.length; W++) {
              var Qe = Ke[W];
              Qe.element.scrollLeft = Qe.left, Qe.element.scrollTop = Qe.top;
            }
          }
          Zn = !!fh, Ip = fh = null;
        } finally {
          ji = A, vt.p = g, He.T = h;
        }
      }
      i.current = s, ba = 2;
    }
  }
  function Yf() {
    if (ba === 2) {
      ba = 0;
      var i = yu, s = oh, h = (s.flags & 8772) !== 0;
      if ((s.subtreeFlags & 8772) !== 0 || h) {
        h = He.T, He.T = null;
        var g = vt.p;
        vt.p = 2;
        var A = ji;
        ji |= 4;
        try {
          Df(i, s.alternate, s);
        } finally {
          ji = A, vt.p = g, He.T = h;
        }
      }
      ba = 3;
    }
  }
  function Go() {
    if (ba === 4 || ba === 3) {
      ba = 0, ho();
      var i = yu, s = oh, h = zl, g = tg;
      (s.subtreeFlags & 10256) !== 0 || (s.flags & 10256) !== 0 ? ba = 5 : (ba = 0, oh = yu = null, Il(i, i.pendingLanes));
      var A = i.pendingLanes;
      if (A === 0 && (gu = null), la(h), s = s.stateNode, me && typeof me.onCommitFiberRoot == "function")
        try {
          me.onCommitFiberRoot(
            le,
            s,
            void 0,
            (s.current.flags & 128) === 128
          );
        } catch {
        }
      if (g !== null) {
        s = He.T, A = vt.p, vt.p = 2, He.T = null;
        try {
          for (var I = i.onRecoverableError, F = 0; F < g.length; F++) {
            var W = g[F];
            I(W.value, {
              componentStack: W.stack
            });
          }
        } finally {
          He.T = s, vt.p = A;
        }
      }
      (zl & 3) !== 0 && pd(), Zo(i), A = i.pendingLanes, (h & 261930) !== 0 && (A & 42) !== 0 ? i === Uf ? cd++ : (cd = 0, Uf = i) : cd = 0, dh(0);
    }
  }
  function Il(i, s) {
    (i.pooledCacheLanes &= s) === 0 && (s = i.pooledCache, s != null && (i.pooledCache = null, Ms(s)));
  }
  function pd() {
    return Xf(), Yf(), Go(), wp();
  }
  function wp() {
    if (ba !== 5) return !1;
    var i = yu, s = Nf;
    Nf = 0;
    var h = la(zl), g = He.T, A = vt.p;
    try {
      vt.p = 32 > h ? 32 : h, He.T = null, h = jf, jf = null;
      var I = yu, F = zl;
      if (ba = 0, oh = yu = null, zl = 0, (ji & 6) !== 0) throw Error(b(331));
      var W = ji;
      if (ji |= 4, Jm(I.current), Wm(
        I,
        I.current,
        F,
        h
      ), ji = W, dh(0, !1), me && typeof me.onPostCommitFiberRoot == "function")
        try {
          me.onPostCommitFiberRoot(le, I);
        } catch {
        }
      return !0;
    } finally {
      vt.p = A, He.T = g, Il(i, s);
    }
  }
  function og(i, s, h) {
    s = tr(h, s), s = Jc(i.stateNode, s, 2), i = zs(i, s, 2), i !== null && (xn(i, 2), Zo(i));
  }
  function Gi(i, s, h) {
    if (i.tag === 3)
      og(i, i, h);
    else
      for (; s !== null; ) {
        if (s.tag === 3) {
          og(
            s,
            i,
            h
          );
          break;
        } else if (s.tag === 1) {
          var g = s.stateNode;
          if (typeof s.type.getDerivedStateFromError == "function" || typeof g.componentDidCatch == "function" && (gu === null || !gu.has(g))) {
            i = tr(h, i), h = gf(2), g = zs(s, h, 2), g !== null && (yf(
              h,
              g,
              s,
              i
            ), xn(g, 2), Zo(g));
            break;
          }
        }
        s = s.return;
      }
  }
  function fd(i, s, h) {
    var g = i.pingCache;
    if (g === null) {
      g = i.pingCache = new eg();
      var A = /* @__PURE__ */ new Set();
      g.set(s, A);
    } else
      A = g.get(s), A === void 0 && (A = /* @__PURE__ */ new Set(), g.set(s, A));
    A.has(h) || (Of = !0, A.add(h), i = Ay.bind(null, i, s, h), s.then(i, i));
  }
  function Ay(i, s, h) {
    var g = i.pingCache;
    g !== null && g.delete(s), i.pingedLanes |= i.suspendedLanes & h, i.warmLanes &= ~h, sn === i && (Pi & h) === h && (qn === 4 || qn === 3 && (Pi & 62914560) === Pi && 300 > Yn() - sh ? (ji & 2) === 0 && uh(i, 0) : Bf |= h, Tn === Pi && (Tn = 0)), Zo(i);
  }
  function Sp(i, s) {
    s === 0 && (s = Yi()), i = Ao(i, s), i !== null && (xn(i, s), Zo(i));
  }
  function Kf(i) {
    var s = i.memoizedState, h = 0;
    s !== null && (h = s.retryLane), Sp(i, h);
  }
  function hh(i, s) {
    var h = 0;
    switch (i.tag) {
      case 31:
      case 13:
        var g = i.stateNode, A = i.memoizedState;
        A !== null && (h = A.retryLane);
        break;
      case 19:
        g = i.stateNode;
        break;
      case 22:
        g = i.stateNode._retryCache;
        break;
      default:
        throw Error(b(314));
    }
    g !== null && g.delete(s), Sp(i, h);
  }
  function lg(i, s) {
    return Os(i, s);
  }
  var md = null, _u = null, Tp = !1, Tc = !1, Mp = !1, vu = 0;
  function Zo(i) {
    i !== _u && i.next === null && (_u === null ? md = _u = i : _u = _u.next = i), Tc = !0, Tp || (Tp = !0, Wf());
  }
  function dh(i, s) {
    if (!Mp && Tc) {
      Mp = !0;
      do
        for (var h = !1, g = md; g !== null; ) {
          if (i !== 0) {
            var A = g.pendingLanes;
            if (A === 0) var I = 0;
            else {
              var F = g.suspendedLanes, W = g.pingedLanes;
              I = (1 << 31 - Ee(42 | i) + 1) - 1, I &= A & ~(F & ~W), I = I & 201326741 ? I & 201326741 | 1 : I ? I | 2 : 0;
            }
            I !== 0 && (h = !0, dg(g, I));
          } else
            I = Pi, I = ri(
              g,
              g === sn ? I : 0,
              g.cancelPendingCommit !== null || g.timeoutHandle !== -1
            ), (I & 3) === 0 || It(g, I) || (h = !0, dg(g, I));
          g = g.next;
        }
      while (h);
      Mp = !1;
    }
  }
  function Ey() {
    ug();
  }
  function ug() {
    Tc = Tp = !1;
    var i = 0;
    vu !== 0 && zy() && (i = vu);
    for (var s = Yn(), h = null, g = md; g !== null; ) {
      var A = g.next, I = cg(g, s);
      I === 0 ? (g.next = null, h === null ? md = A : h.next = A, A === null && (_u = h)) : (h = g, (i !== 0 || (I & 3) !== 0) && (Tc = !0)), g = A;
    }
    ba !== 0 && ba !== 5 || dh(i), vu !== 0 && (vu = 0);
  }
  function cg(i, s) {
    for (var h = i.suspendedLanes, g = i.pingedLanes, A = i.expirationTimes, I = i.pendingLanes & -62914561; 0 < I; ) {
      var F = 31 - Ee(I), W = 1 << F, _e = A[F];
      _e === -1 ? ((W & h) === 0 || (W & g) !== 0) && (A[F] = ti(W, s)) : _e <= s && (i.expiredLanes |= W), I &= ~W;
    }
    if (s = sn, h = Pi, h = ri(
      i,
      i === s ? h : 0,
      i.cancelPendingCommit !== null || i.timeoutHandle !== -1
    ), g = i.callbackNode, h === 0 || i === s && (en === 2 || en === 9) || i.cancelPendingCommit !== null)
      return g !== null && g !== null && Xr(g), i.callbackNode = null, i.callbackPriority = 0;
    if ((h & 3) === 0 || It(i, h)) {
      if (s = h & -h, s === i.callbackPriority) return s;
      switch (g !== null && Xr(g), la(h)) {
        case 2:
        case 8:
          h = Ns;
          break;
        case 32:
          h = js;
          break;
        case 268435456:
          h = H;
          break;
        default:
          h = js;
      }
      return g = hg.bind(null, i), h = Os(h, g), i.callbackPriority = s, i.callbackNode = h, s;
    }
    return g !== null && g !== null && Xr(g), i.callbackPriority = 2, i.callbackNode = null, 2;
  }
  function hg(i, s) {
    if (ba !== 0 && ba !== 5)
      return i.callbackNode = null, i.callbackPriority = 0, null;
    var h = i.callbackNode;
    if (pd() && i.callbackNode !== h)
      return null;
    var g = Pi;
    return g = ri(
      i,
      i === sn ? g : 0,
      i.cancelPendingCommit !== null || i.timeoutHandle !== -1
    ), g === 0 ? null : (Vf(i, g, s), cg(i, Yn()), i.callbackNode != null && i.callbackNode === h ? hg.bind(null, i) : null);
  }
  function dg(i, s) {
    if (pd()) return null;
    Vf(i, s, !0);
  }
  function Wf() {
    xg(function() {
      (ji & 6) !== 0 ? Os(
        Bs,
        Ey
      ) : ug();
    });
  }
  function $o() {
    if (vu === 0) {
      var i = au;
      i === 0 && (i = Ye, Ye <<= 1, (Ye & 261888) === 0 && (Ye = 256)), vu = i;
    }
    return vu;
  }
  function Jf(i) {
    return i == null || typeof i == "symbol" || typeof i == "boolean" ? null : typeof i == "function" ? i : us("" + i);
  }
  function Qf(i, s) {
    var h = s.ownerDocument.createElement("input");
    return h.name = s.name, h.value = s.value, i.id && h.setAttribute("form", i.id), s.parentNode.insertBefore(h, s), i = new FormData(i), h.parentNode.removeChild(h), i;
  }
  function pg(i, s, h, g, A) {
    if (s === "submit" && h && h.stateNode === A) {
      var I = Jf(
        (A[Zt] || null).action
      ), F = g.submitter;
      F && (s = (s = F[Zt] || null) ? Jf(s.formAction) : F.getAttribute("formAction"), s !== null && (I = s, F = null));
      var W = new Gl(
        "action",
        "action",
        null,
        g,
        A
      );
      i.push({
        event: W,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (g.defaultPrevented) {
                if (vu !== 0) {
                  var _e = F ? Qf(A, F) : new FormData(A);
                  Uo(
                    h,
                    {
                      pending: !0,
                      data: _e,
                      method: A.method,
                      action: I
                    },
                    null,
                    _e
                  );
                }
              } else
                typeof I == "function" && (W.preventDefault(), _e = F ? Qf(A, F) : new FormData(A), Uo(
                  h,
                  {
                    pending: !0,
                    data: _e,
                    method: A.method,
                    action: I
                  },
                  I,
                  _e
                ));
            },
            currentTarget: A
          }
        ]
      });
    }
  }
  for (var Ap = 0; Ap < Xu.length; Ap++) {
    var Ep = Xu[Ap], em = Ep.toLowerCase(), fg = Ep[0].toUpperCase() + Ep.slice(1);
    ya(
      em,
      "on" + fg
    );
  }
  ya($u, "onAnimationEnd"), ya(Gc, "onAnimationIteration"), ya(Mo, "onAnimationStart"), ya("dblclick", "onDoubleClick"), ya("focusin", "onFocus"), ya("focusout", "onBlur"), ya(Hu, "onTransitionRun"), ya(Ql, "onTransitionStart"), ya(Dr, "onTransitionCancel"), ya(Gh, "onTransitionEnd"), ls("onMouseEnter", ["mouseout", "mouseover"]), ls("onMouseLeave", ["mouseout", "mouseover"]), ls("onPointerEnter", ["pointerout", "pointerover"]), ls("onPointerLeave", ["pointerout", "pointerover"]), go(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), go(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), go("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), go(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), go(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), go(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var kl = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), mg = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(kl)
  );
  function Cp(i, s) {
    s = (s & 4) !== 0;
    for (var h = 0; h < i.length; h++) {
      var g = i[h], A = g.event;
      g = g.listeners;
      e: {
        var I = void 0;
        if (s)
          for (var F = g.length - 1; 0 <= F; F--) {
            var W = g[F], _e = W.instance, Be = W.currentTarget;
            if (W = W.listener, _e !== I && A.isPropagationStopped())
              break e;
            I = W, A.currentTarget = Be;
            try {
              I(A);
            } catch (Ze) {
              pl(Ze);
            }
            A.currentTarget = null, I = _e;
          }
        else
          for (F = 0; F < g.length; F++) {
            if (W = g[F], _e = W.instance, Be = W.currentTarget, W = W.listener, _e !== I && A.isPropagationStopped())
              break e;
            I = W, A.currentTarget = Be;
            try {
              I(A);
            } catch (Ze) {
              pl(Ze);
            }
            A.currentTarget = null, I = _e;
          }
      }
    }
  }
  function Ai(i, s) {
    var h = s[Kn];
    h === void 0 && (h = s[Kn] = /* @__PURE__ */ new Set());
    var g = i + "__bubble";
    h.has(g) || (xu(s, i, 2, !1), h.add(g));
  }
  function Cr(i, s, h) {
    var g = 0;
    s && (g |= 4), xu(
      h,
      i,
      g,
      s
    );
  }
  var Rl = "_reactListening" + Math.random().toString(36).slice(2);
  function Mc(i) {
    if (!i[Rl]) {
      i[Rl] = !0, Na.forEach(function(h) {
        h !== "selectionchange" && (mg.has(h) || Cr(h, !1, i), Cr(h, !0, i));
      });
      var s = i.nodeType === 9 ? i : i.ownerDocument;
      s === null || s[Rl] || (s[Rl] = !0, Cr("selectionchange", !1, s));
    }
  }
  function xu(i, s, h, g) {
    switch (ra(s)) {
      case 2:
        var A = Sa;
        break;
      case 8:
        A = hr;
        break;
      default:
        A = zr;
    }
    h = A.bind(
      null,
      s,
      h,
      i
    ), A = void 0, !ua || s !== "touchstart" && s !== "touchmove" && s !== "wheel" || (A = !0), g ? A !== void 0 ? i.addEventListener(s, h, {
      capture: !0,
      passive: A
    }) : i.addEventListener(s, h, !0) : A !== void 0 ? i.addEventListener(s, h, {
      passive: A
    }) : i.addEventListener(s, h, !1);
  }
  function zp(i, s, h, g, A) {
    var I = g;
    if ((s & 1) === 0 && (s & 2) === 0 && g !== null)
      e: for (; ; ) {
        if (g === null) return;
        var F = g.tag;
        if (F === 3 || F === 4) {
          var W = g.stateNode.containerInfo;
          if (W === A) break;
          if (F === 4)
            for (F = g.return; F !== null; ) {
              var _e = F.tag;
              if ((_e === 3 || _e === 4) && F.stateNode.containerInfo === A)
                return;
              F = F.return;
            }
          for (; W !== null; ) {
            if (F = Fs(W), F === null) return;
            if (_e = F.tag, _e === 5 || _e === 6 || _e === 26 || _e === 27) {
              g = I = F;
              continue e;
            }
            W = W.parentNode;
          }
        }
        g = g.return;
      }
    zh(function() {
      var Be = I, Ze = ga(h), Ke = [];
      e: {
        var Ne = Zh.get(i);
        if (Ne !== void 0) {
          var Ve = Gl, zt = i;
          switch (i) {
            case "keypress":
              if (fi(h) === 0) break e;
            case "keydown":
            case "keyup":
              Ve = Zd;
              break;
            case "focusin":
              zt = "focus", Ve = pn;
              break;
            case "focusout":
              zt = "blur", Ve = pn;
              break;
            case "beforeblur":
            case "afterblur":
              Ve = pn;
              break;
            case "click":
              if (h.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Ve = Jn;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Ve = Ou;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Ve = rf;
              break;
            case $u:
            case Gc:
            case Mo:
              Ve = Bu;
              break;
            case Gh:
              Ve = Oc;
              break;
            case "scroll":
            case "scrollend":
              Ve = Lu;
              break;
            case "wheel":
              Ve = ul;
              break;
            case "copy":
            case "cut":
            case "paste":
              Ve = af;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Ve = $d;
              break;
            case "toggle":
            case "beforetoggle":
              Ve = Bc;
          }
          var Nt = (s & 4) !== 0, _n = !Nt && (i === "scroll" || i === "scrollend"), Ce = Nt ? Ne !== null ? Ne + "Capture" : null : Ne;
          Nt = [];
          for (var Me = Be, je; Me !== null; ) {
            var Qe = Me;
            if (je = Qe.stateNode, Qe = Qe.tag, Qe !== 5 && Qe !== 26 && Qe !== 27 || je === null || Ce === null || (Qe = Wn(Me, Ce), Qe != null && Nt.push(
              ph(Me, Qe, je)
            )), _n) break;
            Me = Me.return;
          }
          0 < Nt.length && (Ne = new Ve(
            Ne,
            zt,
            null,
            h,
            Ze
          ), Ke.push({ event: Ne, listeners: Nt }));
        }
      }
      if ((s & 7) === 0) {
        e: {
          if (Ne = i === "mouseover" || i === "pointerover", Ve = i === "mouseout" || i === "pointerout", Ne && h !== ql && (zt = h.relatedTarget || h.fromElement) && (Fs(zt) || zt[Jt]))
            break e;
          if ((Ve || Ne) && (Ne = Ze.window === Ze ? Ze : (Ne = Ze.ownerDocument) ? Ne.defaultView || Ne.parentWindow : window, Ve ? (zt = h.relatedTarget || h.toElement, Ve = Be, zt = zt ? Fs(zt) : null, zt !== null && (_n = z(zt), Nt = zt.tag, zt !== _n || Nt !== 5 && Nt !== 27 && Nt !== 6) && (zt = null)) : (Ve = null, zt = Be), Ve !== zt)) {
            if (Nt = Jn, Qe = "onMouseLeave", Ce = "onMouseEnter", Me = "mouse", (i === "pointerout" || i === "pointerover") && (Nt = $d, Qe = "onPointerLeave", Ce = "onPointerEnter", Me = "pointer"), _n = Ve == null ? Ne : os(Ve), je = zt == null ? Ne : os(zt), Ne = new Nt(
              Qe,
              Me + "leave",
              Ve,
              h,
              Ze
            ), Ne.target = _n, Ne.relatedTarget = je, Qe = null, Fs(Ze) === Be && (Nt = new Nt(
              Ce,
              Me + "enter",
              zt,
              h,
              Ze
            ), Nt.target = je, Nt.relatedTarget = _n, Qe = Nt), _n = Qe, Ve && zt)
              t: {
                for (Nt = gg, Ce = Ve, Me = zt, je = 0, Qe = Ce; Qe; Qe = Nt(Qe))
                  je++;
                Qe = 0;
                for (var Yt = Me; Yt; Yt = Nt(Yt))
                  Qe++;
                for (; 0 < je - Qe; )
                  Ce = Nt(Ce), je--;
                for (; 0 < Qe - je; )
                  Me = Nt(Me), Qe--;
                for (; je--; ) {
                  if (Ce === Me || Me !== null && Ce === Me.alternate) {
                    Nt = Ce;
                    break t;
                  }
                  Ce = Nt(Ce), Me = Nt(Me);
                }
                Nt = null;
              }
            else Nt = null;
            Ve !== null && yg(
              Ke,
              Ne,
              Ve,
              Nt,
              !1
            ), zt !== null && _n !== null && yg(
              Ke,
              _n,
              zt,
              Nt,
              !0
            );
          }
        }
        e: {
          if (Ne = Be ? os(Be) : window, Ve = Ne.nodeName && Ne.nodeName.toLowerCase(), Ve === "select" || Ve === "input" && Ne.type === "file")
            var Wi = jc;
          else if (Nc(Ne))
            if (Uc)
              Wi = Uh;
            else {
              Wi = Qd;
              var Ft = Jd;
            }
          else
            Ve = Ne.nodeName, !Ve || Ve.toLowerCase() !== "input" || Ne.type !== "checkbox" && Ne.type !== "radio" ? Be && Kr(Be.elementType) && (Wi = jc) : Wi = jh;
          if (Wi && (Wi = Wi(i, Be))) {
            Oh(
              Ke,
              Wi,
              h,
              Ze
            );
            break e;
          }
          Ft && Ft(i, Ne, Be), i === "focusout" && Be && Ne.type === "number" && Be.memoizedProps.value != null && Du(Ne, "number", Ne.value);
        }
        switch (Ft = Be ? os(Be) : window, i) {
          case "focusin":
            (Nc(Ft) || Ft.contentEditable === "true") && (So = Ft, Vh = Be, Gu = null);
            break;
          case "focusout":
            Gu = Vh = So = null;
            break;
          case "mousedown":
            qh = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            qh = !1, tp(Ke, h, Ze);
            break;
          case "selectionchange":
            if (dl) break;
          case "keydown":
          case "keyup":
            tp(Ke, h, Ze);
        }
        var Si;
        if (Dh)
          e: {
            switch (i) {
              case "compositionstart":
                var Oi = "onCompositionStart";
                break e;
              case "compositionend":
                Oi = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Oi = "onCompositionUpdate";
                break e;
            }
            Oi = void 0;
          }
        else
          cl ? Xd(i, h) && (Oi = "onCompositionEnd") : i === "keydown" && h.keyCode === 229 && (Oi = "onCompositionStart");
        Oi && (Yl && h.locale !== "ko" && (cl || Oi !== "onCompositionStart" ? Oi === "onCompositionEnd" && cl && (Si = cs()) : (Ja = Ze, Ut = "value" in Ja ? Ja.value : Ja.textContent, cl = !0)), Ft = gd(Be, Oi), 0 < Ft.length && (Oi = new ca(
          Oi,
          i,
          null,
          h,
          Ze
        ), Ke.push({ event: Oi, listeners: Ft }), Si ? Oi.data = Si : (Si = bo(h), Si !== null && (Oi.data = Si)))), (Si = Fu ? Lh(i, h) : of(i, h)) && (Oi = gd(Be, "onBeforeInput"), 0 < Oi.length && (Ft = new ca(
          "onBeforeInput",
          "beforeinput",
          null,
          h,
          Ze
        ), Ke.push({
          event: Ft,
          listeners: Oi
        }), Ft.data = Si)), pg(
          Ke,
          i,
          Be,
          h,
          Ze
        );
      }
      Cp(Ke, s);
    });
  }
  function ph(i, s, h) {
    return {
      instance: i,
      listener: s,
      currentTarget: h
    };
  }
  function gd(i, s) {
    for (var h = s + "Capture", g = []; i !== null; ) {
      var A = i, I = A.stateNode;
      if (A = A.tag, A !== 5 && A !== 26 && A !== 27 || I === null || (A = Wn(i, h), A != null && g.unshift(
        ph(i, A, I)
      ), A = Wn(i, s), A != null && g.push(
        ph(i, A, I)
      )), i.tag === 3) return g;
      i = i.return;
    }
    return [];
  }
  function gg(i) {
    if (i === null) return null;
    do
      i = i.return;
    while (i && i.tag !== 5 && i.tag !== 27);
    return i || null;
  }
  function yg(i, s, h, g, A) {
    for (var I = s._reactName, F = []; h !== null && h !== g; ) {
      var W = h, _e = W.alternate, Be = W.stateNode;
      if (W = W.tag, _e !== null && _e === g) break;
      W !== 5 && W !== 26 && W !== 27 || Be === null || (_e = Be, A ? (Be = Wn(h, I), Be != null && F.unshift(
        ph(h, Be, _e)
      )) : A || (Be = Wn(h, I), Be != null && F.push(
        ph(h, Be, _e)
      ))), h = h.return;
    }
    F.length !== 0 && i.push({ event: s, listeners: F });
  }
  var _g = /\r\n?/g, bu = /\u0000|\uFFFD/g;
  function tm(i) {
    return (typeof i == "string" ? i : "" + i).replace(_g, `
`).replace(bu, "");
  }
  function im(i, s) {
    return s = tm(s), tm(i) === s;
  }
  function tn(i, s, h, g, A, I) {
    switch (h) {
      case "children":
        typeof g == "string" ? s === "body" || s === "textarea" && g === "" || Ma(i, g) : (typeof g == "number" || typeof g == "bigint") && s !== "body" && Ma(i, "" + g);
        break;
      case "className":
        Ru(i, "class", g);
        break;
      case "tabIndex":
        Ru(i, "tabindex", g);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Ru(i, h, g);
        break;
      case "style":
        Zs(i, g, I);
        break;
      case "data":
        if (s !== "object") {
          Ru(i, "data", g);
          break;
        }
      case "src":
      case "href":
        if (g === "" && (s !== "a" || h !== "href")) {
          i.removeAttribute(h);
          break;
        }
        if (g == null || typeof g == "function" || typeof g == "symbol" || typeof g == "boolean") {
          i.removeAttribute(h);
          break;
        }
        g = us("" + g), i.setAttribute(h, g);
        break;
      case "action":
      case "formAction":
        if (typeof g == "function") {
          i.setAttribute(
            h,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof I == "function" && (h === "formAction" ? (s !== "input" && tn(i, s, "name", A.name, A, null), tn(
            i,
            s,
            "formEncType",
            A.formEncType,
            A,
            null
          ), tn(
            i,
            s,
            "formMethod",
            A.formMethod,
            A,
            null
          ), tn(
            i,
            s,
            "formTarget",
            A.formTarget,
            A,
            null
          )) : (tn(i, s, "encType", A.encType, A, null), tn(i, s, "method", A.method, A, null), tn(i, s, "target", A.target, A, null)));
        if (g == null || typeof g == "symbol" || typeof g == "boolean") {
          i.removeAttribute(h);
          break;
        }
        g = us("" + g), i.setAttribute(h, g);
        break;
      case "onClick":
        g != null && (i.onclick = Rr);
        break;
      case "onScroll":
        g != null && Ai("scroll", i);
        break;
      case "onScrollEnd":
        g != null && Ai("scrollend", i);
        break;
      case "dangerouslySetInnerHTML":
        if (g != null) {
          if (typeof g != "object" || !("__html" in g))
            throw Error(b(61));
          if (h = g.__html, h != null) {
            if (A.children != null) throw Error(b(60));
            i.innerHTML = h;
          }
        }
        break;
      case "multiple":
        i.multiple = g && typeof g != "function" && typeof g != "symbol";
        break;
      case "muted":
        i.muted = g && typeof g != "function" && typeof g != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (g == null || typeof g == "function" || typeof g == "boolean" || typeof g == "symbol") {
          i.removeAttribute("xlink:href");
          break;
        }
        h = us("" + g), i.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          h
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        g != null && typeof g != "function" && typeof g != "symbol" ? i.setAttribute(h, "" + g) : i.removeAttribute(h);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        g && typeof g != "function" && typeof g != "symbol" ? i.setAttribute(h, "") : i.removeAttribute(h);
        break;
      case "capture":
      case "download":
        g === !0 ? i.setAttribute(h, "") : g !== !1 && g != null && typeof g != "function" && typeof g != "symbol" ? i.setAttribute(h, g) : i.removeAttribute(h);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        g != null && typeof g != "function" && typeof g != "symbol" && !isNaN(g) && 1 <= g ? i.setAttribute(h, g) : i.removeAttribute(h);
        break;
      case "rowSpan":
      case "start":
        g == null || typeof g == "function" || typeof g == "symbol" || isNaN(g) ? i.removeAttribute(h) : i.setAttribute(h, g);
        break;
      case "popover":
        Ai("beforetoggle", i), Ai("toggle", i), ku(i, "popover", g);
        break;
      case "xlinkActuate":
        Ka(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          g
        );
        break;
      case "xlinkArcrole":
        Ka(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          g
        );
        break;
      case "xlinkRole":
        Ka(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          g
        );
        break;
      case "xlinkShow":
        Ka(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          g
        );
        break;
      case "xlinkTitle":
        Ka(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          g
        );
        break;
      case "xlinkType":
        Ka(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          g
        );
        break;
      case "xmlBase":
        Ka(
          i,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          g
        );
        break;
      case "xmlLang":
        Ka(
          i,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          g
        );
        break;
      case "xmlSpace":
        Ka(
          i,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          g
        );
        break;
      case "is":
        ku(i, "is", g);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < h.length) || h[0] !== "o" && h[0] !== "O" || h[1] !== "n" && h[1] !== "N") && (h = sl.get(h) || h, ku(i, h, g));
    }
  }
  function Pp(i, s, h, g, A, I) {
    switch (h) {
      case "style":
        Zs(i, g, I);
        break;
      case "dangerouslySetInnerHTML":
        if (g != null) {
          if (typeof g != "object" || !("__html" in g))
            throw Error(b(61));
          if (h = g.__html, h != null) {
            if (A.children != null) throw Error(b(60));
            i.innerHTML = h;
          }
        }
        break;
      case "children":
        typeof g == "string" ? Ma(i, g) : (typeof g == "number" || typeof g == "bigint") && Ma(i, "" + g);
        break;
      case "onScroll":
        g != null && Ai("scroll", i);
        break;
      case "onScrollEnd":
        g != null && Ai("scrollend", i);
        break;
      case "onClick":
        g != null && (i.onclick = Rr);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!Hi.hasOwnProperty(h))
          e: {
            if (h[0] === "o" && h[1] === "n" && (A = h.endsWith("Capture"), s = h.slice(2, A ? h.length - 7 : void 0), I = i[Zt] || null, I = I != null ? I[h] : null, typeof I == "function" && i.removeEventListener(s, I, A), typeof g == "function")) {
              typeof I != "function" && I !== null && (h in i ? i[h] = null : i.hasAttribute(h) && i.removeAttribute(h)), i.addEventListener(s, g, A);
              break e;
            }
            h in i ? i[h] = g : g === !0 ? i.setAttribute(h, "") : ku(i, h, g);
          }
    }
  }
  function $a(i, s, h) {
    switch (s) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Ai("error", i), Ai("load", i);
        var g = !1, A = !1, I;
        for (I in h)
          if (h.hasOwnProperty(I)) {
            var F = h[I];
            if (F != null)
              switch (I) {
                case "src":
                  g = !0;
                  break;
                case "srcSet":
                  A = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(b(137, s));
                default:
                  tn(i, s, I, F, h, null);
              }
          }
        A && tn(i, s, "srcSet", h.srcSet, h, null), g && tn(i, s, "src", h.src, h, null);
        return;
      case "input":
        Ai("invalid", i);
        var W = I = F = A = null, _e = null, Be = null;
        for (g in h)
          if (h.hasOwnProperty(g)) {
            var Ze = h[g];
            if (Ze != null)
              switch (g) {
                case "name":
                  A = Ze;
                  break;
                case "type":
                  F = Ze;
                  break;
                case "checked":
                  _e = Ze;
                  break;
                case "defaultChecked":
                  Be = Ze;
                  break;
                case "value":
                  I = Ze;
                  break;
                case "defaultValue":
                  W = Ze;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Ze != null)
                    throw Error(b(137, s));
                  break;
                default:
                  tn(i, s, g, Ze, h, null);
              }
          }
        Dc(
          i,
          I,
          W,
          _e,
          Be,
          F,
          A,
          !1
        );
        return;
      case "select":
        Ai("invalid", i), g = F = I = null;
        for (A in h)
          if (h.hasOwnProperty(A) && (W = h[A], W != null))
            switch (A) {
              case "value":
                I = W;
                break;
              case "defaultValue":
                F = W;
                break;
              case "multiple":
                g = W;
              default:
                tn(i, s, A, W, h, null);
            }
        s = I, h = F, i.multiple = !!g, s != null ? Fl(i, !!g, s, !1) : h != null && Fl(i, !!g, h, !0);
        return;
      case "textarea":
        Ai("invalid", i), I = A = g = null;
        for (F in h)
          if (h.hasOwnProperty(F) && (W = h[F], W != null))
            switch (F) {
              case "value":
                g = W;
                break;
              case "defaultValue":
                A = W;
                break;
              case "children":
                I = W;
                break;
              case "dangerouslySetInnerHTML":
                if (W != null) throw Error(b(91));
                break;
              default:
                tn(i, s, F, W, h, null);
            }
        Vl(i, g, A, I);
        return;
      case "option":
        for (_e in h)
          if (h.hasOwnProperty(_e) && (g = h[_e], g != null))
            switch (_e) {
              case "selected":
                i.selected = g && typeof g != "function" && typeof g != "symbol";
                break;
              default:
                tn(i, s, _e, g, h, null);
            }
        return;
      case "dialog":
        Ai("beforetoggle", i), Ai("toggle", i), Ai("cancel", i), Ai("close", i);
        break;
      case "iframe":
      case "object":
        Ai("load", i);
        break;
      case "video":
      case "audio":
        for (g = 0; g < kl.length; g++)
          Ai(kl[g], i);
        break;
      case "image":
        Ai("error", i), Ai("load", i);
        break;
      case "details":
        Ai("toggle", i);
        break;
      case "embed":
      case "source":
      case "link":
        Ai("error", i), Ai("load", i);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (Be in h)
          if (h.hasOwnProperty(Be) && (g = h[Be], g != null))
            switch (Be) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(b(137, s));
              default:
                tn(i, s, Be, g, h, null);
            }
        return;
      default:
        if (Kr(s)) {
          for (Ze in h)
            h.hasOwnProperty(Ze) && (g = h[Ze], g !== void 0 && Pp(
              i,
              s,
              Ze,
              g,
              h,
              void 0
            ));
          return;
        }
    }
    for (W in h)
      h.hasOwnProperty(W) && (g = h[W], g != null && tn(i, s, W, g, h, null));
  }
  function Cy(i, s, h, g) {
    switch (s) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var A = null, I = null, F = null, W = null, _e = null, Be = null, Ze = null;
        for (Ve in h) {
          var Ke = h[Ve];
          if (h.hasOwnProperty(Ve) && Ke != null)
            switch (Ve) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                _e = Ke;
              default:
                g.hasOwnProperty(Ve) || tn(i, s, Ve, null, g, Ke);
            }
        }
        for (var Ne in g) {
          var Ve = g[Ne];
          if (Ke = h[Ne], g.hasOwnProperty(Ne) && (Ve != null || Ke != null))
            switch (Ne) {
              case "type":
                I = Ve;
                break;
              case "name":
                A = Ve;
                break;
              case "checked":
                Be = Ve;
                break;
              case "defaultChecked":
                Ze = Ve;
                break;
              case "value":
                F = Ve;
                break;
              case "defaultValue":
                W = Ve;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (Ve != null)
                  throw Error(b(137, s));
                break;
              default:
                Ve !== Ke && tn(
                  i,
                  s,
                  Ne,
                  Ve,
                  g,
                  Ke
                );
            }
        }
        yo(
          i,
          F,
          W,
          _e,
          Be,
          Ze,
          I,
          A
        );
        return;
      case "select":
        Ve = F = W = Ne = null;
        for (I in h)
          if (_e = h[I], h.hasOwnProperty(I) && _e != null)
            switch (I) {
              case "value":
                break;
              case "multiple":
                Ve = _e;
              default:
                g.hasOwnProperty(I) || tn(
                  i,
                  s,
                  I,
                  null,
                  g,
                  _e
                );
            }
        for (A in g)
          if (I = g[A], _e = h[A], g.hasOwnProperty(A) && (I != null || _e != null))
            switch (A) {
              case "value":
                Ne = I;
                break;
              case "defaultValue":
                W = I;
                break;
              case "multiple":
                F = I;
              default:
                I !== _e && tn(
                  i,
                  s,
                  A,
                  I,
                  g,
                  _e
                );
            }
        s = W, h = F, g = Ve, Ne != null ? Fl(i, !!h, Ne, !1) : !!g != !!h && (s != null ? Fl(i, !!h, s, !0) : Fl(i, !!h, h ? [] : "", !1));
        return;
      case "textarea":
        Ve = Ne = null;
        for (W in h)
          if (A = h[W], h.hasOwnProperty(W) && A != null && !g.hasOwnProperty(W))
            switch (W) {
              case "value":
                break;
              case "children":
                break;
              default:
                tn(i, s, W, null, g, A);
            }
        for (F in g)
          if (A = g[F], I = h[F], g.hasOwnProperty(F) && (A != null || I != null))
            switch (F) {
              case "value":
                Ne = A;
                break;
              case "defaultValue":
                Ve = A;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (A != null) throw Error(b(91));
                break;
              default:
                A !== I && tn(i, s, F, A, g, I);
            }
        rl(i, Ne, Ve);
        return;
      case "option":
        for (var zt in h)
          if (Ne = h[zt], h.hasOwnProperty(zt) && Ne != null && !g.hasOwnProperty(zt))
            switch (zt) {
              case "selected":
                i.selected = !1;
                break;
              default:
                tn(
                  i,
                  s,
                  zt,
                  null,
                  g,
                  Ne
                );
            }
        for (_e in g)
          if (Ne = g[_e], Ve = h[_e], g.hasOwnProperty(_e) && Ne !== Ve && (Ne != null || Ve != null))
            switch (_e) {
              case "selected":
                i.selected = Ne && typeof Ne != "function" && typeof Ne != "symbol";
                break;
              default:
                tn(
                  i,
                  s,
                  _e,
                  Ne,
                  g,
                  Ve
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Nt in h)
          Ne = h[Nt], h.hasOwnProperty(Nt) && Ne != null && !g.hasOwnProperty(Nt) && tn(i, s, Nt, null, g, Ne);
        for (Be in g)
          if (Ne = g[Be], Ve = h[Be], g.hasOwnProperty(Be) && Ne !== Ve && (Ne != null || Ve != null))
            switch (Be) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (Ne != null)
                  throw Error(b(137, s));
                break;
              default:
                tn(
                  i,
                  s,
                  Be,
                  Ne,
                  g,
                  Ve
                );
            }
        return;
      default:
        if (Kr(s)) {
          for (var _n in h)
            Ne = h[_n], h.hasOwnProperty(_n) && Ne !== void 0 && !g.hasOwnProperty(_n) && Pp(
              i,
              s,
              _n,
              void 0,
              g,
              Ne
            );
          for (Ze in g)
            Ne = g[Ze], Ve = h[Ze], !g.hasOwnProperty(Ze) || Ne === Ve || Ne === void 0 && Ve === void 0 || Pp(
              i,
              s,
              Ze,
              Ne,
              g,
              Ve
            );
          return;
        }
    }
    for (var Ce in h)
      Ne = h[Ce], h.hasOwnProperty(Ce) && Ne != null && !g.hasOwnProperty(Ce) && tn(i, s, Ce, null, g, Ne);
    for (Ke in g)
      Ne = g[Ke], Ve = h[Ke], !g.hasOwnProperty(Ke) || Ne === Ve || Ne == null && Ve == null || tn(i, s, Ke, Ne, g, Ve);
  }
  function nm(i) {
    switch (i) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return !0;
      default:
        return !1;
    }
  }
  function vg() {
    if (typeof performance.getEntriesByType == "function") {
      for (var i = 0, s = 0, h = performance.getEntriesByType("resource"), g = 0; g < h.length; g++) {
        var A = h[g], I = A.transferSize, F = A.initiatorType, W = A.duration;
        if (I && W && nm(F)) {
          for (F = 0, W = A.responseEnd, g += 1; g < h.length; g++) {
            var _e = h[g], Be = _e.startTime;
            if (Be > W) break;
            var Ze = _e.transferSize, Ke = _e.initiatorType;
            Ze && nm(Ke) && (_e = _e.responseEnd, F += Ze * (_e < W ? 1 : (W - Be) / (_e - Be)));
          }
          if (--g, s += 8 * (I + F) / (A.duration / 1e3), i++, 10 < i) break;
        }
      }
      if (0 < i) return s / i / 1e6;
    }
    return navigator.connection && (i = navigator.connection.downlink, typeof i == "number") ? i : 5;
  }
  var fh = null, Ip = null;
  function Ac(i) {
    return i.nodeType === 9 ? i : i.ownerDocument;
  }
  function yd(i) {
    switch (i) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function _d(i, s) {
    if (i === 0)
      switch (s) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return i === 1 && s === "foreignObject" ? 0 : i;
  }
  function am(i, s) {
    return i === "textarea" || i === "noscript" || typeof s.children == "string" || typeof s.children == "number" || typeof s.children == "bigint" || typeof s.dangerouslySetInnerHTML == "object" && s.dangerouslySetInnerHTML !== null && s.dangerouslySetInnerHTML.__html != null;
  }
  var rm = null;
  function zy() {
    var i = window.event;
    return i && i.type === "popstate" ? i === rm ? !1 : (rm = i, !0) : (rm = null, !1);
  }
  var Ec = typeof setTimeout == "function" ? setTimeout : void 0, Ra = typeof clearTimeout == "function" ? clearTimeout : void 0, kp = typeof Promise == "function" ? Promise : void 0, xg = typeof queueMicrotask == "function" ? queueMicrotask : typeof kp < "u" ? function(i) {
    return kp.resolve(null).then(i).catch(bg);
  } : Ec;
  function bg(i) {
    setTimeout(function() {
      throw i;
    });
  }
  function Ho(i) {
    return i === "head";
  }
  function wg(i, s) {
    var h = s, g = 0;
    do {
      var A = h.nextSibling;
      if (i.removeChild(h), A && A.nodeType === 8)
        if (h = A.data, h === "/$" || h === "/&") {
          if (g === 0) {
            i.removeChild(A), $r(s);
            return;
          }
          g--;
        } else if (h === "$" || h === "$?" || h === "$~" || h === "$!" || h === "&")
          g++;
        else if (h === "html")
          Cc(i.ownerDocument.documentElement);
        else if (h === "head") {
          h = i.ownerDocument.head, Cc(h);
          for (var I = h.firstChild; I; ) {
            var F = I.nextSibling, W = I.nodeName;
            I[mo] || W === "SCRIPT" || W === "STYLE" || W === "LINK" && I.rel.toLowerCase() === "stylesheet" || h.removeChild(I), I = F;
          }
        } else
          h === "body" && Cc(i.ownerDocument.body);
      h = A;
    } while (h);
    $r(s);
  }
  function sm(i, s) {
    var h = i;
    i = 0;
    do {
      var g = h.nextSibling;
      if (h.nodeType === 1 ? s ? (h._stashedDisplay = h.style.display, h.style.display = "none") : (h.style.display = h._stashedDisplay || "", h.getAttribute("style") === "" && h.removeAttribute("style")) : h.nodeType === 3 && (s ? (h._stashedText = h.nodeValue, h.nodeValue = "") : h.nodeValue = h._stashedText || ""), g && g.nodeType === 8)
        if (h = g.data, h === "/$") {
          if (i === 0) break;
          i--;
        } else
          h !== "$" && h !== "$?" && h !== "$~" && h !== "$!" || i++;
      h = g;
    } while (h);
  }
  function Rp(i) {
    var s = i.firstChild;
    for (s && s.nodeType === 10 && (s = s.nextSibling); s; ) {
      var h = s;
      switch (s = s.nextSibling, h.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          Rp(h), ss(h);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (h.rel.toLowerCase() === "stylesheet") continue;
      }
      i.removeChild(h);
    }
  }
  function Py(i, s, h, g) {
    for (; i.nodeType === 1; ) {
      var A = h;
      if (i.nodeName.toLowerCase() !== s.toLowerCase()) {
        if (!g && (i.nodeName !== "INPUT" || i.type !== "hidden"))
          break;
      } else if (g) {
        if (!i[mo])
          switch (s) {
            case "meta":
              if (!i.hasAttribute("itemprop")) break;
              return i;
            case "link":
              if (I = i.getAttribute("rel"), I === "stylesheet" && i.hasAttribute("data-precedence"))
                break;
              if (I !== A.rel || i.getAttribute("href") !== (A.href == null || A.href === "" ? null : A.href) || i.getAttribute("crossorigin") !== (A.crossOrigin == null ? null : A.crossOrigin) || i.getAttribute("title") !== (A.title == null ? null : A.title))
                break;
              return i;
            case "style":
              if (i.hasAttribute("data-precedence")) break;
              return i;
            case "script":
              if (I = i.getAttribute("src"), (I !== (A.src == null ? null : A.src) || i.getAttribute("type") !== (A.type == null ? null : A.type) || i.getAttribute("crossorigin") !== (A.crossOrigin == null ? null : A.crossOrigin)) && I && i.hasAttribute("async") && !i.hasAttribute("itemprop"))
                break;
              return i;
            default:
              return i;
          }
      } else if (s === "input" && i.type === "hidden") {
        var I = A.name == null ? null : "" + A.name;
        if (A.type === "hidden" && i.getAttribute("name") === I)
          return i;
      } else return i;
      if (i = qr(i.nextSibling), i === null) break;
    }
    return null;
  }
  function Sg(i, s, h) {
    if (s === "") return null;
    for (; i.nodeType !== 3; )
      if ((i.nodeType !== 1 || i.nodeName !== "INPUT" || i.type !== "hidden") && !h || (i = qr(i.nextSibling), i === null)) return null;
    return i;
  }
  function Dp(i, s) {
    for (; i.nodeType !== 8; )
      if ((i.nodeType !== 1 || i.nodeName !== "INPUT" || i.type !== "hidden") && !s || (i = qr(i.nextSibling), i === null)) return null;
    return i;
  }
  function vd(i) {
    return i.data === "$?" || i.data === "$~";
  }
  function Lp(i) {
    return i.data === "$!" || i.data === "$?" && i.ownerDocument.readyState !== "loading";
  }
  function xd(i, s) {
    var h = i.ownerDocument;
    if (i.data === "$~") i._reactRetry = s;
    else if (i.data !== "$?" || h.readyState !== "loading")
      s();
    else {
      var g = function() {
        s(), h.removeEventListener("DOMContentLoaded", g);
      };
      h.addEventListener("DOMContentLoaded", g), i._reactRetry = g;
    }
  }
  function qr(i) {
    for (; i != null; i = i.nextSibling) {
      var s = i.nodeType;
      if (s === 1 || s === 3) break;
      if (s === 8) {
        if (s = i.data, s === "$" || s === "$!" || s === "$?" || s === "$~" || s === "&" || s === "F!" || s === "F")
          break;
        if (s === "/$" || s === "/&") return null;
      }
    }
    return i;
  }
  var Op = null;
  function Bp(i) {
    i = i.nextSibling;
    for (var s = 0; i; ) {
      if (i.nodeType === 8) {
        var h = i.data;
        if (h === "/$" || h === "/&") {
          if (s === 0)
            return qr(i.nextSibling);
          s--;
        } else
          h !== "$" && h !== "$!" && h !== "$?" && h !== "$~" && h !== "&" || s++;
      }
      i = i.nextSibling;
    }
    return null;
  }
  function bd(i) {
    i = i.previousSibling;
    for (var s = 0; i; ) {
      if (i.nodeType === 8) {
        var h = i.data;
        if (h === "$" || h === "$!" || h === "$?" || h === "$~" || h === "&") {
          if (s === 0) return i;
          s--;
        } else h !== "/$" && h !== "/&" || s++;
      }
      i = i.previousSibling;
    }
    return null;
  }
  function mh(i, s, h) {
    switch (s = Ac(h), i) {
      case "html":
        if (i = s.documentElement, !i) throw Error(b(452));
        return i;
      case "head":
        if (i = s.head, !i) throw Error(b(453));
        return i;
      case "body":
        if (i = s.body, !i) throw Error(b(454));
        return i;
      default:
        throw Error(b(451));
    }
  }
  function Cc(i) {
    for (var s = i.attributes; s.length; )
      i.removeAttributeNode(s[0]);
    ss(i);
  }
  var Gr = /* @__PURE__ */ new Map(), Np = /* @__PURE__ */ new Set();
  function jp(i) {
    return typeof i.getRootNode == "function" ? i.getRootNode() : i.nodeType === 9 ? i : i.ownerDocument;
  }
  var a = vt.d;
  vt.d = {
    f: t,
    r: n,
    D: v,
    C: x,
    L: T,
    m: E,
    X: D,
    S: k,
    M: N
  };
  function t() {
    var i = a.f(), s = Sc();
    return i || s;
  }
  function n(i) {
    var s = Ba(i);
    s !== null && s.tag === 5 && s.type === "form" ? Ur(s) : a.r(i);
  }
  var l = typeof document > "u" ? null : document;
  function p(i, s, h) {
    var g = l;
    if (g && typeof s == "string" && s) {
      var A = Wa(s);
      A = 'link[rel="' + i + '"][href="' + A + '"]', typeof h == "string" && (A += '[crossorigin="' + h + '"]'), Np.has(A) || (Np.add(A), i = { rel: i, crossOrigin: h, href: s }, g.querySelector(A) === null && (s = g.createElement("link"), $a(s, "link", i), Rn(s), g.head.appendChild(s)));
    }
  }
  function v(i) {
    a.D(i), p("dns-prefetch", i, null);
  }
  function x(i, s) {
    a.C(i, s), p("preconnect", i, s);
  }
  function T(i, s, h) {
    a.L(i, s, h);
    var g = l;
    if (g && i && s) {
      var A = 'link[rel="preload"][as="' + Wa(s) + '"]';
      s === "image" && h && h.imageSrcSet ? (A += '[imagesrcset="' + Wa(
        h.imageSrcSet
      ) + '"]', typeof h.imageSizes == "string" && (A += '[imagesizes="' + Wa(
        h.imageSizes
      ) + '"]')) : A += '[href="' + Wa(i) + '"]';
      var I = A;
      switch (s) {
        case "style":
          I = G(i);
          break;
        case "script":
          I = se(i);
      }
      Gr.has(I) || (i = ae(
        {
          rel: "preload",
          href: s === "image" && h && h.imageSrcSet ? void 0 : i,
          as: s
        },
        h
      ), Gr.set(I, i), g.querySelector(A) !== null || s === "style" && g.querySelector(Z(I)) || s === "script" && g.querySelector(xe(I)) || (s = g.createElement("link"), $a(s, "link", i), Rn(s), g.head.appendChild(s)));
    }
  }
  function E(i, s) {
    a.m(i, s);
    var h = l;
    if (h && i) {
      var g = s && typeof s.as == "string" ? s.as : "script", A = 'link[rel="modulepreload"][as="' + Wa(g) + '"][href="' + Wa(i) + '"]', I = A;
      switch (g) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          I = se(i);
      }
      if (!Gr.has(I) && (i = ae({ rel: "modulepreload", href: i }, s), Gr.set(I, i), h.querySelector(A) === null)) {
        switch (g) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (h.querySelector(xe(I)))
              return;
        }
        g = h.createElement("link"), $a(g, "link", i), Rn(g), h.head.appendChild(g);
      }
    }
  }
  function k(i, s, h) {
    a.S(i, s, h);
    var g = l;
    if (g && i) {
      var A = Qi(g).hoistableStyles, I = G(i);
      s = s || "default";
      var F = A.get(I);
      if (!F) {
        var W = { loading: 0, preload: null };
        if (F = g.querySelector(
          Z(I)
        ))
          W.loading = 5;
        else {
          i = ae(
            { rel: "stylesheet", href: i, "data-precedence": s },
            h
          ), (h = Gr.get(I)) && Ie(i, h);
          var _e = F = g.createElement("link");
          Rn(_e), $a(_e, "link", i), _e._p = new Promise(function(Be, Ze) {
            _e.onload = Be, _e.onerror = Ze;
          }), _e.addEventListener("load", function() {
            W.loading |= 1;
          }), _e.addEventListener("error", function() {
            W.loading |= 2;
          }), W.loading |= 4, ge(F, s, g);
        }
        F = {
          type: "stylesheet",
          instance: F,
          count: 1,
          state: W
        }, A.set(I, F);
      }
    }
  }
  function D(i, s) {
    a.X(i, s);
    var h = l;
    if (h && i) {
      var g = Qi(h).hoistableScripts, A = se(i), I = g.get(A);
      I || (I = h.querySelector(xe(A)), I || (i = ae({ src: i, async: !0 }, s), (s = Gr.get(A)) && Fe(i, s), I = h.createElement("script"), Rn(I), $a(I, "link", i), h.head.appendChild(I)), I = {
        type: "script",
        instance: I,
        count: 1,
        state: null
      }, g.set(A, I));
    }
  }
  function N(i, s) {
    a.M(i, s);
    var h = l;
    if (h && i) {
      var g = Qi(h).hoistableScripts, A = se(i), I = g.get(A);
      I || (I = h.querySelector(xe(A)), I || (i = ae({ src: i, async: !0, type: "module" }, s), (s = Gr.get(A)) && Fe(i, s), I = h.createElement("script"), Rn(I), $a(I, "link", i), h.head.appendChild(I)), I = {
        type: "script",
        instance: I,
        count: 1,
        state: null
      }, g.set(A, I));
    }
  }
  function q(i, s, h, g) {
    var A = (A = Vt.current) ? jp(A) : null;
    if (!A) throw Error(b(446));
    switch (i) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof h.precedence == "string" && typeof h.href == "string" ? (s = G(h.href), h = Qi(
          A
        ).hoistableStyles, g = h.get(s), g || (g = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, h.set(s, g)), g) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (h.rel === "stylesheet" && typeof h.href == "string" && typeof h.precedence == "string") {
          i = G(h.href);
          var I = Qi(
            A
          ).hoistableStyles, F = I.get(i);
          if (F || (A = A.ownerDocument || A, F = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, I.set(i, F), (I = A.querySelector(
            Z(i)
          )) && !I._p && (F.instance = I, F.state.loading = 5), Gr.has(i) || (h = {
            rel: "preload",
            as: "style",
            href: h.href,
            crossOrigin: h.crossOrigin,
            integrity: h.integrity,
            media: h.media,
            hrefLang: h.hrefLang,
            referrerPolicy: h.referrerPolicy
          }, Gr.set(i, h), I || ee(
            A,
            i,
            h,
            F.state
          ))), s && g === null)
            throw Error(b(528, ""));
          return F;
        }
        if (s && g !== null)
          throw Error(b(529, ""));
        return null;
      case "script":
        return s = h.async, h = h.src, typeof h == "string" && s && typeof s != "function" && typeof s != "symbol" ? (s = se(h), h = Qi(
          A
        ).hoistableScripts, g = h.get(s), g || (g = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, h.set(s, g)), g) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(b(444, i));
    }
  }
  function G(i) {
    return 'href="' + Wa(i) + '"';
  }
  function Z(i) {
    return 'link[rel="stylesheet"][' + i + "]";
  }
  function X(i) {
    return ae({}, i, {
      "data-precedence": i.precedence,
      precedence: null
    });
  }
  function ee(i, s, h, g) {
    i.querySelector('link[rel="preload"][as="style"][' + s + "]") ? g.loading = 1 : (s = i.createElement("link"), g.preload = s, s.addEventListener("load", function() {
      return g.loading |= 1;
    }), s.addEventListener("error", function() {
      return g.loading |= 2;
    }), $a(s, "link", h), Rn(s), i.head.appendChild(s));
  }
  function se(i) {
    return '[src="' + Wa(i) + '"]';
  }
  function xe(i) {
    return "script[async]" + i;
  }
  function de(i, s, h) {
    if (s.count++, s.instance === null)
      switch (s.type) {
        case "style":
          var g = i.querySelector(
            'style[data-href~="' + Wa(h.href) + '"]'
          );
          if (g)
            return s.instance = g, Rn(g), g;
          var A = ae({}, h, {
            "data-href": h.href,
            "data-precedence": h.precedence,
            href: null,
            precedence: null
          });
          return g = (i.ownerDocument || i).createElement(
            "style"
          ), Rn(g), $a(g, "style", A), ge(g, h.precedence, i), s.instance = g;
        case "stylesheet":
          A = G(h.href);
          var I = i.querySelector(
            Z(A)
          );
          if (I)
            return s.state.loading |= 4, s.instance = I, Rn(I), I;
          g = X(h), (A = Gr.get(A)) && Ie(g, A), I = (i.ownerDocument || i).createElement("link"), Rn(I);
          var F = I;
          return F._p = new Promise(function(W, _e) {
            F.onload = W, F.onerror = _e;
          }), $a(I, "link", g), s.state.loading |= 4, ge(I, h.precedence, i), s.instance = I;
        case "script":
          return I = se(h.src), (A = i.querySelector(
            xe(I)
          )) ? (s.instance = A, Rn(A), A) : (g = h, (A = Gr.get(I)) && (g = ae({}, h), Fe(g, A)), i = i.ownerDocument || i, A = i.createElement("script"), Rn(A), $a(A, "link", g), i.head.appendChild(A), s.instance = A);
        case "void":
          return null;
        default:
          throw Error(b(443, s.type));
      }
    else
      s.type === "stylesheet" && (s.state.loading & 4) === 0 && (g = s.instance, s.state.loading |= 4, ge(g, h.precedence, i));
    return s.instance;
  }
  function ge(i, s, h) {
    for (var g = h.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), A = g.length ? g[g.length - 1] : null, I = A, F = 0; F < g.length; F++) {
      var W = g[F];
      if (W.dataset.precedence === s) I = W;
      else if (I !== A) break;
    }
    I ? I.parentNode.insertBefore(i, I.nextSibling) : (s = h.nodeType === 9 ? h.head : h, s.insertBefore(i, s.firstChild));
  }
  function Ie(i, s) {
    i.crossOrigin == null && (i.crossOrigin = s.crossOrigin), i.referrerPolicy == null && (i.referrerPolicy = s.referrerPolicy), i.title == null && (i.title = s.title);
  }
  function Fe(i, s) {
    i.crossOrigin == null && (i.crossOrigin = s.crossOrigin), i.referrerPolicy == null && (i.referrerPolicy = s.referrerPolicy), i.integrity == null && (i.integrity = s.integrity);
  }
  var Je = null;
  function gt(i, s, h) {
    if (Je === null) {
      var g = /* @__PURE__ */ new Map(), A = Je = /* @__PURE__ */ new Map();
      A.set(h, g);
    } else
      A = Je, g = A.get(h), g || (g = /* @__PURE__ */ new Map(), A.set(h, g));
    if (g.has(i)) return g;
    for (g.set(i, null), h = h.getElementsByTagName(i), A = 0; A < h.length; A++) {
      var I = h[A];
      if (!(I[mo] || I[st] || i === "link" && I.getAttribute("rel") === "stylesheet") && I.namespaceURI !== "http://www.w3.org/2000/svg") {
        var F = I.getAttribute(s) || "";
        F = i + F;
        var W = g.get(F);
        W ? W.push(I) : g.set(F, [I]);
      }
    }
    return g;
  }
  function ut(i, s, h) {
    i = i.ownerDocument || i, i.head.insertBefore(
      h,
      s === "title" ? i.querySelector("head > title") : null
    );
  }
  function yt(i, s, h) {
    if (h === 1 || s.itemProp != null) return !1;
    switch (i) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof s.precedence != "string" || typeof s.href != "string" || s.href === "")
          break;
        return !0;
      case "link":
        if (typeof s.rel != "string" || typeof s.href != "string" || s.href === "" || s.onLoad || s.onError)
          break;
        switch (s.rel) {
          case "stylesheet":
            return i = s.disabled, typeof s.precedence == "string" && i == null;
          default:
            return !0;
        }
      case "script":
        if (s.async && typeof s.async != "function" && typeof s.async != "symbol" && !s.onLoad && !s.onError && s.src && typeof s.src == "string")
          return !0;
    }
    return !1;
  }
  function kt(i) {
    return !(i.type === "stylesheet" && (i.state.loading & 3) === 0);
  }
  function mt(i, s, h, g) {
    if (h.type === "stylesheet" && (typeof g.media != "string" || matchMedia(g.media).matches !== !1) && (h.state.loading & 4) === 0) {
      if (h.instance === null) {
        var A = G(g.href), I = s.querySelector(
          Z(A)
        );
        if (I) {
          s = I._p, s !== null && typeof s == "object" && typeof s.then == "function" && (i.count++, i = Bt.bind(i), s.then(i, i)), h.state.loading |= 4, h.instance = I, Rn(I);
          return;
        }
        I = s.ownerDocument || s, g = X(g), (A = Gr.get(A)) && Ie(g, A), I = I.createElement("link"), Rn(I);
        var F = I;
        F._p = new Promise(function(W, _e) {
          F.onload = W, F.onerror = _e;
        }), $a(I, "link", g), h.instance = I;
      }
      i.stylesheets === null && (i.stylesheets = /* @__PURE__ */ new Map()), i.stylesheets.set(h, s), (s = h.state.preload) && (h.state.loading & 3) === 0 && (i.count++, h = Bt.bind(i), s.addEventListener("load", h), s.addEventListener("error", h));
    }
  }
  var pt = 0;
  function Xe(i, s) {
    return i.stylesheets && i.count === 0 && Rt(i, i.stylesheets), 0 < i.count || 0 < i.imgCount ? function(h) {
      var g = setTimeout(function() {
        if (i.stylesheets && Rt(i, i.stylesheets), i.unsuspend) {
          var I = i.unsuspend;
          i.unsuspend = null, I();
        }
      }, 6e4 + s);
      0 < i.imgBytes && pt === 0 && (pt = 62500 * vg());
      var A = setTimeout(
        function() {
          if (i.waitingForImages = !1, i.count === 0 && (i.stylesheets && Rt(i, i.stylesheets), i.unsuspend)) {
            var I = i.unsuspend;
            i.unsuspend = null, I();
          }
        },
        (i.imgBytes > pt ? 50 : 800) + s
      );
      return i.unsuspend = h, function() {
        i.unsuspend = null, clearTimeout(g), clearTimeout(A);
      };
    } : null;
  }
  function Bt() {
    if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
      if (this.stylesheets) Rt(this, this.stylesheets);
      else if (this.unsuspend) {
        var i = this.unsuspend;
        this.unsuspend = null, i();
      }
    }
  }
  var $t = null;
  function Rt(i, s) {
    i.stylesheets = null, i.unsuspend !== null && (i.count++, $t = /* @__PURE__ */ new Map(), s.forEach(Ct, i), $t = null, Bt.call(i));
  }
  function Ct(i, s) {
    if (!(s.state.loading & 4)) {
      var h = $t.get(i);
      if (h) var g = h.get(null);
      else {
        h = /* @__PURE__ */ new Map(), $t.set(i, h);
        for (var A = i.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), I = 0; I < A.length; I++) {
          var F = A[I];
          (F.nodeName === "LINK" || F.getAttribute("media") !== "not all") && (h.set(F.dataset.precedence, F), g = F);
        }
        g && h.set(null, g);
      }
      A = s.instance, F = A.getAttribute("data-precedence"), I = h.get(F) || g, I === g && h.set(null, A), h.set(F, A), this.count++, g = Bt.bind(this), A.addEventListener("load", g), A.addEventListener("error", g), I ? I.parentNode.insertBefore(A, I.nextSibling) : (i = i.nodeType === 9 ? i.head : i, i.insertBefore(A, i.firstChild)), s.state.loading |= 4;
    }
  }
  var li = {
    $$typeof: nt,
    Provider: null,
    Consumer: null,
    _currentValue: Gt,
    _currentValue2: Gt,
    _threadCount: 0
  };
  function Mn(i, s, h, g, A, I, F, W, _e) {
    this.tag = 1, this.containerInfo = i, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Pn(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Pn(0), this.hiddenUpdates = Pn(null), this.identifierPrefix = g, this.onUncaughtError = A, this.onCaughtError = I, this.onRecoverableError = F, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = _e, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function Gn(i, s, h, g, A, I, F, W, _e, Be, Ze, Ke) {
    return i = new Mn(
      i,
      s,
      h,
      F,
      _e,
      Be,
      Ze,
      Ke,
      W
    ), s = 1, I === !0 && (s |= 24), I = er(3, null, null, s), i.current = I, I.stateNode = i, s = vr(), s.refCount++, i.pooledCache = s, s.refCount++, I.memoizedState = {
      element: g,
      isDehydrated: h,
      cache: s
    }, Lo(I), i;
  }
  function wa(i) {
    return i ? (i = _s, i) : _s;
  }
  function Zr(i, s, h, g, A, I) {
    A = wa(A), g.context === null ? g.context = A : g.pendingContext = A, g = Ws(s), g.payload = { element: h }, I = I === void 0 ? null : I, I !== null && (g.callback = I), h = zs(i, g, s), h !== null && (ur(h, i, s), wl(h, i, s));
  }
  function cr(i, s) {
    if (i = i.memoizedState, i !== null && i.dehydrated !== null) {
      var h = i.retryLane;
      i.retryLane = h !== 0 && h < s ? h : s;
    }
  }
  function na(i, s) {
    cr(i, s), (i = i.alternate) && cr(i, s);
  }
  function hn(i) {
    if (i.tag === 13 || i.tag === 31) {
      var s = Ao(i, 67108864);
      s !== null && ur(s, i, 67108864), na(i, 67108864);
    }
  }
  function aa(i) {
    if (i.tag === 13 || i.tag === 31) {
      var s = is();
      s = ot(s);
      var h = Ao(i, s);
      h !== null && ur(h, i, s), na(i, s);
    }
  }
  var Zn = !0;
  function Sa(i, s, h, g) {
    var A = He.T;
    He.T = null;
    var I = vt.p;
    try {
      vt.p = 2, zr(i, s, h, g);
    } finally {
      vt.p = I, He.T = A;
    }
  }
  function hr(i, s, h, g) {
    var A = He.T;
    He.T = null;
    var I = vt.p;
    try {
      vt.p = 8, zr(i, s, h, g);
    } finally {
      vt.p = I, He.T = A;
    }
  }
  function zr(i, s, h, g) {
    if (Zn) {
      var A = $n(g);
      if (A === null)
        zp(
          i,
          s,
          g,
          Da,
          h
        ), Su(i, g);
      else if (yh(
        A,
        i,
        s,
        h,
        g
      ))
        g.stopPropagation();
      else if (Su(i, g), s & 4 && -1 < gh.indexOf(i)) {
        for (; A !== null; ) {
          var I = Ba(A);
          if (I !== null)
            switch (I.tag) {
              case 3:
                if (I = I.stateNode, I.current.memoizedState.isDehydrated) {
                  var F = qt(I.pendingLanes);
                  if (F !== 0) {
                    var W = I;
                    for (W.pendingLanes |= 2, W.entangledLanes |= 2; F; ) {
                      var _e = 1 << 31 - Ee(F);
                      W.entanglements[1] |= _e, F &= ~_e;
                    }
                    Zo(I), (ji & 6) === 0 && (ud = Yn() + 500, dh(0));
                  }
                }
                break;
              case 31:
              case 13:
                W = Ao(I, 2), W !== null && ur(W, I, 2), Sc(), na(I, 2);
            }
          if (I = $n(g), I === null && zp(
            i,
            s,
            g,
            Da,
            h
          ), I === A) break;
          A = I;
        }
        A !== null && g.stopPropagation();
      } else
        zp(
          i,
          s,
          g,
          null,
          h
        );
    }
  }
  function $n(i) {
    return i = ga(i), Fn(i);
  }
  var Da = null;
  function Fn(i) {
    if (Da = null, i = Fs(i), i !== null) {
      var s = z(i);
      if (s === null) i = null;
      else {
        var h = s.tag;
        if (h === 13) {
          if (i = S(s), i !== null) return i;
          i = null;
        } else if (h === 31) {
          if (i = u(s), i !== null) return i;
          i = null;
        } else if (h === 3) {
          if (s.stateNode.current.memoizedState.isDehydrated)
            return s.tag === 3 ? s.stateNode.containerInfo : null;
          i = null;
        } else s !== i && (i = null);
      }
    }
    return Da = i, null;
  }
  function ra(i) {
    switch (i) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (po()) {
          case Bs:
            return 2;
          case Ns:
            return 8;
          case js:
          case be:
            return 32;
          case H:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var Hn = !1, nn = null, Ri = null, La = null, Xo = /* @__PURE__ */ new Map(), Pr = /* @__PURE__ */ new Map(), wu = [], gh = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function Su(i, s) {
    switch (i) {
      case "focusin":
      case "focusout":
        nn = null;
        break;
      case "dragenter":
      case "dragleave":
        Ri = null;
        break;
      case "mouseover":
      case "mouseout":
        La = null;
        break;
      case "pointerover":
      case "pointerout":
        Xo.delete(s.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pr.delete(s.pointerId);
    }
  }
  function Yo(i, s, h, g, A, I) {
    return i === null || i.nativeEvent !== I ? (i = {
      blockedOn: s,
      domEventName: h,
      eventSystemFlags: g,
      nativeEvent: I,
      targetContainers: [A]
    }, s !== null && (s = Ba(s), s !== null && hn(s)), i) : (i.eventSystemFlags |= g, s = i.targetContainers, A !== null && s.indexOf(A) === -1 && s.push(A), i);
  }
  function yh(i, s, h, g, A) {
    switch (s) {
      case "focusin":
        return nn = Yo(
          nn,
          i,
          s,
          h,
          g,
          A
        ), !0;
      case "dragenter":
        return Ri = Yo(
          Ri,
          i,
          s,
          h,
          g,
          A
        ), !0;
      case "mouseover":
        return La = Yo(
          La,
          i,
          s,
          h,
          g,
          A
        ), !0;
      case "pointerover":
        var I = A.pointerId;
        return Xo.set(
          I,
          Yo(
            Xo.get(I) || null,
            i,
            s,
            h,
            g,
            A
          )
        ), !0;
      case "gotpointercapture":
        return I = A.pointerId, Pr.set(
          I,
          Yo(
            Pr.get(I) || null,
            i,
            s,
            h,
            g,
            A
          )
        ), !0;
    }
    return !1;
  }
  function zc(i) {
    var s = Fs(i.target);
    if (s !== null) {
      var h = z(s);
      if (h !== null) {
        if (s = h.tag, s === 13) {
          if (s = S(h), s !== null) {
            i.blockedOn = s, Us(i.priority, function() {
              aa(h);
            });
            return;
          }
        } else if (s === 31) {
          if (s = u(h), s !== null) {
            i.blockedOn = s, Us(i.priority, function() {
              aa(h);
            });
            return;
          }
        } else if (s === 3 && h.stateNode.current.memoizedState.isDehydrated) {
          i.blockedOn = h.tag === 3 ? h.stateNode.containerInfo : null;
          return;
        }
      }
    }
    i.blockedOn = null;
  }
  function wd(i) {
    if (i.blockedOn !== null) return !1;
    for (var s = i.targetContainers; 0 < s.length; ) {
      var h = $n(i.nativeEvent);
      if (h === null) {
        h = i.nativeEvent;
        var g = new h.constructor(
          h.type,
          h
        );
        ql = g, h.target.dispatchEvent(g), ql = null;
      } else
        return s = Ba(h), s !== null && hn(s), i.blockedOn = h, !1;
      s.shift();
    }
    return !0;
  }
  function om(i, s, h) {
    wd(i) && h.delete(s);
  }
  function Tg() {
    Hn = !1, nn !== null && wd(nn) && (nn = null), Ri !== null && wd(Ri) && (Ri = null), La !== null && wd(La) && (La = null), Xo.forEach(om), Pr.forEach(om);
  }
  function Sd(i, s) {
    i.blockedOn === s && (i.blockedOn = null, Hn || (Hn = !0, d.unstable_scheduleCallback(
      d.unstable_NormalPriority,
      Tg
    )));
  }
  var _h = null;
  function Up(i) {
    _h !== i && (_h = i, d.unstable_scheduleCallback(
      d.unstable_NormalPriority,
      function() {
        _h === i && (_h = null);
        for (var s = 0; s < i.length; s += 3) {
          var h = i[s], g = i[s + 1], A = i[s + 2];
          if (typeof g != "function") {
            if (Fn(g || h) === null)
              continue;
            break;
          }
          var I = Ba(h);
          I !== null && (i.splice(s, 3), s -= 3, Uo(
            I,
            {
              pending: !0,
              data: A,
              method: h.method,
              action: g
            },
            g,
            A
          ));
        }
      }
    ));
  }
  function $r(i) {
    function s(_e) {
      return Sd(_e, i);
    }
    nn !== null && Sd(nn, i), Ri !== null && Sd(Ri, i), La !== null && Sd(La, i), Xo.forEach(s), Pr.forEach(s);
    for (var h = 0; h < wu.length; h++) {
      var g = wu[h];
      g.blockedOn === i && (g.blockedOn = null);
    }
    for (; 0 < wu.length && (h = wu[0], h.blockedOn === null); )
      zc(h), h.blockedOn === null && wu.shift();
    if (h = (i.ownerDocument || i).$$reactFormReplay, h != null)
      for (g = 0; g < h.length; g += 3) {
        var A = h[g], I = h[g + 1], F = A[Zt] || null;
        if (typeof I == "function")
          F || Up(h);
        else if (F) {
          var W = null;
          if (I && I.hasAttribute("formAction")) {
            if (A = I, F = I[Zt] || null)
              W = F.formAction;
            else if (Fn(A) !== null) continue;
          } else W = F.action;
          typeof W == "function" ? h[g + 1] = W : (h.splice(g, 3), g -= 3), Up(h);
        }
      }
  }
  function lm() {
    function i(I) {
      I.canIntercept && I.info === "react-transition" && I.intercept({
        handler: function() {
          return new Promise(function(F) {
            return A = F;
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
    function s() {
      A !== null && (A(), A = null), g || setTimeout(h, 20);
    }
    function h() {
      if (!g && !navigation.transition) {
        var I = navigation.currentEntry;
        I && I.url != null && navigation.navigate(I.url, {
          state: I.getState(),
          info: "react-transition",
          history: "replace"
        });
      }
    }
    if (typeof navigation == "object") {
      var g = !1, A = null;
      return navigation.addEventListener("navigate", i), navigation.addEventListener("navigatesuccess", s), navigation.addEventListener("navigateerror", s), setTimeout(h, 100), function() {
        g = !0, navigation.removeEventListener("navigate", i), navigation.removeEventListener("navigatesuccess", s), navigation.removeEventListener("navigateerror", s), A !== null && (A(), A = null);
      };
    }
  }
  function Fp(i) {
    this._internalRoot = i;
  }
  Vp.prototype.render = Fp.prototype.render = function(i) {
    var s = this._internalRoot;
    if (s === null) throw Error(b(409));
    var h = s.current, g = is();
    Zr(h, g, i, s, null, null);
  }, Vp.prototype.unmount = Fp.prototype.unmount = function() {
    var i = this._internalRoot;
    if (i !== null) {
      this._internalRoot = null;
      var s = i.containerInfo;
      Zr(i.current, 2, null, i, null, null), Sc(), s[Jt] = null;
    }
  };
  function Vp(i) {
    this._internalRoot = i;
  }
  Vp.prototype.unstable_scheduleHydration = function(i) {
    if (i) {
      var s = dn();
      i = { blockedOn: null, target: i, priority: s };
      for (var h = 0; h < wu.length && s !== 0 && s < wu[h].priority; h++) ;
      wu.splice(h, 0, i), h === 0 && zc(i);
    }
  };
  var Mg = o.version;
  if (Mg !== "19.2.0")
    throw Error(
      b(
        527,
        Mg,
        "19.2.0"
      )
    );
  vt.findDOMNode = function(i) {
    var s = i._reactInternals;
    if (s === void 0)
      throw typeof i.render == "function" ? Error(b(188)) : (i = Object.keys(i).join(","), Error(b(268, i)));
    return i = U(s), i = i !== null ? K(i) : null, i = i === null ? null : i.stateNode, i;
  };
  var Iy = {
    bundleType: 0,
    version: "19.2.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: He,
    reconcilerVersion: "19.2.0"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var qp = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!qp.isDisabled && qp.supportsFiber)
      try {
        le = qp.inject(
          Iy
        ), me = qp;
      } catch {
      }
  }
  return cm.createRoot = function(i, s) {
    if (!M(i)) throw Error(b(299));
    var h = !1, g = "", A = mf, I = hc, F = jm;
    return s != null && (s.unstable_strictMode === !0 && (h = !0), s.identifierPrefix !== void 0 && (g = s.identifierPrefix), s.onUncaughtError !== void 0 && (A = s.onUncaughtError), s.onCaughtError !== void 0 && (I = s.onCaughtError), s.onRecoverableError !== void 0 && (F = s.onRecoverableError)), s = Gn(
      i,
      1,
      !1,
      null,
      null,
      h,
      g,
      null,
      A,
      I,
      F,
      lm
    ), i[Jt] = s.current, Mc(i), new Fp(s);
  }, cm.hydrateRoot = function(i, s, h) {
    if (!M(i)) throw Error(b(299));
    var g = !1, A = "", I = mf, F = hc, W = jm, _e = null;
    return h != null && (h.unstable_strictMode === !0 && (g = !0), h.identifierPrefix !== void 0 && (A = h.identifierPrefix), h.onUncaughtError !== void 0 && (I = h.onUncaughtError), h.onCaughtError !== void 0 && (F = h.onCaughtError), h.onRecoverableError !== void 0 && (W = h.onRecoverableError), h.formState !== void 0 && (_e = h.formState)), s = Gn(
      i,
      1,
      !0,
      s,
      h ?? null,
      g,
      A,
      _e,
      I,
      F,
      W,
      lm
    ), s.context = wa(null), h = s.current, g = is(), g = ot(g), A = Ws(g), A.callback = null, zs(h, A, g), h = g, s.current.lanes = h, xn(s, h), Zo(s), i[Jt] = s.current, Mc(i), new Vp(s);
  }, cm.version = "19.2.0", cm;
}
var m0;
function u1() {
  if (m0) return Dy.exports;
  m0 = 1;
  function d() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(d);
      } catch (o) {
        console.error(o);
      }
  }
  return d(), Dy.exports = l1(), Dy.exports;
}
var c1 = u1();
const Iv = /* @__PURE__ */ iy(c1), R_ = Eu.createContext(), h1 = (d) => {
  const [o, m] = ei.useState([]), [b, M] = ei.useState(null), [z, S] = ei.useState([]), [u, O] = ei.useState([]), [U, K] = ei.useState({}), [ae, he] = ei.useState(!0), [J, ke] = ei.useState(!0), [qe, ft] = ei.useState(!0);
  ei.useEffect(() => {
    (async () => {
      he(!0);
      try {
        const nt = await fetch("https://listen.eternityready.com/api/station", {
          method: "GET"
        });
        if (!nt.ok)
          throw new Error(`HTTP error! status: ${nt.status}`);
        let Re = await nt.json();
        Re.forEach(($e) => {
          $e.url = $e.url.replace("https://", "https://listen.eternityready.com/stream-proxy/");
        }), console.log("Stations loaded", Re), m(Re), he(!1);
      } catch (nt) {
        console.error("Failed to fetch stations", nt), he(!1);
      }
    })();
  }, []);
  const ht = (it) => {
    it.stationId !== b?.id || !it.metaDataFound || z.some((nt) => nt.trackId == it.trackId) || S((nt) => {
      let De = [it, ...nt];
      return De.length > 5 && De.pop(), De;
    });
  };
  return ei.useEffect(() => {
    if (o.length === 0) return;
    let it = null, nt = o.find((De) => De.isDefault);
    nt || (nt = o[0]), it = nt, M(it);
  }, [o]), ei.useEffect(() => {
    b && b.id && (async (nt) => {
      ke(!0);
      try {
        const De = await fetch(`https://listen.eternityready.com/api/station/${nt}/tracks`), Re = await De.json();
        if (!De.ok)
          throw new Error(Re.error || "Failed to fetch tracks");
        console.log("Last played loaded", Re), Re && Re.tracks.length > 0 && (S(Re.tracks), ke(!1)), Re && Re.currentPlaying && K(Re.currentPlaying);
      } catch (De) {
        console.error("Error fetching tracks:", De), ke(!1);
      }
    })(b.id);
  }, [b]), ei.useEffect(() => {
    let it = null;
    if (b && b.id) {
      const nt = async (De) => {
        if (De === b.id) {
          it && clearTimeout(it);
          try {
            const $e = await fetch(
              `https://listen.eternityready.com/api/station/${De}/schedule/upnext`
            ), rt = await $e.json();
            if (!$e.ok)
              throw new Error(rt.error || "Failed to fetch tracks");
            console.log("Upcoming tracks loaded", De, rt), O(rt);
            let wt = (/* @__PURE__ */ new Date(
              rt[0].dateScheduled.replace(" ", "T") + "Z"
            )).toLocaleString(), Ht = (/* @__PURE__ */ new Date()).toLocaleString(), Dt = new Date(wt) - new Date(Ht);
            it = setTimeout(() => {
              nt(b.id);
            }, Dt), ft(!1), it = setTimeout(() => {
              nt(b.id);
            }, 3e5);
          } catch (Re) {
            console.error("Error fetching tracks:", Re), ft(!1);
          }
        }
      };
      nt(b.id);
    }
    return () => {
      clearTimeout(it);
    };
  }, [b]), /* @__PURE__ */ Se.jsx(
    R_.Provider,
    {
      value: {
        station: b,
        setStation: M,
        stationsList: o,
        tracks: z,
        currentPlaying: U,
        addTrack: ht,
        loadingStations: ae,
        loadingTracks: J,
        upcomingTracks: u,
        loadingUpcomingTracks: qe
      },
      children: d.children
    }
  );
};
class d1 {
  constructor() {
    this._totalBytesRead = 0, this._streamBytesRead = 0, this._metadataLengthBytesRead = 0, this._metadataBytesRead = 0, this._currentBytesRemaining = 0, this._currentStreamBytesRemaining = 0, this._currentMetadataBytesRemaining = 0;
  }
  get stats() {
    return {
      totalBytesRead: this._totalBytesRead,
      streamBytesRead: this._streamBytesRead,
      metadataLengthBytesRead: this._metadataLengthBytesRead,
      metadataBytesRead: this._metadataBytesRead,
      currentBytesRemaining: this._currentBytesRemaining,
      currentStreamBytesRemaining: this._currentStreamBytesRemaining,
      currentMetadataBytesRemaining: this._currentMetadataBytesRemaining
    };
  }
  set currentStreamBytesRemaining(o) {
    this._currentStreamBytesRemaining += o;
  }
  set currentMetadataBytesRemaining(o) {
    this._currentMetadataBytesRemaining = o;
  }
  addBytes(o) {
    this._totalBytesRead += o, this._currentBytesRemaining -= o;
  }
  addStreamBytes(o) {
    this._streamBytesRead += o, this._currentStreamBytesRemaining -= o;
  }
  addMetadataLengthBytes(o) {
    this._metadataLengthBytesRead += o;
  }
  addMetadataBytes(o) {
    this._metadataBytesRead += o, this._currentMetadataBytesRemaining -= o;
  }
  addCurrentBytesRemaining(o) {
    this._currentBytesRemaining += o;
  }
}
const Ag = () => {
};
class jd {
  constructor(o) {
    this._remainingData = 0, this._currentPosition = 0, this._buffer = new Uint8Array(0), this._streamBuffer = [], this._streamBufferLength = 0, this._stats = new d1(), this._onStream = o.onStream || Ag, this._onMetadata = o.onMetadata || Ag, this._onMetadataFailed = o.onMetadataFailed || Ag, this._onError = o.onError || Ag, this._enableLogging = o.enableLogging || !1, this._onStreamPromise = Promise.resolve(), this._onMetadataPromise = Promise.resolve(), this._generator = this._passThroughParser(), this._generator.next();
  }
  *_passThroughParser() {
    for (this._remainingData = 1 / 0; ; )
      this._addStream(yield* this._getNextValue()), yield* this._sendStream();
  }
  static _concatBuffers(...o) {
    const m = o.reduce((b, M) => b + M.length, 0);
    return this._concatBuffersKnownLength(o, m);
  }
  static _concatBuffersKnownLength(o, m) {
    const b = new Uint8Array(m);
    return o.reduce((M, z) => (b.set(z, M), M + z.length), 0), b;
  }
  *iterator(o) {
    for (let m = this._generator.next(o); m.value; m = this._generator.next())
      yield m.value;
  }
  readAll(o) {
    for (let m = this._generator.next(o); m.value; m = this._generator.next())
      ;
  }
  async *asyncIterator(o) {
    for (let m = this._generator.next(o); m.value; m = this._generator.next())
      await this._onStreamPromise, await this._onMetadataPromise, yield m.value;
  }
  async asyncReadAll(o) {
    for (let m = this._generator.next(o); m.value; m = this._generator.next())
      await this._onStreamPromise, await this._onMetadataPromise;
  }
  _logError(...o) {
    this._enableLogging && console.warn(
      "icecast-metadata-js",
      o.reduce((m, b) => m + `
  ` + b, "")
    ), this._onError(...o);
  }
  _addStream(o) {
    this._streamBuffer.push(o), this._streamBufferLength += o.length;
  }
  *_sendStream() {
    if (this._streamBuffer.length) {
      const o = jd._concatBuffersKnownLength(
        this._streamBuffer,
        this._streamBufferLength
      );
      this._streamBuffer = [], this._streamBufferLength = 0, this._stats.addStreamBytes(o.length);
      const m = { stream: o, stats: this._stats.stats };
      this._onStreamPromise = this._onStream(m), yield m;
    }
  }
  *_sendMetadata(o) {
    yield* this._sendStream();
    const m = {
      metadata: o,
      stats: this._stats.stats
    };
    this._onMetadataPromise = this._onMetadata(m), yield m;
  }
  *_getNextValue(o = 0) {
    for (this._currentPosition === this._buffer.length && (this._buffer = yield* this._readData(), this._currentPosition = 0); this._buffer.length - this._currentPosition < o; )
      this._buffer = jd._concatBuffers(
        this._buffer,
        yield* this._readData()
      );
    const m = this._buffer.subarray(
      this._currentPosition,
      (o || this._remainingData) + this._currentPosition
    );
    return this._stats.addBytes(m.length), this._remainingData = m.length < this._remainingData ? this._remainingData - m.length : 0, this._currentPosition += m.length, m;
  }
  *_readData() {
    yield* this._sendStream();
    let o;
    do
      o = yield;
    while (!o || o.length === 0);
    return this._stats.addCurrentBytesRemaining(o.length), o;
  }
}
class wm extends jd {
  constructor({
    icyMetaInt: o,
    icyDetectionTimeout: m = 2e3,
    icyCharacterEncoding: b = "utf-8",
    ...M
  }) {
    super(M), this._decoder = new globalThis.TextDecoder(b), this._icyMetaInt = o, this._icyDetectionTimeout = m, this._generator = this._icyParser(), this._generator.next();
  }
  *_icyParser() {
    if (yield* this._hasIcyMetadata())
      do
        this._remainingData = this._icyMetaInt, yield* this._getStream(), yield* this._getMetadataLength(), this._remainingData && (yield* this._getMetadata());
      while (!0);
    this._remainingData = 1 / 0, yield* this._getStream();
  }
  static parseIcyMetadata(o) {
    const m = /(?<key>[^\0]+?)='(?<val>[^\0]*?)(;$|';|'$|$)/, b = {};
    for (const M of o.match(
      new RegExp(m, "g")
    ) || []) {
      const z = M.match(m);
      z && (b[z.groups.key] = z.groups.val);
    }
    return b;
  }
  get icyMetaInt() {
    return this._icyMetaInt;
  }
  *_hasIcyMetadata() {
    if (this._icyMetaInt > 0) return !0;
    if (!this._icyDetectionTimeout) return !1;
    this._logError(
      "Passed in Icy-MetaInt is invalid. Attempting to detect ICY Metadata.",
      "See https://github.com/eshaz/icecast-metadata-js for information on how to properly request ICY Metadata."
    );
    const o = [null, 83, 116, 114, 101, 97, 109, 84, 105, 116, 108, 101, 61], m = Date.now();
    let b = 0;
    for (; m + this._icyDetectionTimeout > Date.now(); ) {
      this._buffer = jd._concatBuffers(
        this._buffer,
        yield* this._readData()
      );
      e: for (; b < this._buffer.length - o.length; ) {
        for (let M = 1; M < o.length; M++)
          if (this._buffer[M + b] !== o[M]) {
            b++;
            continue e;
          }
        return this._logError(`Found ICY Metadata! Setting Icy-MetaInt to ${b}.`), this._icyMetaInt = b, !0;
      }
    }
    return this._logError(
      "ICY Metadata not detected, but continuing anyway. Audio errors will occur if there is ICY metadata.",
      `Searched ${this._buffer.length} bytes for ${(Date.now() - m) / 1e3} seconds.`,
      "Try increasing the `icyDetectionTimeout` value if ICY metadata is present in the stream."
    ), this._onMetadataFailed("icy"), !1;
  }
  *_getStream() {
    for (this._stats.currentStreamBytesRemaining = this._remainingData; this._remainingData; )
      this._addStream(yield* super._getNextValue());
  }
  *_getMetadataLength() {
    this._remainingData = 1;
    do
      this._remainingData = (yield* this._getNextValue())[0] * 16;
    while (this._remainingData === 1);
    this._stats.addMetadataLengthBytes(1);
  }
  *_getMetadata() {
    this._stats.currentMetadataBytesRemaining = this._remainingData;
    const o = yield* this._getNextValue(this._remainingData);
    this._stats.addMetadataBytes(o.length), yield* this._sendMetadata(
      wm.parseIcyMetadata(this._decoder.decode(o))
    );
  }
}
class kv extends jd {
  constructor(o) {
    super(o), this._decoder = new globalThis.TextDecoder("utf-8"), this._generator = this._oggParser(), this._generator.next(), this._isContinuePacket = !1;
  }
  *_oggParser() {
    if (yield* this._hasOggPage()) {
      const o = yield* this._identifyCodec();
      if (o)
        for (; yield* this._hasOggPage(); )
          this._isContinuePacket || (yield* this._getMetadata(o)), yield* this._getStream();
    }
    this._remainingData = 1 / 0, yield* this._getStream();
  }
  _getUint32(o, m = 0) {
    return new DataView(
      Uint8Array.from([...o.subarray(m, m + 4)]).buffer
    ).getUint32(0, !0);
  }
  _matchBytes(o, m) {
    return String.fromCharCode(...m).match(o);
  }
  *_hasOggPage() {
    let o = [];
    for (; o.length <= 65307; ) {
      const M = yield* super._getNextValue(6);
      if (M[0] === 79 && M[1] === 103 && M[2] === 103 && M[3] === 83 && !(M[5] & 248)) {
        this._isContinuePacket = M[5] & 1, this._currentPosition -= 6, this._remainingData += 6, this._stats._totalBytesRead -= 6, this._stats._currentBytesRemaining += 6;
        break;
      }
      o.push(M[0]), this._currentPosition -= 5, this._stats._totalBytesRead -= 5, this._stats._currentBytesRemaining += 5;
    }
    if (o.length && this._addStream(Uint8Array.from(o)), o.length > 65307)
      return this._logError(
        "This stream is not an Ogg stream. No Ogg metadata will be returned.",
        "See https://github.com/eshaz/icecast-metadata-js for information on Ogg metadata."
      ), this._onMetadataFailed("ogg"), !1;
    const m = yield* this._getNextValue(27), b = yield* this._getNextValue(m[26]);
    return this._remainingData = b.reduce(
      (M, z) => M + z,
      0
    ), !0;
  }
  *_identifyCodec() {
    const o = yield* this._getNextValue(8);
    if (yield* this._getStream(), this._matchBytes(/\x7fFLAC/, o.subarray(0, 5)))
      return { regex: /^[\x84|\x04]/, length: 4 };
    if (this._matchBytes(/OpusHead/, o.subarray(0, 8)))
      return { regex: /OpusTags/, length: 8 };
    if (this._matchBytes(/\x01vorbis/, o.subarray(0, 7)))
      return { regex: /\x03vorbis/, length: 7 };
  }
  *_getMetadata({ regex: o, length: m }) {
    this._matchBytes(o, yield* this._getNextValue(m)) && (yield* this._sendMetadata(yield* this._readVorbisComment()));
  }
  *_getStream() {
    for (; this._remainingData; )
      yield* this._getNextValue();
  }
  *_getNextValue(o) {
    const m = yield* super._getNextValue(o);
    return this._addStream(m), m;
  }
  *_readData() {
    const o = yield* super._readData();
    return this._stats.currentStreamBytesRemaining = o.length, o;
  }
  *_readVorbisComment() {
    const o = this._getUint32(yield* this._getNextValue(4));
    this._stats.addMetadataBytes(4);
    const m = this._decoder.decode(
      yield* this._getNextValue(o)
    );
    this._stats.addMetadataBytes(o);
    const b = this._getUint32(yield* this._getNextValue(4));
    this._stats.addMetadataBytes(4);
    const M = [];
    for (let z = 0; z < b; z++) {
      const S = yield* this._getNextValue(4);
      this._stats.addMetadataBytes(4), M.push(yield* this._getNextValue(this._getUint32(S))), this._stats.addMetadataBytes(M[M.length - 1].length);
    }
    return this._stats.currentMetadataBytesRemaining = 0, M.reduce(
      (z, S) => {
        const u = S.indexOf(61), O = String.fromCharCode(...S.subarray(0, u)).toUpperCase(), U = this._decoder.decode(S.subarray(u + 1));
        return z[O] = z[O] ? `${z[O]}; ${U}` : U, z;
      },
      { VENDOR_STRING: m }
    );
  }
}
class p1 {
  constructor(o) {
    const { onStream: m, ...b } = o;
    this._oggMetadataParser = new kv(o), this._icyMetadataParser = new wm(b);
  }
  get icyMetaInt() {
    return this._icyMetadataParser.icyMetaInt;
  }
  *iterator(o) {
    for (const m of this._icyMetadataParser.iterator(o))
      m.stream ? yield* this._oggMetadataParser.iterator(m.stream) : yield m;
  }
  readAll(o) {
    for (const m of this._icyMetadataParser.iterator(o))
      m.stream && this._oggMetadataParser.readAll(m.stream);
  }
  async *asyncIterator(o) {
    for await (const m of this._icyMetadataParser.asyncIterator(o))
      if (m.stream)
        for await (const b of this._oggMetadataParser.asyncIterator(
          m.stream
        ))
          yield b;
      else
        yield m;
  }
  async asyncReadAll(o) {
    for await (const m of this._icyMetadataParser.iterator(o))
      m.stream && await this._oggMetadataParser.asyncReadAll(m.stream);
  }
}
class f1 {
  /**
   * @description Splits Icecast raw response into stream bytes and metadata key / value pairs.
   * @param {number} IcecastMetadataReader.icyMetaInt Interval in bytes of metadata updates returned by the Icecast server
   * @param {number} IcecastMetadataReader.icyCharacterEncoding Character encoding to use for ICY metadata (defaults to "utf-8")
   * @param {number} IcecastMetadataReader.icyDetectionTimeout Duration in milliseconds to search for metadata if icyMetaInt isn't passed in
   * @param {Array} IcecastMetadataReader.metadataTypes Types of metadata to capture: "icy" and/or "ogg"
   *
   * @callback onMetadata
   * @param {object} value Object containing Metadata and Statistics
   * @param {object} metadata Object containing the metadata received.
   * @param {string} [metadata.StreamTitle] (ICY) Title of the metadata update.
   * @param {string} [metadata.StreamUrl] (ICY) Url (usually album art) of the metadata update.
   * @param {string} [metadata.TITLE] (Ogg) Url Title of the metadata update.
   * @param {object} stats Object containing statistics on how many bytes were read and the current read position.
   *
   * @callback onStream
   * @param {object} value Object containing Stream data and Statistics
   * @param {Uint8Array} stream Object containing the stream buffer.
   * @param {object} stats Object containing statistics on how many bytes were read and the current read position.
   *
   * @callback onMetadataFailed Called when metadata detection has failed and no metadata will be returned
   * @param {string} metadataType Metadata type that failed ("icy" or "ogg")
   *
   * @callback onError Called when an error is encountered
   * @param {string} message Error message
   */
  constructor({ metadataTypes: o = ["icy"], ...m } = {}) {
    const b = o.includes("icy"), M = o.includes("ogg");
    b && M ? this._metadataParser = new p1(m) : M ? this._metadataParser = new kv(m) : b ? this._metadataParser = new wm(m) : this._metadataParser = new jd(m);
  }
  /**
   * @description Parses an already decoded ICY metadata string into key value pairs.
   * @param {string} metadataString ICY formatted metadata string. (i.e. "StreamTitle='A Title';")
   * @returns {object} Parsed metadata key value pairs. (i.e. {StreamTitle: "A Title"})
   */
  static parseIcyMetadata(o) {
    return wm.parseIcyMetadata(o);
  }
  /**
   * @description Gets the ICY metadata interval for this instance.
   * @returns {number} ICY metadata interval in bytes.
   */
  get icyMetaInt() {
    return this._metadataParser.icyMetaInt;
  }
  /**
   * @description Returns an iterator that yields stream or metadata.
   * @param {Uint8Array} chunk Next chunk of data to read
   * @returns {Iterator} Iterator that operates over a raw icecast response.
   * @yields {object} Object containing stream or metadata.
   */
  *iterator(o) {
    yield* this._metadataParser.iterator(o);
  }
  /**
   * @description Reads all data in the passed in chunk and calls the onStream and onMetadata callbacks.
   * @param {Uint8Array} chunk Next chunk of data to read
   */
  readAll(o) {
    this._metadataParser.readAll(o);
  }
  /**
   * @description Returns an async iterator that yields stream or metadata and awaits the onStream and onMetadata callbacks.
   * @param {Uint8Array} chunk Next chunk of data to read
   * @returns {IterableIterator} Iterator that operates over a raw icecast response.
   * @yields {object} Object containing stream or metadata.
   */
  async *asyncIterator(o) {
    return yield* this._metadataParser.asyncIterator(o);
  }
  /**
   * @description Reads all data in the chunk and awaits the onStream and onMetadata callbacks.
   * @param {Uint8Array} chunk Next chunk of data to read
   */
  async asyncReadAll(o) {
    return this._metadataParser.asyncReadAll(o);
  }
}
const m1 = () => {
};
class qg {
  /**
   * @param {ReadableStream} response ReadableStream for raw Icecast response data
   * @param {object} options Configuration options for IcecastMetadataReader
   * @see IcecastMetadataReader for information on the options parameter
   */
  constructor(o, { onStream: m = m1, ...b }) {
    let M;
    this._readableStream = new ReadableStream({
      async start(z) {
        M = new f1({
          icyMetaInt: parseInt(o.headers.get("Icy-MetaInt")),
          ...b,
          onStream: async (S) => (z.enqueue(S.stream), m(S))
        });
        for await (const S of qg.asyncIterator(
          o.body
        ))
          await M.asyncReadAll(S);
        z.close();
      }
    }), this._icecast = M;
  }
  /**
   * @returns Icecast Metadata Interval if it is present on this stream
   */
  get icyMetaInt() {
    return this._icecast.icyMetaInt;
  }
  /**
   * @returns The ReadableStream instance
   */
  get readableStream() {
    return this._readableStream;
  }
  /**
   * @description Starts reading from the response and processing stream and metadata.
   */
  async startReading() {
    try {
      for await (const o of qg.asyncIterator(
        this._readableStream
      ))
        ;
    } catch (o) {
      if (o.name !== "AbortError") throw o;
    }
  }
  /**
   * @description Wraps a ReadableStream as an Async Iterator.
   * @param {ReadableStream} readableStream ReadableStream to convert to AsyncIterator
   * @returns {Symbol.asyncIterator} Async Iterator that wraps the ReadableStream
   */
  static asyncIterator(o) {
    const m = o.getReader();
    return {
      [Symbol.asyncIterator]: () => ({
        next: () => m.read()
      })
    };
  }
}
/**
 * @license
 * @see https://github.com/eshaz/icecast-metadata-js
 * @copyright 2021-2023 Ethan Halsall
 *  This file is part of icecast-metadata-stats.
 *
 *  icecast-metadata-stats free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  icecast-metadata-stats distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>
 */
const g0 = () => {
}, Eg = "stopped", g1 = "running", Ny = "fetching", ui = /* @__PURE__ */ new WeakMap(), jy = Symbol(), y1 = Symbol(), Uy = Symbol(), _1 = Symbol(), Fy = Symbol(), Vy = Symbol(), v1 = Symbol(), qy = Symbol(), Gy = Symbol(), x1 = Symbol(), Zy = Symbol(), y0 = Symbol(), b1 = Symbol(), $y = Symbol(), Hy = Symbol(), w1 = Symbol(), Xy = Symbol(), _0 = Symbol(), v0 = Symbol(), x0 = Symbol(), xh = Symbol(), b0 = Symbol(), Yy = Symbol(), w0 = Symbol(), Ko = Symbol(), S0 = Symbol(), Gp = Symbol(), Ky = Symbol(), Tu = (d) => {
  let o = parseInt(d);
  return isNaN(o) && (o = null), o;
};
class Gg {
  /**
   * @constructor
   * @param {URL} endpoint Stream endpoint
   * @param {object} [options] Options object
   *
   * @callback [options.onStats] Called when the automatic query completes
   * @callback [options.onStatsFetch] Called when the automatic query begins
   * @param {Array} [options.sources] List of sources to automatically query ["icy", "ogg", "icestats", "stats", "sevenhtml", "nextsongs"]
   * @param {number} [options.interval] Time in seconds to wait between automatically queries
   * @param {URL} [options.icestatsEndpoint] Endpoint for the `status-json.xsl` source
   * @param {URL} [options.statsEndpoint] Endpoint for the `stats` source
   * @param {URL} [options.nextsongsEndpoint] Endpoint for the `nextsongs` source
   * @param {URL} [options.sevenhtmlEndpoint] Endpoint for the `7.html` source
   * @param {number} [options.icyMetaInt] Manually sets the ICY metadata interval
   * @param {string} [options.icyCharacterEncoding] Character encoding to use for ICY metadata (defaults to "utf-8")
   * @param {number} [options.icyDetectionTimeout] Time in milliseconds to search for ICY metadata
   */
  constructor(o, m = {}) {
    const b = o.split("/").slice(0, -1).join("/");
    ui.set(this, {
      [Xy]: o,
      [Fy]: m.icestatsEndpoint || `${b}/status-json.xsl`,
      [qy]: m.statsEndpoint || `${b}/stats`,
      [Zy]: m.nextsongsEndpoint || `${b}/nextsongs`,
      [$y]: m.sevenhtmlEndpoint || `${b}/7.html`,
      [xh]: m.sources || [],
      [b0]: (m.interval || 30) * 1e3,
      [Yy]: m.onStats || g0,
      [w0]: m.onStatsFetch || g0,
      [_0]: m.icyMetaInt,
      [v0]: m.icyCharacterEncoding,
      [x0]: m.icyDetectionTimeout,
      [jy]: new AbortController(),
      [Uy]: new AbortController(),
      [Vy]: new AbortController(),
      [Gy]: new AbortController(),
      [y0]: new AbortController(),
      [Hy]: new AbortController(),
      [Ko]: Eg
    });
  }
  static xml2Json(o) {
    const m = (M) => new DOMParser().parseFromString(M, "application/xml"), b = (M) => {
      if (!M.children.length)
        return Number.isNaN(Number(M.innerHTML)) ? M.innerHTML : Number(M.innerHTML);
      const z = {};
      for (const S of M.children)
        S.nodeName in z ? Array.isArray(z[S.nodeName]) ? z[S.nodeName].push(b(S)) : z[S.nodeName] = [z[S.nodeName], b(S)] : z[S.nodeName] = b(S);
      return z;
    };
    return b(m(o));
  }
  /**
   * @returns The current state ["stopped", "running", "fetching"]
   */
  get state() {
    return ui.get(this)[Ko];
  }
  /**
   * @returns The generated `status-json.xsl` endpoint
   */
  get icestatsEndpoint() {
    return ui.get(this)[Fy];
  }
  /**
   * @returns The generated `stats` endpoint
   */
  get statsEndpoint() {
    return ui.get(this)[qy];
  }
  /**
   * @returns The generated `nextsongs` endpoint
   */
  get nextsongsEndpoint() {
    return ui.get(this)[Zy];
  }
  /**
   * @returns The generated `7.html` endpoint
   */
  get sevenhtmlEndpoint() {
    return ui.get(this)[$y];
  }
  /**
   * @description Starts automatically fetching stats
   */
  start() {
    ui.get(this)[Ko] === Eg && (ui.get(this)[Ko] = g1, this.fetch().then(ui.get(this)[Yy]), ui.get(this)[S0] = setInterval(() => {
      this.fetch().then(ui.get(this)[Yy]);
    }, ui.get(this)[b0]));
  }
  /**
   * @description Stops automatically fetching stats and cancels any inprogress stats
   */
  stop() {
    ui.get(this)[Ko] !== Eg && (ui.get(this)[Ko] = Eg, clearInterval(ui.get(this)[S0]), ui.get(this)[jy].abort(), ui.get(this)[Uy].abort(), ui.get(this)[Vy].abort(), ui.get(this)[Gy].abort(), ui.get(this)[Hy].abort());
  }
  /**
   * @description Manually fetches stats from the sources passed in to the `options.sources` parameter
   * @async
   * @returns {object} Object containing the stats from the sources
   */
  async fetch() {
    if (ui.get(this)[Ko] !== Ny) {
      const o = ui.get(this)[Ko];
      ui.get(this)[Ko] = Ny, ui.get(this)[w0](ui.get(this)[xh]);
      const m = [];
      ui.get(this)[xh].includes("icestats") && m.push(this.getIcestats()), ui.get(this)[xh].includes("sevenhtml") && m.push(this.getSevenhtml()), ui.get(this)[xh].includes("stats") && m.push(this.getStats()), ui.get(this)[xh].includes("nextsongs") && m.push(this.getNextsongs()), ui.get(this)[xh].includes("icy") && m.push(this.getIcyMetadata()), ui.get(this)[xh].includes("ogg") && m.push(this.getOggMetadata());
      const b = await Promise.all(m).then(
        (M) => M.reduce((z, S) => ({ ...z, ...S }), {})
      );
      return ui.get(this)[Ko] = ui.get(this)[Ko] !== Ny ? ui.get(this)[Ko] : o, b;
    }
  }
  /**
   * @description Fetches the data from the `/status-json.xsl` endpoint
   * @async
   * @returns {object} Object containing results of `/status-json.xsl`
   */
  async getIcestats() {
    return this[Gp]({
      status: v1,
      endpoint: Fy,
      controller: Vy,
      mapper: (o) => o.json()
    }).then((o) => ({ icestats: o && o.icestats }));
  }
  /*
  <HTML><meta http-equiv="Pragma" content="no-cache"></head><body>350,1,132,1000,41,128,Dj Mixes Sety</body></html>
  ,141,1000,50,128,Gra AutoPilot audycje Energy 2000</body></html>
  ,27,1000,8,128,Gra Wavelogic audycje Rave With The Wave</body></html>
  ,578,1000,233,128,youtube.com/RadioPartyOfficial</body></html>
  ,15,1000,5,64,youtube.com/RadioPartyOfficial</body></html>
  */
  // http://wiki.winamp.com/wiki/SHOUTcast_DNAS_Server_2_XML_Reponses#Equivalent_of_7.html
  // CURRENTLISTENERS STREAMSTATUS PEAKLISTENERS MAXLISTENERS UNIQUELISTENERS BITRATE SONGTITLE
  /**
   * @description Fetches the data from the `/7.html` endpoint
   * @async
   * @returns {object} Object containing results of `/7.html`
   */
  async getSevenhtml() {
    return this[Gp]({
      status: w1,
      endpoint: $y,
      controller: Hy,
      mapper: async (o) => (await o.text()).match(/(.*?)<\/body>/gi).map((m) => {
        const b = m.match(/(<body>|,)(?<stats>.*)<\/body>/i).groups.stats.split(",");
        return b.length === 7 ? {
          StreamTitle: b[6],
          currentListeners: Tu(b[4]),
          peakListeners: Tu(b[2]),
          maxListeners: Tu(b[3]),
          bitrate: Tu(b[5]),
          status: Tu(b[1]),
          serverListeners: Tu(b[0])
        } : {
          StreamTitle: b[4],
          currentListeners: Tu(b[2]),
          peakListeners: Tu(b[0]),
          maxListeners: Tu(b[1]),
          bitrate: Tu(b[3])
        };
      })
    }).then((o) => ({
      sevenhtml: o
    }));
  }
  // http://wiki.winamp.com/wiki/SHOUTcast_DNAS_Server_2_XML_Reponses#General_Server_Summary
  /**
   * @description Fetches the data from the `/stats` endpoint
   * @async
   * @returns {object} Object containing results of `/stats`
   */
  async getStats() {
    return this[Gp]({
      status: x1,
      endpoint: qy,
      controller: Gy,
      mapper: async (o) => Gg.xml2Json(await o.text()).SHOUTCASTSERVER.STREAMSTATS
    }).then((o) => ({
      stats: o
    }));
  }
  // http://wiki.winamp.com/wiki/SHOUTcast_DNAS_Server_2_XML_Reponses#Nextsongs
  /**
   * @description Fetches the data from the `/nextsongs` endpoint
   * @async
   * @returns {object} Object containing results of `/nextsongs`
   */
  async getNextsongs() {
    return this[Gp]({
      status: b1,
      endpoint: Zy,
      controller: y0,
      mapper: async (o) => Gg.xml2Json(await o.text()).SHOUTCASTSERVER.NEXTSONGS
    }).then((o) => ({
      nextsongs: o
    }));
  }
  /**
   * @description Fetches the first ICY metadata update from the stream
   * @async
   * @returns {object} Object containing ICY metadata
   */
  async getIcyMetadata() {
    return this[Ky]({
      status: y1,
      endpoint: Xy,
      controller: jy,
      metadataType: "icy",
      headers: { "Icy-MetaData": 1 }
    });
  }
  /**
   * @description Fetches the first Ogg metadata update from the stream
   * @async
   * @returns {object} Object containing Ogg metadata
   */
  async getOggMetadata() {
    return this[Ky]({
      status: _1,
      endpoint: Xy,
      controller: Uy,
      metadataType: "ogg"
    });
  }
  async [Ky]({
    status: o,
    endpoint: m,
    controller: b,
    headers: M,
    metadataType: z
  }) {
    return this[Gp]({
      status: o,
      endpoint: m,
      controller: b,
      headers: M,
      mapper: async (S) => new Promise((u) => {
        new qg(S, {
          onMetadata: ({ metadata: O }) => {
            ui.get(this)[b].abort(), u(O);
          },
          onMetadataFailed: () => {
            ui.get(this)[b].abort(), u();
          },
          metadataTypes: z,
          icyMetaInt: ui.get(this)[_0],
          icyCharacterEncoding: ui.get(this)[v0],
          icyDetectionTimeout: ui.get(this)[x0]
        }).startReading();
      })
    }).then((S) => ({ [z]: S }));
  }
  async [Gp]({ status: o, endpoint: m, controller: b, mapper: M, headers: z = {} }) {
    if (!ui.get(this)[o])
      return ui.get(this)[o] = !0, fetch(ui.get(this)[m], {
        method: "GET",
        headers: z,
        signal: ui.get(this)[b].signal
      }).then((S) => {
        if (!S.ok) throw new Error(`HTTP Error ${S.status}`);
        return S;
      }).then(M).catch((S) => {
        S.name !== "AbortError" && console.warn(`Failed to fetch ${ui.get(this)[m]}`, S);
      }).finally(() => {
        ui.get(this)[o] = !1, ui.get(this)[b] = new AbortController();
      });
  }
}
function T0(d, o) {
  const [m = "", b = o] = o.split(" - ");
  if (d.length === 0)
    return null;
  if (m) {
    const M = d.find(
      (z) => typeof z?.artistName == "string" && typeof z?.trackName == "string" && z.artistName.toLowerCase() === m.toLowerCase() && z.trackName.toLowerCase().includes(b.toLowerCase())
    );
    return M || null;
  }
  return d[0];
}
function M0(d) {
  let o = d.trim();
  return o = o.replace(/\(\d{4}\)/g, "").trim(), /^\d+\.\s?-\s?\S+-\S+/.test(o) && (o = o.replace(
    /^(\d+\.)\s?-?\s?(\S+-\S+)-(.+)$/,
    (m, b, M, z) => {
      const S = M.replace(/-/g, " "), u = z.replace(/-/g, " ");
      return `${S} - ${u}`;
    }
  )), o = o.replace(/\s?\/\s?/g, " "), o = o.replace(/\s?&\s?/g, " "), / - .+ - /.test(o) && (o = o.replace(
    /^(.+?) - (.+?) - (.+)$/,
    (m, b, M, z) => `${b} ${M} - ${z}`
  )), o.trim();
}
const Cg = {
  stationId: null,
  trackId: null,
  artistId: null,
  StreamTitle: "",
  trackName: "",
  artistName: "",
  artworkURL: null,
  artistImage: null,
  trackViewUrl: "#",
  loaded: !1,
  processed: !1,
  metaDataFound: !1
}, Rv = Eu.createContext(), S1 = (d) => {
  const { station: o, currentPlaying: m, addTrack: b } = ei.useContext(R_), [M, z] = ei.useState({
    play: () => {
    },
    stop: () => {
    },
    setVolume: () => {
    },
    switchEndpoint: () => {
    }
  }), [S, u] = ei.useState(!1), [O, U] = ei.useState(!1), [K, ae] = ei.useState("stopped"), [he, J] = ei.useState(1), [ke, qe] = ei.useState(Cg), [ft, ht] = ei.useState(!1), [it, nt] = ei.useState(null), [De, Re] = ei.useState(null), $e = (at) => {
    J(at), M.setVolume(at);
  }, [rt, wt] = ei.useState(null);
  ei.useEffect(() => {
    if (!ft) {
      const at = {
        ...Cg,
        loaded: !0,
        processed: !1
      }, Et = m.title ? {
        ...at,
        StreamTitle: m.title,
        stationId: m.stationId,
        artworkURL: m.artworkURL || o?.thumbnail,
        trackName: m.trackName,
        artistName: m.artistName,
        artistImage: m.artistImage || o?.thumbnail,
        metaDataFound: !0
      } : o ? {
        ...at,
        trackName: o.metaPreset,
        artworkURL: o.thumbnail,
        artistImage: o.thumbnail,
        metaDataFound: !1
      } : ke;
      ht(!0), qe(Et);
    }
  }, [m, ft, o]), ei.useEffect(() => {
    let at;
    return (async () => {
      if (!o && !d?.externalStation) return;
      if (De)
        try {
          await De.stop(), await De.detachAudioElement();
        } catch (et) {
          console.error("error stopping old player:", et);
        }
      const { default: fe } = await import("./IcecastMetadataPlayer-CW5QCJoS.js").then((et) => et.I), Ue = {
        lastPlayedMetadata: !0,
        metadataTypes: ["icy", "ogg"],
        onMetadata: (et) => {
          qe((dt) => et.StreamTitle === dt.StreamTitle ? dt : {
            ...Cg,
            StreamTitle: et.StreamTitle,
            stationId: o.id,
            artworkURL: o.thumbnail
          });
        },
        onError: (et) => console.error("error", et)
      };
      at = new fe(
        d?.externalStation ? d.externalStation.src.replace("https://", "https://listen.eternityready.com/stream-proxy/") : o.url,
        Ue
      ), Re(at), u(!0), z({
        play: async () => {
          ae("loading"), await at.play(), at.audioElement.volume = he, ae("playing");
        },
        stop: async () => {
          await at.stop(), ae("stopped");
        },
        setVolume: (et) => {
          at.audioElement.volume = et;
        },
        switchEndpoint: async () => {
          await at.stop(), await at.detachAudioElement(), u(!1), U(!0), ae("stopped");
        }
      }), O && (ae("loading"), await at.play(), at.audioElement.volume = he, ae("playing"));
    })(), () => {
      at && (at.stop(), at.detachAudioElement());
    };
  }, [o, d.externalStation]), ei.useEffect(() => {
    De && M.setVolume(he);
  }, [he]), ei.useEffect(() => {
    if (ke.stationId !== null && !ke.loaded) {
      async function at() {
        await Dt(ke);
      }
      at();
    }
  }, [ke]), ei.useEffect(() => {
    ke.processed && b(ke);
  }, [ke]), ei.useEffect(() => (o && K !== "playing" && (async () => {
    try {
      const Et = new Gg(o.url, {
        onStats: async (fe) => {
          fe?.icy?.StreamTitle && qe((Ue) => fe.icy.StreamTitle === Ue.StreamTitle || Ue.stationId === o.id && Ue.stationId !== null ? Ue : {
            ...Cg,
            StreamTitle: fe.icy.StreamTitle,
            stationId: o.id,
            artworkURL: o.thumbnail
          });
        },
        onError: (fe) => {
          console.error("Error fetching stats:", fe);
        },
        interval: 5,
        sources: ["icy", "ogg"]
      });
      nt(Et), Et.start();
    } catch (Et) {
      console.error("Error fetching stations:", Et);
    }
  })(), () => {
    it && it.stop();
  }), [o, K]);
  const Ht = async () => {
    const Ue = await fetch("https://accounts.spotify.com/api/token", {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        Authorization: `Basic ${btoa("ceff5b2e43cb4190b4f33debdaada601:db6feddda20142f1ab5f7a08e3f4ed91")}`
      },
      body: "grant_type=client_credentials"
    });
    if (!Ue.ok)
      throw new Error("Failed to fetch Spotify token");
    return (await Ue.json()).access_token;
  }, Dt = async (at) => {
    if (qe((Pt) => ({
      ...Pt,
      loaded: !0
    })), !at.StreamTitle) return;
    const [Et, fe] = at.StreamTitle.split(" - ");
    let Ue = {
      artistId: null,
      trackId: null,
      trackName: fe || at.StreamTitle,
      artistName: Et || "",
      artistImage: o?.thumbnail
    }, et = null, dt = null;
    if (at.StreamTitle.trim().toLowerCase() !== "unknown") {
      const Pt = await vn(at), Vt = await Cn(Pt);
      if (Pt && Vt)
        dt = await Gt(Pt.artistViewUrl.replace("https://", "https://listen.eternityready.com/stream-proxy/")), et = await He(Pt.artistId, Pt.trackName), console.log(et), Ue = {
          ...Pt,
          artworkURL: Pt.artworkUrl100?.replace("100x100", "600x600") || Pt.artworkUrl100,
          artistImage: Vt || o?.thumbnail
        };
      else {
        const si = await Xt(at), Ii = await pi(si?.artistViewUrl);
        if (si) {
          Ue = {
            ...si,
            artworkURL: si.artworkUrl100?.replace("100x100", "600x600") || o?.thumbnail,
            artistImage: Ii || o?.thumbnail
          };
          try {
            et = await zn(Ue.artistId, Ue.trackName), dt = await vt(Ue.artistName, Ue.trackName), console.log(dt);
          } catch (xi) {
            console.error(xi);
          }
        }
      }
    }
    qe((Pt) => ({
      ...Pt,
      ...Ue,
      metaDataFound: !0,
      processed: !0,
      relatedSongs: et,
      aboutDescription: dt
    }));
  }, Xt = async (at) => {
    try {
      const Et = M0(at.StreamTitle), Ue = `https://itunes.apple.com/search?term=${encodeURIComponent(Et)}&media=music&entity=song&limit=10`, dt = await (await fetch(Ue)).json();
      return dt.results && T0(dt.results, Et);
    } catch (Et) {
      console.log("There was a problem fetching the data:", Et);
    }
    return console.log("getAppleData - null"), null;
  }, pi = async (at) => {
    if (!at)
      return null;
    try {
      const fe = await (await fetch(
        at
      )).text(), dt = new DOMParser().parseFromString(
        fe,
        "text/html"
      ).querySelector(
        "main picture source"
      );
      return dt && dt.getAttribute("srcset").split(" ")[0].replace(
        /\d{1,4}x\d{1,4}/,
        "1280x1280"
      );
    } catch (Et) {
      console.log("There was a problem fetching the data:", Et);
    }
    return console.log("getArtistImageFromApple - null"), null;
  }, vn = async (at) => {
    try {
      const Et = await Ht(), fe = at.StreamTitle.split(" - "), Ue = fe[1]?.trim().toLowerCase() === "unknown" ? "" : `track:${fe[1]}`, et = fe[0].trim().toLowerCase() === "unknown" ? "" : `artist:${fe[0]}`, dt = M0(`${Ue} ${et}`), Vt = `https://api.spotify.com/v1/search?q=${encodeURIComponent(dt)}&type=track&limit=10`, xi = (await (await fetch(Vt, {
        headers: {
          Authorization: `Bearer ${Et}`
        }
      })).json()).tracks.items.map((bi) => ({
        artistId: bi.artists[0]?.id || null,
        artistName: bi.artists[0]?.name || null,
        artistImage: bi.artists[0]?.images?.[0]?.url || o?.thumbnail,
        artistViewUrl: bi.artists[0]?.external_urls?.spotify || null,
        artworkUrl30: bi.album.images[2]?.url || null,
        artworkUrl60: bi.album.images[1]?.url || null,
        artworkUrl100: bi.album.images[0]?.url || null,
        collectionExplicitness: bi.explicit ? "explicit" : "notExplicit",
        collectionId: bi.album.id || null,
        collectionName: bi.album.name || null,
        collectionViewUrl: bi.album.external_urls?.spotify || null,
        discNumber: bi.disc_number || 1,
        isStreamable: !0,
        kind: "song",
        previewUrl: bi.preview_url || null,
        releaseDate: bi.album.release_date || null,
        trackCensoredName: bi.name || null,
        trackCount: bi.album.total_tracks || 1,
        trackExplicitness: bi.explicit ? "explicit" : "notExplicit",
        trackId: bi.id || null,
        trackName: bi.name || null,
        trackNumber: bi.track_number || null,
        trackTimeMillis: bi.duration_ms || null,
        trackViewUrl: bi.external_urls?.spotify || null,
        wrapperType: "track"
      })), Ta = T0(xi, dt) || xi[0] || null;
      return Ta && Ta;
    } catch (Et) {
      console.log("There was a problem fetching the data:", Et);
    }
    return console.log("getSpotifyData - null"), null;
  }, Cn = async (at) => {
    if (!at?.artistId)
      return null;
    try {
      const Et = await Ht(), Ue = await (await fetch(
        `https://api.spotify.com/v1/artists/${at.artistId}`,
        {
          headers: {
            Authorization: `Bearer ${Et}`
          }
        }
      )).json();
      return Ue.images.length > 0 && Ue.images[0].url.replace(/\d{1,4}x\d{1,4}/, "1280x1280");
    } catch (Et) {
      console.log("There was a problem fetching the data:", Et);
    }
    return console.log("getArtistImageFromSpotify - null"), null;
  };
  async function zn(at, Et, fe = 10) {
    const Ue = `https://itunes.apple.com/lookup?id=${at}&entity=song&limit=${fe}`;
    return (await (await fetch(Ue)).json()).results.filter((Pt) => Pt.wrapperType === "track" && Pt?.trackName != Et);
  }
  async function He(at, Et) {
    const fe = await Ht(), Ue = `https://api.spotify.com/v1/artists/${at}/top-tracks`;
    return (await (await fetch(Ue, {
      headers: {
        Authorization: `Bearer ${fe}`
      }
    })).json()).tracks.filter((Pt) => Pt.name != Et);
  }
  async function vt(at, Et) {
    const fe = `recording:"${Et}" AND artist:"${at}"`, Ue = `https://musicbrainz.org/ws/2/recording/?query=${encodeURIComponent(fe)}&fmt=json&limit=1`, et = await fetch(Ue);
    if (!et.ok) throw new Error(`MusicBrainz recording search failed: ${et.status}`);
    const dt = await et.json();
    if (!dt.recordings || dt.recordings.length === 0) return null;
    const si = `https://musicbrainz.org/ws/2/artist/${dt.recordings[0]["artist-credit"][0].artist.id}?inc=url-rels&fmt=json`, Ii = await fetch(si);
    if (!Ii.ok) throw new Error(`MusicBrainz artist lookup failed: ${Ii.status}`);
    const Ta = (await Ii.json()).relations || [];
    let bi = (Ta.find((Xa) => Xa.type === "wikipedia") || {}).url?.resource || null;
    const oa = Ta.find((Xa) => Xa.type === "wikidata");
    if (!bi && oa) {
      const Xa = oa.url.resource.split("/").pop(), Ya = await fetch(`https://www.wikidata.org/wiki/Special:EntityData/${Xa}.json`);
      if (Ya.ok) {
        const Yr = ((await Ya.json()).entities[Xa]?.sitelinks || {}).enwiki;
        Yr && (bi = `https://en.wikipedia.org/wiki/${encodeURIComponent(Yr.title)}`);
      }
    }
    if (!bi) return null;
    const an = bi.match(/\/wiki\/(.+)$/)?.[1];
    if (!an) return null;
    const $i = `https://en.wikipedia.org/api/rest_v1/page/summary/${an}`, ma = await fetch($i);
    if (!ma.ok) throw new Error(`Wikipedia API fetch failed: ${ma.status}`);
    return (await ma.json()).extract || null;
  }
  const Gt = async (at) => {
    if (!at)
      return null;
    try {
      const fe = await (await fetch(
        at
      )).text();
      return new DOMParser().parseFromString(
        fe,
        "text/html"
      ).querySelector(
        // Worst parsing ever written
        "div[data-testid='expandable-description'] span"
      ).innerText;
    } catch (Et) {
      console.log("There was a problem fetching the data:", Et);
    }
    return console.log("getArtistAboutFromSpotify - null"), null;
  };
  return /* @__PURE__ */ Se.jsx(
    Rv.Provider,
    {
      value: {
        player: M,
        playerState: K,
        playerVolume: he,
        setPlayerIsLoaded: U,
        changeVolume: $e,
        currentTrack: ke,
        externalStation: d.externalStation,
        setExternalStation: d.setExternalStation
      },
      children: d.children
    }
  );
};
var Og = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.6.2/LICENSE.txt
 */
var T1 = Og.exports, A0;
function M1() {
  return A0 || (A0 = 1, (function(d, o) {
    (function(m, b) {
      d.exports = b();
    })(T1, (function() {
      var m = {}, b = {};
      function M(S, u, O) {
        if (b[S] = O, S === "index") {
          var U = "var sharedModule = {}; (" + b.shared + ")(sharedModule); (" + b.worker + ")(sharedModule);", K = {};
          return b.shared(K), b.index(m, K), typeof window < "u" && m.setWorkerUrl(window.URL.createObjectURL(new Blob([U], { type: "text/javascript" }))), m;
        }
      }
      M("shared", ["exports"], (function(S) {
        function u(a, t, n, l) {
          return new (n || (n = Promise))((function(p, v) {
            function x(k) {
              try {
                E(l.next(k));
              } catch (D) {
                v(D);
              }
            }
            function T(k) {
              try {
                E(l.throw(k));
              } catch (D) {
                v(D);
              }
            }
            function E(k) {
              var D;
              k.done ? p(k.value) : (D = k.value, D instanceof n ? D : new n((function(N) {
                N(D);
              }))).then(x, T);
            }
            E((l = l.apply(a, t || [])).next());
          }));
        }
        function O(a, t) {
          this.x = a, this.y = t;
        }
        function U(a) {
          return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
        }
        var K, ae;
        typeof SuppressedError == "function" && SuppressedError, O.prototype = { clone() {
          return new O(this.x, this.y);
        }, add(a) {
          return this.clone()._add(a);
        }, sub(a) {
          return this.clone()._sub(a);
        }, multByPoint(a) {
          return this.clone()._multByPoint(a);
        }, divByPoint(a) {
          return this.clone()._divByPoint(a);
        }, mult(a) {
          return this.clone()._mult(a);
        }, div(a) {
          return this.clone()._div(a);
        }, rotate(a) {
          return this.clone()._rotate(a);
        }, rotateAround(a, t) {
          return this.clone()._rotateAround(a, t);
        }, matMult(a) {
          return this.clone()._matMult(a);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(a) {
          return this.x === a.x && this.y === a.y;
        }, dist(a) {
          return Math.sqrt(this.distSqr(a));
        }, distSqr(a) {
          const t = a.x - this.x, n = a.y - this.y;
          return t * t + n * n;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(a) {
          return Math.atan2(this.y - a.y, this.x - a.x);
        }, angleWith(a) {
          return this.angleWithSep(a.x, a.y);
        }, angleWithSep(a, t) {
          return Math.atan2(this.x * t - this.y * a, this.x * a + this.y * t);
        }, _matMult(a) {
          const t = a[2] * this.x + a[3] * this.y;
          return this.x = a[0] * this.x + a[1] * this.y, this.y = t, this;
        }, _add(a) {
          return this.x += a.x, this.y += a.y, this;
        }, _sub(a) {
          return this.x -= a.x, this.y -= a.y, this;
        }, _mult(a) {
          return this.x *= a, this.y *= a, this;
        }, _div(a) {
          return this.x /= a, this.y /= a, this;
        }, _multByPoint(a) {
          return this.x *= a.x, this.y *= a.y, this;
        }, _divByPoint(a) {
          return this.x /= a.x, this.y /= a.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const a = this.y;
          return this.y = this.x, this.x = -a, this;
        }, _rotate(a) {
          const t = Math.cos(a), n = Math.sin(a), l = n * this.x + t * this.y;
          return this.x = t * this.x - n * this.y, this.y = l, this;
        }, _rotateAround(a, t) {
          const n = Math.cos(a), l = Math.sin(a), p = t.y + l * (this.x - t.x) + n * (this.y - t.y);
          return this.x = t.x + n * (this.x - t.x) - l * (this.y - t.y), this.y = p, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: O }, O.convert = function(a) {
          if (a instanceof O) return a;
          if (Array.isArray(a)) return new O(+a[0], +a[1]);
          if (a.x !== void 0 && a.y !== void 0) return new O(+a.x, +a.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var he = (function() {
          if (ae) return K;
          function a(t, n, l, p) {
            this.cx = 3 * t, this.bx = 3 * (l - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (p - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = l, this.p2y = p;
          }
          return ae = 1, K = a, a.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, n) {
            if (n === void 0 && (n = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var l = t, p = 0; p < 8; p++) {
              var v = this.sampleCurveX(l) - t;
              if (Math.abs(v) < n) return l;
              var x = this.sampleCurveDerivativeX(l);
              if (Math.abs(x) < 1e-6) break;
              l -= v / x;
            }
            var T = 0, E = 1;
            for (l = t, p = 0; p < 20 && (v = this.sampleCurveX(l), !(Math.abs(v - t) < n)); p++) t > v ? T = l : E = l, l = 0.5 * (E - T) + T;
            return l;
          }, solve: function(t, n) {
            return this.sampleCurveY(this.solveCurveX(t, n));
          } }, K;
        })(), J = U(he);
        let ke, qe;
        function ft() {
          return ke == null && (ke = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), ke;
        }
        function ht() {
          if (qe == null && (qe = !1, ft())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
            if (t) {
              for (let l = 0; l < 25; l++) {
                const p = 4 * l;
                t.fillStyle = `rgb(${p},${p + 1},${p + 2})`, t.fillRect(l % 5, Math.floor(l / 5), 1, 1);
              }
              const n = t.getImageData(0, 0, 5, 5).data;
              for (let l = 0; l < 100; l++) if (l % 4 != 3 && n[l] !== l) {
                qe = !0;
                break;
              }
            }
          }
          return qe || !1;
        }
        var it = 1e-6, nt = typeof Float32Array < "u" ? Float32Array : Array;
        function De() {
          var a = new nt(9);
          return nt != Float32Array && (a[1] = 0, a[2] = 0, a[3] = 0, a[5] = 0, a[6] = 0, a[7] = 0), a[0] = 1, a[4] = 1, a[8] = 1, a;
        }
        function Re(a) {
          return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
        }
        function $e() {
          var a = new nt(3);
          return nt != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0), a;
        }
        function rt(a) {
          return Math.hypot(a[0], a[1], a[2]);
        }
        function wt(a, t, n) {
          var l = new nt(3);
          return l[0] = a, l[1] = t, l[2] = n, l;
        }
        function Ht(a, t, n) {
          return a[0] = t[0] + n[0], a[1] = t[1] + n[1], a[2] = t[2] + n[2], a;
        }
        function Dt(a, t, n) {
          return a[0] = t[0] * n, a[1] = t[1] * n, a[2] = t[2] * n, a;
        }
        function Xt(a, t, n) {
          var l = t[0], p = t[1], v = t[2], x = n[0], T = n[1], E = n[2];
          return a[0] = p * E - v * T, a[1] = v * x - l * E, a[2] = l * T - p * x, a;
        }
        Math.hypot || (Math.hypot = function() {
          for (var a = 0, t = arguments.length; t--; ) a += arguments[t] * arguments[t];
          return Math.sqrt(a);
        });
        var pi, vn = rt;
        function Cn(a, t, n) {
          var l = t[0], p = t[1], v = t[2], x = t[3];
          return a[0] = n[0] * l + n[4] * p + n[8] * v + n[12] * x, a[1] = n[1] * l + n[5] * p + n[9] * v + n[13] * x, a[2] = n[2] * l + n[6] * p + n[10] * v + n[14] * x, a[3] = n[3] * l + n[7] * p + n[11] * v + n[15] * x, a;
        }
        function zn() {
          var a = new nt(4);
          return nt != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0), a[3] = 1, a;
        }
        function He(a, t, n, l) {
          var p = 0.5 * Math.PI / 180;
          t *= p, n *= p, l *= p;
          var v = Math.sin(t), x = Math.cos(t), T = Math.sin(n), E = Math.cos(n), k = Math.sin(l), D = Math.cos(l);
          return a[0] = v * E * D - x * T * k, a[1] = x * T * D + v * E * k, a[2] = x * E * k - v * T * D, a[3] = x * E * D + v * T * k, a;
        }
        function vt() {
          var a = new nt(2);
          return nt != Float32Array && (a[0] = 0, a[1] = 0), a;
        }
        function Gt(a, t) {
          var n = new nt(2);
          return n[0] = a, n[1] = t, n;
        }
        $e(), pi = new nt(4), nt != Float32Array && (pi[0] = 0, pi[1] = 0, pi[2] = 0, pi[3] = 0), $e(), wt(1, 0, 0), wt(0, 1, 0), zn(), zn(), De(), vt();
        const at = 8192;
        function Et(a, t, n) {
          return t * (at / (a.tileSize * Math.pow(2, n - a.tileID.overscaledZ)));
        }
        function fe(a, t) {
          return (a % t + t) % t;
        }
        function Ue(a, t, n) {
          return a * (1 - n) + t * n;
        }
        function et(a) {
          if (a <= 0) return 0;
          if (a >= 1) return 1;
          const t = a * a, n = t * a;
          return 4 * (a < 0.5 ? n : 3 * (a - t) + n - 0.75);
        }
        function dt(a, t, n, l) {
          const p = new J(a, t, n, l);
          return (v) => p.solve(v);
        }
        const Pt = dt(0.25, 0.1, 0.25, 1);
        function Vt(a, t, n) {
          return Math.min(n, Math.max(t, a));
        }
        function si(a, t, n) {
          const l = n - t, p = ((a - t) % l + l) % l + t;
          return p === t ? n : p;
        }
        function Ii(a, ...t) {
          for (const n of t) for (const l in n) a[l] = n[l];
          return a;
        }
        let xi = 1;
        function Ta(a, t, n) {
          const l = {};
          for (const p in a) l[p] = t.call(this, a[p], p, a);
          return l;
        }
        function bi(a, t, n) {
          const l = {};
          for (const p in a) t.call(this, a[p], p, a) && (l[p] = a[p]);
          return l;
        }
        function oa(a) {
          return Array.isArray(a) ? a.map(oa) : typeof a == "object" && a ? Ta(a, oa) : a;
        }
        const an = {};
        function $i(a) {
          an[a] || (typeof console < "u" && console.warn(a), an[a] = !0);
        }
        function ma(a, t, n) {
          return (n.y - a.y) * (t.x - a.x) > (t.y - a.y) * (n.x - a.x);
        }
        function dr(a) {
          return typeof WorkerGlobalScope < "u" && a !== void 0 && a instanceof WorkerGlobalScope;
        }
        let Xa = null;
        function Ya(a) {
          return typeof ImageBitmap < "u" && a instanceof ImageBitmap;
        }
        const pr = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function Os(a, t, n, l, p) {
          return u(this, void 0, void 0, (function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const v = new VideoFrame(a, { timestamp: 0 });
            try {
              const x = v?.format;
              if (!x || !x.startsWith("BGR") && !x.startsWith("RGB")) throw new Error(`Unrecognized format ${x}`);
              const T = x.startsWith("BGR"), E = new Uint8ClampedArray(l * p * 4);
              if (yield v.copyTo(E, (function(k, D, N, q, G) {
                const Z = 4 * Math.max(-D, 0), X = (Math.max(0, N) - N) * q * 4 + Z, ee = 4 * q, se = Math.max(0, D), xe = Math.max(0, N);
                return { rect: { x: se, y: xe, width: Math.min(k.width, D + q) - se, height: Math.min(k.height, N + G) - xe }, layout: [{ offset: X, stride: ee }] };
              })(a, t, n, l, p)), T) for (let k = 0; k < E.length; k += 4) {
                const D = E[k];
                E[k] = E[k + 2], E[k + 2] = D;
              }
              return E;
            } finally {
              v.close();
            }
          }));
        }
        let Xr, Yr;
        function ho(a, t, n, l) {
          return a.addEventListener(t, n, l), { unsubscribe: () => {
            a.removeEventListener(t, n, l);
          } };
        }
        function Yn(a) {
          return a * Math.PI / 180;
        }
        function po(a) {
          return a / Math.PI * 180;
        }
        const Bs = { touchstart: !0, touchmove: !0, touchmoveWindow: !0, touchend: !0, touchcancel: !0 }, Ns = { dblclick: !0, click: !0, mouseover: !0, mouseout: !0, mousedown: !0, mousemove: !0, mousemoveWindow: !0, mouseup: !0, mouseupWindow: !0, contextmenu: !0, wheel: !0 }, js = "AbortError";
        function be() {
          return new Error(js);
        }
        const H = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function Y(a) {
          return H.REGISTERED_PROTOCOLS[a.substring(0, a.indexOf("://"))];
        }
        const Q = "global-dispatcher";
        class le extends Error {
          constructor(t, n, l, p) {
            super(`AJAXError: ${n} (${t}): ${l}`), this.status = t, this.statusText = n, this.url = l, this.body = p;
          }
        }
        const me = () => dr(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, ve = function(a, t) {
          if (/:\/\//.test(a.url) && !/^https?:|^file:/.test(a.url)) {
            const l = Y(a.url);
            if (l) return l(a, t);
            if (dr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: a, targetMapId: Q }, t);
          }
          if (!(/^file:/.test(n = a.url) || /^file:/.test(me()) && !/^\w+:/.test(n))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(l, p) {
              return u(this, void 0, void 0, (function* () {
                const v = new Request(l.url, { method: l.method || "GET", body: l.body, credentials: l.credentials, headers: l.headers, cache: l.cache, referrer: me(), signal: p.signal });
                let x, T;
                l.type !== "json" || v.headers.has("Accept") || v.headers.set("Accept", "application/json");
                try {
                  x = yield fetch(v);
                } catch (k) {
                  throw new le(0, k.message, l.url, new Blob());
                }
                if (!x.ok) {
                  const k = yield x.blob();
                  throw new le(x.status, x.statusText, l.url, k);
                }
                T = l.type === "arrayBuffer" || l.type === "image" ? x.arrayBuffer() : l.type === "json" ? x.json() : x.text();
                const E = yield T;
                if (p.signal.aborted) throw be();
                return { data: E, cacheControl: x.headers.get("Cache-Control"), expires: x.headers.get("Expires") };
              }));
            })(a, t);
            if (dr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: a, mustQueue: !0, targetMapId: Q }, t);
          }
          var n;
          return (function(l, p) {
            return new Promise(((v, x) => {
              var T;
              const E = new XMLHttpRequest();
              E.open(l.method || "GET", l.url, !0), l.type !== "arrayBuffer" && l.type !== "image" || (E.responseType = "arraybuffer");
              for (const k in l.headers) E.setRequestHeader(k, l.headers[k]);
              l.type === "json" && (E.responseType = "text", !((T = l.headers) === null || T === void 0) && T.Accept || E.setRequestHeader("Accept", "application/json")), E.withCredentials = l.credentials === "include", E.onerror = () => {
                x(new Error(E.statusText));
              }, E.onload = () => {
                if (!p.signal.aborted) if ((E.status >= 200 && E.status < 300 || E.status === 0) && E.response !== null) {
                  let k = E.response;
                  if (l.type === "json") try {
                    k = JSON.parse(E.response);
                  } catch (D) {
                    return void x(D);
                  }
                  v({ data: k, cacheControl: E.getResponseHeader("Cache-Control"), expires: E.getResponseHeader("Expires") });
                } else {
                  const k = new Blob([E.response], { type: E.getResponseHeader("Content-Type") });
                  x(new le(E.status, E.statusText, l.url, k));
                }
              }, p.signal.addEventListener("abort", (() => {
                E.abort(), x(be());
              })), E.send(l.body);
            }));
          })(a, t);
        };
        function Ee(a) {
          if (!a || a.indexOf("://") <= 0 || a.indexOf("data:image/") === 0 || a.indexOf("blob:") === 0) return !0;
          const t = new URL(a), n = window.location;
          return t.protocol === n.protocol && t.host === n.host;
        }
        function Te(a, t, n) {
          n[a] && n[a].indexOf(t) !== -1 || (n[a] = n[a] || [], n[a].push(t));
        }
        function Ge(a, t, n) {
          if (n && n[a]) {
            const l = n[a].indexOf(t);
            l !== -1 && n[a].splice(l, 1);
          }
        }
        class tt {
          constructor(t, n = {}) {
            Ii(this, n), this.type = t;
          }
        }
        class Ye extends tt {
          constructor(t, n = {}) {
            super("error", Ii({ error: t }, n));
          }
        }
        class Mt {
          on(t, n) {
            return this._listeners = this._listeners || {}, Te(t, n, this._listeners), { unsubscribe: () => {
              this.off(t, n);
            } };
          }
          off(t, n) {
            return Ge(t, n, this._listeners), Ge(t, n, this._oneTimeListeners), this;
          }
          once(t, n) {
            return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, Te(t, n, this._oneTimeListeners), this) : new Promise(((l) => this.once(t, l)));
          }
          fire(t, n) {
            typeof t == "string" && (t = new tt(t, n || {}));
            const l = t.type;
            if (this.listens(l)) {
              t.target = this;
              const p = this._listeners && this._listeners[l] ? this._listeners[l].slice() : [];
              for (const T of p) T.call(this, t);
              const v = this._oneTimeListeners && this._oneTimeListeners[l] ? this._oneTimeListeners[l].slice() : [];
              for (const T of v) Ge(l, T, this._oneTimeListeners), T.call(this, t);
              const x = this._eventedParent;
              x && (Ii(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), x.fire(t));
            } else t instanceof Ye && console.error(t.error);
            return this;
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);
          }
          setEventedParent(t, n) {
            return this._eventedParent = t, this._eventedParentData = n, this;
          }
        }
        var Ae = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: !1, expression: { interpolated: !0, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const qt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function ri(a, t) {
          const n = {};
          for (const l in a) l !== "ref" && (n[l] = a[l]);
          return qt.forEach(((l) => {
            l in t && (n[l] = t[l]);
          })), n;
        }
        function It(a, t) {
          if (Array.isArray(a)) {
            if (!Array.isArray(t) || a.length !== t.length) return !1;
            for (let n = 0; n < a.length; n++) if (!It(a[n], t[n])) return !1;
            return !0;
          }
          if (typeof a == "object" && a !== null && t !== null) {
            if (typeof t != "object" || Object.keys(a).length !== Object.keys(t).length) return !1;
            for (const n in a) if (!It(a[n], t[n])) return !1;
            return !0;
          }
          return a === t;
        }
        function ti(a, t) {
          a.push(t);
        }
        function Yi(a, t, n) {
          ti(n, { command: "addSource", args: [a, t[a]] });
        }
        function Pn(a, t, n) {
          ti(t, { command: "removeSource", args: [a] }), n[a] = !0;
        }
        function xn(a, t, n, l) {
          Pn(a, n, l), Yi(a, t, n);
        }
        function In(a, t, n) {
          let l;
          for (l in a[n]) if (Object.prototype.hasOwnProperty.call(a[n], l) && l !== "data" && !It(a[n][l], t[n][l])) return !1;
          for (l in t[n]) if (Object.prototype.hasOwnProperty.call(t[n], l) && l !== "data" && !It(a[n][l], t[n][l])) return !1;
          return !0;
        }
        function ci(a, t, n, l, p, v) {
          a = a || {}, t = t || {};
          for (const x in a) Object.prototype.hasOwnProperty.call(a, x) && (It(a[x], t[x]) || n.push({ command: v, args: [l, x, t[x], p] }));
          for (const x in t) Object.prototype.hasOwnProperty.call(t, x) && !Object.prototype.hasOwnProperty.call(a, x) && (It(a[x], t[x]) || n.push({ command: v, args: [l, x, t[x], p] }));
        }
        function _i(a) {
          return a.id;
        }
        function kn(a, t) {
          return a[t.id] = t, a;
        }
        class ot {
          constructor(t, n, l, p) {
            this.message = (t ? `${t}: ` : "") + l, p && (this.identifier = p), n != null && n.__line__ && (this.line = n.__line__);
          }
        }
        function la(a, ...t) {
          for (const n of t) for (const l in n) a[l] = n[l];
          return a;
        }
        class dn extends Error {
          constructor(t, n) {
            super(n), this.message = n, this.key = t;
          }
        }
        class Us {
          constructor(t, n = []) {
            this.parent = t, this.bindings = {};
            for (const [l, p] of n) this.bindings[l] = p;
          }
          concat(t) {
            return new Us(this, t);
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`);
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t);
          }
        }
        const fr = { kind: "null" }, st = { kind: "number" }, Zt = { kind: "string" }, Jt = { kind: "boolean" }, Kn = { kind: "color" }, al = { kind: "projectionDefinition" }, fo = { kind: "object" }, ii = { kind: "value" }, mo = { kind: "collator" }, ss = { kind: "formatted" }, Fs = { kind: "padding" }, Ba = { kind: "colorArray" }, os = { kind: "numberArray" }, Qi = { kind: "resolvedImage" }, Rn = { kind: "variableAnchorOffsetCollection" };
        function Na(a, t) {
          return { kind: "array", itemType: a, N: t };
        }
        function Hi(a) {
          if (a.kind === "array") {
            const t = Hi(a.itemType);
            return typeof a.N == "number" ? `array<${t}, ${a.N}>` : a.itemType.kind === "value" ? "array" : `array<${t}>`;
          }
          return a.kind;
        }
        const go = [fr, st, Zt, Jt, Kn, al, ss, fo, Na(ii), Fs, os, Ba, Qi, Rn];
        function ls(a, t) {
          if (t.kind === "error") return null;
          if (a.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !ls(a.itemType, t.itemType)) && (typeof a.N != "number" || a.N === t.N)) return null;
          } else {
            if (a.kind === t.kind) return null;
            if (a.kind === "value") {
              for (const n of go) if (!ls(n, t)) return null;
            }
          }
          return `Expected ${Hi(a)} but found ${Hi(t)} instead.`;
        }
        function Mh(a, t) {
          return t.some(((n) => n.kind === a.kind));
        }
        function Vs(a, t) {
          return t.some(((n) => n === "null" ? a === null : n === "array" ? Array.isArray(a) : n === "object" ? a && !Array.isArray(a) && typeof a == "object" : n === typeof a));
        }
        function qs(a, t) {
          return a.kind === "array" && t.kind === "array" ? a.itemType.kind === t.itemType.kind && typeof a.N == "number" : a.kind === t.kind;
        }
        const Ah = 0.96422, ku = 0.82521, Ru = 4 / 29, Ka = 6 / 29, mr = 3 * Ka * Ka, qd = Ka * Ka * Ka, nf = Math.PI / 180, Eh = 180 / Math.PI;
        function Rc(a) {
          return (a %= 360) < 0 && (a += 360), a;
        }
        function Gs([a, t, n, l]) {
          let p, v;
          const x = Wa((0.2225045 * (a = Ch(a)) + 0.7168786 * (t = Ch(t)) + 0.0606169 * (n = Ch(n))) / 1);
          a === t && t === n ? p = v = x : (p = Wa((0.4360747 * a + 0.3850649 * t + 0.1430804 * n) / Ah), v = Wa((0.0139322 * a + 0.0971045 * t + 0.7141733 * n) / ku));
          const T = 116 * x - 16;
          return [T < 0 ? 0 : T, 500 * (p - x), 200 * (x - v), l];
        }
        function Ch(a) {
          return a <= 0.04045 ? a / 12.92 : Math.pow((a + 0.055) / 1.055, 2.4);
        }
        function Wa(a) {
          return a > qd ? Math.pow(a, 1 / 3) : a / mr + Ru;
        }
        function yo([a, t, n, l]) {
          let p = (a + 16) / 116, v = isNaN(t) ? p : p + t / 500, x = isNaN(n) ? p : p - n / 200;
          return p = 1 * Du(p), v = Ah * Du(v), x = ku * Du(x), [Dc(3.1338561 * v - 1.6168667 * p - 0.4906146 * x), Dc(-0.9787684 * v + 1.9161415 * p + 0.033454 * x), Dc(0.0719453 * v - 0.2289914 * p + 1.4052427 * x), l];
        }
        function Dc(a) {
          return (a = a <= 304e-5 ? 12.92 * a : 1.055 * Math.pow(a, 1 / 2.4) - 0.055) < 0 ? 0 : a > 1 ? 1 : a;
        }
        function Du(a) {
          return a > Ka ? a * a * a : mr * (a - Ru);
        }
        const Fl = Object.hasOwn || function(a, t) {
          return Object.prototype.hasOwnProperty.call(a, t);
        };
        function rl(a, t) {
          return Fl(a, t) ? a[t] : void 0;
        }
        function Vl(a) {
          return parseInt(a.padEnd(2, a), 16) / 255;
        }
        function Ma(a, t) {
          return hi(t ? a / 100 : a, 0, 1);
        }
        function hi(a, t, n) {
          return Math.min(Math.max(t, a), n);
        }
        function _o(a) {
          return !a.some(Number.isNaN);
        }
        const Zs = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function Kr(a, t, n) {
          return a + n * (t - a);
        }
        function sl(a, t, n) {
          return a.map(((l, p) => Kr(l, t[p], n)));
        }
        class di {
          constructor(t, n, l, p = 1, v = !0) {
            this.r = t, this.g = n, this.b = l, this.a = p, v || (this.r *= p, this.g *= p, this.b *= p, p || this.overwriteGetter("rgb", [t, n, l, p]));
          }
          static parse(t) {
            if (t instanceof di) return t;
            if (typeof t != "string") return;
            const n = (function(l) {
              if ((l = l.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const p = rl(Zs, l);
              if (p) {
                const [x, T, E] = p;
                return [x / 255, T / 255, E / 255, 1];
              }
              if (l.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(l)) {
                const x = l.length < 6 ? 1 : 2;
                let T = 1;
                return [Vl(l.slice(T, T += x)), Vl(l.slice(T, T += x)), Vl(l.slice(T, T += x)), Vl(l.slice(T, T + x) || "ff")];
              }
              if (l.startsWith("rgb")) {
                const x = l.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (x) {
                  const [T, E, k, D, N, q, G, Z, X, ee, se, xe] = x, de = [D || " ", G || " ", ee].join("");
                  if (de === "  " || de === "  /" || de === ",," || de === ",,,") {
                    const ge = [k, q, X].join(""), Ie = ge === "%%%" ? 100 : ge === "" ? 255 : 0;
                    if (Ie) {
                      const Fe = [hi(+E / Ie, 0, 1), hi(+N / Ie, 0, 1), hi(+Z / Ie, 0, 1), se ? Ma(+se, xe) : 1];
                      if (_o(Fe)) return Fe;
                    }
                  }
                  return;
                }
              }
              const v = l.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (v) {
                const [x, T, E, k, D, N, q, G, Z] = v, X = [E || " ", D || " ", q].join("");
                if (X === "  " || X === "  /" || X === ",," || X === ",,,") {
                  const ee = [+T, hi(+k, 0, 100), hi(+N, 0, 100), G ? Ma(+G, Z) : 1];
                  if (_o(ee)) return (function([se, xe, de, ge]) {
                    function Ie(Fe) {
                      const Je = (Fe + se / 30) % 12, gt = xe * Math.min(de, 1 - de);
                      return de - gt * Math.max(-1, Math.min(Je - 3, 9 - Je, 1));
                    }
                    return se = Rc(se), xe /= 100, de /= 100, [Ie(0), Ie(8), Ie(4), ge];
                  })(ee);
                }
              }
            })(t);
            return n ? new di(...n, !1) : void 0;
          }
          get rgb() {
            const { r: t, g: n, b: l, a: p } = this, v = p || 1 / 0;
            return this.overwriteGetter("rgb", [t / v, n / v, l / v, p]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [n, l, p, v] = Gs(t), x = Math.sqrt(l * l + p * p);
              return [Math.round(1e4 * x) ? Rc(Math.atan2(p, l) * Eh) : NaN, x, n, v];
            })(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", Gs(this.rgb));
          }
          overwriteGetter(t, n) {
            return Object.defineProperty(this, t, { value: n }), n;
          }
          toString() {
            const [t, n, l, p] = this.rgb;
            return `rgba(${[t, n, l].map(((v) => Math.round(255 * v))).join(",")},${p})`;
          }
          static interpolate(t, n, l, p = "rgb") {
            switch (p) {
              case "rgb": {
                const [v, x, T, E] = sl(t.rgb, n.rgb, l);
                return new di(v, x, T, E, !1);
              }
              case "hcl": {
                const [v, x, T, E] = t.hcl, [k, D, N, q] = n.hcl;
                let G, Z;
                if (isNaN(v) || isNaN(k)) isNaN(v) ? isNaN(k) ? G = NaN : (G = k, T !== 1 && T !== 0 || (Z = D)) : (G = v, N !== 1 && N !== 0 || (Z = x));
                else {
                  let de = k - v;
                  k > v && de > 180 ? de -= 360 : k < v && v - k > 180 && (de += 360), G = v + l * de;
                }
                const [X, ee, se, xe] = (function([de, ge, Ie, Fe]) {
                  return de = isNaN(de) ? 0 : de * nf, yo([Ie, Math.cos(de) * ge, Math.sin(de) * ge, Fe]);
                })([G, Z ?? Kr(x, D, l), Kr(T, N, l), Kr(E, q, l)]);
                return new di(X, ee, se, xe, !1);
              }
              case "lab": {
                const [v, x, T, E] = yo(sl(t.lab, n.lab, l));
                return new di(v, x, T, E, !1);
              }
            }
          }
        }
        di.black = new di(0, 0, 0, 1), di.white = new di(1, 1, 1, 1), di.transparent = new di(0, 0, 0, 0), di.red = new di(1, 0, 0, 1);
        class us {
          constructor(t, n, l) {
            this.sensitivity = t ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = l, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t, n) {
            return this.collator.compare(t, n);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const Rr = ["bottom", "center", "top"];
        class ql {
          constructor(t, n, l, p, v, x) {
            this.text = t, this.image = n, this.scale = l, this.fontStack = p, this.textColor = v, this.verticalAlign = x;
          }
        }
        class ga {
          constructor(t) {
            this.sections = t;
          }
          static fromString(t) {
            return new ga([new ql(t, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some(((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0));
          }
          static factory(t) {
            return t instanceof ga ? t : ga.fromString(t);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map(((t) => t.text)).join("");
          }
        }
        class bn {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof bn) return t;
            if (typeof t == "number") return new bn([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const n of t) if (typeof n != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]];
              }
              return new bn(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, l) {
            return new bn(sl(t.values, n.values, l));
          }
        }
        class Vn {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Vn) return t;
            if (typeof t == "number") return new Vn([t]);
            if (Array.isArray(t)) {
              for (const n of t) if (typeof n != "number") return;
              return new Vn(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, l) {
            return new Vn(sl(t.values, n.values, l));
          }
        }
        class Dn {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Dn) return t;
            if (typeof t == "string") {
              const l = di.parse(t);
              return l ? new Dn([l]) : void 0;
            }
            if (!Array.isArray(t)) return;
            const n = [];
            for (const l of t) {
              if (typeof l != "string") return;
              const p = di.parse(l);
              if (!p) return;
              n.push(p);
            }
            return new Dn(n);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, l, p = "rgb") {
            const v = [];
            if (t.values.length != n.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${n.values.length}), cannot interpolate.`);
            for (let x = 0; x < t.values.length; x++) v.push(di.interpolate(t.values[x], n.values[x], l, p));
            return new Dn(v);
          }
        }
        class Ui extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const zh = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Wn {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Wn) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let n = 0; n < t.length; n += 2) {
                const l = t[n], p = t[n + 1];
                if (typeof l != "string" || !zh.has(l) || !Array.isArray(p) || p.length !== 2 || typeof p[0] != "number" || typeof p[1] != "number") return;
              }
              return new Wn(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, l) {
            const p = t.values, v = n.values;
            if (p.length !== v.length) throw new Ui(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${n.toString()}`);
            const x = [];
            for (let T = 0; T < p.length; T += 2) {
              if (p[T] !== v[T]) throw new Ui(`Cannot interpolate values containing mismatched anchors. from[${T}]: ${p[T]}, to[${T}]: ${v[T]}`);
              x.push(p[T]);
              const [E, k] = p[T + 1], [D, N] = v[T + 1];
              x.push([Kr(E, D, l), Kr(k, N, l)]);
            }
            return new Wn(x);
          }
        }
        class Ln {
          constructor(t) {
            this.name = t.name, this.available = t.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t) {
            return t ? new Ln({ name: t, available: !1 }) : null;
          }
        }
        class ua {
          constructor(t, n, l) {
            this.from = t, this.to = n, this.transition = l;
          }
          static interpolate(t, n, l) {
            return new ua(t, n, l);
          }
          static parse(t) {
            return t instanceof ua ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new ua(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new ua(t.from, t.to, t.transition) : typeof t == "string" ? new ua(t, t, 1) : void 0;
          }
        }
        function Fi(a, t, n, l) {
          return typeof a == "number" && a >= 0 && a <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? l === void 0 || typeof l == "number" && l >= 0 && l <= 1 ? null : `Invalid rgba value [${[a, t, n, l].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof l == "number" ? [a, t, n, l] : [a, t, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Ja(a) {
          if (a === null || typeof a == "string" || typeof a == "boolean" || typeof a == "number" || a instanceof ua || a instanceof di || a instanceof us || a instanceof ga || a instanceof bn || a instanceof Vn || a instanceof Dn || a instanceof Wn || a instanceof Ln) return !0;
          if (Array.isArray(a)) {
            for (const t of a) if (!Ja(t)) return !1;
            return !0;
          }
          if (typeof a == "object") {
            for (const t in a) if (!Ja(a[t])) return !1;
            return !0;
          }
          return !1;
        }
        function Ut(a) {
          if (a === null) return fr;
          if (typeof a == "string") return Zt;
          if (typeof a == "boolean") return Jt;
          if (typeof a == "number") return st;
          if (a instanceof di) return Kn;
          if (a instanceof ua) return al;
          if (a instanceof us) return mo;
          if (a instanceof ga) return ss;
          if (a instanceof bn) return Fs;
          if (a instanceof Vn) return os;
          if (a instanceof Dn) return Ba;
          if (a instanceof Wn) return Rn;
          if (a instanceof Ln) return Qi;
          if (Array.isArray(a)) {
            const t = a.length;
            let n;
            for (const l of a) {
              const p = Ut(l);
              if (n) {
                if (n === p) continue;
                n = ii;
                break;
              }
              n = p;
            }
            return Na(n || ii, t);
          }
          return fo;
        }
        function Wt(a) {
          const t = typeof a;
          return a === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(a) : a instanceof di || a instanceof ua || a instanceof ga || a instanceof bn || a instanceof Vn || a instanceof Dn || a instanceof Wn || a instanceof Ln ? a.toString() : JSON.stringify(a);
        }
        class cs {
          constructor(t, n) {
            this.type = t, this.value = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (!Ja(t[1])) return n.error("invalid value");
            const l = t[1];
            let p = Ut(l);
            const v = n.expectedType;
            return p.kind !== "array" || p.N !== 0 || !v || v.kind !== "array" || typeof v.N == "number" && v.N !== 0 || (p = v), new cs(p, l);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        const fi = { string: Zt, number: st, boolean: Jt, object: fo };
        class Aa {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let l, p = 1;
            const v = t[0];
            if (v === "array") {
              let T, E;
              if (t.length > 2) {
                const k = t[1];
                if (typeof k != "string" || !(k in fi) || k === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
                T = fi[k], p++;
              } else T = ii;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
                E = t[2], p++;
              }
              l = Na(T, E);
            } else {
              if (!fi[v]) throw new Error(`Types doesn't contain name = ${v}`);
              l = fi[v];
            }
            const x = [];
            for (; p < t.length; p++) {
              const T = n.parse(t[p], p, ii);
              if (!T) return null;
              x.push(T);
            }
            return new Aa(l, x);
          }
          evaluate(t) {
            for (let n = 0; n < this.args.length; n++) {
              const l = this.args[n].evaluate(t);
              if (!ls(this.type, Ut(l))) return l;
              if (n === this.args.length - 1) throw new Ui(`Expected value to be of type ${Hi(this.type)}, but found ${Hi(Ut(l))} instead.`);
            }
            throw new Error();
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const Wr = { "to-boolean": Jt, "to-color": Kn, "to-number": st, "to-string": Zt };
        class wn {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const l = t[0];
            if (!Wr[l]) throw new Error(`Can't parse ${l} as it is not part of the known types`);
            if ((l === "to-boolean" || l === "to-string") && t.length !== 2) return n.error("Expected one argument.");
            const p = Wr[l], v = [];
            for (let x = 1; x < t.length; x++) {
              const T = n.parse(t[x], x, ii);
              if (!T) return null;
              v.push(T);
            }
            return new wn(p, v);
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let n, l;
                for (const p of this.args) {
                  if (n = p.evaluate(t), l = null, n instanceof di) return n;
                  if (typeof n == "string") {
                    const v = t.parseColor(n);
                    if (v) return v;
                  } else if (Array.isArray(n) && (l = n.length < 3 || n.length > 4 ? `Invalid rgba value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : Fi(n[0], n[1], n[2], n[3]), !l)) return new di(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
                }
                throw new Ui(l || `Could not parse color from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "padding": {
                let n;
                for (const l of this.args) {
                  n = l.evaluate(t);
                  const p = bn.parse(n);
                  if (p) return p;
                }
                throw new Ui(`Could not parse padding from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "numberArray": {
                let n;
                for (const l of this.args) {
                  n = l.evaluate(t);
                  const p = Vn.parse(n);
                  if (p) return p;
                }
                throw new Ui(`Could not parse numberArray from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "colorArray": {
                let n;
                for (const l of this.args) {
                  n = l.evaluate(t);
                  const p = Dn.parse(n);
                  if (p) return p;
                }
                throw new Ui(`Could not parse colorArray from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let n;
                for (const l of this.args) {
                  n = l.evaluate(t);
                  const p = Wn.parse(n);
                  if (p) return p;
                }
                throw new Ui(`Could not parse variableAnchorOffsetCollection from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "number": {
                let n = null;
                for (const l of this.args) {
                  if (n = l.evaluate(t), n === null) return 0;
                  const p = Number(n);
                  if (!isNaN(p)) return p;
                }
                throw new Ui(`Could not convert ${JSON.stringify(n)} to number.`);
              }
              case "formatted":
                return ga.fromString(Wt(this.args[0].evaluate(t)));
              case "resolvedImage":
                return Ln.fromString(Wt(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return Wt(this.args[0].evaluate(t));
            }
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const hs = ["Unknown", "Point", "LineString", "Polygon"];
        class Gl {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? hs[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t) {
            let n = this._parseColorCache.get(t);
            return n || (n = di.parse(t), this._parseColorCache.set(t, n)), n;
          }
        }
        class ds {
          constructor(t, n, l = [], p, v = new Us(), x = []) {
            this.registry = t, this.path = l, this.key = l.map(((T) => `[${T}]`)).join(""), this.scope = v, this.errors = x, this.expectedType = p, this._isConstant = n;
          }
          parse(t, n, l, p, v = {}) {
            return n ? this.concat(n, l, p)._parse(t, v) : this._parse(t, v);
          }
          _parse(t, n) {
            function l(p, v, x) {
              return x === "assert" ? new Aa(v, [p]) : x === "coerce" ? new wn(v, [p]) : p;
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const p = t[0];
              if (typeof p != "string") return this.error(`Expression name must be a string, but found ${typeof p} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const v = this.registry[p];
              if (v) {
                let x = v.parse(t, this);
                if (!x) return null;
                if (this.expectedType) {
                  const T = this.expectedType, E = x.type;
                  if (T.kind !== "string" && T.kind !== "number" && T.kind !== "boolean" && T.kind !== "object" && T.kind !== "array" || E.kind !== "value") {
                    if (T.kind === "projectionDefinition" && ["string", "array"].includes(E.kind) || ["color", "formatted", "resolvedImage"].includes(T.kind) && ["value", "string"].includes(E.kind) || ["padding", "numberArray"].includes(T.kind) && ["value", "number", "array"].includes(E.kind) || T.kind === "colorArray" && ["value", "string", "array"].includes(E.kind) || T.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(E.kind)) x = l(x, T, n.typeAnnotation || "coerce");
                    else if (this.checkSubtype(T, E)) return null;
                  } else x = l(x, T, n.typeAnnotation || "assert");
                }
                if (!(x instanceof cs) && x.type.kind !== "resolvedImage" && this._isConstant(x)) {
                  const T = new Gl();
                  try {
                    x = new cs(x.type, x.evaluate(T));
                  } catch (E) {
                    return this.error(E.message), null;
                  }
                }
                return x;
              }
              return this.error(`Unknown expression "${p}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
          }
          concat(t, n, l) {
            const p = typeof t == "number" ? this.path.concat(t) : this.path, v = l ? this.scope.concat(l) : this.scope;
            return new ds(this.registry, this._isConstant, p, n || null, v, this.errors);
          }
          error(t, ...n) {
            const l = `${this.key}${n.map(((p) => `[${p}]`)).join("")}`;
            this.errors.push(new dn(l, t));
          }
          checkSubtype(t, n) {
            const l = ls(t, n);
            return l && this.error(l), l;
          }
        }
        class Lu {
          constructor(t, n) {
            this.type = n.type, this.bindings = [].concat(t), this.result = n;
          }
          evaluate(t) {
            return this.result.evaluate(t);
          }
          eachChild(t) {
            for (const n of this.bindings) t(n[1]);
            t(this.result);
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
            const l = [];
            for (let v = 1; v < t.length - 1; v += 2) {
              const x = t[v];
              if (typeof x != "string") return n.error(`Expected string, but found ${typeof x} instead.`, v);
              if (/[^a-zA-Z0-9_]/.test(x)) return n.error("Variable names must contain only alphanumeric characters or '_'.", v);
              const T = n.parse(t[v + 1], v + 1);
              if (!T) return null;
              l.push([x, T]);
            }
            const p = n.parse(t[t.length - 1], t.length - 1, n.expectedType, l);
            return p ? new Lu(l, p) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Zl {
          constructor(t, n) {
            this.type = n.type, this.name = t, this.boundExpression = n;
          }
          static parse(t, n) {
            if (t.length !== 2 || typeof t[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
            const l = t[1];
            return n.scope.has(l) ? new Zl(l, n.scope.get(l)) : n.error(`Unknown variable "${l}". Make sure "${l}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t);
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        class $l {
          constructor(t, n, l) {
            this.type = t, this.index = n, this.input = l;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const l = n.parse(t[1], 1, st), p = n.parse(t[2], 2, Na(n.expectedType || ii));
            return l && p ? new $l(p.type.itemType, l, p) : null;
          }
          evaluate(t) {
            const n = this.index.evaluate(t), l = this.input.evaluate(t);
            if (n < 0) throw new Ui(`Array index out of bounds: ${n} < 0.`);
            if (n >= l.length) throw new Ui(`Array index out of bounds: ${n} > ${l.length - 1}.`);
            if (n !== Math.floor(n)) throw new Ui(`Array index must be an integer, but found ${n} instead.`);
            return l[n];
          }
          eachChild(t) {
            t(this.index), t(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class vo {
          constructor(t, n) {
            this.type = Jt, this.needle = t, this.haystack = n;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const l = n.parse(t[1], 1, ii), p = n.parse(t[2], 2, ii);
            return l && p ? Mh(l.type, [Jt, Zt, st, fr, ii]) ? new vo(l, p) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${Hi(l.type)} instead`) : null;
          }
          evaluate(t) {
            const n = this.needle.evaluate(t), l = this.haystack.evaluate(t);
            if (!l) return !1;
            if (!Vs(n, ["boolean", "string", "number", "null"])) throw new Ui(`Expected first argument to be of type boolean, string, number or null, but found ${Hi(Ut(n))} instead.`);
            if (!Vs(l, ["string", "array"])) throw new Ui(`Expected second argument to be of type array or string, but found ${Hi(Ut(l))} instead.`);
            return l.indexOf(n) >= 0;
          }
          eachChild(t) {
            t(this.needle), t(this.haystack);
          }
          outputDefined() {
            return !0;
          }
        }
        class Qa {
          constructor(t, n, l) {
            this.type = st, this.needle = t, this.haystack = n, this.fromIndex = l;
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
            const l = n.parse(t[1], 1, ii), p = n.parse(t[2], 2, ii);
            if (!l || !p) return null;
            if (!Mh(l.type, [Jt, Zt, st, fr, ii])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${Hi(l.type)} instead`);
            if (t.length === 4) {
              const v = n.parse(t[3], 3, st);
              return v ? new Qa(l, p, v) : null;
            }
            return new Qa(l, p);
          }
          evaluate(t) {
            const n = this.needle.evaluate(t), l = this.haystack.evaluate(t);
            if (!Vs(n, ["boolean", "string", "number", "null"])) throw new Ui(`Expected first argument to be of type boolean, string, number or null, but found ${Hi(Ut(n))} instead.`);
            let p;
            if (this.fromIndex && (p = this.fromIndex.evaluate(t)), Vs(l, ["string"])) {
              const v = l.indexOf(n, p);
              return v === -1 ? -1 : [...l.slice(0, v)].length;
            }
            if (Vs(l, ["array"])) return l.indexOf(n, p);
            throw new Ui(`Expected second argument to be of type array or string, but found ${Hi(Ut(l))} instead.`);
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        class Jn {
          constructor(t, n, l, p, v, x) {
            this.inputType = t, this.type = n, this.input = l, this.cases = p, this.outputs = v, this.otherwise = x;
          }
          static parse(t, n) {
            if (t.length < 5) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 1) return n.error("Expected an even number of arguments.");
            let l, p;
            n.expectedType && n.expectedType.kind !== "value" && (p = n.expectedType);
            const v = {}, x = [];
            for (let k = 2; k < t.length - 1; k += 2) {
              let D = t[k];
              const N = t[k + 1];
              Array.isArray(D) || (D = [D]);
              const q = n.concat(k);
              if (D.length === 0) return q.error("Expected at least one branch label.");
              for (const Z of D) {
                if (typeof Z != "number" && typeof Z != "string") return q.error("Branch labels must be numbers or strings.");
                if (typeof Z == "number" && Math.abs(Z) > Number.MAX_SAFE_INTEGER) return q.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof Z == "number" && Math.floor(Z) !== Z) return q.error("Numeric branch labels must be integer values.");
                if (l) {
                  if (q.checkSubtype(l, Ut(Z))) return null;
                } else l = Ut(Z);
                if (v[String(Z)] !== void 0) return q.error("Branch labels must be unique.");
                v[String(Z)] = x.length;
              }
              const G = n.parse(N, k, p);
              if (!G) return null;
              p = p || G.type, x.push(G);
            }
            const T = n.parse(t[1], 1, ii);
            if (!T) return null;
            const E = n.parse(t[t.length - 1], t.length - 1, p);
            return E ? T.type.kind !== "value" && n.concat(1).checkSubtype(l, T.type) ? null : new Jn(l, p, T, v, x, E) : null;
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            return (Ut(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(t);
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class Hl {
          constructor(t, n, l) {
            this.type = t, this.branches = n, this.otherwise = l;
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 0) return n.error("Expected an odd number of arguments.");
            let l;
            n.expectedType && n.expectedType.kind !== "value" && (l = n.expectedType);
            const p = [];
            for (let x = 1; x < t.length - 1; x += 2) {
              const T = n.parse(t[x], x, Jt);
              if (!T) return null;
              const E = n.parse(t[x + 1], x + 1, l);
              if (!E) return null;
              p.push([T, E]), l = l || E.type;
            }
            const v = n.parse(t[t.length - 1], t.length - 1, l);
            if (!v) return null;
            if (!l) throw new Error("Can't infer output type");
            return new Hl(l, p, v);
          }
          evaluate(t) {
            for (const [n, l] of this.branches) if (n.evaluate(t)) return l.evaluate(t);
            return this.otherwise.evaluate(t);
          }
          eachChild(t) {
            for (const [n, l] of this.branches) t(n), t(l);
            t(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((([t, n]) => n.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class Ou {
          constructor(t, n, l, p) {
            this.type = t, this.input = n, this.beginIndex = l, this.endIndex = p;
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
            const l = n.parse(t[1], 1, ii), p = n.parse(t[2], 2, st);
            if (!l || !p) return null;
            if (!Mh(l.type, [Na(ii), Zt, ii])) return n.error(`Expected first argument to be of type array or string, but found ${Hi(l.type)} instead`);
            if (t.length === 4) {
              const v = n.parse(t[3], 3, st);
              return v ? new Ou(l.type, l, p, v) : null;
            }
            return new Ou(l.type, l, p);
          }
          evaluate(t) {
            const n = this.input.evaluate(t), l = this.beginIndex.evaluate(t);
            let p;
            if (this.endIndex && (p = this.endIndex.evaluate(t)), Vs(n, ["string"])) return [...n].slice(l, p).join("");
            if (Vs(n, ["array"])) return n.slice(l, p);
            throw new Ui(`Expected first argument to be of type array or string, but found ${Hi(Ut(n))} instead.`);
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        function ol(a, t) {
          const n = a.length - 1;
          let l, p, v = 0, x = n, T = 0;
          for (; v <= x; ) if (T = Math.floor((v + x) / 2), l = a[T], p = a[T + 1], l <= t) {
            if (T === n || t < p) return T;
            v = T + 1;
          } else {
            if (!(l > t)) throw new Ui("Input is not a number.");
            x = T - 1;
          }
          return 0;
        }
        class pn {
          constructor(t, n, l) {
            this.type = t, this.input = n, this.labels = [], this.outputs = [];
            for (const [p, v] of l) this.labels.push(p), this.outputs.push(v);
          }
          static parse(t, n) {
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            const l = n.parse(t[1], 1, st);
            if (!l) return null;
            const p = [];
            let v = null;
            n.expectedType && n.expectedType.kind !== "value" && (v = n.expectedType);
            for (let x = 1; x < t.length; x += 2) {
              const T = x === 1 ? -1 / 0 : t[x], E = t[x + 1], k = x, D = x + 1;
              if (typeof T != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', k);
              if (p.length && p[p.length - 1][0] >= T) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', k);
              const N = n.parse(E, D, v);
              if (!N) return null;
              v = v || N.type, p.push([T, N]);
            }
            return new pn(v, l, p);
          }
          evaluate(t) {
            const n = this.labels, l = this.outputs;
            if (n.length === 1) return l[0].evaluate(t);
            const p = this.input.evaluate(t);
            if (p <= n[0]) return l[0].evaluate(t);
            const v = n.length;
            return p >= n[v - 1] ? l[v - 1].evaluate(t) : l[ol(n, p)].evaluate(t);
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function Gd(a) {
          return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
        }
        var Bu, Ph, af = (function() {
          if (Ph) return Bu;
          function a(t, n, l, p) {
            this.cx = 3 * t, this.bx = 3 * (l - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (p - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = l, this.p2y = p;
          }
          return Ph = 1, Bu = a, a.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, n) {
            if (n === void 0 && (n = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var l = t, p = 0; p < 8; p++) {
              var v = this.sampleCurveX(l) - t;
              if (Math.abs(v) < n) return l;
              var x = this.sampleCurveDerivativeX(l);
              if (Math.abs(x) < 1e-6) break;
              l -= v / x;
            }
            var T = 0, E = 1;
            for (l = t, p = 0; p < 20 && (v = this.sampleCurveX(l), !(Math.abs(v - t) < n)); p++) t > v ? T = l : E = l, l = 0.5 * (E - T) + T;
            return l;
          }, solve: function(t, n) {
            return this.sampleCurveY(this.solveCurveX(t, n));
          } }, Bu;
        })(), Xl = Gd(af);
        class ca {
          constructor(t, n, l, p, v) {
            this.type = t, this.operator = n, this.interpolation = l, this.input = p, this.labels = [], this.outputs = [];
            for (const [x, T] of v) this.labels.push(x), this.outputs.push(T);
          }
          static interpolationFactor(t, n, l, p) {
            let v = 0;
            if (t.name === "exponential") v = Nu(n, t.base, l, p);
            else if (t.name === "linear") v = Nu(n, 1, l, p);
            else if (t.name === "cubic-bezier") {
              const x = t.controlPoints;
              v = new Xl(x[0], x[1], x[2], x[3]).solve(Nu(n, 1, l, p));
            }
            return v;
          }
          static parse(t, n) {
            let [l, p, v, ...x] = t;
            if (!Array.isArray(p) || p.length === 0) return n.error("Expected an interpolation type expression.", 1);
            if (p[0] === "linear") p = { name: "linear" };
            else if (p[0] === "exponential") {
              const k = p[1];
              if (typeof k != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
              p = { name: "exponential", base: k };
            } else {
              if (p[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(p[0])}`, 1, 0);
              {
                const k = p.slice(1);
                if (k.length !== 4 || k.some(((D) => typeof D != "number" || D < 0 || D > 1))) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                p = { name: "cubic-bezier", controlPoints: k };
              }
            }
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            if (v = n.parse(v, 2, st), !v) return null;
            const T = [];
            let E = null;
            l !== "interpolate-hcl" && l !== "interpolate-lab" || n.expectedType == Ba ? n.expectedType && n.expectedType.kind !== "value" && (E = n.expectedType) : E = Kn;
            for (let k = 0; k < x.length; k += 2) {
              const D = x[k], N = x[k + 1], q = k + 3, G = k + 4;
              if (typeof D != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', q);
              if (T.length && T[T.length - 1][0] >= D) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', q);
              const Z = n.parse(N, G, E);
              if (!Z) return null;
              E = E || Z.type, T.push([D, Z]);
            }
            return qs(E, st) || qs(E, al) || qs(E, Kn) || qs(E, Fs) || qs(E, os) || qs(E, Ba) || qs(E, Rn) || qs(E, Na(st)) ? new ca(E, l, p, v, T) : n.error(`Type ${Hi(E)} is not interpolatable.`);
          }
          evaluate(t) {
            const n = this.labels, l = this.outputs;
            if (n.length === 1) return l[0].evaluate(t);
            const p = this.input.evaluate(t);
            if (p <= n[0]) return l[0].evaluate(t);
            const v = n.length;
            if (p >= n[v - 1]) return l[v - 1].evaluate(t);
            const x = ol(n, p), T = ca.interpolationFactor(this.interpolation, p, n[x], n[x + 1]), E = l[x].evaluate(t), k = l[x + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Kr(E, k, T);
                  case "color":
                    return di.interpolate(E, k, T);
                  case "padding":
                    return bn.interpolate(E, k, T);
                  case "colorArray":
                    return Dn.interpolate(E, k, T);
                  case "numberArray":
                    return Vn.interpolate(E, k, T);
                  case "variableAnchorOffsetCollection":
                    return Wn.interpolate(E, k, T);
                  case "array":
                    return sl(E, k, T);
                  case "projectionDefinition":
                    return ua.interpolate(E, k, T);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return di.interpolate(E, k, T, "hcl");
                  case "colorArray":
                    return Dn.interpolate(E, k, T, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return di.interpolate(E, k, T, "lab");
                  case "colorArray":
                    return Dn.interpolate(E, k, T, "lab");
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function Nu(a, t, n, l) {
          const p = l - n, v = a - n;
          return p === 0 ? 0 : t === 1 ? v / p : (Math.pow(t, v) - 1) / (Math.pow(t, p) - 1);
        }
        const ps = { color: di.interpolate, number: Kr, padding: bn.interpolate, numberArray: Vn.interpolate, colorArray: Dn.interpolate, variableAnchorOffsetCollection: Wn.interpolate, array: sl };
        class ju {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let l = null;
            const p = n.expectedType;
            p && p.kind !== "value" && (l = p);
            const v = [];
            for (const T of t.slice(1)) {
              const E = n.parse(T, 1 + v.length, l, void 0, { typeAnnotation: "omit" });
              if (!E) return null;
              l = l || E.type, v.push(E);
            }
            if (!l) throw new Error("No output type");
            const x = p && v.some(((T) => ls(p, T.type)));
            return new ju(x ? ii : l, v);
          }
          evaluate(t) {
            let n, l = null, p = 0;
            for (const v of this.args) if (p++, l = v.evaluate(t), l && l instanceof Ln && !l.available && (n || (n = l.name), l = null, p === this.args.length && (l = n)), l !== null) break;
            return l;
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        function Uu(a, t) {
          return a === "==" || a === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
        }
        function ll(a, t, n, l) {
          return l.compare(t, n) === 0;
        }
        function Ea(a, t, n) {
          const l = a !== "==" && a !== "!=";
          return class Dv {
            constructor(v, x, T) {
              this.type = Jt, this.lhs = v, this.rhs = x, this.collator = T, this.hasUntypedArgument = v.type.kind === "value" || x.type.kind === "value";
            }
            static parse(v, x) {
              if (v.length !== 3 && v.length !== 4) return x.error("Expected two or three arguments.");
              const T = v[0];
              let E = x.parse(v[1], 1, ii);
              if (!E) return null;
              if (!Uu(T, E.type)) return x.concat(1).error(`"${T}" comparisons are not supported for type '${Hi(E.type)}'.`);
              let k = x.parse(v[2], 2, ii);
              if (!k) return null;
              if (!Uu(T, k.type)) return x.concat(2).error(`"${T}" comparisons are not supported for type '${Hi(k.type)}'.`);
              if (E.type.kind !== k.type.kind && E.type.kind !== "value" && k.type.kind !== "value") return x.error(`Cannot compare types '${Hi(E.type)}' and '${Hi(k.type)}'.`);
              l && (E.type.kind === "value" && k.type.kind !== "value" ? E = new Aa(k.type, [E]) : E.type.kind !== "value" && k.type.kind === "value" && (k = new Aa(E.type, [k])));
              let D = null;
              if (v.length === 4) {
                if (E.type.kind !== "string" && k.type.kind !== "string" && E.type.kind !== "value" && k.type.kind !== "value") return x.error("Cannot use collator to compare non-string types.");
                if (D = x.parse(v[3], 3, mo), !D) return null;
              }
              return new Dv(E, k, D);
            }
            evaluate(v) {
              const x = this.lhs.evaluate(v), T = this.rhs.evaluate(v);
              if (l && this.hasUntypedArgument) {
                const E = Ut(x), k = Ut(T);
                if (E.kind !== k.kind || E.kind !== "string" && E.kind !== "number") throw new Ui(`Expected arguments for "${a}" to be (string, string) or (number, number), but found (${E.kind}, ${k.kind}) instead.`);
              }
              if (this.collator && !l && this.hasUntypedArgument) {
                const E = Ut(x), k = Ut(T);
                if (E.kind !== "string" || k.kind !== "string") return t(v, x, T);
              }
              return this.collator ? n(v, x, T, this.collator.evaluate(v)) : t(v, x, T);
            }
            eachChild(v) {
              v(this.lhs), v(this.rhs), this.collator && v(this.collator);
            }
            outputDefined() {
              return !0;
            }
          };
        }
        const Zd = Ea("==", (function(a, t, n) {
          return t === n;
        }), ll), Lc = Ea("!=", (function(a, t, n) {
          return t !== n;
        }), (function(a, t, n, l) {
          return !ll(0, t, n, l);
        })), $d = Ea("<", (function(a, t, n) {
          return t < n;
        }), (function(a, t, n, l) {
          return l.compare(t, n) < 0;
        })), Ih = Ea(">", (function(a, t, n) {
          return t > n;
        }), (function(a, t, n, l) {
          return l.compare(t, n) > 0;
        })), rf = Ea("<=", (function(a, t, n) {
          return t <= n;
        }), (function(a, t, n, l) {
          return l.compare(t, n) <= 0;
        })), sf = Ea(">=", (function(a, t, n) {
          return t >= n;
        }), (function(a, t, n, l) {
          return l.compare(t, n) >= 0;
        }));
        class Oc {
          constructor(t, n, l) {
            this.type = mo, this.locale = l, this.caseSensitive = t, this.diacriticSensitive = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected one argument.");
            const l = t[1];
            if (typeof l != "object" || Array.isArray(l)) return n.error("Collator options argument must be an object.");
            const p = n.parse(l["case-sensitive"] !== void 0 && l["case-sensitive"], 1, Jt);
            if (!p) return null;
            const v = n.parse(l["diacritic-sensitive"] !== void 0 && l["diacritic-sensitive"], 1, Jt);
            if (!v) return null;
            let x = null;
            return l.locale && (x = n.parse(l.locale, 1, Zt), !x) ? null : new Oc(p, v, x);
          }
          evaluate(t) {
            return new us(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
          }
          outputDefined() {
            return !1;
          }
        }
        class kh {
          constructor(t, n, l, p, v) {
            this.type = Zt, this.number = t, this.locale = n, this.currency = l, this.minFractionDigits = p, this.maxFractionDigits = v;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error("Expected two arguments.");
            const l = n.parse(t[1], 1, st);
            if (!l) return null;
            const p = t[2];
            if (typeof p != "object" || Array.isArray(p)) return n.error("NumberFormat options argument must be an object.");
            let v = null;
            if (p.locale && (v = n.parse(p.locale, 1, Zt), !v)) return null;
            let x = null;
            if (p.currency && (x = n.parse(p.currency, 1, Zt), !x)) return null;
            let T = null;
            if (p["min-fraction-digits"] && (T = n.parse(p["min-fraction-digits"], 1, st), !T)) return null;
            let E = null;
            return p["max-fraction-digits"] && (E = n.parse(p["max-fraction-digits"], 1, st), !E) ? null : new kh(l, v, x, T, E);
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
          }
          outputDefined() {
            return !1;
          }
        }
        class ul {
          constructor(t) {
            this.type = ss, this.sections = t;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const l = t[1];
            if (!Array.isArray(l) && typeof l == "object") return n.error("First argument must be an image or text section.");
            const p = [];
            let v = !1;
            for (let x = 1; x <= t.length - 1; ++x) {
              const T = t[x];
              if (v && typeof T == "object" && !Array.isArray(T)) {
                v = !1;
                let E = null;
                if (T["font-scale"] && (E = n.parse(T["font-scale"], 1, st), !E)) return null;
                let k = null;
                if (T["text-font"] && (k = n.parse(T["text-font"], 1, Na(Zt)), !k)) return null;
                let D = null;
                if (T["text-color"] && (D = n.parse(T["text-color"], 1, Kn), !D)) return null;
                let N = null;
                if (T["vertical-align"]) {
                  if (typeof T["vertical-align"] == "string" && !Rr.includes(T["vertical-align"])) return n.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${T["vertical-align"]}' instead.`);
                  if (N = n.parse(T["vertical-align"], 1, Zt), !N) return null;
                }
                const q = p[p.length - 1];
                q.scale = E, q.font = k, q.textColor = D, q.verticalAlign = N;
              } else {
                const E = n.parse(t[x], 1, ii);
                if (!E) return null;
                const k = E.type.kind;
                if (k !== "string" && k !== "value" && k !== "null" && k !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                v = !0, p.push({ content: E, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new ul(p);
          }
          evaluate(t) {
            return new ga(this.sections.map(((n) => {
              const l = n.content.evaluate(t);
              return Ut(l) === Qi ? new ql("", l, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null) : new ql(Wt(l), null, n.scale ? n.scale.evaluate(t) : null, n.font ? n.font.evaluate(t).join(",") : null, n.textColor ? n.textColor.evaluate(t) : null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null);
            })));
          }
          eachChild(t) {
            for (const n of this.sections) t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor), n.verticalAlign && t(n.verticalAlign);
          }
          outputDefined() {
            return !1;
          }
        }
        class Rh {
          constructor(t) {
            this.type = Qi, this.input = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected two arguments.");
            const l = n.parse(t[1], 1, Zt);
            return l ? new Rh(l) : n.error("No image name provided.");
          }
          evaluate(t) {
            const n = this.input.evaluate(t), l = Ln.fromString(n);
            return l && t.availableImages && (l.available = t.availableImages.indexOf(n) > -1), l;
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class Bc {
          constructor(t) {
            this.type = st, this.input = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const l = n.parse(t[1], 1);
            return l ? l.type.kind !== "array" && l.type.kind !== "string" && l.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${Hi(l.type)} instead.`) : new Bc(l) : null;
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            if (typeof n == "string") return [...n].length;
            if (Array.isArray(n)) return n.length;
            throw new Ui(`Expected value to be of type string or array, but found ${Hi(Ut(n))} instead.`);
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        const Jr = 8192;
        function Dh(a, t) {
          const n = (180 + a[0]) / 360, l = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a[1] * Math.PI / 360))) / 360, p = Math.pow(2, t.z);
          return [Math.round(n * p * Jr), Math.round(l * p * Jr)];
        }
        function xo(a, t) {
          const n = Math.pow(2, t.z);
          return [(p = (a[0] / Jr + t.x) / n, 360 * p - 180), (l = (a[1] / Jr + t.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * l) * Math.PI / 180)) - 90)];
          var l, p;
        }
        function Fu(a, t) {
          a[0] = Math.min(a[0], t[0]), a[1] = Math.min(a[1], t[1]), a[2] = Math.max(a[2], t[0]), a[3] = Math.max(a[3], t[1]);
        }
        function Yl(a, t) {
          return !(a[0] <= t[0] || a[2] >= t[2] || a[1] <= t[1] || a[3] >= t[3]);
        }
        function Hd(a, t, n) {
          const l = a[0] - t[0], p = a[1] - t[1], v = a[0] - n[0], x = a[1] - n[1];
          return l * x - v * p == 0 && l * v <= 0 && p * x <= 0;
        }
        function Vu(a, t, n, l) {
          return (p = [l[0] - n[0], l[1] - n[1]])[0] * (v = [t[0] - a[0], t[1] - a[1]])[1] - p[1] * v[0] != 0 && !(!Yd(a, t, n, l) || !Yd(n, l, a, t));
          var p, v;
        }
        function Xd(a, t, n) {
          for (const l of n) for (let p = 0; p < l.length - 1; ++p) if (Vu(a, t, l[p], l[p + 1])) return !0;
          return !1;
        }
        function bo(a, t, n = !1) {
          let l = !1;
          for (const T of t) for (let E = 0; E < T.length - 1; E++) {
            if (Hd(a, T[E], T[E + 1])) return n;
            (v = T[E])[1] > (p = a)[1] != (x = T[E + 1])[1] > p[1] && p[0] < (x[0] - v[0]) * (p[1] - v[1]) / (x[1] - v[1]) + v[0] && (l = !l);
          }
          var p, v, x;
          return l;
        }
        function cl(a, t) {
          for (const n of t) if (bo(a, n)) return !0;
          return !1;
        }
        function Lh(a, t) {
          for (const n of a) if (!bo(n, t)) return !1;
          for (let n = 0; n < a.length - 1; ++n) if (Xd(a[n], a[n + 1], t)) return !1;
          return !0;
        }
        function of(a, t) {
          for (const n of t) if (Lh(a, n)) return !0;
          return !1;
        }
        function Yd(a, t, n, l) {
          const p = l[0] - n[0], v = l[1] - n[1], x = (a[0] - n[0]) * v - p * (a[1] - n[1]), T = (t[0] - n[0]) * v - p * (t[1] - n[1]);
          return x > 0 && T < 0 || x < 0 && T > 0;
        }
        function Nc(a, t, n) {
          const l = [];
          for (let p = 0; p < a.length; p++) {
            const v = [];
            for (let x = 0; x < a[p].length; x++) {
              const T = Dh(a[p][x], n);
              Fu(t, T), v.push(T);
            }
            l.push(v);
          }
          return l;
        }
        function Oh(a, t, n) {
          const l = [];
          for (let p = 0; p < a.length; p++) {
            const v = Nc(a[p], t, n);
            l.push(v);
          }
          return l;
        }
        function wo(a, t, n, l) {
          if (a[0] < n[0] || a[0] > n[2]) {
            const p = 0.5 * l;
            let v = a[0] - n[0] > p ? -l : n[0] - a[0] > p ? l : 0;
            v === 0 && (v = a[0] - n[2] > p ? -l : n[2] - a[0] > p ? l : 0), a[0] += v;
          }
          Fu(t, a);
        }
        function Kl(a, t, n, l) {
          const p = Math.pow(2, l.z) * Jr, v = [l.x * Jr, l.y * Jr], x = [];
          for (const T of a) for (const E of T) {
            const k = [E.x + v[0], E.y + v[1]];
            wo(k, t, n, p), x.push(k);
          }
          return x;
        }
        function Kd(a, t, n, l) {
          const p = Math.pow(2, l.z) * Jr, v = [l.x * Jr, l.y * Jr], x = [];
          for (const E of a) {
            const k = [];
            for (const D of E) {
              const N = [D.x + v[0], D.y + v[1]];
              Fu(t, N), k.push(N);
            }
            x.push(k);
          }
          if (t[2] - t[0] <= p / 2) {
            (T = t)[0] = T[1] = 1 / 0, T[2] = T[3] = -1 / 0;
            for (const E of x) for (const k of E) wo(k, t, n, p);
          }
          var T;
          return x;
        }
        class fs {
          constructor(t, n) {
            this.type = Jt, this.geojson = t, this.geometries = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (Ja(t[1])) {
              const l = t[1];
              if (l.type === "FeatureCollection") {
                const p = [];
                for (const v of l.features) {
                  const { type: x, coordinates: T } = v.geometry;
                  x === "Polygon" && p.push(T), x === "MultiPolygon" && p.push(...T);
                }
                if (p.length) return new fs(l, { type: "MultiPolygon", coordinates: p });
              } else if (l.type === "Feature") {
                const p = l.geometry.type;
                if (p === "Polygon" || p === "MultiPolygon") return new fs(l, l.geometry);
              } else if (l.type === "Polygon" || l.type === "MultiPolygon") return new fs(l, l);
            }
            return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, l) {
                const p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = n.canonicalID();
                if (l.type === "Polygon") {
                  const T = Nc(l.coordinates, v, x), E = Kl(n.geometry(), p, v, x);
                  if (!Yl(p, v)) return !1;
                  for (const k of E) if (!bo(k, T)) return !1;
                }
                if (l.type === "MultiPolygon") {
                  const T = Oh(l.coordinates, v, x), E = Kl(n.geometry(), p, v, x);
                  if (!Yl(p, v)) return !1;
                  for (const k of E) if (!cl(k, T)) return !1;
                }
                return !0;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, l) {
                const p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = n.canonicalID();
                if (l.type === "Polygon") {
                  const T = Nc(l.coordinates, v, x), E = Kd(n.geometry(), p, v, x);
                  if (!Yl(p, v)) return !1;
                  for (const k of E) if (!Lh(k, T)) return !1;
                }
                if (l.type === "MultiPolygon") {
                  const T = Oh(l.coordinates, v, x), E = Kd(n.geometry(), p, v, x);
                  if (!Yl(p, v)) return !1;
                  for (const k of E) if (!of(k, T)) return !1;
                }
                return !0;
              })(t, this.geometries);
            }
            return !1;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        let jc = class {
          constructor(a = [], t = (n, l) => n < l ? -1 : n > l ? 1 : 0) {
            if (this.data = a, this.length = this.data.length, this.compare = t, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
          }
          push(a) {
            this.data.push(a), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const a = this.data[0], t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), a;
          }
          peek() {
            return this.data[0];
          }
          _up(a) {
            const { data: t, compare: n } = this, l = t[a];
            for (; a > 0; ) {
              const p = a - 1 >> 1, v = t[p];
              if (n(l, v) >= 0) break;
              t[a] = v, a = p;
            }
            t[a] = l;
          }
          _down(a) {
            const { data: t, compare: n } = this, l = this.length >> 1, p = t[a];
            for (; a < l; ) {
              let v = 1 + (a << 1);
              const x = v + 1;
              if (x < this.length && n(t[x], t[v]) < 0 && (v = x), n(t[v], p) >= 0) break;
              t[a] = t[v], a = v;
            }
            t[a] = p;
          }
        };
        function Uc(a, t, n = 0, l = a.length - 1, p = Bh) {
          for (; l > n; ) {
            if (l - n > 600) {
              const E = l - n + 1, k = t - n + 1, D = Math.log(E), N = 0.5 * Math.exp(2 * D / 3), q = 0.5 * Math.sqrt(D * N * (E - N) / E) * (k - E / 2 < 0 ? -1 : 1);
              Uc(a, t, Math.max(n, Math.floor(t - k * N / E + q)), Math.min(l, Math.floor(t + (E - k) * N / E + q)), p);
            }
            const v = a[t];
            let x = n, T = l;
            for (hl(a, n, t), p(a[l], v) > 0 && hl(a, n, l); x < T; ) {
              for (hl(a, x, T), x++, T--; p(a[x], v) < 0; ) x++;
              for (; p(a[T], v) > 0; ) T--;
            }
            p(a[n], v) === 0 ? hl(a, n, T) : (T++, hl(a, T, l)), T <= t && (n = T + 1), t <= T && (l = T - 1);
          }
        }
        function hl(a, t, n) {
          const l = a[t];
          a[t] = a[n], a[n] = l;
        }
        function Bh(a, t) {
          return a < t ? -1 : a > t ? 1 : 0;
        }
        function Wl(a, t) {
          if (a.length <= 1) return [a];
          const n = [];
          let l, p;
          for (const v of a) {
            const x = Wd(v);
            x !== 0 && (v.area = Math.abs(x), p === void 0 && (p = x < 0), p === x < 0 ? (l && n.push(l), l = [v]) : l.push(v));
          }
          if (l && n.push(l), t > 1) for (let v = 0; v < n.length; v++) n[v].length <= t || (Uc(n[v], t, 1, n[v].length - 1, Nh), n[v] = n[v].slice(0, t));
          return n;
        }
        function Nh(a, t) {
          return t.area - a.area;
        }
        function Wd(a) {
          let t = 0;
          for (let n, l, p = 0, v = a.length, x = v - 1; p < v; x = p++) n = a[p], l = a[x], t += (l.x - n.x) * (n.y + l.y);
          return t;
        }
        const Jd = 1 / 298.257223563, Qd = Jd * (2 - Jd), jh = Math.PI / 180;
        class Uh {
          constructor(t) {
            const n = 6378.137 * jh * 1e3, l = Math.cos(t * jh), p = 1 / (1 - Qd * (1 - l * l)), v = Math.sqrt(p);
            this.kx = n * v * l, this.ky = n * v * p * (1 - Qd);
          }
          distance(t, n) {
            const l = this.wrap(t[0] - n[0]) * this.kx, p = (t[1] - n[1]) * this.ky;
            return Math.sqrt(l * l + p * p);
          }
          pointOnLine(t, n) {
            let l, p, v, x, T = 1 / 0;
            for (let E = 0; E < t.length - 1; E++) {
              let k = t[E][0], D = t[E][1], N = this.wrap(t[E + 1][0] - k) * this.kx, q = (t[E + 1][1] - D) * this.ky, G = 0;
              N === 0 && q === 0 || (G = (this.wrap(n[0] - k) * this.kx * N + (n[1] - D) * this.ky * q) / (N * N + q * q), G > 1 ? (k = t[E + 1][0], D = t[E + 1][1]) : G > 0 && (k += N / this.kx * G, D += q / this.ky * G)), N = this.wrap(n[0] - k) * this.kx, q = (n[1] - D) * this.ky;
              const Z = N * N + q * q;
              Z < T && (T = Z, l = k, p = D, v = E, x = G);
            }
            return { point: [l, p], index: v, t: Math.max(0, Math.min(1, x)) };
          }
          wrap(t) {
            for (; t < -180; ) t += 360;
            for (; t > 180; ) t -= 360;
            return t;
          }
        }
        function ep(a, t) {
          return t[0] - a[0];
        }
        function Ca(a) {
          return a[1] - a[0] + 1;
        }
        function gr(a, t) {
          return a[1] >= a[0] && a[1] < t;
        }
        function Ci(a, t) {
          if (a[0] > a[1]) return [null, null];
          const n = Ca(a);
          if (t) {
            if (n === 2) return [a, null];
            const p = Math.floor(n / 2);
            return [[a[0], a[0] + p], [a[0] + p, a[1]]];
          }
          if (n === 1) return [a, null];
          const l = Math.floor(n / 2) - 1;
          return [[a[0], a[0] + l], [a[0] + l + 1, a[1]]];
        }
        function Fc(a, t) {
          if (!gr(t, a.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let l = t[0]; l <= t[1]; ++l) Fu(n, a[l]);
          return n;
        }
        function Vc(a) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const n of a) for (const l of n) Fu(t, l);
          return t;
        }
        function Fh(a) {
          return a[0] !== -1 / 0 && a[1] !== -1 / 0 && a[2] !== 1 / 0 && a[3] !== 1 / 0;
        }
        function qu(a, t, n) {
          if (!Fh(a) || !Fh(t)) return NaN;
          let l = 0, p = 0;
          return a[2] < t[0] && (l = t[0] - a[2]), a[0] > t[2] && (l = a[0] - t[2]), a[1] > t[3] && (p = a[1] - t[3]), a[3] < t[1] && (p = t[1] - a[3]), n.distance([0, 0], [l, p]);
        }
        function dl(a, t, n) {
          const l = n.pointOnLine(t, a);
          return n.distance(a, l.point);
        }
        function So(a, t, n, l, p) {
          const v = Math.min(dl(a, [n, l], p), dl(t, [n, l], p)), x = Math.min(dl(n, [a, t], p), dl(l, [a, t], p));
          return Math.min(v, x);
        }
        function Vh(a, t, n, l, p) {
          if (!gr(t, a.length) || !gr(l, n.length)) return 1 / 0;
          let v = 1 / 0;
          for (let x = t[0]; x < t[1]; ++x) {
            const T = a[x], E = a[x + 1];
            for (let k = l[0]; k < l[1]; ++k) {
              const D = n[k], N = n[k + 1];
              if (Vu(T, E, D, N)) return 0;
              v = Math.min(v, So(T, E, D, N, p));
            }
          }
          return v;
        }
        function Gu(a, t, n, l, p) {
          if (!gr(t, a.length) || !gr(l, n.length)) return NaN;
          let v = 1 / 0;
          for (let x = t[0]; x <= t[1]; ++x) for (let T = l[0]; T <= l[1]; ++T) if (v = Math.min(v, p.distance(a[x], n[T])), v === 0) return v;
          return v;
        }
        function qh(a, t, n) {
          if (bo(a, t, !0)) return 0;
          let l = 1 / 0;
          for (const p of t) {
            const v = p[0], x = p[p.length - 1];
            if (v !== x && (l = Math.min(l, dl(a, [x, v], n)), l === 0)) return l;
            const T = n.pointOnLine(p, a);
            if (l = Math.min(l, n.distance(a, T.point)), l === 0) return l;
          }
          return l;
        }
        function tp(a, t, n, l) {
          if (!gr(t, a.length)) return NaN;
          for (let v = t[0]; v <= t[1]; ++v) if (bo(a[v], n, !0)) return 0;
          let p = 1 / 0;
          for (let v = t[0]; v < t[1]; ++v) {
            const x = a[v], T = a[v + 1];
            for (const E of n) for (let k = 0, D = E.length, N = D - 1; k < D; N = k++) {
              const q = E[N], G = E[k];
              if (Vu(x, T, q, G)) return 0;
              p = Math.min(p, So(x, T, q, G, l));
            }
          }
          return p;
        }
        function To(a, t) {
          for (const n of a) for (const l of n) if (bo(l, t, !0)) return !0;
          return !1;
        }
        function Jl(a, t, n, l = 1 / 0) {
          const p = Vc(a), v = Vc(t);
          if (l !== 1 / 0 && qu(p, v, n) >= l) return l;
          if (Yl(p, v)) {
            if (To(a, t)) return 0;
          } else if (To(t, a)) return 0;
          let x = 1 / 0;
          for (const T of a) for (let E = 0, k = T.length, D = k - 1; E < k; D = E++) {
            const N = T[D], q = T[E];
            for (const G of t) for (let Z = 0, X = G.length, ee = X - 1; Z < X; ee = Z++) {
              const se = G[ee], xe = G[Z];
              if (Vu(N, q, se, xe)) return 0;
              x = Math.min(x, So(N, q, se, xe, n));
            }
          }
          return x;
        }
        function qc(a, t, n, l, p, v) {
          if (!v) return;
          const x = qu(Fc(l, v), p, n);
          x < t && a.push([x, v, [0, 0]]);
        }
        function Zu(a, t, n, l, p, v, x) {
          if (!v || !x) return;
          const T = qu(Fc(l, v), Fc(p, x), n);
          T < t && a.push([T, v, x]);
        }
        function ms(a, t, n, l, p = 1 / 0) {
          let v = Math.min(l.distance(a[0], n[0][0]), p);
          if (v === 0) return v;
          const x = new jc([[0, [0, a.length - 1], [0, 0]]], ep), T = Vc(n);
          for (; x.length > 0; ) {
            const E = x.pop();
            if (E[0] >= v) continue;
            const k = E[1], D = t ? 50 : 100;
            if (Ca(k) <= D) {
              if (!gr(k, a.length)) return NaN;
              if (t) {
                const N = tp(a, k, n, l);
                if (isNaN(N) || N === 0) return N;
                v = Math.min(v, N);
              } else for (let N = k[0]; N <= k[1]; ++N) {
                const q = qh(a[N], n, l);
                if (v = Math.min(v, q), v === 0) return 0;
              }
            } else {
              const N = Ci(k, t);
              qc(x, v, l, a, T, N[0]), qc(x, v, l, a, T, N[1]);
            }
          }
          return v;
        }
        function $u(a, t, n, l, p, v = 1 / 0) {
          let x = Math.min(v, p.distance(a[0], n[0]));
          if (x === 0) return x;
          const T = new jc([[0, [0, a.length - 1], [0, n.length - 1]]], ep);
          for (; T.length > 0; ) {
            const E = T.pop();
            if (E[0] >= x) continue;
            const k = E[1], D = E[2], N = t ? 50 : 100, q = l ? 50 : 100;
            if (Ca(k) <= N && Ca(D) <= q) {
              if (!gr(k, a.length) && gr(D, n.length)) return NaN;
              let G;
              if (t && l) G = Vh(a, k, n, D, p), x = Math.min(x, G);
              else if (t && !l) {
                const Z = a.slice(k[0], k[1] + 1);
                for (let X = D[0]; X <= D[1]; ++X) if (G = dl(n[X], Z, p), x = Math.min(x, G), x === 0) return x;
              } else if (!t && l) {
                const Z = n.slice(D[0], D[1] + 1);
                for (let X = k[0]; X <= k[1]; ++X) if (G = dl(a[X], Z, p), x = Math.min(x, G), x === 0) return x;
              } else G = Gu(a, k, n, D, p), x = Math.min(x, G);
            } else {
              const G = Ci(k, t), Z = Ci(D, l);
              Zu(T, x, p, a, n, G[0], Z[0]), Zu(T, x, p, a, n, G[0], Z[1]), Zu(T, x, p, a, n, G[1], Z[0]), Zu(T, x, p, a, n, G[1], Z[1]);
            }
          }
          return x;
        }
        function Gc(a) {
          return a.type === "MultiPolygon" ? a.coordinates.map(((t) => ({ type: "Polygon", coordinates: t }))) : a.type === "MultiLineString" ? a.coordinates.map(((t) => ({ type: "LineString", coordinates: t }))) : a.type === "MultiPoint" ? a.coordinates.map(((t) => ({ type: "Point", coordinates: t }))) : [a];
        }
        class Mo {
          constructor(t, n) {
            this.type = st, this.geojson = t, this.geometries = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (Ja(t[1])) {
              const l = t[1];
              if (l.type === "FeatureCollection") return new Mo(l, l.features.map(((p) => Gc(p.geometry))).flat());
              if (l.type === "Feature") return new Mo(l, Gc(l.geometry));
              if ("type" in l && "coordinates" in l) return new Mo(l, Gc(l));
            }
            return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, l) {
                const p = n.geometry(), v = p.flat().map(((E) => xo([E.x, E.y], n.canonical)));
                if (p.length === 0) return NaN;
                const x = new Uh(v[0][1]);
                let T = 1 / 0;
                for (const E of l) {
                  switch (E.type) {
                    case "Point":
                      T = Math.min(T, $u(v, !1, [E.coordinates], !1, x, T));
                      break;
                    case "LineString":
                      T = Math.min(T, $u(v, !1, E.coordinates, !0, x, T));
                      break;
                    case "Polygon":
                      T = Math.min(T, ms(v, !1, E.coordinates, x, T));
                  }
                  if (T === 0) return T;
                }
                return T;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, l) {
                const p = n.geometry(), v = p.flat().map(((E) => xo([E.x, E.y], n.canonical)));
                if (p.length === 0) return NaN;
                const x = new Uh(v[0][1]);
                let T = 1 / 0;
                for (const E of l) {
                  switch (E.type) {
                    case "Point":
                      T = Math.min(T, $u(v, !0, [E.coordinates], !1, x, T));
                      break;
                    case "LineString":
                      T = Math.min(T, $u(v, !0, E.coordinates, !0, x, T));
                      break;
                    case "Polygon":
                      T = Math.min(T, ms(v, !0, E.coordinates, x, T));
                  }
                  if (T === 0) return T;
                }
                return T;
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(n, l) {
                const p = n.geometry();
                if (p.length === 0 || p[0].length === 0) return NaN;
                const v = Wl(p, 0).map(((E) => E.map(((k) => k.map(((D) => xo([D.x, D.y], n.canonical))))))), x = new Uh(v[0][0][0][1]);
                let T = 1 / 0;
                for (const E of l) for (const k of v) {
                  switch (E.type) {
                    case "Point":
                      T = Math.min(T, ms([E.coordinates], !1, k, x, T));
                      break;
                    case "LineString":
                      T = Math.min(T, ms(E.coordinates, !0, k, x, T));
                      break;
                    case "Polygon":
                      T = Math.min(T, Jl(k, E.coordinates, x, T));
                  }
                  if (T === 0) return T;
                }
                return T;
              })(t, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        class Hu {
          constructor(t) {
            this.type = ii, this.key = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const l = t[1];
            return l == null ? n.error("Global state property must be defined.") : typeof l != "string" ? n.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Hu(l);
          }
          evaluate(t) {
            var n;
            const l = (n = t.globals) === null || n === void 0 ? void 0 : n.globalState;
            return l && Object.keys(l).length !== 0 ? rl(l, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        const Ql = { "==": Zd, "!=": Lc, ">": Ih, "<": $d, ">=": sf, "<=": rf, array: Aa, at: $l, boolean: Aa, case: Hl, coalesce: ju, collator: Oc, format: ul, image: Rh, in: vo, "index-of": Qa, interpolate: ca, "interpolate-hcl": ca, "interpolate-lab": ca, length: Bc, let: Lu, literal: cs, match: Jn, number: Aa, "number-format": kh, object: Aa, slice: Ou, step: pn, string: Aa, "to-boolean": wn, "to-color": wn, "to-number": wn, "to-string": wn, var: Zl, within: fs, distance: Mo, "global-state": Hu };
        class Dr {
          constructor(t, n, l, p) {
            this.name = t, this.type = n, this._evaluate = l, this.args = p;
          }
          evaluate(t) {
            return this._evaluate(t, this.args);
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return !1;
          }
          static parse(t, n) {
            const l = t[0], p = Dr.definitions[l];
            if (!p) return n.error(`Unknown expression "${l}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const v = Array.isArray(p) ? p[0] : p.type, x = Array.isArray(p) ? [[p[1], p[2]]] : p.overloads, T = x.filter((([k]) => !Array.isArray(k) || k.length === t.length - 1));
            let E = null;
            for (const [k, D] of T) {
              E = new ds(n.registry, pl, n.path, null, n.scope);
              const N = [];
              let q = !1;
              for (let G = 1; G < t.length; G++) {
                const Z = t[G], X = Array.isArray(k) ? k[G - 1] : k.type, ee = E.parse(Z, 1 + N.length, X);
                if (!ee) {
                  q = !0;
                  break;
                }
                N.push(ee);
              }
              if (!q) if (Array.isArray(k) && k.length !== N.length) E.error(`Expected ${k.length} arguments, but found ${N.length} instead.`);
              else {
                for (let G = 0; G < N.length; G++) {
                  const Z = Array.isArray(k) ? k[G] : k.type, X = N[G];
                  E.concat(G + 1).checkSubtype(Z, X.type);
                }
                if (E.errors.length === 0) return new Dr(l, v, D, N);
              }
            }
            if (T.length === 1) n.errors.push(...E.errors);
            else {
              const k = (T.length ? T : x).map((([N]) => {
                return q = N, Array.isArray(q) ? `(${q.map(Hi).join(", ")})` : `(${Hi(q.type)}...)`;
                var q;
              })).join(" | "), D = [];
              for (let N = 1; N < t.length; N++) {
                const q = n.parse(t[N], 1 + D.length);
                if (!q) return null;
                D.push(Hi(q.type));
              }
              n.error(`Expected arguments of type ${k}, but found (${D.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t, n) {
            Dr.definitions = n;
            for (const l in n) t[l] = Dr;
          }
        }
        function Gh(a, [t, n, l, p]) {
          t = t.evaluate(a), n = n.evaluate(a), l = l.evaluate(a);
          const v = p ? p.evaluate(a) : 1, x = Fi(t, n, l, v);
          if (x) throw new Ui(x);
          return new di(t / 255, n / 255, l / 255, v, !1);
        }
        function Zh(a, t) {
          return a in t;
        }
        function Xu(a, t) {
          const n = t[a];
          return n === void 0 ? null : n;
        }
        function ya(a) {
          return { type: a };
        }
        function pl(a) {
          if (a instanceof Zl) return pl(a.boundExpression);
          if (a instanceof Dr && a.name === "error" || a instanceof Oc || a instanceof fs || a instanceof Mo || a instanceof Hu) return !1;
          const t = a instanceof wn || a instanceof Aa;
          let n = !0;
          return a.eachChild(((l) => {
            n = t ? n && pl(l) : n && l instanceof cs;
          })), !!n && ja(a) && eu(a, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function ja(a) {
          if (a instanceof Dr && (a.name === "get" && a.args.length === 1 || a.name === "feature-state" || a.name === "has" && a.args.length === 1 || a.name === "properties" || a.name === "geometry-type" || a.name === "id" || /^filter-/.test(a.name)) || a instanceof fs || a instanceof Mo) return !1;
          let t = !0;
          return a.eachChild(((n) => {
            t && !ja(n) && (t = !1);
          })), t;
        }
        function gs(a) {
          if (a instanceof Dr && a.name === "feature-state") return !1;
          let t = !0;
          return a.eachChild(((n) => {
            t && !gs(n) && (t = !1);
          })), t;
        }
        function eu(a, t) {
          if (a instanceof Dr && t.indexOf(a.name) >= 0) return !1;
          let n = !0;
          return a.eachChild(((l) => {
            n && !eu(l, t) && (n = !1);
          })), n;
        }
        function Yu(a) {
          return { result: "success", value: a };
        }
        function $s(a) {
          return { result: "error", value: a };
        }
        function ys(a) {
          return a["property-type"] === "data-driven" || a["property-type"] === "cross-faded-data-driven";
        }
        function Ao(a) {
          return !!a.expression && a.expression.parameters.indexOf("zoom") > -1;
        }
        function Zc(a) {
          return !!a.expression && a.expression.interpolated;
        }
        function oi(a) {
          return a instanceof Number ? "number" : a instanceof String ? "string" : a instanceof Boolean ? "boolean" : Array.isArray(a) ? "array" : a === null ? "null" : typeof a;
        }
        function _s(a) {
          return typeof a == "object" && a !== null && !Array.isArray(a) && Ut(a) === fo;
        }
        function lf(a) {
          return a;
        }
        function er(a, t) {
          const n = a.stops && typeof a.stops[0][0] == "object", l = n || !(n || a.property !== void 0), p = a.type || (Zc(t) ? "exponential" : "interval"), v = (function(D) {
            switch (D.type) {
              case "color":
                return di.parse;
              case "padding":
                return bn.parse;
              case "numberArray":
                return Vn.parse;
              case "colorArray":
                return Dn.parse;
              default:
                return null;
            }
          })(t);
          if (v && ((a = la({}, a)).stops && (a.stops = a.stops.map(((D) => [D[0], v(D[1])]))), a.default = v(a.default ? a.default : t.default)), a.colorSpace && (x = a.colorSpace) !== "rgb" && x !== "hcl" && x !== "lab") throw new Error(`Unknown color space: "${a.colorSpace}"`);
          var x;
          const T = (function(D) {
            switch (D) {
              case "exponential":
                return Ku;
              case "interval":
                return ip;
              case "categorical":
                return xs;
              case "identity":
                return fl;
              default:
                throw new Error(`Unknown function type "${D}"`);
            }
          })(p);
          let E, k;
          if (p === "categorical") {
            E = /* @__PURE__ */ Object.create(null);
            for (const D of a.stops) E[D[0]] = D[1];
            k = typeof a.stops[0][0];
          }
          if (n) {
            const D = {}, N = [];
            for (let Z = 0; Z < a.stops.length; Z++) {
              const X = a.stops[Z], ee = X[0].zoom;
              D[ee] === void 0 && (D[ee] = { zoom: ee, type: a.type, property: a.property, default: a.default, stops: [] }, N.push(ee)), D[ee].stops.push([X[0].value, X[1]]);
            }
            const q = [];
            for (const Z of N) q.push([D[Z].zoom, er(D[Z], t)]);
            const G = { name: "linear" };
            return { kind: "composite", interpolationType: G, interpolationFactor: ca.interpolationFactor.bind(void 0, G), zoomStops: q.map(((Z) => Z[0])), evaluate: ({ zoom: Z }, X) => Ku({ stops: q, base: a.base }, t, Z).evaluate(Z, X) };
          }
          if (l) {
            const D = p === "exponential" ? { name: "exponential", base: a.base !== void 0 ? a.base : 1 } : null;
            return { kind: "camera", interpolationType: D, interpolationFactor: ca.interpolationFactor.bind(void 0, D), zoomStops: a.stops.map(((N) => N[0])), evaluate: ({ zoom: N }) => T(a, t, N, E, k) };
          }
          return { kind: "source", evaluate(D, N) {
            const q = N && N.properties ? N.properties[a.property] : void 0;
            return q === void 0 ? vs(a.default, t.default) : T(a, t, q, E, k);
          } };
        }
        function vs(a, t, n) {
          return a !== void 0 ? a : t !== void 0 ? t : n !== void 0 ? n : void 0;
        }
        function xs(a, t, n, l, p) {
          return vs(typeof n === p ? l[n] : void 0, a.default, t.default);
        }
        function ip(a, t, n) {
          if (oi(n) !== "number") return vs(a.default, t.default);
          const l = a.stops.length;
          if (l === 1 || n <= a.stops[0][0]) return a.stops[0][1];
          if (n >= a.stops[l - 1][0]) return a.stops[l - 1][1];
          const p = ol(a.stops.map(((v) => v[0])), n);
          return a.stops[p][1];
        }
        function Ku(a, t, n) {
          const l = a.base !== void 0 ? a.base : 1;
          if (oi(n) !== "number") return vs(a.default, t.default);
          const p = a.stops.length;
          if (p === 1 || n <= a.stops[0][0]) return a.stops[0][1];
          if (n >= a.stops[p - 1][0]) return a.stops[p - 1][1];
          const v = ol(a.stops.map(((D) => D[0])), n), x = (function(D, N, q, G) {
            const Z = G - q, X = D - q;
            return Z === 0 ? 0 : N === 1 ? X / Z : (Math.pow(N, X) - 1) / (Math.pow(N, Z) - 1);
          })(n, l, a.stops[v][0], a.stops[v + 1][0]), T = a.stops[v][1], E = a.stops[v + 1][1], k = ps[t.type] || lf;
          return typeof T.evaluate == "function" ? { evaluate(...D) {
            const N = T.evaluate.apply(void 0, D), q = E.evaluate.apply(void 0, D);
            if (N !== void 0 && q !== void 0) return k(N, q, x, a.colorSpace);
          } } : k(T, E, x, a.colorSpace);
        }
        function fl(a, t, n) {
          switch (t.type) {
            case "color":
              n = di.parse(n);
              break;
            case "formatted":
              n = ga.fromString(n.toString());
              break;
            case "resolvedImage":
              n = Ln.fromString(n.toString());
              break;
            case "padding":
              n = bn.parse(n);
              break;
            case "colorArray":
              n = Dn.parse(n);
              break;
            case "numberArray":
              n = Vn.parse(n);
              break;
            default:
              oi(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0);
          }
          return vs(n, a.default, t.default);
        }
        Dr.register(Ql, { error: [{ kind: "error" }, [Zt], (a, [t]) => {
          throw new Ui(t.evaluate(a));
        }], typeof: [Zt, [ii], (a, [t]) => Hi(Ut(t.evaluate(a)))], "to-rgba": [Na(st, 4), [Kn], (a, [t]) => {
          const [n, l, p, v] = t.evaluate(a).rgb;
          return [255 * n, 255 * l, 255 * p, v];
        }], rgb: [Kn, [st, st, st], Gh], rgba: [Kn, [st, st, st, st], Gh], has: { type: Jt, overloads: [[[Zt], (a, [t]) => Zh(t.evaluate(a), a.properties())], [[Zt, fo], (a, [t, n]) => Zh(t.evaluate(a), n.evaluate(a))]] }, get: { type: ii, overloads: [[[Zt], (a, [t]) => Xu(t.evaluate(a), a.properties())], [[Zt, fo], (a, [t, n]) => Xu(t.evaluate(a), n.evaluate(a))]] }, "feature-state": [ii, [Zt], (a, [t]) => Xu(t.evaluate(a), a.featureState || {})], properties: [fo, [], (a) => a.properties()], "geometry-type": [Zt, [], (a) => a.geometryType()], id: [ii, [], (a) => a.id()], zoom: [st, [], (a) => a.globals.zoom], "heatmap-density": [st, [], (a) => a.globals.heatmapDensity || 0], elevation: [st, [], (a) => a.globals.elevation || 0], "line-progress": [st, [], (a) => a.globals.lineProgress || 0], accumulated: [ii, [], (a) => a.globals.accumulated === void 0 ? null : a.globals.accumulated], "+": [st, ya(st), (a, t) => {
          let n = 0;
          for (const l of t) n += l.evaluate(a);
          return n;
        }], "*": [st, ya(st), (a, t) => {
          let n = 1;
          for (const l of t) n *= l.evaluate(a);
          return n;
        }], "-": { type: st, overloads: [[[st, st], (a, [t, n]) => t.evaluate(a) - n.evaluate(a)], [[st], (a, [t]) => -t.evaluate(a)]] }, "/": [st, [st, st], (a, [t, n]) => t.evaluate(a) / n.evaluate(a)], "%": [st, [st, st], (a, [t, n]) => t.evaluate(a) % n.evaluate(a)], ln2: [st, [], () => Math.LN2], pi: [st, [], () => Math.PI], e: [st, [], () => Math.E], "^": [st, [st, st], (a, [t, n]) => Math.pow(t.evaluate(a), n.evaluate(a))], sqrt: [st, [st], (a, [t]) => Math.sqrt(t.evaluate(a))], log10: [st, [st], (a, [t]) => Math.log(t.evaluate(a)) / Math.LN10], ln: [st, [st], (a, [t]) => Math.log(t.evaluate(a))], log2: [st, [st], (a, [t]) => Math.log(t.evaluate(a)) / Math.LN2], sin: [st, [st], (a, [t]) => Math.sin(t.evaluate(a))], cos: [st, [st], (a, [t]) => Math.cos(t.evaluate(a))], tan: [st, [st], (a, [t]) => Math.tan(t.evaluate(a))], asin: [st, [st], (a, [t]) => Math.asin(t.evaluate(a))], acos: [st, [st], (a, [t]) => Math.acos(t.evaluate(a))], atan: [st, [st], (a, [t]) => Math.atan(t.evaluate(a))], min: [st, ya(st), (a, t) => Math.min(...t.map(((n) => n.evaluate(a))))], max: [st, ya(st), (a, t) => Math.max(...t.map(((n) => n.evaluate(a))))], abs: [st, [st], (a, [t]) => Math.abs(t.evaluate(a))], round: [st, [st], (a, [t]) => {
          const n = t.evaluate(a);
          return n < 0 ? -Math.round(-n) : Math.round(n);
        }], floor: [st, [st], (a, [t]) => Math.floor(t.evaluate(a))], ceil: [st, [st], (a, [t]) => Math.ceil(t.evaluate(a))], "filter-==": [Jt, [Zt, ii], (a, [t, n]) => a.properties()[t.value] === n.value], "filter-id-==": [Jt, [ii], (a, [t]) => a.id() === t.value], "filter-type-==": [Jt, [Zt], (a, [t]) => a.geometryType() === t.value], "filter-<": [Jt, [Zt, ii], (a, [t, n]) => {
          const l = a.properties()[t.value], p = n.value;
          return typeof l == typeof p && l < p;
        }], "filter-id-<": [Jt, [ii], (a, [t]) => {
          const n = a.id(), l = t.value;
          return typeof n == typeof l && n < l;
        }], "filter->": [Jt, [Zt, ii], (a, [t, n]) => {
          const l = a.properties()[t.value], p = n.value;
          return typeof l == typeof p && l > p;
        }], "filter-id->": [Jt, [ii], (a, [t]) => {
          const n = a.id(), l = t.value;
          return typeof n == typeof l && n > l;
        }], "filter-<=": [Jt, [Zt, ii], (a, [t, n]) => {
          const l = a.properties()[t.value], p = n.value;
          return typeof l == typeof p && l <= p;
        }], "filter-id-<=": [Jt, [ii], (a, [t]) => {
          const n = a.id(), l = t.value;
          return typeof n == typeof l && n <= l;
        }], "filter->=": [Jt, [Zt, ii], (a, [t, n]) => {
          const l = a.properties()[t.value], p = n.value;
          return typeof l == typeof p && l >= p;
        }], "filter-id->=": [Jt, [ii], (a, [t]) => {
          const n = a.id(), l = t.value;
          return typeof n == typeof l && n >= l;
        }], "filter-has": [Jt, [ii], (a, [t]) => t.value in a.properties()], "filter-has-id": [Jt, [], (a) => a.id() !== null && a.id() !== void 0], "filter-type-in": [Jt, [Na(Zt)], (a, [t]) => t.value.indexOf(a.geometryType()) >= 0], "filter-id-in": [Jt, [Na(ii)], (a, [t]) => t.value.indexOf(a.id()) >= 0], "filter-in-small": [Jt, [Zt, Na(ii)], (a, [t, n]) => n.value.indexOf(a.properties()[t.value]) >= 0], "filter-in-large": [Jt, [Zt, Na(ii)], (a, [t, n]) => (function(l, p, v, x) {
          for (; v <= x; ) {
            const T = v + x >> 1;
            if (p[T] === l) return !0;
            p[T] > l ? x = T - 1 : v = T + 1;
          }
          return !1;
        })(a.properties()[t.value], n.value, 0, n.value.length - 1)], all: { type: Jt, overloads: [[[Jt, Jt], (a, [t, n]) => t.evaluate(a) && n.evaluate(a)], [ya(Jt), (a, t) => {
          for (const n of t) if (!n.evaluate(a)) return !1;
          return !0;
        }]] }, any: { type: Jt, overloads: [[[Jt, Jt], (a, [t, n]) => t.evaluate(a) || n.evaluate(a)], [ya(Jt), (a, t) => {
          for (const n of t) if (n.evaluate(a)) return !0;
          return !1;
        }]] }, "!": [Jt, [Jt], (a, [t]) => !t.evaluate(a)], "is-supported-script": [Jt, [Zt], (a, [t]) => {
          const n = a.globals && a.globals.isSupportedScript;
          return !n || n(t.evaluate(a));
        }], upcase: [Zt, [Zt], (a, [t]) => t.evaluate(a).toUpperCase()], downcase: [Zt, [Zt], (a, [t]) => t.evaluate(a).toLowerCase()], concat: [Zt, ya(ii), (a, t) => t.map(((n) => Wt(n.evaluate(a)))).join("")], "resolved-locale": [Zt, [mo], (a, [t]) => t.evaluate(a).resolvedLocale()] });
        class Wu {
          constructor(t, n) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new Gl(), this._defaultValue = n ? (function(l) {
              if (l.type === "color" && _s(l.default)) return new di(0, 0, 0, 0);
              switch (l.type) {
                case "color":
                  return di.parse(l.default) || null;
                case "padding":
                  return bn.parse(l.default) || null;
                case "numberArray":
                  return Vn.parse(l.default) || null;
                case "colorArray":
                  return Dn.parse(l.default) || null;
                case "variableAnchorOffsetCollection":
                  return Wn.parse(l.default) || null;
                case "projectionDefinition":
                  return ua.parse(l.default) || null;
                default:
                  return l.default === void 0 ? null : l.default;
              }
            })(n) : null, this._enumValues = n && n.type === "enum" ? n.values : null;
          }
          evaluateWithoutErrorHandling(t, n, l, p, v, x) {
            return this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = l, this._evaluator.canonical = p, this._evaluator.availableImages = v || null, this._evaluator.formattedSection = x, this.expression.evaluate(this._evaluator);
          }
          evaluate(t, n, l, p, v, x) {
            this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = l || null, this._evaluator.canonical = p, this._evaluator.availableImages = v || null, this._evaluator.formattedSection = x || null;
            try {
              const T = this.expression.evaluate(this._evaluator);
              if (T == null || typeof T == "number" && T != T) return this._defaultValue;
              if (this._enumValues && !(T in this._enumValues)) throw new Ui(`Expected value to be one of ${Object.keys(this._enumValues).map(((E) => JSON.stringify(E))).join(", ")}, but found ${JSON.stringify(T)} instead.`);
              return T;
            } catch (T) {
              return this._warningHistory[T.message] || (this._warningHistory[T.message] = !0, typeof console < "u" && console.warn(T.message)), this._defaultValue;
            }
          }
        }
        function Ju(a) {
          return Array.isArray(a) && a.length > 0 && typeof a[0] == "string" && a[0] in Ql;
        }
        function ml(a, t) {
          const n = new ds(Ql, pl, [], t ? (function(p) {
            const v = { color: Kn, string: Zt, number: st, enum: Zt, boolean: Jt, formatted: ss, padding: Fs, numberArray: os, colorArray: Ba, projectionDefinition: al, resolvedImage: Qi, variableAnchorOffsetCollection: Rn };
            return p.type === "array" ? Na(v[p.value] || ii, p.length) : v[p.type];
          })(t) : void 0), l = n.parse(a, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return l ? Yu(new Wu(l, t)) : $s(n.errors);
        }
        class tu {
          constructor(t, n) {
            this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !gs(n.expression), this.globalStateRefs = Hs(n.expression);
          }
          evaluateWithoutErrorHandling(t, n, l, p, v, x) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, n, l, p, v, x);
          }
          evaluate(t, n, l, p, v, x) {
            return this._styleExpression.evaluate(t, n, l, p, v, x);
          }
        }
        class tr {
          constructor(t, n, l, p) {
            this.kind = t, this.zoomStops = l, this._styleExpression = n, this.isStateDependent = t !== "camera" && !gs(n.expression), this.globalStateRefs = Hs(n.expression), this.interpolationType = p;
          }
          evaluateWithoutErrorHandling(t, n, l, p, v, x) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, n, l, p, v, x);
          }
          evaluate(t, n, l, p, v, x) {
            return this._styleExpression.evaluate(t, n, l, p, v, x);
          }
          interpolationFactor(t, n, l) {
            return this.interpolationType ? ca.interpolationFactor(this.interpolationType, t, n, l) : 0;
          }
        }
        function gl(a, t) {
          const n = ml(a, t);
          if (n.result === "error") return n;
          const l = n.value.expression, p = ja(l);
          if (!p && !ys(t)) return $s([new dn("", "data expressions not supported")]);
          const v = eu(l, ["zoom"]);
          if (!v && !Ao(t)) return $s([new dn("", "zoom expressions not supported")]);
          const x = Eo(l);
          return x || v ? x instanceof dn ? $s([x]) : x instanceof ca && !Zc(t) ? $s([new dn("", '"interpolate" expressions cannot be used with this property')]) : Yu(x ? new tr(p ? "camera" : "composite", n.value, x.labels, x instanceof ca ? x.interpolation : void 0) : new tu(p ? "constant" : "source", n.value)) : $s([new dn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class bs {
          constructor(t, n) {
            this._parameters = t, this._specification = n, la(this, er(this._parameters, this._specification));
          }
          static deserialize(t) {
            return new bs(t._parameters, t._specification);
          }
          static serialize(t) {
            return { _parameters: t._parameters, _specification: t._specification };
          }
        }
        function Eo(a) {
          let t = null;
          if (a instanceof Lu) t = Eo(a.result);
          else if (a instanceof ju) {
            for (const n of a.args) if (t = Eo(n), t) break;
          } else (a instanceof pn || a instanceof ca) && a.input instanceof Dr && a.input.name === "zoom" && (t = a);
          return t instanceof dn || a.eachChild(((n) => {
            const l = Eo(n);
            l instanceof dn ? t = l : !t && l ? t = new dn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && l && t !== l && (t = new dn("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          })), t;
        }
        function Hs(a, t = /* @__PURE__ */ new Set()) {
          return a instanceof Hu && t.add(a.key), a.eachChild(((n) => {
            Hs(n, t);
          })), t;
        }
        function Ua(a) {
          if (a === !0 || a === !1) return !0;
          if (!Array.isArray(a) || a.length === 0) return !1;
          switch (a[0]) {
            case "has":
              return a.length >= 2 && a[1] !== "$id" && a[1] !== "$type";
            case "in":
              return a.length >= 3 && (typeof a[1] != "string" || Array.isArray(a[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return a.length !== 3 || Array.isArray(a[1]) || Array.isArray(a[2]);
            case "any":
            case "all":
              for (const t of a.slice(1)) if (!Ua(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0;
          }
        }
        const ir = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
        function nr(a) {
          if (a == null) return { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          Ua(a) || (a = Fa(a));
          const t = ml(a, ir);
          if (t.result === "error") throw new Error(t.value.map(((n) => `${n.key}: ${n.message}`)).join(", "));
          return { filter: (n, l, p) => t.value.evaluate(n, l, {}, p), needGeometry: yr(a), getGlobalStateRefs: () => Hs(t.value.expression) };
        }
        function Lr(a, t) {
          return a < t ? -1 : a > t ? 1 : 0;
        }
        function yr(a) {
          if (!Array.isArray(a)) return !1;
          if (a[0] === "within" || a[0] === "distance") return !0;
          for (let t = 1; t < a.length; t++) if (yr(a[t])) return !0;
          return !1;
        }
        function Fa(a) {
          if (!a) return !0;
          const t = a[0];
          return a.length <= 1 ? t !== "any" : t === "==" ? $c(a[1], a[2], "==") : t === "!=" ? Qu($c(a[1], a[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? $c(a[1], a[2], t) : t === "any" ? (n = a.slice(1), ["any"].concat(n.map(Fa))) : t === "all" ? ["all"].concat(a.slice(1).map(Fa)) : t === "none" ? ["all"].concat(a.slice(1).map(Fa).map(Qu)) : t === "in" ? Hc(a[1], a.slice(2)) : t === "!in" ? Qu(Hc(a[1], a.slice(2))) : t === "has" ? Xc(a[1]) : t !== "!has" || Qu(Xc(a[1]));
          var n;
        }
        function $c(a, t, n) {
          switch (a) {
            case "$type":
              return [`filter-type-${n}`, t];
            case "$id":
              return [`filter-id-${n}`, t];
            default:
              return [`filter-${n}`, a, t];
          }
        }
        function Hc(a, t) {
          if (t.length === 0) return !1;
          switch (a) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some(((n) => typeof n != typeof t[0])) ? ["filter-in-large", a, ["literal", t.sort(Lr)]] : ["filter-in-small", a, ["literal", t]];
          }
        }
        function Xc(a) {
          switch (a) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", a];
          }
        }
        function Qu(a) {
          return ["!", a];
        }
        function Qn(a) {
          const t = typeof a;
          if (t === "number" || t === "boolean" || t === "string" || a == null) return JSON.stringify(a);
          if (Array.isArray(a)) {
            let p = "[";
            for (const v of a) p += `${Qn(v)},`;
            return `${p}]`;
          }
          const n = Object.keys(a).sort();
          let l = "{";
          for (let p = 0; p < n.length; p++) l += `${JSON.stringify(n[p])}:${Qn(a[n[p]])},`;
          return `${l}}`;
        }
        function ln(a) {
          let t = "";
          for (const n of qt) t += `/${Qn(a[n])}`;
          return t;
        }
        function wi(a) {
          const t = a.value;
          return t ? [new ot(a.key, t, "constants have been deprecated as of v8")] : [];
        }
        function Vi(a) {
          return a instanceof Number || a instanceof String || a instanceof Boolean ? a.valueOf() : a;
        }
        function On(a) {
          if (Array.isArray(a)) return a.map(On);
          if (a instanceof Object && !(a instanceof Number || a instanceof String || a instanceof Boolean)) {
            const t = {};
            for (const n in a) t[n] = On(a[n]);
            return t;
          }
          return Vi(a);
        }
        function ar(a) {
          const t = a.key, n = a.value, l = a.valueSpec || {}, p = a.objectElementValidators || {}, v = a.style, x = a.styleSpec, T = a.validateSpec;
          let E = [];
          const k = oi(n);
          if (k !== "object") return [new ot(t, n, `object expected, ${k} found`)];
          for (const D in n) {
            const N = D.split(".")[0], q = rl(l, N) || l["*"];
            let G;
            if (rl(p, N)) G = p[N];
            else if (rl(l, N)) G = T;
            else if (p["*"]) G = p["*"];
            else {
              if (!l["*"]) {
                E.push(new ot(t, n[D], `unknown property "${D}"`));
                continue;
              }
              G = T;
            }
            E = E.concat(G({ key: (t && `${t}.`) + D, value: n[D], valueSpec: q, style: v, styleSpec: x, object: n, objectKey: D, validateSpec: T }, n));
          }
          for (const D in l) p[D] || l[D].required && l[D].default === void 0 && n[D] === void 0 && E.push(new ot(t, n, `missing required property "${D}"`));
          return E;
        }
        function Qr(a) {
          const t = a.value, n = a.valueSpec, l = a.style, p = a.styleSpec, v = a.key, x = a.arrayElementValidator || a.validateSpec;
          if (oi(t) !== "array") return [new ot(v, t, `array expected, ${oi(t)} found`)];
          if (n.length && t.length !== n.length) return [new ot(v, t, `array length ${n.length} expected, length ${t.length} found`)];
          if (n["min-length"] && t.length < n["min-length"]) return [new ot(v, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
          let T = { type: n.value, values: n.values };
          p.$version < 7 && (T.function = n.function), oi(n.value) === "object" && (T = n.value);
          let E = [];
          for (let k = 0; k < t.length; k++) E = E.concat(x({ array: t, arrayIndex: k, value: t[k], valueSpec: T, validateSpec: a.validateSpec, style: l, styleSpec: p, key: `${v}[${k}]` }));
          return E;
        }
        function iu(a) {
          const t = a.key, n = a.value, l = a.valueSpec;
          let p = oi(n);
          return p === "number" && n != n && (p = "NaN"), p !== "number" ? [new ot(t, n, `number expected, ${p} found`)] : "minimum" in l && n < l.minimum ? [new ot(t, n, `${n} is less than the minimum value ${l.minimum}`)] : "maximum" in l && n > l.maximum ? [new ot(t, n, `${n} is greater than the maximum value ${l.maximum}`)] : [];
        }
        function $h(a) {
          const t = a.valueSpec, n = Vi(a.value.type);
          let l, p, v, x = {};
          const T = n !== "categorical" && a.value.property === void 0, E = !T, k = oi(a.value.stops) === "array" && oi(a.value.stops[0]) === "array" && oi(a.value.stops[0][0]) === "object", D = ar({ key: a.key, value: a.value, valueSpec: a.styleSpec.function, validateSpec: a.validateSpec, style: a.style, styleSpec: a.styleSpec, objectElementValidators: { stops: function(G) {
            if (n === "identity") return [new ot(G.key, G.value, 'identity function may not have a "stops" property')];
            let Z = [];
            const X = G.value;
            return Z = Z.concat(Qr({ key: G.key, value: X, valueSpec: G.valueSpec, validateSpec: G.validateSpec, style: G.style, styleSpec: G.styleSpec, arrayElementValidator: N })), oi(X) === "array" && X.length === 0 && Z.push(new ot(G.key, X, "array must have at least one stop")), Z;
          }, default: function(G) {
            return G.validateSpec({ key: G.key, value: G.value, valueSpec: t, validateSpec: G.validateSpec, style: G.style, styleSpec: G.styleSpec });
          } } });
          return n === "identity" && T && D.push(new ot(a.key, a.value, 'missing required property "property"')), n === "identity" || a.value.stops || D.push(new ot(a.key, a.value, 'missing required property "stops"')), n === "exponential" && a.valueSpec.expression && !Zc(a.valueSpec) && D.push(new ot(a.key, a.value, "exponential functions not supported")), a.styleSpec.$version >= 8 && (E && !ys(a.valueSpec) ? D.push(new ot(a.key, a.value, "property functions not supported")) : T && !Ao(a.valueSpec) && D.push(new ot(a.key, a.value, "zoom functions not supported"))), n !== "categorical" && !k || a.value.property !== void 0 || D.push(new ot(a.key, a.value, '"property" property is required')), D;
          function N(G) {
            let Z = [];
            const X = G.value, ee = G.key;
            if (oi(X) !== "array") return [new ot(ee, X, `array expected, ${oi(X)} found`)];
            if (X.length !== 2) return [new ot(ee, X, `array length 2 expected, length ${X.length} found`)];
            if (k) {
              if (oi(X[0]) !== "object") return [new ot(ee, X, `object expected, ${oi(X[0])} found`)];
              if (X[0].zoom === void 0) return [new ot(ee, X, "object stop key must have zoom")];
              if (X[0].value === void 0) return [new ot(ee, X, "object stop key must have value")];
              if (v && v > Vi(X[0].zoom)) return [new ot(ee, X[0].zoom, "stop zoom values must appear in ascending order")];
              Vi(X[0].zoom) !== v && (v = Vi(X[0].zoom), p = void 0, x = {}), Z = Z.concat(ar({ key: `${ee}[0]`, value: X[0], valueSpec: { zoom: {} }, validateSpec: G.validateSpec, style: G.style, styleSpec: G.styleSpec, objectElementValidators: { zoom: iu, value: q } }));
            } else Z = Z.concat(q({ key: `${ee}[0]`, value: X[0], validateSpec: G.validateSpec, style: G.style, styleSpec: G.styleSpec }, X));
            return Ju(On(X[1])) ? Z.concat([new ot(`${ee}[1]`, X[1], "expressions are not allowed in function stops.")]) : Z.concat(G.validateSpec({ key: `${ee}[1]`, value: X[1], valueSpec: t, validateSpec: G.validateSpec, style: G.style, styleSpec: G.styleSpec }));
          }
          function q(G, Z) {
            const X = oi(G.value), ee = Vi(G.value), se = G.value !== null ? G.value : Z;
            if (l) {
              if (X !== l) return [new ot(G.key, se, `${X} stop domain type must match previous stop domain type ${l}`)];
            } else l = X;
            if (X !== "number" && X !== "string" && X !== "boolean") return [new ot(G.key, se, "stop domain value must be a number, string, or boolean")];
            if (X !== "number" && n !== "categorical") {
              let xe = `number expected, ${X} found`;
              return ys(t) && n === void 0 && (xe += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ot(G.key, se, xe)];
            }
            return n !== "categorical" || X !== "number" || isFinite(ee) && Math.floor(ee) === ee ? n !== "categorical" && X === "number" && p !== void 0 && ee < p ? [new ot(G.key, se, "stop domain values must appear in ascending order")] : (p = ee, n === "categorical" && ee in x ? [new ot(G.key, se, "stop domain values must be unique")] : (x[ee] = !0, [])) : [new ot(G.key, se, `integer expected, found ${ee}`)];
          }
        }
        function Or(a) {
          const t = (a.expressionContext === "property" ? gl : ml)(On(a.value), a.valueSpec);
          if (t.result === "error") return t.value.map(((l) => new ot(`${a.key}${l.key}`, a.value, l.message)));
          const n = t.value.expression || t.value._styleExpression.expression;
          if (a.expressionContext === "property" && a.propertyKey === "text-font" && !n.outputDefined()) return [new ot(a.key, a.value, `Invalid data expression for "${a.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (a.expressionContext === "property" && a.propertyType === "layout" && !gs(n)) return [new ot(a.key, a.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (a.expressionContext === "filter" && !gs(n)) return [new ot(a.key, a.value, '"feature-state" data expressions are not supported with filters.')];
          if (a.expressionContext && a.expressionContext.indexOf("cluster") === 0) {
            if (!eu(n, ["zoom", "feature-state"])) return [new ot(a.key, a.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (a.expressionContext === "cluster-initial" && !ja(n)) return [new ot(a.key, a.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function ws(a) {
          const t = a.key, n = a.value, l = oi(n);
          return l !== "string" ? [new ot(t, n, `color expected, ${l} found`)] : di.parse(String(n)) ? [] : [new ot(t, n, `color expected, "${n}" found`)];
        }
        function es(a) {
          const t = a.key, n = a.value, l = a.valueSpec, p = [];
          return Array.isArray(l.values) ? l.values.indexOf(Vi(n)) === -1 && p.push(new ot(t, n, `expected one of [${l.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(l.values).indexOf(Vi(n)) === -1 && p.push(new ot(t, n, `expected one of [${Object.keys(l.values).join(", ")}], ${JSON.stringify(n)} found`)), p;
        }
        function yl(a) {
          return Ua(On(a.value)) ? Or(la({}, a, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Yc(a);
        }
        function Yc(a) {
          const t = a.value, n = a.key;
          if (oi(t) !== "array") return [new ot(n, t, `array expected, ${oi(t)} found`)];
          const l = a.styleSpec;
          let p, v = [];
          if (t.length < 1) return [new ot(n, t, "filter array must have at least 1 element")];
          switch (v = v.concat(es({ key: `${n}[0]`, value: t[0], valueSpec: l.filter_operator, style: a.style, styleSpec: a.styleSpec })), Vi(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && Vi(t[1]) === "$type" && v.push(new ot(n, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && v.push(new ot(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (p = oi(t[1]), p !== "string" && v.push(new ot(`${n}[1]`, t[1], `string expected, ${p} found`)));
              for (let x = 2; x < t.length; x++) p = oi(t[x]), Vi(t[1]) === "$type" ? v = v.concat(es({ key: `${n}[${x}]`, value: t[x], valueSpec: l.geometry_type, style: a.style, styleSpec: a.styleSpec })) : p !== "string" && p !== "number" && p !== "boolean" && v.push(new ot(`${n}[${x}]`, t[x], `string, number, or boolean expected, ${p} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let x = 1; x < t.length; x++) v = v.concat(Yc({ key: `${n}[${x}]`, value: t[x], style: a.style, styleSpec: a.styleSpec }));
              break;
            case "has":
            case "!has":
              p = oi(t[1]), t.length !== 2 ? v.push(new ot(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : p !== "string" && v.push(new ot(`${n}[1]`, t[1], `string expected, ${p} found`));
          }
          return v;
        }
        function Co(a, t) {
          const n = a.key, l = a.validateSpec, p = a.style, v = a.styleSpec, x = a.value, T = a.objectKey, E = v[`${t}_${a.layerType}`];
          if (!E) return [];
          const k = T.match(/^(.*)-transition$/);
          if (t === "paint" && k && E[k[1]] && E[k[1]].transition) return l({ key: n, value: x, valueSpec: v.transition, style: p, styleSpec: v });
          const D = a.valueSpec || E[T];
          if (!D) return [new ot(n, x, `unknown property "${T}"`)];
          let N;
          if (oi(x) === "string" && ys(D) && !D.tokens && (N = /^{([^}]+)}$/.exec(x))) return [new ot(n, x, `"${T}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(N[1])} }\`.`)];
          const q = [];
          return a.layerType === "symbol" && (T === "text-field" && p && !p.glyphs && q.push(new ot(n, x, 'use of "text-field" requires a style "glyphs" property')), T === "text-font" && _s(On(x)) && Vi(x.type) === "identity" && q.push(new ot(n, x, '"text-font" does not support identity functions'))), q.concat(l({ key: a.key, value: x, valueSpec: D, style: p, styleSpec: v, expressionContext: "property", propertyType: t, propertyKey: T }));
        }
        function Ss(a) {
          return Co(a, "paint");
        }
        function Xs(a) {
          return Co(a, "layout");
        }
        function Ts(a) {
          let t = [];
          const n = a.value, l = a.key, p = a.style, v = a.styleSpec;
          if (oi(n) !== "object") return [new ot(l, n, `object expected, ${oi(n)} found`)];
          n.type || n.ref || t.push(new ot(l, n, 'either "type" or "ref" is required'));
          let x = Vi(n.type);
          const T = Vi(n.ref);
          if (n.id) {
            const E = Vi(n.id);
            for (let k = 0; k < a.arrayIndex; k++) {
              const D = p.layers[k];
              Vi(D.id) === E && t.push(new ot(l, n.id, `duplicate layer id "${n.id}", previously used at line ${D.id.__line__}`));
            }
          }
          if ("ref" in n) {
            let E;
            ["type", "source", "source-layer", "filter", "layout"].forEach(((k) => {
              k in n && t.push(new ot(l, n[k], `"${k}" is prohibited for ref layers`));
            })), p.layers.forEach(((k) => {
              Vi(k.id) === T && (E = k);
            })), E ? E.ref ? t.push(new ot(l, n.ref, "ref cannot reference another ref layer")) : x = Vi(E.type) : t.push(new ot(l, n.ref, `ref layer "${T}" not found`));
          } else if (x !== "background") if (n.source) {
            const E = p.sources && p.sources[n.source], k = E && Vi(E.type);
            E ? k === "vector" && x === "raster" ? t.push(new ot(l, n.source, `layer "${n.id}" requires a raster source`)) : k !== "raster-dem" && x === "hillshade" || k !== "raster-dem" && x === "color-relief" ? t.push(new ot(l, n.source, `layer "${n.id}" requires a raster-dem source`)) : k === "raster" && x !== "raster" ? t.push(new ot(l, n.source, `layer "${n.id}" requires a vector source`)) : k !== "vector" || n["source-layer"] ? k === "raster-dem" && x !== "hillshade" && x !== "color-relief" ? t.push(new ot(l, n.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : x !== "line" || !n.paint || !n.paint["line-gradient"] || k === "geojson" && E.lineMetrics || t.push(new ot(l, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new ot(l, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new ot(l, n.source, `source "${n.source}" not found`));
          } else t.push(new ot(l, n, 'missing required property "source"'));
          return t = t.concat(ar({ key: l, value: n, valueSpec: v.layer, style: a.style, styleSpec: a.styleSpec, validateSpec: a.validateSpec, objectElementValidators: { "*": () => [], type: () => a.validateSpec({ key: `${l}.type`, value: n.type, valueSpec: v.layer.type, style: a.style, styleSpec: a.styleSpec, validateSpec: a.validateSpec, object: n, objectKey: "type" }), filter: yl, layout: (E) => ar({ layer: n, key: E.key, value: E.value, style: E.style, styleSpec: E.styleSpec, validateSpec: E.validateSpec, objectElementValidators: { "*": (k) => Xs(la({ layerType: x }, k)) } }), paint: (E) => ar({ layer: n, key: E.key, value: E.value, style: E.style, styleSpec: E.styleSpec, validateSpec: E.validateSpec, objectElementValidators: { "*": (k) => Ss(la({ layerType: x }, k)) } }) } })), t;
        }
        function _r(a) {
          const t = a.value, n = a.key, l = oi(t);
          return l !== "string" ? [new ot(n, t, `string expected, ${l} found`)] : [];
        }
        const zo = { promoteId: function({ key: a, value: t }) {
          if (oi(t) === "string") return _r({ key: a, value: t });
          {
            const n = [];
            for (const l in t) n.push(..._r({ key: `${a}.${l}`, value: t[l] }));
            return n;
          }
        } };
        function ea(a) {
          const t = a.value, n = a.key, l = a.styleSpec, p = a.style, v = a.validateSpec;
          if (!t.type) return [new ot(n, t, '"type" is required')];
          const x = Vi(t.type);
          let T;
          switch (x) {
            case "vector":
            case "raster":
              return T = ar({ key: n, value: t, valueSpec: l[`source_${x.replace("-", "_")}`], style: a.style, styleSpec: l, objectElementValidators: zo, validateSpec: v }), T;
            case "raster-dem":
              return T = (function(E) {
                var k;
                const D = (k = E.sourceName) !== null && k !== void 0 ? k : "", N = E.value, q = E.styleSpec, G = q.source_raster_dem, Z = E.style;
                let X = [];
                const ee = oi(N);
                if (N === void 0) return X;
                if (ee !== "object") return X.push(new ot("source_raster_dem", N, `object expected, ${ee} found`)), X;
                const se = Vi(N.encoding) === "custom", xe = ["redFactor", "greenFactor", "blueFactor", "baseShift"], de = E.value.encoding ? `"${E.value.encoding}"` : "Default";
                for (const ge in N) !se && xe.includes(ge) ? X.push(new ot(ge, N[ge], `In "${D}": "${ge}" is only valid when "encoding" is set to "custom". ${de} encoding found`)) : G[ge] ? X = X.concat(E.validateSpec({ key: ge, value: N[ge], valueSpec: G[ge], validateSpec: E.validateSpec, style: Z, styleSpec: q })) : X.push(new ot(ge, N[ge], `unknown property "${ge}"`));
                return X;
              })({ sourceName: n, value: t, style: a.style, styleSpec: l, validateSpec: v }), T;
            case "geojson":
              if (T = ar({ key: n, value: t, valueSpec: l.source_geojson, style: p, styleSpec: l, validateSpec: v, objectElementValidators: zo }), t.cluster) for (const E in t.clusterProperties) {
                const [k, D] = t.clusterProperties[E], N = typeof k == "string" ? [k, ["accumulated"], ["get", E]] : k;
                T.push(...Or({ key: `${n}.${E}.map`, value: D, expressionContext: "cluster-map" })), T.push(...Or({ key: `${n}.${E}.reduce`, value: N, expressionContext: "cluster-reduce" }));
              }
              return T;
            case "video":
              return ar({ key: n, value: t, valueSpec: l.source_video, style: p, validateSpec: v, styleSpec: l });
            case "image":
              return ar({ key: n, value: t, valueSpec: l.source_image, style: p, validateSpec: v, styleSpec: l });
            case "canvas":
              return [new ot(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return es({ key: `${n}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function Ys(a) {
          const t = a.value, n = a.styleSpec, l = n.light, p = a.style;
          let v = [];
          const x = oi(t);
          if (t === void 0) return v;
          if (x !== "object") return v = v.concat([new ot("light", t, `object expected, ${x} found`)]), v;
          for (const T in t) {
            const E = T.match(/^(.*)-transition$/);
            v = v.concat(E && l[E[1]] && l[E[1]].transition ? a.validateSpec({ key: T, value: t[T], valueSpec: n.transition, validateSpec: a.validateSpec, style: p, styleSpec: n }) : l[T] ? a.validateSpec({ key: T, value: t[T], valueSpec: l[T], validateSpec: a.validateSpec, style: p, styleSpec: n }) : [new ot(T, t[T], `unknown property "${T}"`)]);
          }
          return v;
        }
        function Ks(a) {
          const t = a.value, n = a.styleSpec, l = n.sky, p = a.style, v = oi(t);
          if (t === void 0) return [];
          if (v !== "object") return [new ot("sky", t, `object expected, ${v} found`)];
          let x = [];
          for (const T in t) x = x.concat(l[T] ? a.validateSpec({ key: T, value: t[T], valueSpec: l[T], style: p, styleSpec: n }) : [new ot(T, t[T], `unknown property "${T}"`)]);
          return x;
        }
        function ha(a) {
          const t = a.value, n = a.styleSpec, l = n.terrain, p = a.style;
          let v = [];
          const x = oi(t);
          if (t === void 0) return v;
          if (x !== "object") return v = v.concat([new ot("terrain", t, `object expected, ${x} found`)]), v;
          for (const T in t) v = v.concat(l[T] ? a.validateSpec({ key: T, value: t[T], valueSpec: l[T], validateSpec: a.validateSpec, style: p, styleSpec: n }) : [new ot(T, t[T], `unknown property "${T}"`)]);
          return v;
        }
        function ec(a) {
          let t = [];
          const n = a.value, l = a.key;
          if (Array.isArray(n)) {
            const p = [], v = [];
            for (const x in n) n[x].id && p.includes(n[x].id) && t.push(new ot(l, n, `all the sprites' ids must be unique, but ${n[x].id} is duplicated`)), p.push(n[x].id), n[x].url && v.includes(n[x].url) && t.push(new ot(l, n, `all the sprites' URLs must be unique, but ${n[x].url} is duplicated`)), v.push(n[x].url), t = t.concat(ar({ key: `${l}[${x}]`, value: n[x], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: a.validateSpec }));
            return t;
          }
          return _r({ key: l, value: n });
        }
        function _l(a) {
          return t = a.value, t && t.constructor === Object ? [] : [new ot(a.key, a.value, `object expected, ${oi(a.value)} found`)];
          var t;
        }
        const Hh = { "*": () => [], array: Qr, boolean: function(a) {
          const t = a.value, n = a.key, l = oi(t);
          return l !== "boolean" ? [new ot(n, t, `boolean expected, ${l} found`)] : [];
        }, number: iu, color: ws, constants: wi, enum: es, filter: yl, function: $h, layer: Ts, object: ar, source: ea, light: Ys, sky: Ks, terrain: ha, projection: function(a) {
          const t = a.value, n = a.styleSpec, l = n.projection, p = a.style, v = oi(t);
          if (t === void 0) return [];
          if (v !== "object") return [new ot("projection", t, `object expected, ${v} found`)];
          let x = [];
          for (const T in t) x = x.concat(l[T] ? a.validateSpec({ key: T, value: t[T], valueSpec: l[T], style: p, styleSpec: n }) : [new ot(T, t[T], `unknown property "${T}"`)]);
          return x;
        }, projectionDefinition: function(a) {
          const t = a.key;
          let n = a.value;
          n = n instanceof String ? n.valueOf() : n;
          const l = oi(n);
          return l !== "array" || (function(p) {
            return Array.isArray(p) && p.length === 3 && typeof p[0] == "string" && typeof p[1] == "string" && typeof p[2] == "number";
          })(n) || (function(p) {
            return !!["interpolate", "step", "literal"].includes(p[0]);
          })(n) ? ["array", "string"].includes(l) ? [] : [new ot(t, n, `projection expected, invalid type "${l}" found`)] : [new ot(t, n, `projection expected, invalid array ${JSON.stringify(n)} found`)];
        }, string: _r, formatted: function(a) {
          return _r(a).length === 0 ? [] : Or(a);
        }, resolvedImage: function(a) {
          return _r(a).length === 0 ? [] : Or(a);
        }, padding: function(a) {
          const t = a.key, n = a.value;
          if (oi(n) === "array") {
            if (n.length < 1 || n.length > 4) return [new ot(t, n, `padding requires 1 to 4 values; ${n.length} values found`)];
            const l = { type: "number" };
            let p = [];
            for (let v = 0; v < n.length; v++) p = p.concat(a.validateSpec({ key: `${t}[${v}]`, value: n[v], validateSpec: a.validateSpec, valueSpec: l }));
            return p;
          }
          return iu({ key: t, value: n, valueSpec: {} });
        }, numberArray: function(a) {
          const t = a.key, n = a.value;
          if (oi(n) === "array") {
            const l = { type: "number" };
            if (n.length < 1) return [new ot(t, n, "array length at least 1 expected, length 0 found")];
            let p = [];
            for (let v = 0; v < n.length; v++) p = p.concat(a.validateSpec({ key: `${t}[${v}]`, value: n[v], validateSpec: a.validateSpec, valueSpec: l }));
            return p;
          }
          return iu({ key: t, value: n, valueSpec: {} });
        }, colorArray: function(a) {
          const t = a.key, n = a.value;
          if (oi(n) === "array") {
            if (n.length < 1) return [new ot(t, n, "array length at least 1 expected, length 0 found")];
            let l = [];
            for (let p = 0; p < n.length; p++) l = l.concat(ws({ key: `${t}[${p}]`, value: n[p] }));
            return l;
          }
          return ws({ key: t, value: n });
        }, variableAnchorOffsetCollection: function(a) {
          const t = a.key, n = a.value, l = oi(n), p = a.styleSpec;
          if (l !== "array" || n.length < 1 || n.length % 2 != 0) return [new ot(t, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let v = [];
          for (let x = 0; x < n.length; x += 2) v = v.concat(es({ key: `${t}[${x}]`, value: n[x], valueSpec: p.layout_symbol["text-anchor"] })), v = v.concat(Qr({ key: `${t}[${x + 1}]`, value: n[x + 1], valueSpec: { length: 2, value: "number" }, validateSpec: a.validateSpec, style: a.style, styleSpec: p }));
          return v;
        }, sprite: ec, state: _l };
        function nu(a) {
          const t = a.value, n = a.valueSpec, l = a.styleSpec;
          return a.validateSpec = nu, n.expression && _s(Vi(t)) ? $h(a) : n.expression && Ju(On(t)) ? Or(a) : n.type && Hh[n.type] ? Hh[n.type](a) : ar(la({}, a, { valueSpec: n.type ? l[n.type] : n }));
        }
        function np(a) {
          const t = a.value, n = a.key, l = _r(a);
          return l.length || (t.indexOf("{fontstack}") === -1 && l.push(new ot(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && l.push(new ot(n, t, '"glyphs" url must include a "{range}" token'))), l;
        }
        function ki(a, t = Ae) {
          let n = [];
          return n = n.concat(nu({ key: "", value: a, valueSpec: t.$root, styleSpec: t, style: a, validateSpec: nu, objectElementValidators: { glyphs: np, "*": () => [] } })), a.constants && (n = n.concat(wi({ key: "constants", value: a.constants }))), Ms(n);
        }
        function vr(a) {
          return function(t) {
            return a({ ...t, validateSpec: nu });
          };
        }
        function Ms(a) {
          return [].concat(a).sort(((t, n) => t.line - n.line));
        }
        function Va(a) {
          return function(...t) {
            return Ms(a.apply(this, t));
          };
        }
        ki.source = Va(vr(ea)), ki.sprite = Va(vr(ec)), ki.glyphs = Va(vr(np)), ki.light = Va(vr(Ys)), ki.sky = Va(vr(Ks)), ki.terrain = Va(vr(ha)), ki.state = Va(vr(_l)), ki.layer = Va(vr(Ts)), ki.filter = Va(vr(yl)), ki.paintProperty = Va(vr(Ss)), ki.layoutProperty = Va(vr(Xs));
        const Po = ki, au = Po.light, As = Po.sky, uf = Po.paintProperty, ap = Po.layoutProperty;
        function tc(a, t) {
          let n = !1;
          if (t && t.length) for (const l of t) a.fire(new Ye(new Error(l.message))), n = !0;
          return n;
        }
        class ru {
          constructor(t, n, l) {
            const p = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const x = new Int32Array(this.arrayBuffer);
              t = x[0], this.d = (n = x[1]) + 2 * (l = x[2]);
              for (let E = 0; E < this.d * this.d; E++) {
                const k = x[3 + E], D = x[3 + E + 1];
                p.push(k === D ? null : x.subarray(k, D));
              }
              const T = x[3 + p.length + 1];
              this.keys = x.subarray(x[3 + p.length], T), this.bboxes = x.subarray(T), this.insert = this._insertReadonly;
            } else {
              this.d = n + 2 * l;
              for (let x = 0; x < this.d * this.d; x++) p.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = n, this.extent = t, this.padding = l, this.scale = n / t, this.uid = 0;
            const v = l / n * t;
            this.min = -v, this.max = t + v;
          }
          insert(t, n, l, p, v) {
            this._forEachCell(n, l, p, v, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(n), this.bboxes.push(l), this.bboxes.push(p), this.bboxes.push(v);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t, n, l, p, v, x) {
            this.cells[v].push(x);
          }
          query(t, n, l, p, v) {
            const x = this.min, T = this.max;
            if (t <= x && n <= x && T <= l && T <= p && !v) return Array.prototype.slice.call(this.keys);
            {
              const E = [];
              return this._forEachCell(t, n, l, p, this._queryCell, E, {}, v), E;
            }
          }
          _queryCell(t, n, l, p, v, x, T, E) {
            const k = this.cells[v];
            if (k !== null) {
              const D = this.keys, N = this.bboxes;
              for (let q = 0; q < k.length; q++) {
                const G = k[q];
                if (T[G] === void 0) {
                  const Z = 4 * G;
                  (E ? E(N[Z + 0], N[Z + 1], N[Z + 2], N[Z + 3]) : t <= N[Z + 2] && n <= N[Z + 3] && l >= N[Z + 0] && p >= N[Z + 1]) ? (T[G] = !0, x.push(D[G])) : T[G] = !1;
                }
              }
            }
          }
          _forEachCell(t, n, l, p, v, x, T, E) {
            const k = this._convertToCellCoord(t), D = this._convertToCellCoord(n), N = this._convertToCellCoord(l), q = this._convertToCellCoord(p);
            for (let G = k; G <= N; G++) for (let Z = D; Z <= q; Z++) {
              const X = this.d * Z + G;
              if ((!E || E(this._convertFromCellCoord(G), this._convertFromCellCoord(Z), this._convertFromCellCoord(G + 1), this._convertFromCellCoord(Z + 1))) && v.call(this, t, n, l, p, X, x, T, E)) return;
            }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale;
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells, n = 3 + this.cells.length + 1 + 1;
            let l = 0;
            for (let x = 0; x < this.cells.length; x++) l += this.cells[x].length;
            const p = new Int32Array(n + l + this.keys.length + this.bboxes.length);
            p[0] = this.extent, p[1] = this.n, p[2] = this.padding;
            let v = n;
            for (let x = 0; x < t.length; x++) {
              const T = t[x];
              p[3 + x] = v, p.set(T, v), v += T.length;
            }
            return p[3 + t.length] = v, p.set(this.keys, v), v += this.keys.length, p[3 + t.length + 1] = v, p.set(this.bboxes, v), v += this.bboxes.length, p.buffer;
          }
          static serialize(t, n) {
            const l = t.toArrayBuffer();
            return n && n.push(l), { buffer: l };
          }
          static deserialize(t) {
            return new ru(t.buffer);
          }
        }
        const _a = {};
        function xt(a, t, n = {}) {
          if (_a[a]) throw new Error(`${a} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", { value: a, writeable: !1 }), _a[a] = { klass: t, omit: n.omit || [], shallow: n.shallow || [] };
        }
        xt("Object", Object), xt("Set", Set), xt("TransferableGridIndex", ru), xt("Color", di), xt("Error", Error), xt("AJAXError", le), xt("ResolvedImage", Ln), xt("StylePropertyFunction", bs), xt("StyleExpression", Wu, { omit: ["_evaluator"] }), xt("ZoomDependentExpression", tr), xt("ZoomConstantExpression", tu), xt("CompoundExpression", Dr, { omit: ["_evaluate"] });
        for (const a in Ql) Ql[a]._classRegistryKey || xt(`Expression_${a}`, Ql[a]);
        function su(a) {
          return a && typeof ArrayBuffer < "u" && (a instanceof ArrayBuffer || a.constructor && a.constructor.name === "ArrayBuffer");
        }
        function ic(a) {
          return a.$name || a.constructor._classRegistryKey;
        }
        function Io(a) {
          return !(function(t) {
            if (t === null || typeof t != "object") return !1;
            const n = ic(t);
            return !(!n || n === "Object");
          })(a) && (a == null || typeof a == "boolean" || typeof a == "number" || typeof a == "string" || a instanceof Boolean || a instanceof Number || a instanceof String || a instanceof Date || a instanceof RegExp || a instanceof Blob || a instanceof Error || su(a) || Ya(a) || ArrayBuffer.isView(a) || a instanceof ImageData);
        }
        function ko(a, t) {
          if (Io(a)) return (su(a) || Ya(a)) && t && t.push(a), ArrayBuffer.isView(a) && t && t.push(a.buffer), a instanceof ImageData && t && t.push(a.data.buffer), a;
          if (Array.isArray(a)) {
            const v = [];
            for (const x of a) v.push(ko(x, t));
            return v;
          }
          if (typeof a != "object") throw new Error("can't serialize object of type " + typeof a);
          const n = ic(a);
          if (!n) throw new Error(`can't serialize object of unregistered class ${a.constructor.name}`);
          if (!_a[n]) throw new Error(`${n} is not registered.`);
          const { klass: l } = _a[n], p = l.serialize ? l.serialize(a, t) : {};
          if (l.serialize) {
            if (t && p === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const v in a) {
              if (!a.hasOwnProperty(v) || _a[n].omit.indexOf(v) >= 0) continue;
              const x = a[v];
              p[v] = _a[n].shallow.indexOf(v) >= 0 ? x : ko(x, t);
            }
            a instanceof Error && (p.message = a.message);
          }
          if (p.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return n !== "Object" && (p.$name = n), p;
        }
        function Es(a) {
          if (Io(a)) return a;
          if (Array.isArray(a)) return a.map(Es);
          if (typeof a != "object") throw new Error("can't deserialize object of type " + typeof a);
          const t = ic(a) || "Object";
          if (!_a[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const { klass: n } = _a[t];
          if (!n) throw new Error(`can't deserialize unregistered class ${t}`);
          if (n.deserialize) return n.deserialize(a);
          const l = Object.create(n.prototype);
          for (const p of Object.keys(a)) {
            if (p === "$name") continue;
            const v = a[p];
            l[p] = _a[t].shallow.indexOf(p) >= 0 ? v : Es(v);
          }
          return l;
        }
        class vl {
          constructor() {
            this.first = !0;
          }
          update(t, n) {
            const l = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = l, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = l, !0) : (this.lastFloorZoom > l ? (this.lastIntegerZoom = l + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < l && (this.lastIntegerZoom = l, this.lastIntegerZoomTime = n), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = l, !0));
          }
        }
        const mi = { "Latin-1 Supplement": (a) => a >= 128 && a <= 255, "Hangul Jamo": (a) => a >= 4352 && a <= 4607, Khmer: (a) => a >= 6016 && a <= 6143, "General Punctuation": (a) => a >= 8192 && a <= 8303, "Letterlike Symbols": (a) => a >= 8448 && a <= 8527, "Number Forms": (a) => a >= 8528 && a <= 8591, "Miscellaneous Technical": (a) => a >= 8960 && a <= 9215, "Control Pictures": (a) => a >= 9216 && a <= 9279, "Optical Character Recognition": (a) => a >= 9280 && a <= 9311, "Enclosed Alphanumerics": (a) => a >= 9312 && a <= 9471, "Geometric Shapes": (a) => a >= 9632 && a <= 9727, "Miscellaneous Symbols": (a) => a >= 9728 && a <= 9983, "Miscellaneous Symbols and Arrows": (a) => a >= 11008 && a <= 11263, "Ideographic Description Characters": (a) => a >= 12272 && a <= 12287, "CJK Symbols and Punctuation": (a) => a >= 12288 && a <= 12351, Hiragana: (a) => a >= 12352 && a <= 12447, Katakana: (a) => a >= 12448 && a <= 12543, Kanbun: (a) => a >= 12688 && a <= 12703, "CJK Strokes": (a) => a >= 12736 && a <= 12783, "Enclosed CJK Letters and Months": (a) => a >= 12800 && a <= 13055, "CJK Compatibility": (a) => a >= 13056 && a <= 13311, "Yijing Hexagram Symbols": (a) => a >= 19904 && a <= 19967, "CJK Unified Ideographs": (a) => a >= 19968 && a <= 40959, "Hangul Syllables": (a) => a >= 44032 && a <= 55215, "Private Use Area": (a) => a >= 57344 && a <= 63743, "Vertical Forms": (a) => a >= 65040 && a <= 65055, "CJK Compatibility Forms": (a) => a >= 65072 && a <= 65103, "Small Form Variants": (a) => a >= 65104 && a <= 65135, "Halfwidth and Fullwidth Forms": (a) => a >= 65280 && a <= 65519 };
        function nc(a) {
          for (const t of a) if (bl(t.charCodeAt(0))) return !0;
          return !1;
        }
        function xl(a) {
          for (const t of a) if (!Xh(t.charCodeAt(0))) return !1;
          return !0;
        }
        function Cs(a) {
          const t = a.map(((n) => {
            try {
              return new RegExp(`\\p{sc=${n}}`, "u").source;
            } catch {
              return null;
            }
          })).filter(((n) => n));
          return new RegExp(t.join("|"), "u");
        }
        const rp = Cs(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function Xh(a) {
          return !rp.test(String.fromCodePoint(a));
        }
        const Ro = Cs(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function bl(a) {
          return !(a !== 746 && a !== 747 && (a < 4352 || !(mi["CJK Compatibility Forms"](a) && !(a >= 65097 && a <= 65103) || mi["CJK Compatibility"](a) || mi["CJK Strokes"](a) || !(!mi["CJK Symbols and Punctuation"](a) || a >= 12296 && a <= 12305 || a >= 12308 && a <= 12319 || a === 12336) || mi["Enclosed CJK Letters and Months"](a) || mi["Ideographic Description Characters"](a) || mi.Kanbun(a) || mi.Katakana(a) && a !== 12540 || !(!mi["Halfwidth and Fullwidth Forms"](a) || a === 65288 || a === 65289 || a === 65293 || a >= 65306 && a <= 65310 || a === 65339 || a === 65341 || a === 65343 || a >= 65371 && a <= 65503 || a === 65507 || a >= 65512 && a <= 65519) || !(!mi["Small Form Variants"](a) || a >= 65112 && a <= 65118 || a >= 65123 && a <= 65126) || mi["Vertical Forms"](a) || mi["Yijing Hexagram Symbols"](a) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(a)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(a)) || Ro.test(String.fromCodePoint(a)))));
        }
        function ac(a) {
          return !(bl(a) || (function(t) {
            return !!(mi["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || mi["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || mi["Letterlike Symbols"](t) || mi["Number Forms"](t) || mi["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || mi["Control Pictures"](t) && t !== 9251 || mi["Optical Character Recognition"](t) || mi["Enclosed Alphanumerics"](t) || mi["Geometric Shapes"](t) || mi["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || mi["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || mi["CJK Symbols and Punctuation"](t) || mi.Katakana(t) || mi["Private Use Area"](t) || mi["CJK Compatibility Forms"](t) || mi["Small Form Variants"](t) || mi["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533);
          })(a));
        }
        const ou = Cs(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function lu(a) {
          return ou.test(String.fromCodePoint(a));
        }
        function Yh(a, t) {
          return !(!t && lu(a) || a >= 2304 && a <= 3583 || a >= 3840 && a <= 4255 || mi.Khmer(a));
        }
        function Do(a) {
          for (const t of a) if (lu(t.charCodeAt(0))) return !0;
          return !1;
        }
        const Br = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(a) {
            this.pluginStatus = a.pluginStatus, this.pluginURL = a.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(a) {
            if (Br.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = a.applyArabicShaping, this.processBidirectionalText = a.processBidirectionalText, this.processStyledBidirectionalText = a.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(a, t) {
            return u(this, void 0, void 0, (function* () {
              if (this.isParsed()) return this.getState();
              if (a.pluginStatus !== "loading") return this.setState(a), a;
              const n = a.pluginURL, l = new Promise(((v) => {
                this.loadScriptResolve = v;
              }));
              t(n);
              const p = new Promise(((v) => setTimeout((() => v()), this.TIMEOUT)));
              if (yield Promise.race([l, p]), this.isParsed()) {
                const v = { pluginStatus: "loaded", pluginURL: n };
                return this.setState(v), v;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${n}`);
            }));
          }
        }();
        class Li {
          constructor(t, n) {
            this.zoom = t, n ? (this.now = n.now || 0, this.fadeDuration = n.fadeDuration || 0, this.zoomHistory = n.zoomHistory || new vl(), this.transition = n.transition || {}, this.globalState = n.globalState || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new vl(), this.transition = {}, this.globalState = {});
          }
          isSupportedScript(t) {
            return (function(n, l) {
              for (const p of n) if (!Yh(p.charCodeAt(0), l)) return !1;
              return !0;
            })(t, Br.getRTLTextPluginStatus() === "loaded");
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t = this.zoom, n = t - Math.floor(t), l = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: n + (1 - n) * l } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - l) * n };
          }
        }
        class Lo {
          constructor(t, n) {
            this.property = t, this.value = n, this.expression = (function(l, p) {
              if (_s(l)) return new bs(l, p);
              if (Ju(l)) {
                const v = gl(l, p);
                if (v.result === "error") throw new Error(v.value.map(((x) => `${x.key}: ${x.message}`)).join(", "));
                return v.value;
              }
              {
                let v = l;
                return p.type === "color" && typeof l == "string" ? v = di.parse(l) : p.type !== "padding" || typeof l != "number" && !Array.isArray(l) ? p.type !== "numberArray" || typeof l != "number" && !Array.isArray(l) ? p.type !== "colorArray" || typeof l != "string" && !Array.isArray(l) ? p.type === "variableAnchorOffsetCollection" && Array.isArray(l) ? v = Wn.parse(l) : p.type === "projectionDefinition" && typeof l == "string" && (v = ua.parse(l)) : v = Dn.parse(l) : v = Vn.parse(l) : v = bn.parse(l), { globalStateRefs: /* @__PURE__ */ new Set(), kind: "constant", evaluate: () => v };
              }
            })(n === void 0 ? t.specification.default : n, t.specification);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(t, n, l) {
            return this.property.possiblyEvaluate(this, t, n, l);
          }
        }
        class rc {
          constructor(t) {
            this.property = t, this.value = new Lo(t, void 0);
          }
          transitioned(t, n) {
            return new zs(this.property, this.value, n, Ii({}, t.transition, this.transition), t.now);
          }
          untransitioned() {
            return new zs(this.property, this.value, null, {}, 0);
          }
        }
        class Ws {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);
          }
          getValue(t) {
            return oa(this._values[t].value.value);
          }
          setValue(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new rc(this._values[t].property)), this._values[t].value = new Lo(this._values[t].property, n === null ? void 0 : oa(n));
          }
          getTransition(t) {
            return oa(this._values[t].transition);
          }
          setTransition(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new rc(this._values[t].property)), this._values[t].transition = oa(n) || void 0;
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const l = this.getValue(n);
              l !== void 0 && (t[n] = l);
              const p = this.getTransition(n);
              p !== void 0 && (t[`${n}-transition`] = p);
            }
            return t;
          }
          transitioned(t, n) {
            const l = new wl(this._properties);
            for (const p of Object.keys(this._values)) l._values[p] = this._values[p].transitioned(t, n._values[p]);
            return l;
          }
          untransitioned() {
            const t = new wl(this._properties);
            for (const n of Object.keys(this._values)) t._values[n] = this._values[n].untransitioned();
            return t;
          }
        }
        class zs {
          constructor(t, n, l, p, v) {
            this.property = t, this.value = n, this.begin = v + p.delay || 0, this.end = this.begin + p.duration || 0, t.specification.transition && (p.delay || p.duration) && (this.prior = l);
          }
          possiblyEvaluate(t, n, l) {
            const p = t.now || 0, v = this.value.possiblyEvaluate(t, n, l), x = this.prior;
            if (x) {
              if (p > this.end) return this.prior = null, v;
              if (this.value.isDataDriven()) return this.prior = null, v;
              if (p < this.begin) return x.possiblyEvaluate(t, n, l);
              {
                const T = (p - this.begin) / (this.end - this.begin);
                return this.property.interpolate(x.possiblyEvaluate(t, n, l), v, et(T));
              }
            }
            return v;
          }
        }
        class wl {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t, n, l) {
            const p = new Oo(this._properties);
            for (const v of Object.keys(this._values)) p._values[v] = this._values[v].possiblyEvaluate(t, n, l);
            return p;
          }
          hasTransition() {
            for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;
            return !1;
          }
        }
        class Kc {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues);
          }
          hasValue(t) {
            return this._values[t].value !== void 0;
          }
          getValue(t) {
            return oa(this._values[t].value);
          }
          setValue(t, n) {
            this._values[t] = new Lo(this._values[t].property, n === null ? void 0 : oa(n));
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const l = this.getValue(n);
              l !== void 0 && (t[n] = l);
            }
            return t;
          }
          possiblyEvaluate(t, n, l) {
            const p = new Oo(this._properties);
            for (const v of Object.keys(this._values)) p._values[v] = this._values[v].possiblyEvaluate(t, n, l);
            return p;
          }
        }
        class Nr {
          constructor(t, n, l) {
            this.property = t, this.value = n, this.parameters = l;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t;
          }
          evaluate(t, n, l, p) {
            return this.property.evaluate(this.value, this.parameters, t, n, l, p);
          }
        }
        class Oo {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
          }
          get(t) {
            return this._values[t];
          }
        }
        class Tt {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(n);
          }
          interpolate(t, n, l) {
            const p = ps[this.specification.type];
            return p ? p(t, n, l) : t;
          }
        }
        class Ot {
          constructor(t, n) {
            this.specification = t, this.overrides = n;
          }
          possiblyEvaluate(t, n, l, p) {
            return new Nr(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(n, null, {}, l, p) } : t.expression, n);
          }
          interpolate(t, n, l) {
            if (t.value.kind !== "constant" || n.value.kind !== "constant") return t;
            if (t.value.value === void 0 || n.value.value === void 0) return new Nr(this, { kind: "constant", value: void 0 }, t.parameters);
            const p = ps[this.specification.type];
            if (p) {
              const v = p(t.value.value, n.value.value, l);
              return new Nr(this, { kind: "constant", value: v }, t.parameters);
            }
            return t;
          }
          evaluate(t, n, l, p, v, x) {
            return t.kind === "constant" ? t.value : t.evaluate(n, l, p, v, x);
          }
        }
        class sc extends Ot {
          possiblyEvaluate(t, n, l, p) {
            if (t.value === void 0) return new Nr(this, { kind: "constant", value: void 0 }, n);
            if (t.expression.kind === "constant") {
              const v = t.expression.evaluate(n, null, {}, l, p), x = t.property.specification.type === "resolvedImage" && typeof v != "string" ? v.name : v, T = this._calculate(x, x, x, n);
              return new Nr(this, { kind: "constant", value: T }, n);
            }
            if (t.expression.kind === "camera") {
              const v = this._calculate(t.expression.evaluate({ zoom: n.zoom - 1 }), t.expression.evaluate({ zoom: n.zoom }), t.expression.evaluate({ zoom: n.zoom + 1 }), n);
              return new Nr(this, { kind: "constant", value: v }, n);
            }
            return new Nr(this, t.expression, n);
          }
          evaluate(t, n, l, p, v, x) {
            if (t.kind === "source") {
              const T = t.evaluate(n, l, p, v, x);
              return this._calculate(T, T, T, n);
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(n.zoom) - 1 }, l, p), t.evaluate({ zoom: Math.floor(n.zoom) }, l, p), t.evaluate({ zoom: Math.floor(n.zoom) + 1 }, l, p), n) : t.value;
          }
          _calculate(t, n, l, p) {
            return p.zoom > p.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: l, to: n };
          }
          interpolate(t) {
            return t;
          }
        }
        class xr {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n, l, p) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const v = t.expression.evaluate(n, null, {}, l, p);
                return this._calculate(v, v, v, n);
              }
              return this._calculate(t.expression.evaluate(new Li(Math.floor(n.zoom - 1), n)), t.expression.evaluate(new Li(Math.floor(n.zoom), n)), t.expression.evaluate(new Li(Math.floor(n.zoom + 1), n)), n);
            }
          }
          _calculate(t, n, l, p) {
            return p.zoom > p.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: l, to: n };
          }
          interpolate(t) {
            return t;
          }
        }
        class Sl {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n, l, p) {
            return !!t.expression.evaluate(n, null, {}, l, p);
          }
          interpolate() {
            return !1;
          }
        }
        class za {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const n in t) {
              const l = t[n];
              l.specification.overridable && this.overridableProperties.push(n);
              const p = this.defaultPropertyValues[n] = new Lo(l, void 0), v = this.defaultTransitionablePropertyValues[n] = new rc(l);
              this.defaultTransitioningPropertyValues[n] = v.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = p.possiblyEvaluate({});
            }
          }
        }
        xt("DataDrivenProperty", Ot), xt("DataConstantProperty", Tt), xt("CrossFadedDataDrivenProperty", sc), xt("CrossFadedProperty", xr), xt("ColorRampProperty", Sl);
        const Wc = "-transition";
        class rr extends Mt {
          constructor(t, n) {
            if (super(), this.id = t.id, this.type = t.type, this._featureFilter = { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = nr(t.filter)), n.layout && (this._unevaluatedLayout = new Kc(n.layout)), n.paint)) {
              this._transitionablePaint = new Ws(n.paint);
              for (const l in t.paint) this.setPaintProperty(l, t.paint[l], { validate: !1 });
              for (const l in t.layout) this.setLayoutProperty(l, t.layout[l], { validate: !1 });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Oo(n.paint);
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = nr(t);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t);
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = /* @__PURE__ */ new Set();
            if (this._unevaluatedLayout) for (const n in this._unevaluatedLayout._values) {
              const l = this._unevaluatedLayout._values[n];
              for (const p of l.getGlobalStateRefs()) t.add(p);
            }
            for (const n of this._featureFilter.getGlobalStateRefs()) t.add(n);
            return t;
          }
          setLayoutProperty(t, n, l = {}) {
            n != null && this._validate(ap, `layers.${this.id}.layout.${t}`, t, n, l) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, n) : this.visibility = n);
          }
          getPaintProperty(t) {
            return t.endsWith(Wc) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
          }
          setPaintProperty(t, n, l = {}) {
            if (n != null && this._validate(uf, `layers.${this.id}.paint.${t}`, t, n, l)) return !1;
            if (t.endsWith(Wc)) return this._transitionablePaint.setTransition(t.slice(0, -11), n || void 0), !1;
            {
              const p = this._transitionablePaint._values[t], v = p.property.specification["property-type"] === "cross-faded-data-driven", x = p.value.isDataDriven(), T = p.value;
              this._transitionablePaint.setValue(t, n), this._handleSpecialPaintPropertyUpdate(t);
              const E = this._transitionablePaint._values[t].value;
              return E.isDataDriven() || x || v || this._handleOverridablePaintPropertyUpdate(t, T, E);
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {
          }
          _handleOverridablePaintPropertyUpdate(t, n, l) {
            return !1;
          }
          isHidden(t) {
            return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t, n) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, n);
          }
          serialize() {
            const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), bi(t, ((n, l) => !(n === void 0 || l === "layout" && !Object.keys(n).length || l === "paint" && !Object.keys(n).length)));
          }
          _validate(t, n, l, p, v = {}) {
            return (!v || v.validate !== !1) && tc(this, t.call(Po, { key: n, layerType: this.type, objectKey: l, value: p, styleSpec: Ae, style: { glyphs: !0, sprite: !0 } }));
          }
          is3D() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          resize() {
          }
          isStateDependent() {
            for (const t in this.paint._values) {
              const n = this.paint.get(t);
              if (n instanceof Nr && ys(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return !0;
            }
            return !1;
          }
        }
        const br = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Pa {
          constructor(t, n) {
            this._structArray = t, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class Ti {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(t, n) {
            return t._trim(), n && (t.isTransferred = !0, n.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
          }
          static deserialize(t) {
            const n = Object.create(this.prototype);
            return n.arrayBuffer = t.arrayBuffer, n.length = t.length, n.capacity = t.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t) {
            this.reserve(t), this.length = t;
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const n = this.uint8;
              this._refreshViews(), n && this.uint8.set(n);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function fn(a, t = 1) {
          let n = 0, l = 0;
          return { members: a.map(((p) => {
            const v = br[p.type].BYTES_PER_ELEMENT, x = n = oc(n, Math.max(t, v)), T = p.components || 1;
            return l = Math.max(l, v), n += v * T, { name: p.name, type: p.type, components: T, offset: x };
          })), size: oc(n, Math.max(l, t)), alignment: t };
        }
        function oc(a, t) {
          return Math.ceil(a / t) * t;
        }
        class wr extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, n);
          }
          emplace(t, n, l) {
            const p = 2 * t;
            return this.int16[p + 0] = n, this.int16[p + 1] = l, t;
          }
        }
        wr.prototype.bytesPerElement = 4, xt("StructArrayLayout2i4", wr);
        class da extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, n, l);
          }
          emplace(t, n, l, p) {
            const v = 3 * t;
            return this.int16[v + 0] = n, this.int16[v + 1] = l, this.int16[v + 2] = p, t;
          }
        }
        da.prototype.bytesPerElement = 6, xt("StructArrayLayout3i6", da);
        class Sn extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l, p) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, n, l, p);
          }
          emplace(t, n, l, p, v) {
            const x = 4 * t;
            return this.int16[x + 0] = n, this.int16[x + 1] = l, this.int16[x + 2] = p, this.int16[x + 3] = v, t;
          }
        }
        Sn.prototype.bytesPerElement = 8, xt("StructArrayLayout4i8", Sn);
        class Js extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l, p, v, x) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, t, n, l, p, v, x);
          }
          emplace(t, n, l, p, v, x, T) {
            const E = 6 * t;
            return this.int16[E + 0] = n, this.int16[E + 1] = l, this.int16[E + 2] = p, this.int16[E + 3] = v, this.int16[E + 4] = x, this.int16[E + 5] = T, t;
          }
        }
        Js.prototype.bytesPerElement = 12, xt("StructArrayLayout2i4i12", Js);
        class qa extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l, p, v, x) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, t, n, l, p, v, x);
          }
          emplace(t, n, l, p, v, x, T) {
            const E = 4 * t, k = 8 * t;
            return this.int16[E + 0] = n, this.int16[E + 1] = l, this.uint8[k + 4] = p, this.uint8[k + 5] = v, this.uint8[k + 6] = x, this.uint8[k + 7] = T, t;
          }
        }
        qa.prototype.bytesPerElement = 8, xt("StructArrayLayout2i4ub8", qa);
        class ni extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, n);
          }
          emplace(t, n, l) {
            const p = 2 * t;
            return this.float32[p + 0] = n, this.float32[p + 1] = l, t;
          }
        }
        ni.prototype.bytesPerElement = 8, xt("StructArrayLayout2f8", ni);
        class Bi extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l, p, v, x, T, E, k, D) {
            const N = this.length;
            return this.resize(N + 1), this.emplace(N, t, n, l, p, v, x, T, E, k, D);
          }
          emplace(t, n, l, p, v, x, T, E, k, D, N) {
            const q = 10 * t;
            return this.uint16[q + 0] = n, this.uint16[q + 1] = l, this.uint16[q + 2] = p, this.uint16[q + 3] = v, this.uint16[q + 4] = x, this.uint16[q + 5] = T, this.uint16[q + 6] = E, this.uint16[q + 7] = k, this.uint16[q + 8] = D, this.uint16[q + 9] = N, t;
          }
        }
        Bi.prototype.bytesPerElement = 20, xt("StructArrayLayout10ui20", Bi);
        class rn extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l, p, v, x, T, E, k, D, N, q) {
            const G = this.length;
            return this.resize(G + 1), this.emplace(G, t, n, l, p, v, x, T, E, k, D, N, q);
          }
          emplace(t, n, l, p, v, x, T, E, k, D, N, q, G) {
            const Z = 12 * t;
            return this.int16[Z + 0] = n, this.int16[Z + 1] = l, this.int16[Z + 2] = p, this.int16[Z + 3] = v, this.uint16[Z + 4] = x, this.uint16[Z + 5] = T, this.uint16[Z + 6] = E, this.uint16[Z + 7] = k, this.int16[Z + 8] = D, this.int16[Z + 9] = N, this.int16[Z + 10] = q, this.int16[Z + 11] = G, t;
          }
        }
        rn.prototype.bytesPerElement = 24, xt("StructArrayLayout4i4ui4i24", rn);
        class uu extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, n, l);
          }
          emplace(t, n, l, p) {
            const v = 3 * t;
            return this.float32[v + 0] = n, this.float32[v + 1] = l, this.float32[v + 2] = p, t;
          }
        }
        uu.prototype.bytesPerElement = 12, xt("StructArrayLayout3f12", uu);
        class Bo extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.uint32[1 * t + 0] = n, t;
          }
        }
        Bo.prototype.bytesPerElement = 4, xt("StructArrayLayout1ul4", Bo);
        class Ps extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l, p, v, x, T, E, k) {
            const D = this.length;
            return this.resize(D + 1), this.emplace(D, t, n, l, p, v, x, T, E, k);
          }
          emplace(t, n, l, p, v, x, T, E, k, D) {
            const N = 10 * t, q = 5 * t;
            return this.int16[N + 0] = n, this.int16[N + 1] = l, this.int16[N + 2] = p, this.int16[N + 3] = v, this.int16[N + 4] = x, this.int16[N + 5] = T, this.uint32[q + 3] = E, this.uint16[N + 8] = k, this.uint16[N + 9] = D, t;
          }
        }
        Ps.prototype.bytesPerElement = 20, xt("StructArrayLayout6i1ul2ui20", Ps);
        class cu extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l, p, v, x) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, t, n, l, p, v, x);
          }
          emplace(t, n, l, p, v, x, T) {
            const E = 6 * t;
            return this.int16[E + 0] = n, this.int16[E + 1] = l, this.int16[E + 2] = p, this.int16[E + 3] = v, this.int16[E + 4] = x, this.int16[E + 5] = T, t;
          }
        }
        cu.prototype.bytesPerElement = 12, xt("StructArrayLayout2i2i2i12", cu);
        class y extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l, p, v) {
            const x = this.length;
            return this.resize(x + 1), this.emplace(x, t, n, l, p, v);
          }
          emplace(t, n, l, p, v, x) {
            const T = 4 * t, E = 8 * t;
            return this.float32[T + 0] = n, this.float32[T + 1] = l, this.float32[T + 2] = p, this.int16[E + 6] = v, this.int16[E + 7] = x, t;
          }
        }
        y.prototype.bytesPerElement = 16, xt("StructArrayLayout2f1f2i16", y);
        class e extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l, p, v, x) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, t, n, l, p, v, x);
          }
          emplace(t, n, l, p, v, x, T) {
            const E = 16 * t, k = 4 * t, D = 8 * t;
            return this.uint8[E + 0] = n, this.uint8[E + 1] = l, this.float32[k + 1] = p, this.float32[k + 2] = v, this.int16[D + 6] = x, this.int16[D + 7] = T, t;
          }
        }
        e.prototype.bytesPerElement = 16, xt("StructArrayLayout2ub2f2i16", e);
        class r extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, n, l);
          }
          emplace(t, n, l, p) {
            const v = 3 * t;
            return this.uint16[v + 0] = n, this.uint16[v + 1] = l, this.uint16[v + 2] = p, t;
          }
        }
        r.prototype.bytesPerElement = 6, xt("StructArrayLayout3ui6", r);
        class c extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l, p, v, x, T, E, k, D, N, q, G, Z, X, ee, se) {
            const xe = this.length;
            return this.resize(xe + 1), this.emplace(xe, t, n, l, p, v, x, T, E, k, D, N, q, G, Z, X, ee, se);
          }
          emplace(t, n, l, p, v, x, T, E, k, D, N, q, G, Z, X, ee, se, xe) {
            const de = 24 * t, ge = 12 * t, Ie = 48 * t;
            return this.int16[de + 0] = n, this.int16[de + 1] = l, this.uint16[de + 2] = p, this.uint16[de + 3] = v, this.uint32[ge + 2] = x, this.uint32[ge + 3] = T, this.uint32[ge + 4] = E, this.uint16[de + 10] = k, this.uint16[de + 11] = D, this.uint16[de + 12] = N, this.float32[ge + 7] = q, this.float32[ge + 8] = G, this.uint8[Ie + 36] = Z, this.uint8[Ie + 37] = X, this.uint8[Ie + 38] = ee, this.uint32[ge + 10] = se, this.int16[de + 22] = xe, t;
          }
        }
        c.prototype.bytesPerElement = 48, xt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", c);
        class f extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l, p, v, x, T, E, k, D, N, q, G, Z, X, ee, se, xe, de, ge, Ie, Fe, Je, gt, ut, yt, kt, mt) {
            const pt = this.length;
            return this.resize(pt + 1), this.emplace(pt, t, n, l, p, v, x, T, E, k, D, N, q, G, Z, X, ee, se, xe, de, ge, Ie, Fe, Je, gt, ut, yt, kt, mt);
          }
          emplace(t, n, l, p, v, x, T, E, k, D, N, q, G, Z, X, ee, se, xe, de, ge, Ie, Fe, Je, gt, ut, yt, kt, mt, pt) {
            const Xe = 32 * t, Bt = 16 * t;
            return this.int16[Xe + 0] = n, this.int16[Xe + 1] = l, this.int16[Xe + 2] = p, this.int16[Xe + 3] = v, this.int16[Xe + 4] = x, this.int16[Xe + 5] = T, this.int16[Xe + 6] = E, this.int16[Xe + 7] = k, this.uint16[Xe + 8] = D, this.uint16[Xe + 9] = N, this.uint16[Xe + 10] = q, this.uint16[Xe + 11] = G, this.uint16[Xe + 12] = Z, this.uint16[Xe + 13] = X, this.uint16[Xe + 14] = ee, this.uint16[Xe + 15] = se, this.uint16[Xe + 16] = xe, this.uint16[Xe + 17] = de, this.uint16[Xe + 18] = ge, this.uint16[Xe + 19] = Ie, this.uint16[Xe + 20] = Fe, this.uint16[Xe + 21] = Je, this.uint16[Xe + 22] = gt, this.uint32[Bt + 12] = ut, this.float32[Bt + 13] = yt, this.float32[Bt + 14] = kt, this.uint16[Xe + 30] = mt, this.uint16[Xe + 31] = pt, t;
          }
        }
        f.prototype.bytesPerElement = 64, xt("StructArrayLayout8i15ui1ul2f2ui64", f);
        class _ extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.float32[1 * t + 0] = n, t;
          }
        }
        _.prototype.bytesPerElement = 4, xt("StructArrayLayout1f4", _);
        class w extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, n, l);
          }
          emplace(t, n, l, p) {
            const v = 3 * t;
            return this.uint16[6 * t + 0] = n, this.float32[v + 1] = l, this.float32[v + 2] = p, t;
          }
        }
        w.prototype.bytesPerElement = 12, xt("StructArrayLayout1ui2f12", w);
        class C extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, n, l);
          }
          emplace(t, n, l, p) {
            const v = 4 * t;
            return this.uint32[2 * t + 0] = n, this.uint16[v + 2] = l, this.uint16[v + 3] = p, t;
          }
        }
        C.prototype.bytesPerElement = 8, xt("StructArrayLayout1ul2ui8", C);
        class P extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, n);
          }
          emplace(t, n, l) {
            const p = 2 * t;
            return this.uint16[p + 0] = n, this.uint16[p + 1] = l, t;
          }
        }
        P.prototype.bytesPerElement = 4, xt("StructArrayLayout2ui4", P);
        class R extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.uint16[1 * t + 0] = n, t;
          }
        }
        R.prototype.bytesPerElement = 2, xt("StructArrayLayout1ui2", R);
        class L extends Ti {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, l, p) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, n, l, p);
          }
          emplace(t, n, l, p, v) {
            const x = 4 * t;
            return this.float32[x + 0] = n, this.float32[x + 1] = l, this.float32[x + 2] = p, this.float32[x + 3] = v, t;
          }
        }
        L.prototype.bytesPerElement = 16, xt("StructArrayLayout4f16", L);
        class j extends Pa {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new O(this.anchorPointX, this.anchorPointY);
          }
        }
        j.prototype.size = 20;
        class B extends Ps {
          get(t) {
            return new j(this, t);
          }
        }
        xt("CollisionBoxArray", B);
        class V extends Pa {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        V.prototype.size = 48;
        class $ extends c {
          get(t) {
            return new V(this, t);
          }
        }
        xt("PlacedSymbolArray", $);
        class ie extends Pa {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        ie.prototype.size = 64;
        class te extends f {
          get(t) {
            return new ie(this, t);
          }
        }
        xt("SymbolInstanceArray", te);
        class ne extends _ {
          getoffsetX(t) {
            return this.float32[1 * t + 0];
          }
        }
        xt("GlyphOffsetArray", ne);
        class re extends da {
          getx(t) {
            return this.int16[3 * t + 0];
          }
          gety(t) {
            return this.int16[3 * t + 1];
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2];
          }
        }
        xt("SymbolLineVertexArray", re);
        class ce extends Pa {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        ce.prototype.size = 12;
        class oe extends w {
          get(t) {
            return new ce(this, t);
          }
        }
        xt("TextAnchorOffsetArray", oe);
        class pe extends Pa {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        pe.prototype.size = 8;
        class ye extends C {
          get(t) {
            return new pe(this, t);
          }
        }
        xt("FeatureIndexArray", ye);
        class ue extends wr {
        }
        class we extends wr {
        }
        class Oe extends wr {
        }
        class ze extends Js {
        }
        class Pe extends qa {
        }
        class Le extends ni {
        }
        class lt extends Bi {
        }
        class ct extends rn {
        }
        class We extends uu {
        }
        class At extends Bo {
        }
        class ai extends cu {
        }
        class zi extends e {
        }
        class qi extends r {
        }
        class Ni extends P {
        }
        const un = fn([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: mn } = un;
        class Qt {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t;
          }
          prepareSegment(t, n, l, p) {
            const v = this.segments[this.segments.length - 1];
            return t > Qt.MAX_VERTEX_ARRAY_LENGTH && $i(`Max vertices per segment is ${Qt.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Qt.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !v || v.vertexLength + t > Qt.MAX_VERTEX_ARRAY_LENGTH || v.sortKey !== p ? this.createNewSegment(n, l, p) : v;
          }
          createNewSegment(t, n, l) {
            const p = { vertexOffset: t.length, primitiveOffset: n.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return l !== void 0 && (p.sortKey = l), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(p), p;
          }
          getOrCreateLatestSegment(t, n, l) {
            return this.prepareSegment(0, t, n, l);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t of this.segments) for (const n in t.vaos) t.vaos[n].destroy();
          }
          static simpleSegment(t, n, l, p) {
            return new Qt([{ vertexOffset: t, primitiveOffset: n, vertexLength: l, primitiveLength: p, vaos: {}, sortKey: 0 }]);
          }
        }
        function Xi(a, t) {
          return 256 * (a = Vt(Math.floor(a), 0, 255)) + Vt(Math.floor(t), 0, 255);
        }
        Qt.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, xt("SegmentVector", Qt);
        const Bn = fn([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var gn, ta, pa, sr = { exports: {} }, Qs = { exports: {} }, Is = { exports: {} }, hu = (function() {
          if (pa) return sr.exports;
          pa = 1;
          var a = (gn || (gn = 1, Qs.exports = function(n, l) {
            var p, v, x, T, E, k, D, N;
            for (v = n.length - (p = 3 & n.length), x = l, E = 3432918353, k = 461845907, N = 0; N < v; ) D = 255 & n.charCodeAt(N) | (255 & n.charCodeAt(++N)) << 8 | (255 & n.charCodeAt(++N)) << 16 | (255 & n.charCodeAt(++N)) << 24, ++N, x = 27492 + (65535 & (T = 5 * (65535 & (x = (x ^= D = (65535 & (D = (D = (65535 & D) * E + (((D >>> 16) * E & 65535) << 16) & 4294967295) << 15 | D >>> 17)) * k + (((D >>> 16) * k & 65535) << 16) & 4294967295) << 13 | x >>> 19)) + ((5 * (x >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (T >>> 16) & 65535) << 16);
            switch (D = 0, p) {
              case 3:
                D ^= (255 & n.charCodeAt(N + 2)) << 16;
              case 2:
                D ^= (255 & n.charCodeAt(N + 1)) << 8;
              case 1:
                x ^= D = (65535 & (D = (D = (65535 & (D ^= 255 & n.charCodeAt(N))) * E + (((D >>> 16) * E & 65535) << 16) & 4294967295) << 15 | D >>> 17)) * k + (((D >>> 16) * k & 65535) << 16) & 4294967295;
            }
            return x ^= n.length, x = 2246822507 * (65535 & (x ^= x >>> 16)) + ((2246822507 * (x >>> 16) & 65535) << 16) & 4294967295, x = 3266489909 * (65535 & (x ^= x >>> 13)) + ((3266489909 * (x >>> 16) & 65535) << 16) & 4294967295, (x ^= x >>> 16) >>> 0;
          }), Qs.exports), t = (ta || (ta = 1, Is.exports = function(n, l) {
            for (var p, v = n.length, x = l ^ v, T = 0; v >= 4; ) p = 1540483477 * (65535 & (p = 255 & n.charCodeAt(T) | (255 & n.charCodeAt(++T)) << 8 | (255 & n.charCodeAt(++T)) << 16 | (255 & n.charCodeAt(++T)) << 24)) + ((1540483477 * (p >>> 16) & 65535) << 16), x = 1540483477 * (65535 & x) + ((1540483477 * (x >>> 16) & 65535) << 16) ^ (p = 1540483477 * (65535 & (p ^= p >>> 24)) + ((1540483477 * (p >>> 16) & 65535) << 16)), v -= 4, ++T;
            switch (v) {
              case 3:
                x ^= (255 & n.charCodeAt(T + 2)) << 16;
              case 2:
                x ^= (255 & n.charCodeAt(T + 1)) << 8;
              case 1:
                x = 1540483477 * (65535 & (x ^= 255 & n.charCodeAt(T))) + ((1540483477 * (x >>> 16) & 65535) << 16);
            }
            return x = 1540483477 * (65535 & (x ^= x >>> 13)) + ((1540483477 * (x >>> 16) & 65535) << 16), (x ^= x >>> 15) >>> 0;
          }), Is.exports);
          return sr.exports = a, sr.exports.murmur3 = a, sr.exports.murmur2 = t, sr.exports;
        })(), Tl = U(hu);
        class No {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1;
          }
          add(t, n, l, p) {
            this.ids.push(jo(t)), this.positions.push(n, l, p);
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const n = jo(t);
            let l = 0, p = this.ids.length - 1;
            for (; l < p; ) {
              const x = l + p >> 1;
              this.ids[x] >= n ? p = x : l = x + 1;
            }
            const v = [];
            for (; this.ids[l] === n; ) v.push({ index: this.positions[3 * l], start: this.positions[3 * l + 1], end: this.positions[3 * l + 2] }), l++;
            return v;
          }
          static serialize(t, n) {
            const l = new Float64Array(t.ids), p = new Uint32Array(t.positions);
            return Ga(l, p, 0, l.length - 1), n && n.push(l.buffer, p.buffer), { ids: l, positions: p };
          }
          static deserialize(t) {
            const n = new No();
            return n.ids = t.ids, n.positions = t.positions, n.indexed = !0, n;
          }
        }
        function jo(a) {
          const t = +a;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : Tl(String(a));
        }
        function Ga(a, t, n, l) {
          for (; n < l; ) {
            const p = a[n + l >> 1];
            let v = n - 1, x = l + 1;
            for (; ; ) {
              do
                v++;
              while (a[v] < p);
              do
                x--;
              while (a[x] > p);
              if (v >= x) break;
              jr(a, v, x), jr(t, 3 * v, 3 * x), jr(t, 3 * v + 1, 3 * x + 1), jr(t, 3 * v + 2, 3 * x + 2);
            }
            x - n < l - x ? (Ga(a, t, n, x), n = x + 1) : (Ga(a, t, x + 1, l), l = x);
          }
        }
        function jr(a, t, n) {
          const l = a[t];
          a[t] = a[n], a[n] = l;
        }
        xt("FeaturePositionMap", No);
        class va {
          constructor(t, n) {
            this.gl = t.gl, this.location = n;
          }
        }
        class eo extends va {
          constructor(t, n) {
            super(t, n), this.current = 0;
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
          }
        }
        class Nn extends va {
          constructor(t, n) {
            super(t, n), this.current = [0, 0, 0, 0];
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
          }
        }
        class jn extends va {
          constructor(t, n) {
            super(t, n), this.current = di.transparent;
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
          }
        }
        const Sr = new Float32Array(16);
        function Un(a) {
          return [Xi(255 * a.r, 255 * a.g), Xi(255 * a.b, 255 * a.a)];
        }
        class lc {
          constructor(t, n, l) {
            this.value = t, this.uniformNames = n.map(((p) => `u_${p}`)), this.type = l;
          }
          setUniform(t, n, l) {
            t.set(l.constantOr(this.value));
          }
          getBinding(t, n, l) {
            return this.type === "color" ? new jn(t, n) : new eo(t, n);
          }
        }
        class Uo {
          constructor(t, n) {
            this.uniformNames = n.map(((l) => `u_${l}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t, n) {
            this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = t.tlbr;
          }
          setUniform(t, n, l, p) {
            const v = p === "u_pattern_to" ? this.patternTo : p === "u_pattern_from" ? this.patternFrom : p === "u_pixel_ratio_to" ? this.pixelRatioTo : p === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            v && t.set(v);
          }
          getBinding(t, n, l) {
            return l.substr(0, 9) === "u_pattern" ? new Nn(t, n) : new eo(t, n);
          }
        }
        class ks {
          constructor(t, n, l, p) {
            this.expression = t, this.type = l, this.maxValue = 0, this.paintVertexAttributes = n.map(((v) => ({ name: `a_${v}`, type: "Float32", components: l === "color" ? 2 : 1, offset: 0 }))), this.paintVertexArray = new p();
          }
          populatePaintArray(t, n, l, p, v) {
            const x = this.paintVertexArray.length, T = this.expression.evaluate(new Li(0), n, {}, p, [], v);
            this.paintVertexArray.resize(t), this._setPaintValue(x, t, T);
          }
          updatePaintArray(t, n, l, p) {
            const v = this.expression.evaluate({ zoom: 0 }, l, p);
            this._setPaintValue(t, n, v);
          }
          _setPaintValue(t, n, l) {
            if (this.type === "color") {
              const p = Un(l);
              for (let v = t; v < n; v++) this.paintVertexArray.emplace(v, p[0], p[1]);
            } else {
              for (let p = t; p < n; p++) this.paintVertexArray.emplace(p, l);
              this.maxValue = Math.max(this.maxValue, Math.abs(l));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Ur {
          constructor(t, n, l, p, v, x) {
            this.expression = t, this.uniformNames = n.map(((T) => `u_${T}_t`)), this.type = l, this.useIntegerZoom = p, this.zoom = v, this.maxValue = 0, this.paintVertexAttributes = n.map(((T) => ({ name: `a_${T}`, type: "Float32", components: l === "color" ? 4 : 2, offset: 0 }))), this.paintVertexArray = new x();
          }
          populatePaintArray(t, n, l, p, v) {
            const x = this.expression.evaluate(new Li(this.zoom), n, {}, p, [], v), T = this.expression.evaluate(new Li(this.zoom + 1), n, {}, p, [], v), E = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(E, t, x, T);
          }
          updatePaintArray(t, n, l, p) {
            const v = this.expression.evaluate({ zoom: this.zoom }, l, p), x = this.expression.evaluate({ zoom: this.zoom + 1 }, l, p);
            this._setPaintValue(t, n, v, x);
          }
          _setPaintValue(t, n, l, p) {
            if (this.type === "color") {
              const v = Un(l), x = Un(p);
              for (let T = t; T < n; T++) this.paintVertexArray.emplace(T, v[0], v[1], x[0], x[1]);
            } else {
              for (let v = t; v < n; v++) this.paintVertexArray.emplace(v, l, p);
              this.maxValue = Math.max(this.maxValue, Math.abs(l), Math.abs(p));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t, n) {
            const l = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom, p = Vt(this.expression.interpolationFactor(l, this.zoom, this.zoom + 1), 0, 1);
            t.set(p);
          }
          getBinding(t, n, l) {
            return new eo(t, n);
          }
        }
        class Rs {
          constructor(t, n, l, p, v, x) {
            this.expression = t, this.type = n, this.useIntegerZoom = l, this.zoom = p, this.layerId = x, this.zoomInPaintVertexArray = new v(), this.zoomOutPaintVertexArray = new v();
          }
          populatePaintArray(t, n, l) {
            const p = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(p, t, n.patterns && n.patterns[this.layerId], l);
          }
          updatePaintArray(t, n, l, p, v) {
            this._setPaintValues(t, n, l.patterns && l.patterns[this.layerId], v);
          }
          _setPaintValues(t, n, l, p) {
            if (!p || !l) return;
            const { min: v, mid: x, max: T } = l, E = p[v], k = p[x], D = p[T];
            if (E && k && D) for (let N = t; N < n; N++) this.zoomInPaintVertexArray.emplace(N, k.tl[0], k.tl[1], k.br[0], k.br[1], E.tl[0], E.tl[1], E.br[0], E.br[1], k.pixelRatio, E.pixelRatio), this.zoomOutPaintVertexArray.emplace(N, k.tl[0], k.tl[1], k.br[0], k.br[1], D.tl[0], D.tl[1], D.br[0], D.br[1], k.pixelRatio, D.pixelRatio);
          }
          upload(t) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, Bn.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, Bn.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Kh {
          constructor(t, n, l) {
            this.binders = {}, this._buffers = [];
            const p = [];
            for (const v in t.paint._values) {
              if (!l(v)) continue;
              const x = t.paint.get(v);
              if (!(x instanceof Nr && ys(x.property.specification))) continue;
              const T = sp(v, t.type), E = x.value, k = x.property.specification.type, D = x.property.useIntegerZoom, N = x.property.specification["property-type"], q = N === "cross-faded" || N === "cross-faded-data-driven";
              if (E.kind === "constant") this.binders[v] = q ? new Uo(E.value, T) : new lc(E.value, T, k), p.push(`/u_${v}`);
              else if (E.kind === "source" || q) {
                const G = Wh(v, k, "source");
                this.binders[v] = q ? new Rs(E, k, D, n, G, t.id) : new ks(E, T, k, G), p.push(`/a_${v}`);
              } else {
                const G = Wh(v, k, "composite");
                this.binders[v] = new Ur(E, T, k, D, n, G), p.push(`/z_${v}`);
              }
            }
            this.cacheKey = p.sort().join("");
          }
          getMaxValue(t) {
            const n = this.binders[t];
            return n instanceof ks || n instanceof Ur ? n.maxValue : 0;
          }
          populatePaintArrays(t, n, l, p, v) {
            for (const x in this.binders) {
              const T = this.binders[x];
              (T instanceof ks || T instanceof Ur || T instanceof Rs) && T.populatePaintArray(t, n, l, p, v);
            }
          }
          setConstantPatternPositions(t, n) {
            for (const l in this.binders) {
              const p = this.binders[l];
              p instanceof Uo && p.setConstantPatternPositions(t, n);
            }
          }
          updatePaintArrays(t, n, l, p, v) {
            let x = !1;
            for (const T in t) {
              const E = n.getPositions(T);
              for (const k of E) {
                const D = l.feature(k.index);
                for (const N in this.binders) {
                  const q = this.binders[N];
                  if ((q instanceof ks || q instanceof Ur || q instanceof Rs) && q.expression.isStateDependent === !0) {
                    const G = p.paint.get(N);
                    q.expression = G.value, q.updatePaintArray(k.start, k.end, D, t[T], v), x = !0;
                  }
                }
              }
            }
            return x;
          }
          defines() {
            const t = [];
            for (const n in this.binders) {
              const l = this.binders[n];
              (l instanceof lc || l instanceof Uo) && t.push(...l.uniformNames.map(((p) => `#define HAS_UNIFORM_${p}`)));
            }
            return t;
          }
          getBinderAttributes() {
            const t = [];
            for (const n in this.binders) {
              const l = this.binders[n];
              if (l instanceof ks || l instanceof Ur) for (let p = 0; p < l.paintVertexAttributes.length; p++) t.push(l.paintVertexAttributes[p].name);
              else if (l instanceof Rs) for (let p = 0; p < Bn.members.length; p++) t.push(Bn.members[p].name);
            }
            return t;
          }
          getBinderUniforms() {
            const t = [];
            for (const n in this.binders) {
              const l = this.binders[n];
              if (l instanceof lc || l instanceof Uo || l instanceof Ur) for (const p of l.uniformNames) t.push(p);
            }
            return t;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t, n) {
            const l = [];
            for (const p in this.binders) {
              const v = this.binders[p];
              if (v instanceof lc || v instanceof Uo || v instanceof Ur) {
                for (const x of v.uniformNames) if (n[x]) {
                  const T = v.getBinding(t, n[x], x);
                  l.push({ name: x, property: p, binding: T });
                }
              }
            }
            return l;
          }
          setUniforms(t, n, l, p) {
            for (const { name: v, property: x, binding: T } of n) this.binders[x].setUniform(T, p, l.get(x), v);
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const n in this.binders) {
              const l = this.binders[n];
              if (t && l instanceof Rs) {
                const p = t.fromScale === 2 ? l.zoomInPaintVertexBuffer : l.zoomOutPaintVertexBuffer;
                p && this._buffers.push(p);
              } else (l instanceof ks || l instanceof Ur) && l.paintVertexBuffer && this._buffers.push(l.paintVertexBuffer);
            }
          }
          upload(t) {
            for (const n in this.binders) {
              const l = this.binders[n];
              (l instanceof ks || l instanceof Ur || l instanceof Rs) && l.upload(t);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t in this.binders) {
              const n = this.binders[t];
              (n instanceof ks || n instanceof Ur || n instanceof Rs) && n.destroy();
            }
          }
        }
        class or {
          constructor(t, n, l = () => !0) {
            this.programConfigurations = {};
            for (const p of t) this.programConfigurations[p.id] = new Kh(p, n, l);
            this.needsUpload = !1, this._featureMap = new No(), this._bufferOffset = 0;
          }
          populatePaintArrays(t, n, l, p, v, x) {
            for (const T in this.programConfigurations) this.programConfigurations[T].populatePaintArrays(t, n, p, v, x);
            n.id !== void 0 && this._featureMap.add(n.id, l, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;
          }
          updatePaintArrays(t, n, l, p) {
            for (const v of l) this.needsUpload = this.programConfigurations[v.id].updatePaintArrays(t, this._featureMap, n, v, p) || this.needsUpload;
          }
          get(t) {
            return this.programConfigurations[t];
          }
          upload(t) {
            if (this.needsUpload) {
              for (const n in this.programConfigurations) this.programConfigurations[n].upload(t);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
          }
        }
        function sp(a, t) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[a] || [a.replace(`${t}-`, "").replace(/-/g, "_")];
        }
        function Wh(a, t, n) {
          const l = { color: { source: ni, composite: L }, number: { source: _, composite: ni } }, p = (function(v) {
            return { "line-pattern": { source: lt, composite: lt }, "fill-pattern": { source: lt, composite: lt }, "fill-extrusion-pattern": { source: lt, composite: lt } }[v];
          })(a);
          return p && p[n] || l[t][n];
        }
        xt("ConstantBinder", lc), xt("CrossFadedConstantBinder", Uo), xt("SourceExpressionBinder", ks), xt("CrossFadedCompositeBinder", Rs), xt("CompositeExpressionBinder", Ur), xt("ProgramConfiguration", Kh, { omit: ["_buffers"] }), xt("ProgramConfigurationSet", or);
        const uc = Math.pow(2, 14) - 1, Fo = -uc - 1;
        function Ds(a) {
          const t = at / a.extent, n = a.loadGeometry();
          for (let l = 0; l < n.length; l++) {
            const p = n[l];
            for (let v = 0; v < p.length; v++) {
              const x = p[v], T = Math.round(x.x * t), E = Math.round(x.y * t);
              x.x = Vt(T, Fo, uc), x.y = Vt(E, Fo, uc), (T < x.x || T > x.x + 1 || E < x.y || E > x.y + 1) && $i("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return n;
        }
        function Fr(a, t) {
          return { type: a.type, id: a.id, properties: a.properties, geometry: t ? Ds(a) : [] };
        }
        const cf = -32768;
        function Bm(a, t, n, l, p) {
          a.emplaceBack(cf + 8 * t + l, cf + 8 * n + p);
        }
        class cc {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new we(), this.indexArray = new qi(), this.segments = new Qt(), this.programConfigurations = new or(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, l) {
            const p = this.layers[0], v = [];
            let x = null, T = !1, E = p.type === "heatmap";
            if (p.type === "circle") {
              const D = p;
              x = D.layout.get("circle-sort-key"), T = !x.isConstant(), E = E || D.paint.get("circle-pitch-alignment") === "map";
            }
            const k = E ? n.subdivisionGranularity.circle : 1;
            for (const { feature: D, id: N, index: q, sourceLayerIndex: G } of t) {
              const Z = this.layers[0]._featureFilter.needGeometry, X = Fr(D, Z);
              if (!this.layers[0]._featureFilter.filter(new Li(this.zoom, { globalState: this.globalState }), X, l)) continue;
              const ee = T ? x.evaluate(X, {}, l) : void 0, se = { id: N, properties: D.properties, type: D.type, sourceLayerIndex: G, index: q, geometry: Z ? X.geometry : Ds(D), patterns: {}, sortKey: ee };
              v.push(se);
            }
            T && v.sort(((D, N) => D.sortKey - N.sortKey));
            for (const D of v) {
              const { geometry: N, index: q, sourceLayerIndex: G } = D, Z = t[q].feature;
              this.addFeature(D, N, q, l, k), n.featureIndex.insert(Z, N, q, G, this.index);
            }
          }
          update(t, n, l) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, l);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, mn), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t, n, l, p, v = 1) {
            let x;
            switch (v) {
              case 1:
                x = [0, 7];
                break;
              case 3:
                x = [0, 2, 5, 7];
                break;
              case 5:
                x = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                x = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${v}; valid values are 1, 3, 5, 7.`);
            }
            const T = x.length;
            for (const E of n) for (const k of E) {
              const D = k.x, N = k.y;
              if (D < 0 || D >= at || N < 0 || N >= at) continue;
              const q = this.segments.prepareSegment(T * T, this.layoutVertexArray, this.indexArray, t.sortKey), G = q.vertexLength;
              for (let Z = 0; Z < T; Z++) for (let X = 0; X < T; X++) Bm(this.layoutVertexArray, D, N, x[X], x[Z]);
              for (let Z = 0; Z < T - 1; Z++) for (let X = 0; X < T - 1; X++) {
                const ee = G + Z * T + X, se = G + (Z + 1) * T + X;
                this.indexArray.emplaceBack(ee, se + 1, ee + 1), this.indexArray.emplaceBack(ee, se, se + 1);
              }
              q.vertexLength += T * T, q.primitiveLength += (T - 1) * (T - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, l, {}, p);
          }
        }
        function hf(a, t) {
          for (let n = 0; n < a.length; n++) if (hc(t, a[n])) return !0;
          for (let n = 0; n < t.length; n++) if (hc(a, t[n])) return !0;
          return !!Jh(a, t);
        }
        function df(a, t, n) {
          return !!hc(a, t) || !!op(t, a, n);
        }
        function pf(a, t) {
          if (a.length === 1) return mf(t, a[0]);
          for (let n = 0; n < t.length; n++) {
            const l = t[n];
            for (let p = 0; p < l.length; p++) if (hc(a, l[p])) return !0;
          }
          for (let n = 0; n < a.length; n++) if (mf(t, a[n])) return !0;
          for (let n = 0; n < t.length; n++) if (Jh(a, t[n])) return !0;
          return !1;
        }
        function ff(a, t, n) {
          if (a.length > 1) {
            if (Jh(a, t)) return !0;
            for (let l = 0; l < t.length; l++) if (op(t[l], a, n)) return !0;
          }
          for (let l = 0; l < a.length; l++) if (op(a[l], t, n)) return !0;
          return !1;
        }
        function Jh(a, t) {
          if (a.length === 0 || t.length === 0) return !1;
          for (let n = 0; n < a.length - 1; n++) {
            const l = a[n], p = a[n + 1];
            for (let v = 0; v < t.length - 1; v++) if (Nm(l, p, t[v], t[v + 1])) return !0;
          }
          return !1;
        }
        function Nm(a, t, n, l) {
          return ma(a, n, l) !== ma(t, n, l) && ma(a, t, n) !== ma(a, t, l);
        }
        function op(a, t, n) {
          const l = n * n;
          if (t.length === 1) return a.distSqr(t[0]) < l;
          for (let p = 1; p < t.length; p++) if (du(a, t[p - 1], t[p]) < l) return !0;
          return !1;
        }
        function du(a, t, n) {
          const l = t.distSqr(n);
          if (l === 0) return a.distSqr(t);
          const p = ((a.x - t.x) * (n.x - t.x) + (a.y - t.y) * (n.y - t.y)) / l;
          return a.distSqr(p < 0 ? t : p > 1 ? n : n.sub(t)._mult(p)._add(t));
        }
        function mf(a, t) {
          let n, l, p, v = !1;
          for (let x = 0; x < a.length; x++) {
            n = a[x];
            for (let T = 0, E = n.length - 1; T < n.length; E = T++) l = n[T], p = n[E], l.y > t.y != p.y > t.y && t.x < (p.x - l.x) * (t.y - l.y) / (p.y - l.y) + l.x && (v = !v);
          }
          return v;
        }
        function hc(a, t) {
          let n = !1;
          for (let l = 0, p = a.length - 1; l < a.length; p = l++) {
            const v = a[l], x = a[p];
            v.y > t.y != x.y > t.y && t.x < (x.x - v.x) * (t.y - v.y) / (x.y - v.y) + v.x && (n = !n);
          }
          return n;
        }
        function jm(a, t, n) {
          const l = n[0], p = n[2];
          if (a.x < l.x && t.x < l.x || a.x > p.x && t.x > p.x || a.y < l.y && t.y < l.y || a.y > p.y && t.y > p.y) return !1;
          const v = ma(a, t, n[0]);
          return v !== ma(a, t, n[1]) || v !== ma(a, t, n[2]) || v !== ma(a, t, n[3]);
        }
        function pu(a, t, n) {
          const l = t.paint.get(a).value;
          return l.kind === "constant" ? l.value : n.programConfigurations.get(t.id).getMaxValue(a);
        }
        function Qh(a) {
          return Math.sqrt(a[0] * a[0] + a[1] * a[1]);
        }
        function Jc(a, t, n, l, p) {
          if (!t[0] && !t[1]) return a;
          const v = O.convert(t)._mult(p);
          n === "viewport" && v._rotate(-l);
          const x = [];
          for (let T = 0; T < a.length; T++) x.push(a[T].sub(v));
          return x;
        }
        let gf, yf;
        xt("CircleBucket", cc, { omit: ["layers"] });
        var vy = { get paint() {
          return yf = yf || new za({ "circle-radius": new Ot(Ae.paint_circle["circle-radius"]), "circle-color": new Ot(Ae.paint_circle["circle-color"]), "circle-blur": new Ot(Ae.paint_circle["circle-blur"]), "circle-opacity": new Ot(Ae.paint_circle["circle-opacity"]), "circle-translate": new Tt(Ae.paint_circle["circle-translate"]), "circle-translate-anchor": new Tt(Ae.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Tt(Ae.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Tt(Ae.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Ot(Ae.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Ot(Ae.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Ot(Ae.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return gf = gf || new za({ "circle-sort-key": new Ot(Ae.layout_circle["circle-sort-key"]) });
        } };
        class _f extends rr {
          constructor(t) {
            super(t, vy);
          }
          createBucket(t) {
            return new cc(t);
          }
          queryRadius(t) {
            const n = t;
            return pu("circle-radius", this, n) + pu("circle-stroke-width", this, n) + Qh(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: l, geometry: p, transform: v, pixelsToTileUnits: x, unwrappedTileID: T, getElevation: E }) {
            const k = Jc(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -v.bearingInRadians, x), D = this.paint.get("circle-radius").evaluate(n, l) + this.paint.get("circle-stroke-width").evaluate(n, l), N = this.paint.get("circle-pitch-alignment") === "map", q = N ? k : (function(Z, X, ee, se) {
              return Z.map(((xe) => ia(xe, X, ee, se)));
            })(k, v, T, E), G = N ? D * x : D;
            for (const Z of p) for (const X of Z) {
              const ee = N ? X : ia(X, v, T, E);
              let se = G;
              const xe = v.projectTileCoordinates(X.x, X.y, T, E).signedDistanceFromCamera;
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? se *= xe / v.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (se *= v.cameraToCenterDistance / xe), df(q, ee, se)) return !0;
            }
            return !1;
          }
        }
        function ia(a, t, n, l) {
          const p = t.projectTileCoordinates(a.x, a.y, n, l).point;
          return new O((0.5 * p.x + 0.5) * t.width, (0.5 * -p.y + 0.5) * t.height);
        }
        class Ia extends cc {
        }
        let vf;
        xt("HeatmapBucket", Ia, { omit: ["layers"] });
        var Um = { get paint() {
          return vf = vf || new za({ "heatmap-radius": new Ot(Ae.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Ot(Ae.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Tt(Ae.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Sl(Ae.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Tt(Ae.paint_heatmap["heatmap-opacity"]) });
        } };
        function lp(a, { width: t, height: n }, l, p) {
          if (p) {
            if (p instanceof Uint8ClampedArray) p = new Uint8Array(p.buffer);
            else if (p.length !== t * n * l) throw new RangeError(`mismatched image size. expected: ${p.length} but got: ${t * n * l}`);
          } else p = new Uint8Array(t * n * l);
          return a.width = t, a.height = n, a.data = p, a;
        }
        function xf(a, { width: t, height: n }, l) {
          if (t === a.width && n === a.height) return;
          const p = lp({}, { width: t, height: n }, l);
          dc(a, p, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(a.width, t), height: Math.min(a.height, n) }, l), a.width = t, a.height = n, a.data = p.data;
        }
        function dc(a, t, n, l, p, v) {
          if (p.width === 0 || p.height === 0) return t;
          if (p.width > a.width || p.height > a.height || n.x > a.width - p.width || n.y > a.height - p.height) throw new RangeError("out of range source coordinates for image copy");
          if (p.width > t.width || p.height > t.height || l.x > t.width - p.width || l.y > t.height - p.height) throw new RangeError("out of range destination coordinates for image copy");
          const x = a.data, T = t.data;
          if (x === T) throw new Error("srcData equals dstData, so image is already copied");
          for (let E = 0; E < p.height; E++) {
            const k = ((n.y + E) * a.width + n.x) * v, D = ((l.y + E) * t.width + l.x) * v;
            for (let N = 0; N < p.width * v; N++) T[D + N] = x[k + N];
          }
          return t;
        }
        class Qc {
          constructor(t, n) {
            lp(this, t, 1, n);
          }
          resize(t) {
            xf(this, t, 1);
          }
          clone() {
            return new Qc({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, n, l, p, v) {
            dc(t, n, l, p, v, 1);
          }
        }
        class ka {
          constructor(t, n) {
            lp(this, t, 4, n);
          }
          resize(t) {
            xf(this, t, 4);
          }
          replace(t, n) {
            n ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
          }
          clone() {
            return new ka({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, n, l, p, v) {
            dc(t, n, l, p, v, 4);
          }
          setPixel(t, n, l) {
            const p = 4 * (t * this.width + n);
            this.data[p + 0] = Math.round(255 * l.r / l.a), this.data[p + 1] = Math.round(255 * l.g / l.a), this.data[p + 2] = Math.round(255 * l.b / l.a), this.data[p + 3] = Math.round(255 * l.a);
          }
        }
        function bf(a) {
          const t = {}, n = a.resolution || 256, l = a.clips ? a.clips.length : 1, p = a.image || new ka({ width: n, height: l });
          if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
          const v = (x, T, E) => {
            t[a.evaluationKey] = E;
            const k = a.expression.evaluate(t);
            p.setPixel(x / 4 / n, T / 4, k);
          };
          if (a.clips) for (let x = 0, T = 0; x < l; ++x, T += 4 * n) for (let E = 0, k = 0; E < n; E++, k += 4) {
            const D = E / (n - 1), { start: N, end: q } = a.clips[x];
            v(T, k, N * (1 - D) + q * D);
          }
          else for (let x = 0, T = 0; x < n; x++, T += 4) v(0, T, x / (n - 1));
          return p;
        }
        xt("AlphaImage", Qc), xt("RGBAImage", ka);
        const wf = "big-fb";
        class up extends rr {
          createBucket(t) {
            return new Ia(t);
          }
          constructor(t) {
            super(t, Um), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = bf({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(wf) && this.heatmapFbos.delete(wf);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return !1;
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let cp;
        var Fm = { get paint() {
          return cp = cp || new za({ "hillshade-illumination-direction": new Tt(Ae.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new Tt(Ae.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new Tt(Ae.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Tt(Ae.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Tt(Ae.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Tt(Ae.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Tt(Ae.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new Tt(Ae.paint_hillshade["hillshade-method"]) });
        } };
        class Vm extends rr {
          constructor(t) {
            super(t, Fm), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values, n = this.paint.get("hillshade-illumination-altitude").values, l = this.paint.get("hillshade-highlight-color").values, p = this.paint.get("hillshade-shadow-color").values;
            const v = Math.max(t.length, n.length, l.length, p.length);
            t = t.concat(Array(v - t.length).fill(t.at(-1))), n = n.concat(Array(v - n.length).fill(n.at(-1))), l = l.concat(Array(v - l.length).fill(l.at(-1))), p = p.concat(Array(v - p.length).fill(p.at(-1)));
            const x = n.map(Yn);
            return { directionRadians: t.map(Yn), altitudeRadians: x, shadowColor: p, highlightColor: l };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        let Sf;
        var Tf = { get paint() {
          return Sf = Sf || new za({ "color-relief-opacity": new Tt(Ae["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new Sl(Ae["paint_color-relief"]["color-relief-color"]) });
        } };
        class ed {
          constructor(t, n, l, p) {
            this.context = t, this.format = l, this.texture = t.gl.createTexture(), this.update(n, p);
          }
          update(t, n, l) {
            const { width: p, height: v } = t, x = !(this.size && this.size[0] === p && this.size[1] === v || l), { context: T } = this, { gl: E } = T;
            if (this.useMipmap = !!(n && n.useMipmap), E.bindTexture(E.TEXTURE_2D, this.texture), T.pixelStoreUnpackFlipY.set(!1), T.pixelStoreUnpack.set(1), T.pixelStoreUnpackPremultiplyAlpha.set(this.format === E.RGBA && (!n || n.premultiply !== !1)), x) this.size = [p, v], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Ya(t) ? E.texImage2D(E.TEXTURE_2D, 0, this.format, this.format, E.UNSIGNED_BYTE, t) : E.texImage2D(E.TEXTURE_2D, 0, this.format, p, v, 0, this.format, E.UNSIGNED_BYTE, t.data);
            else {
              const { x: k, y: D } = l || { x: 0, y: 0 };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Ya(t) ? E.texSubImage2D(E.TEXTURE_2D, 0, k, D, E.RGBA, E.UNSIGNED_BYTE, t) : E.texSubImage2D(E.TEXTURE_2D, 0, k, D, p, v, E.RGBA, E.UNSIGNED_BYTE, t.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && E.generateMipmap(E.TEXTURE_2D), T.pixelStoreUnpackFlipY.setDefault(), T.pixelStoreUnpack.setDefault(), T.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(t, n, l) {
            const { context: p } = this, { gl: v } = p;
            v.bindTexture(v.TEXTURE_2D, this.texture), l !== v.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (l = v.LINEAR), t !== this.filter && (v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MAG_FILTER, t), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MIN_FILTER, l || t), this.filter = t), n !== this.wrap && (v.texParameteri(v.TEXTURE_2D, v.TEXTURE_WRAP_S, n), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_WRAP_T, n), this.wrap = n);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t } = this.context;
            t.deleteTexture(this.texture), this.texture = null;
          }
        }
        class hp {
          constructor(t, n, l, p = 1, v = 1, x = 1, T = 0) {
            if (this.uid = t, n.height !== n.width) throw new RangeError("DEM tiles must be square");
            if (l && !["mapbox", "terrarium", "custom"].includes(l)) return void $i(`"${l}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = n.height;
            const E = this.dim = n.height - 2;
            switch (this.data = new Uint32Array(n.data.buffer), l) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = p, this.greenFactor = v, this.blueFactor = x, this.baseShift = T;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let k = 0; k < E; k++) this.data[this._idx(-1, k)] = this.data[this._idx(0, k)], this.data[this._idx(E, k)] = this.data[this._idx(E - 1, k)], this.data[this._idx(k, -1)] = this.data[this._idx(k, 0)], this.data[this._idx(k, E)] = this.data[this._idx(k, E - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(E, -1)] = this.data[this._idx(E - 1, 0)], this.data[this._idx(-1, E)] = this.data[this._idx(0, E - 1)], this.data[this._idx(E, E)] = this.data[this._idx(E - 1, E - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let k = 0; k < E; k++) for (let D = 0; D < E; D++) {
              const N = this.get(k, D);
              N > this.max && (this.max = N), N < this.min && (this.min = N);
            }
          }
          get(t, n) {
            const l = new Uint8Array(this.data.buffer), p = 4 * this._idx(t, n);
            return this.unpack(l[p], l[p + 1], l[p + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t, n) {
            if (t < -1 || t >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (n + 1) * this.stride + (t + 1);
          }
          unpack(t, n, l) {
            return t * this.redFactor + n * this.greenFactor + l * this.blueFactor - this.baseShift;
          }
          pack(t) {
            return Mf(t, this.getUnpackVector());
          }
          getPixels() {
            return new ka({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t, n, l) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let p = n * this.dim, v = n * this.dim + this.dim, x = l * this.dim, T = l * this.dim + this.dim;
            switch (n) {
              case -1:
                p = v - 1;
                break;
              case 1:
                v = p + 1;
            }
            switch (l) {
              case -1:
                x = T - 1;
                break;
              case 1:
                T = x + 1;
            }
            const E = -n * this.dim, k = -l * this.dim;
            for (let D = x; D < T; D++) for (let N = p; N < v; N++) this.data[this._idx(N, D)] = t.data[this._idx(N + E, D + k)];
          }
        }
        function Mf(a, t) {
          const n = t[0], l = t[1], p = t[2], v = t[3], x = Math.min(n, l, p), T = Math.round((a + v) / x);
          return { r: Math.floor(T * x / n) % 256, g: Math.floor(T * x / l) % 256, b: Math.floor(T * x / p) % 256 };
        }
        xt("DEMData", hp);
        class Af extends rr {
          constructor(t) {
            super(t, Tf);
          }
          _createColorRamp(t) {
            const n = { elevationStops: [], colorStops: [] }, l = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (l instanceof tu && l._styleExpression.expression instanceof ca) {
              this.colorRampExpression = l;
              const x = l._styleExpression.expression;
              n.elevationStops = x.labels, n.colorStops = [];
              for (const T of n.elevationStops) n.colorStops.push(x.evaluate({ globals: { elevation: T } }));
            }
            if (n.elevationStops.length < 1 && (n.elevationStops = [0], n.colorStops = [di.transparent]), n.elevationStops.length < 2 && (n.elevationStops.push(n.elevationStops[0] + 1), n.colorStops.push(n.colorStops[0])), n.elevationStops.length <= t) return n;
            const p = { elevationStops: [], colorStops: [] }, v = (n.elevationStops.length - 1) / (t - 1);
            for (let x = 0; x < n.elevationStops.length - 0.5; x += v) p.elevationStops.push(n.elevationStops[Math.round(x)]), p.colorStops.push(n.colorStops[Math.round(x)]);
            return $i(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), p;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(t, n, l) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const p = this._createColorRamp(n), v = new ka({ width: p.colorStops.length, height: 1 }), x = new ka({ width: p.colorStops.length, height: 1 });
            for (let T = 0; T < p.elevationStops.length; T++) {
              const E = Mf(p.elevationStops[T], l);
              x.setPixel(0, T, new di(E.r / 255, E.g / 255, E.b / 255, 1)), v.setPixel(0, T, p.colorStops[T]);
            }
            return this.colorRampTextures = { elevationTexture: new ed(t, x, t.gl.RGBA), colorTexture: new ed(t, v, t.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures;
          }
        }
        const dp = fn([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ef } = dp;
        function pp(a, t, n) {
          const l = n.patternDependencies;
          let p = !1;
          for (const v of t) {
            const x = v.paint.get(`${a}-pattern`);
            x.isConstant() || (p = !0);
            const T = x.constantOr(null);
            T && (p = !0, l[T.to] = !0, l[T.from] = !0);
          }
          return p;
        }
        function td(a, t, n, l, p) {
          const v = p.patternDependencies;
          for (const x of t) {
            const T = x.paint.get(`${a}-pattern`).value;
            if (T.kind !== "constant") {
              let E = T.evaluate({ zoom: l - 1 }, n, {}, p.availableImages), k = T.evaluate({ zoom: l }, n, {}, p.availableImages), D = T.evaluate({ zoom: l + 1 }, n, {}, p.availableImages);
              E = E && E.name ? E.name : E, k = k && k.name ? k.name : k, D = D && D.name ? D.name : D, v[E] = !0, v[k] = !0, v[D] = !0, n.patterns[x.id] = { min: E, mid: k, max: D };
            }
          }
          return n;
        }
        function Cf(a, t, n, l, p) {
          let v;
          if (p === (function(x, T, E, k) {
            let D = 0;
            for (let N = T, q = E - k; N < E; N += k) D += (x[q] - x[N]) * (x[N + 1] + x[q + 1]), q = N;
            return D;
          })(a, t, n, l) > 0) for (let x = t; x < n; x += l) v = If(x / l | 0, a[x], a[x + 1], v);
          else for (let x = n - l; x >= t; x -= l) v = If(x / l | 0, a[x], a[x + 1], v);
          return v && fc(v, v.next) && (mc(v), v = v.next), v;
        }
        function Tr(a, t) {
          if (!a) return a;
          t || (t = a);
          let n, l = a;
          do
            if (n = !1, l.steiner || !fc(l, l.next) && Ki(l.prev, l, l.next) !== 0) l = l.next;
            else {
              if (mc(l), l = t = l.prev, l === l.next) break;
              n = !0;
            }
          while (n || l !== t);
          return t;
        }
        function pc(a, t, n, l, p, v, x) {
          if (!a) return;
          !x && v && (function(E, k, D, N) {
            let q = E;
            do
              q.z === 0 && (q.z = cn(q.x, q.y, k, D, N)), q.prevZ = q.prev, q.nextZ = q.next, q = q.next;
            while (q !== E);
            q.prevZ.nextZ = null, q.prevZ = null, (function(G) {
              let Z, X = 1;
              do {
                let ee, se = G;
                G = null;
                let xe = null;
                for (Z = 0; se; ) {
                  Z++;
                  let de = se, ge = 0;
                  for (let Fe = 0; Fe < X && (ge++, de = de.nextZ, de); Fe++) ;
                  let Ie = X;
                  for (; ge > 0 || Ie > 0 && de; ) ge !== 0 && (Ie === 0 || !de || se.z <= de.z) ? (ee = se, se = se.nextZ, ge--) : (ee = de, de = de.nextZ, Ie--), xe ? xe.nextZ = ee : G = ee, ee.prevZ = xe, xe = ee;
                  se = de;
                }
                xe.nextZ = null, X *= 2;
              } while (Z > 1);
            })(q);
          })(a, l, p, v);
          let T = a;
          for (; a.prev !== a.next; ) {
            const E = a.prev, k = a.next;
            if (v ? qm(a, l, p, v) : xy(a)) t.push(E.i, a.i, k.i), mc(a), a = k.next, T = k.next;
            else if ((a = k) === T) {
              x ? x === 1 ? pc(a = Ml(Tr(a), t), t, n, l, p, v, 2) : x === 2 && zf(a, t, n, l, p, v) : pc(Tr(a), t, n, l, p, v, 1);
              break;
            }
          }
        }
        function xy(a) {
          const t = a.prev, n = a, l = a.next;
          if (Ki(t, n, l) >= 0) return !1;
          const p = t.x, v = n.x, x = l.x, T = t.y, E = n.y, k = l.y, D = Math.min(p, v, x), N = Math.min(T, E, k), q = Math.max(p, v, x), G = Math.max(T, E, k);
          let Z = l.next;
          for (; Z !== t; ) {
            if (Z.x >= D && Z.x <= q && Z.y >= N && Z.y <= G && eh(p, T, v, E, x, k, Z.x, Z.y) && Ki(Z.prev, Z, Z.next) >= 0) return !1;
            Z = Z.next;
          }
          return !0;
        }
        function qm(a, t, n, l) {
          const p = a.prev, v = a, x = a.next;
          if (Ki(p, v, x) >= 0) return !1;
          const T = p.x, E = v.x, k = x.x, D = p.y, N = v.y, q = x.y, G = Math.min(T, E, k), Z = Math.min(D, N, q), X = Math.max(T, E, k), ee = Math.max(D, N, q), se = cn(G, Z, t, n, l), xe = cn(X, ee, t, n, l);
          let de = a.prevZ, ge = a.nextZ;
          for (; de && de.z >= se && ge && ge.z <= xe; ) {
            if (de.x >= G && de.x <= X && de.y >= Z && de.y <= ee && de !== p && de !== x && eh(T, D, E, N, k, q, de.x, de.y) && Ki(de.prev, de, de.next) >= 0 || (de = de.prevZ, ge.x >= G && ge.x <= X && ge.y >= Z && ge.y <= ee && ge !== p && ge !== x && eh(T, D, E, N, k, q, ge.x, ge.y) && Ki(ge.prev, ge, ge.next) >= 0)) return !1;
            ge = ge.nextZ;
          }
          for (; de && de.z >= se; ) {
            if (de.x >= G && de.x <= X && de.y >= Z && de.y <= ee && de !== p && de !== x && eh(T, D, E, N, k, q, de.x, de.y) && Ki(de.prev, de, de.next) >= 0) return !1;
            de = de.prevZ;
          }
          for (; ge && ge.z <= xe; ) {
            if (ge.x >= G && ge.x <= X && ge.y >= Z && ge.y <= ee && ge !== p && ge !== x && eh(T, D, E, N, k, q, ge.x, ge.y) && Ki(ge.prev, ge, ge.next) >= 0) return !1;
            ge = ge.nextZ;
          }
          return !0;
        }
        function Ml(a, t) {
          let n = a;
          do {
            const l = n.prev, p = n.next.next;
            !fc(l, p) && Pf(l, n, n.next, p) && th(l, p) && th(p, l) && (t.push(l.i, n.i, p.i), mc(n), mc(n.next), n = a = p), n = n.next;
          } while (n !== a);
          return Tr(n);
        }
        function zf(a, t, n, l, p, v) {
          let x = a;
          do {
            let T = x.next.next;
            for (; T !== x.prev; ) {
              if (x.i !== T.i && nd(x, T)) {
                let E = mp(x, T);
                return x = Tr(x, x.next), E = Tr(E, E.next), pc(x, t, n, l, p, v, 0), void pc(E, t, n, l, p, v, 0);
              }
              T = T.next;
            }
            x = x.next;
          } while (x !== a);
        }
        function Gm(a, t) {
          let n = a.x - t.x;
          return n === 0 && (n = a.y - t.y, n === 0) && (n = (a.next.y - a.y) / (a.next.x - a.x) - (t.next.y - t.y) / (t.next.x - t.x)), n;
        }
        function fp(a, t) {
          const n = (function(p, v) {
            let x = v;
            const T = p.x, E = p.y;
            let k, D = -1 / 0;
            if (fc(p, x)) return x;
            do {
              if (fc(p, x.next)) return x.next;
              if (E <= x.y && E >= x.next.y && x.next.y !== x.y) {
                const X = x.x + (E - x.y) * (x.next.x - x.x) / (x.next.y - x.y);
                if (X <= T && X > D && (D = X, k = x.x < x.next.x ? x : x.next, X === T)) return k;
              }
              x = x.next;
            } while (x !== v);
            if (!k) return null;
            const N = k, q = k.x, G = k.y;
            let Z = 1 / 0;
            x = k;
            do {
              if (T >= x.x && x.x >= q && T !== x.x && Zm(E < G ? T : D, E, q, G, E < G ? D : T, E, x.x, x.y)) {
                const X = Math.abs(E - x.y) / (T - x.x);
                th(x, p) && (X < Z || X === Z && (x.x > k.x || x.x === k.x && id(k, x))) && (k = x, Z = X);
              }
              x = x.next;
            } while (x !== N);
            return k;
          })(a, t);
          if (!n) return t;
          const l = mp(n, a);
          return Tr(l, l.next), Tr(n, n.next);
        }
        function id(a, t) {
          return Ki(a.prev, a, t.prev) < 0 && Ki(t.next, a, a.next) < 0;
        }
        function cn(a, t, n, l, p) {
          return (a = 1431655765 & ((a = 858993459 & ((a = 252645135 & ((a = 16711935 & ((a = (a - n) * p | 0) | a << 8)) | a << 4)) | a << 2)) | a << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - l) * p | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
        }
        function by(a) {
          let t = a, n = a;
          do
            (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;
          while (t !== a);
          return n;
        }
        function Zm(a, t, n, l, p, v, x, T) {
          return (p - x) * (t - T) >= (a - x) * (v - T) && (a - x) * (l - T) >= (n - x) * (t - T) && (n - x) * (v - T) >= (p - x) * (l - T);
        }
        function eh(a, t, n, l, p, v, x, T) {
          return !(a === x && t === T) && Zm(a, t, n, l, p, v, x, T);
        }
        function nd(a, t) {
          return a.next.i !== t.i && a.prev.i !== t.i && !(function(n, l) {
            let p = n;
            do {
              if (p.i !== n.i && p.next.i !== n.i && p.i !== l.i && p.next.i !== l.i && Pf(p, p.next, n, l)) return !0;
              p = p.next;
            } while (p !== n);
            return !1;
          })(a, t) && (th(a, t) && th(t, a) && (function(n, l) {
            let p = n, v = !1;
            const x = (n.x + l.x) / 2, T = (n.y + l.y) / 2;
            do
              p.y > T != p.next.y > T && p.next.y !== p.y && x < (p.next.x - p.x) * (T - p.y) / (p.next.y - p.y) + p.x && (v = !v), p = p.next;
            while (p !== n);
            return v;
          })(a, t) && (Ki(a.prev, a, t.prev) || Ki(a, t.prev, t)) || fc(a, t) && Ki(a.prev, a, a.next) > 0 && Ki(t.prev, t, t.next) > 0);
        }
        function Ki(a, t, n) {
          return (t.y - a.y) * (n.x - t.x) - (t.x - a.x) * (n.y - t.y);
        }
        function fc(a, t) {
          return a.x === t.x && a.y === t.y;
        }
        function Pf(a, t, n, l) {
          const p = ts(Ki(a, t, n)), v = ts(Ki(a, t, l)), x = ts(Ki(n, l, a)), T = ts(Ki(n, l, t));
          return p !== v && x !== T || !(p !== 0 || !fu(a, n, t)) || !(v !== 0 || !fu(a, l, t)) || !(x !== 0 || !fu(n, a, l)) || !(T !== 0 || !fu(n, t, l));
        }
        function fu(a, t, n) {
          return t.x <= Math.max(a.x, n.x) && t.x >= Math.min(a.x, n.x) && t.y <= Math.max(a.y, n.y) && t.y >= Math.min(a.y, n.y);
        }
        function ts(a) {
          return a > 0 ? 1 : a < 0 ? -1 : 0;
        }
        function th(a, t) {
          return Ki(a.prev, a, a.next) < 0 ? Ki(a, t, a.next) >= 0 && Ki(a, a.prev, t) >= 0 : Ki(a, t, a.prev) < 0 || Ki(a, a.next, t) < 0;
        }
        function mp(a, t) {
          const n = ad(a.i, a.x, a.y), l = ad(t.i, t.x, t.y), p = a.next, v = t.prev;
          return a.next = t, t.prev = a, n.next = p, p.prev = n, l.next = n, n.prev = l, v.next = l, l.prev = v, l;
        }
        function If(a, t, n, l) {
          const p = ad(a, t, n);
          return l ? (p.next = l.next, p.prev = l, l.next.prev = p, l.next = p) : (p.prev = p, p.next = p), p;
        }
        function mc(a) {
          a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ);
        }
        function ad(a, t, n) {
          return { i: a, x: t, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
        }
        class Al {
          constructor(t, n) {
            if (n > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = n;
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1);
          }
        }
        class rd {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle;
          }
        }
        rd.noSubdivision = new rd({ fill: new Al(0, 0), line: new Al(0, 0), tile: new Al(0, 0), stencil: new Al(0, 0), circle: 1 }), xt("SubdivisionGranularityExpression", Al), xt("SubdivisionGranularitySetting", rd);
        const Vr = -32768, An = 32767;
        class kf {
          constructor(t, n) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = t, this._granularityCellSize = at / t, this._canonical = n;
          }
          _getKey(t, n) {
            return (t += 32768) << 16 | n + 32768;
          }
          _vertexToIndex(t, n) {
            if (t < -32768 || n < -32768 || t > 32767 || n > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const l = 0 | Math.round(t), p = 0 | Math.round(n), v = this._getKey(l, p);
            if (this._vertexDictionary.has(v)) return this._vertexDictionary.get(v);
            const x = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(v, x), this._vertexBuffer.push(l, p), x;
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(p, v) {
              const x = [];
              for (let T = 0; T < v.length; T += 3) {
                const E = v[T], k = v[T + 1], D = v[T + 2], N = p[2 * E], q = p[2 * E + 1];
                (p[2 * k] - N) * (p[2 * D + 1] - q) - (p[2 * k + 1] - q) * (p[2 * D] - N) > 0 ? (x.push(E), x.push(D), x.push(k)) : (x.push(E), x.push(k), x.push(D));
              }
              return x;
            })(this._vertexBuffer, t);
            const n = [], l = t.length;
            for (let p = 0; p < l; p += 3) {
              const v = [t[p + 0], t[p + 1], t[p + 2]], x = [this._vertexBuffer[2 * t[p + 0] + 0], this._vertexBuffer[2 * t[p + 0] + 1], this._vertexBuffer[2 * t[p + 1] + 0], this._vertexBuffer[2 * t[p + 1] + 1], this._vertexBuffer[2 * t[p + 2] + 0], this._vertexBuffer[2 * t[p + 2] + 1]];
              let T = 1 / 0, E = 1 / 0, k = -1 / 0, D = -1 / 0;
              for (let X = 0; X < 3; X++) {
                const ee = x[2 * X], se = x[2 * X + 1];
                T = Math.min(T, ee), k = Math.max(k, ee), E = Math.min(E, se), D = Math.max(D, se);
              }
              if (T === k || E === D) continue;
              const N = Math.floor(T / this._granularityCellSize), q = Math.ceil(k / this._granularityCellSize), G = Math.floor(E / this._granularityCellSize), Z = Math.ceil(D / this._granularityCellSize);
              if (N !== q || G !== Z) for (let X = G; X < Z; X++) {
                const ee = this._scanlineGenerateVertexRingForCellRow(X, x, v);
                wy(this._vertexBuffer, ee, n);
              }
              else n.push(...v);
            }
            return n;
          }
          _scanlineGenerateVertexRingForCellRow(t, n, l) {
            const p = t * this._granularityCellSize, v = p + this._granularityCellSize, x = [];
            for (let T = 0; T < 3; T++) {
              const E = n[2 * T], k = n[2 * T + 1], D = n[2 * (T + 1) % 6], N = n[(2 * (T + 1) + 1) % 6], q = n[2 * (T + 2) % 6], G = n[(2 * (T + 2) + 1) % 6], Z = D - E, X = N - k, ee = Z === 0, se = X === 0, xe = (p - k) / X, de = (v - k) / X, ge = Math.min(xe, de), Ie = Math.max(xe, de);
              if (!se && (ge >= 1 || Ie <= 0) || se && (k < p || k > v)) {
                N >= p && N <= v && x.push(l[(T + 1) % 3]);
                continue;
              }
              !se && ge > 0 && x.push(this._vertexToIndex(E + Z * ge, k + X * ge));
              const Fe = E + Z * Math.max(ge, 0), Je = E + Z * Math.min(Ie, 1);
              ee || this._generateIntraEdgeVertices(x, E, k, D, N, Fe, Je), !se && Ie < 1 && x.push(this._vertexToIndex(E + Z * Ie, k + X * Ie)), (se || N >= p && N <= v) && x.push(l[(T + 1) % 3]), !se && (N <= p || N >= v) && this._generateInterEdgeVertices(x, E, k, D, N, q, G, Je, p, v);
            }
            return x;
          }
          _generateIntraEdgeVertices(t, n, l, p, v, x, T) {
            const E = p - n, k = v - l, D = k === 0, N = D ? Math.min(n, p) : Math.min(x, T), q = D ? Math.max(n, p) : Math.max(x, T), G = Math.floor(N / this._granularityCellSize) + 1, Z = Math.ceil(q / this._granularityCellSize) - 1;
            if (D ? n < p : x < T) for (let X = G; X <= Z; X++) {
              const ee = X * this._granularityCellSize;
              t.push(this._vertexToIndex(ee, l + k * (ee - n) / E));
            }
            else for (let X = Z; X >= G; X--) {
              const ee = X * this._granularityCellSize;
              t.push(this._vertexToIndex(ee, l + k * (ee - n) / E));
            }
          }
          _generateInterEdgeVertices(t, n, l, p, v, x, T, E, k, D) {
            const N = v - l, q = x - p, G = T - v, Z = (k - v) / G, X = (D - v) / G, ee = Math.min(Z, X), se = Math.max(Z, X), xe = p + q * ee;
            let de = Math.floor(Math.min(xe, E) / this._granularityCellSize) + 1, ge = Math.ceil(Math.max(xe, E) / this._granularityCellSize) - 1, Ie = E < xe;
            const Fe = G === 0;
            if (Fe && (T === k || T === D)) return;
            if (Fe || ee >= 1 || se <= 0) {
              const gt = l - T, ut = x + (n - x) * Math.min((k - T) / gt, (D - T) / gt);
              de = Math.floor(Math.min(ut, E) / this._granularityCellSize) + 1, ge = Math.ceil(Math.max(ut, E) / this._granularityCellSize) - 1, Ie = E < ut;
            }
            const Je = N > 0 ? D : k;
            if (Ie) for (let gt = de; gt <= ge; gt++) t.push(this._vertexToIndex(gt * this._granularityCellSize, Je));
            else for (let gt = ge; gt >= de; gt--) t.push(this._vertexToIndex(gt * this._granularityCellSize, Je));
          }
          _generateOutline(t) {
            const n = [];
            for (const l of t) {
              const p = En(l, this._granularity, !0), v = this._pointArrayToIndices(p), x = [];
              for (let T = 1; T < v.length; T++) x.push(v[T - 1]), x.push(v[T]);
              n.push(x);
            }
            return n;
          }
          _handlePoles(t) {
            let n = !1, l = !1;
            this._canonical && (this._canonical.y === 0 && (n = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (l = !0)), (n || l) && this._fillPoles(t, n, l);
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let n = 0; n < t.length; n += 2) {
              const l = t[n + 1];
              l === Vr && (t[n + 1] = -32767), l === An && (t[n + 1] = 32766);
            }
          }
          _generatePoleQuad(t, n, l, p, v, x) {
            p > v != (x === Vr) ? (t.push(n), t.push(l), t.push(this._vertexToIndex(p, x)), t.push(l), t.push(this._vertexToIndex(v, x)), t.push(this._vertexToIndex(p, x))) : (t.push(l), t.push(n), t.push(this._vertexToIndex(p, x)), t.push(this._vertexToIndex(v, x)), t.push(l), t.push(this._vertexToIndex(p, x)));
          }
          _fillPoles(t, n, l) {
            const p = this._vertexBuffer, v = at, x = t.length;
            for (let T = 2; T < x; T += 3) {
              const E = t[T - 2], k = t[T - 1], D = t[T], N = p[2 * E], q = p[2 * E + 1], G = p[2 * k], Z = p[2 * k + 1], X = p[2 * D], ee = p[2 * D + 1];
              n && (q === 0 && Z === 0 && this._generatePoleQuad(t, E, k, N, G, Vr), Z === 0 && ee === 0 && this._generatePoleQuad(t, k, D, G, X, Vr), ee === 0 && q === 0 && this._generatePoleQuad(t, D, E, X, N, Vr)), l && (q === v && Z === v && this._generatePoleQuad(t, E, k, N, G, An), Z === v && ee === v && this._generatePoleQuad(t, k, D, G, X, An), ee === v && q === v && this._generatePoleQuad(t, D, E, X, N, An));
            }
          }
          _initializeVertices(t) {
            for (let n = 0; n < t.length; n += 2) this._vertexToIndex(t[n], t[n + 1]);
          }
          subdividePolygonInternal(t, n) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const { flattened: l, holeIndices: p } = (function(T) {
              const E = [], k = [];
              for (const D of T) if (D.length !== 0) {
                D !== T[0] && E.push(k.length / 2);
                for (let N = 0; N < D.length; N++) k.push(D[N].x), k.push(D[N].y);
              }
              return { flattened: k, holeIndices: E };
            })(t);
            let v;
            this._initializeVertices(l);
            try {
              const T = (function(k, D, N = 2) {
                const q = D && D.length, G = q ? D[0] * N : k.length;
                let Z = Cf(k, 0, G, N, !0);
                const X = [];
                if (!Z || Z.next === Z.prev) return X;
                let ee, se, xe;
                if (q && (Z = (function(de, ge, Ie, Fe) {
                  const Je = [];
                  for (let gt = 0, ut = ge.length; gt < ut; gt++) {
                    const yt = Cf(de, ge[gt] * Fe, gt < ut - 1 ? ge[gt + 1] * Fe : de.length, Fe, !1);
                    yt === yt.next && (yt.steiner = !0), Je.push(by(yt));
                  }
                  Je.sort(Gm);
                  for (let gt = 0; gt < Je.length; gt++) Ie = fp(Je[gt], Ie);
                  return Ie;
                })(k, D, Z, N)), k.length > 80 * N) {
                  ee = k[0], se = k[1];
                  let de = ee, ge = se;
                  for (let Ie = N; Ie < G; Ie += N) {
                    const Fe = k[Ie], Je = k[Ie + 1];
                    Fe < ee && (ee = Fe), Je < se && (se = Je), Fe > de && (de = Fe), Je > ge && (ge = Je);
                  }
                  xe = Math.max(de - ee, ge - se), xe = xe !== 0 ? 32767 / xe : 0;
                }
                return pc(Z, X, N, ee, se, xe, 0), X;
              })(l, p), E = this._convertIndices(l, T);
              v = this._subdivideTrianglesScanline(E);
            } catch (T) {
              console.error(T);
            }
            let x = [];
            return n && (x = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(v), { verticesFlattened: this._vertexBuffer, indicesTriangles: v, indicesLineList: x };
          }
          _convertIndices(t, n) {
            const l = [];
            for (let p = 0; p < n.length; p++) l.push(this._vertexToIndex(t[2 * n[p]], t[2 * n[p] + 1]));
            return l;
          }
          _pointArrayToIndices(t) {
            const n = [];
            for (let l = 0; l < t.length; l++) {
              const p = t[l];
              n.push(this._vertexToIndex(p.x, p.y));
            }
            return n;
          }
        }
        function Rf(a, t, n, l = !0) {
          return new kf(n, t).subdividePolygonInternal(a, l);
        }
        function En(a, t, n = !1) {
          if (!a || a.length < 1) return [];
          if (a.length < 2) return [];
          const l = a[0], p = a[a.length - 1], v = n && (l.x !== p.x || l.y !== p.y);
          if (t < 2) return v ? [...a, a[0]] : [...a];
          const x = Math.floor(at / t), T = [];
          T.push(new O(a[0].x, a[0].y));
          const E = a.length, k = v ? E : E - 1;
          for (let D = 0; D < k; D++) {
            const N = a[D], q = D < E - 1 ? a[D + 1] : a[0], G = N.x, Z = N.y, X = q.x, ee = q.y, se = G !== X, xe = Z !== ee;
            if (!se && !xe) continue;
            const de = X - G, ge = ee - Z, Ie = Math.abs(de), Fe = Math.abs(ge);
            let Je = G, gt = Z;
            for (; ; ) {
              const yt = de > 0 ? (Math.floor(Je / x) + 1) * x : (Math.ceil(Je / x) - 1) * x, kt = ge > 0 ? (Math.floor(gt / x) + 1) * x : (Math.ceil(gt / x) - 1) * x, mt = Math.abs(Je - yt), pt = Math.abs(gt - kt), Xe = Math.abs(Je - X), Bt = Math.abs(gt - ee), $t = se ? mt / Ie : Number.POSITIVE_INFINITY, Rt = xe ? pt / Fe : Number.POSITIVE_INFINITY;
              if ((Xe <= mt || !se) && (Bt <= pt || !xe)) break;
              if ($t < Rt && se || !xe) {
                Je = yt, gt += ge * $t;
                const Ct = new O(Je, Math.round(gt));
                T[T.length - 1].x === Ct.x && T[T.length - 1].y === Ct.y || T.push(Ct);
              } else {
                Je += de * Rt, gt = kt;
                const Ct = new O(Math.round(Je), gt);
                T[T.length - 1].x === Ct.x && T[T.length - 1].y === Ct.y || T.push(Ct);
              }
            }
            const ut = new O(X, ee);
            T[T.length - 1].x === ut.x && T[T.length - 1].y === ut.y || T.push(ut);
          }
          return T;
        }
        function wy(a, t, n) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let l = 0, p = a[2 * t[0]];
          for (let E = 1; E < t.length; E++) {
            const k = a[2 * t[E]];
            k < p && (p = k, l = E);
          }
          const v = t.length;
          let x = l, T = (x + 1) % v;
          for (; ; ) {
            const E = x - 1 >= 0 ? x - 1 : v - 1, k = (T + 1) % v, D = a[2 * t[E]], N = a[2 * t[k]], q = a[2 * t[x]], G = a[2 * t[x] + 1], Z = a[2 * t[T] + 1];
            let X = !1;
            if (D < N) X = !0;
            else if (D > N) X = !1;
            else {
              const ee = Z - G, se = -(a[2 * t[T]] - q), xe = G < Z ? 1 : -1;
              ((D - q) * ee + (a[2 * t[E] + 1] - G) * se) * xe > ((N - q) * ee + (a[2 * t[k] + 1] - G) * se) * xe && (X = !0);
            }
            if (X) {
              const ee = t[E], se = t[x], xe = t[T];
              ee !== se && ee !== xe && se !== xe && n.push(xe, se, ee), x--, x < 0 && (x = v - 1);
            } else {
              const ee = t[k], se = t[x], xe = t[T];
              ee !== se && ee !== xe && se !== xe && n.push(xe, se, ee), T++, T >= v && (T = 0);
            }
            if (E === k) break;
          }
        }
        function Df(a, t, n, l, p, v, x, T, E) {
          const k = p.length / 2, D = x && T && E;
          if (k < Qt.MAX_VERTEX_ARRAY_LENGTH) {
            const N = t.prepareSegment(k, n, l), q = N.vertexLength;
            for (let X = 0; X < v.length; X += 3) l.emplaceBack(q + v[X], q + v[X + 1], q + v[X + 2]);
            let G, Z;
            N.vertexLength += k, N.primitiveLength += v.length / 3, D && (Z = x.prepareSegment(k, n, T), G = Z.vertexLength, Z.vertexLength += k);
            for (let X = 0; X < p.length; X += 2) a(p[X], p[X + 1]);
            if (D) for (let X = 0; X < E.length; X++) {
              const ee = E[X];
              for (let se = 1; se < ee.length; se += 2) T.emplaceBack(G + ee[se - 1], G + ee[se]);
              Z.primitiveLength += ee.length / 2;
            }
          } else (function(N, q, G, Z, X, ee) {
            const se = [];
            for (let Fe = 0; Fe < Z.length / 2; Fe++) se.push(-1);
            const xe = { count: 0 };
            let de = 0, ge = N.getOrCreateLatestSegment(q, G), Ie = ge.vertexLength;
            for (let Fe = 2; Fe < X.length; Fe += 3) {
              const Je = X[Fe - 2], gt = X[Fe - 1], ut = X[Fe];
              let yt = se[Je] < de, kt = se[gt] < de, mt = se[ut] < de;
              ge.vertexLength + ((yt ? 1 : 0) + (kt ? 1 : 0) + (mt ? 1 : 0)) > Qt.MAX_VERTEX_ARRAY_LENGTH && (ge = N.createNewSegment(q, G), de = xe.count, yt = !0, kt = !0, mt = !0, Ie = 0);
              const pt = ih(se, Z, ee, xe, Je, yt, ge), Xe = ih(se, Z, ee, xe, gt, kt, ge), Bt = ih(se, Z, ee, xe, ut, mt, ge);
              G.emplaceBack(Ie + pt - de, Ie + Xe - de, Ie + Bt - de), ge.primitiveLength++;
            }
          })(t, n, l, p, v, a), D && (function(N, q, G, Z, X, ee) {
            const se = [];
            for (let Fe = 0; Fe < Z.length / 2; Fe++) se.push(-1);
            const xe = { count: 0 };
            let de = 0, ge = N.getOrCreateLatestSegment(q, G), Ie = ge.vertexLength;
            for (let Fe = 0; Fe < X.length; Fe++) {
              const Je = X[Fe];
              for (let gt = 1; gt < X[Fe].length; gt += 2) {
                const ut = Je[gt - 1], yt = Je[gt];
                let kt = se[ut] < de, mt = se[yt] < de;
                ge.vertexLength + ((kt ? 1 : 0) + (mt ? 1 : 0)) > Qt.MAX_VERTEX_ARRAY_LENGTH && (ge = N.createNewSegment(q, G), de = xe.count, kt = !0, mt = !0, Ie = 0);
                const pt = ih(se, Z, ee, xe, ut, kt, ge), Xe = ih(se, Z, ee, xe, yt, mt, ge);
                G.emplaceBack(Ie + pt - de, Ie + Xe - de), ge.primitiveLength++;
              }
            }
          })(x, n, T, p, E, a), t.forceNewSegmentOnNextPrepare(), x?.forceNewSegmentOnNextPrepare();
        }
        function ih(a, t, n, l, p, v, x) {
          if (v) {
            const T = l.count;
            return n(t[2 * p], t[2 * p + 1]), a[p] = l.count, l.count++, x.vertexLength++, T;
          }
          return a[p];
        }
        class yn {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Oe(), this.indexArray = new qi(), this.indexArray2 = new Ni(), this.programConfigurations = new or(t.layers, t.zoom), this.segments = new Qt(), this.segments2 = new Qt(), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, l) {
            this.hasPattern = pp("fill", this.layers, n);
            const p = this.layers[0].layout.get("fill-sort-key"), v = !p.isConstant(), x = [];
            for (const { feature: T, id: E, index: k, sourceLayerIndex: D } of t) {
              const N = this.layers[0]._featureFilter.needGeometry, q = Fr(T, N);
              if (!this.layers[0]._featureFilter.filter(new Li(this.zoom, { globalState: this.globalState }), q, l)) continue;
              const G = v ? p.evaluate(q, {}, l, n.availableImages) : void 0, Z = { id: E, properties: T.properties, type: T.type, sourceLayerIndex: D, index: k, geometry: N ? q.geometry : Ds(T), patterns: {}, sortKey: G };
              x.push(Z);
            }
            v && x.sort(((T, E) => T.sortKey - E.sortKey));
            for (const T of x) {
              const { geometry: E, index: k, sourceLayerIndex: D } = T;
              if (this.hasPattern) {
                const N = td("fill", this.layers, T, this.zoom, n);
                this.patternFeatures.push(N);
              } else this.addFeature(T, E, k, l, {}, n.subdivisionGranularity);
              n.featureIndex.insert(t[k].feature, E, k, D, this.index);
            }
          }
          update(t, n, l) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, l);
          }
          addFeatures(t, n, l) {
            for (const p of this.patternFeatures) this.addFeature(p, p.geometry, p.index, n, l, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ef), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t, n, l, p, v, x) {
            for (const T of Wl(n, 500)) {
              const E = Rf(T, p, x.fill.getGranularityForZoomLevel(p.z)), k = this.layoutVertexArray;
              Df(((D, N) => {
                k.emplaceBack(D, N);
              }), this.segments, this.layoutVertexArray, this.indexArray, E.verticesFlattened, E.indicesTriangles, this.segments2, this.indexArray2, E.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, l, v, p);
          }
        }
        let Mr, Vo;
        xt("FillBucket", yn, { omit: ["layers", "patternFeatures"] });
        var $m = { get paint() {
          return Vo = Vo || new za({ "fill-antialias": new Tt(Ae.paint_fill["fill-antialias"]), "fill-opacity": new Ot(Ae.paint_fill["fill-opacity"]), "fill-color": new Ot(Ae.paint_fill["fill-color"]), "fill-outline-color": new Ot(Ae.paint_fill["fill-outline-color"]), "fill-translate": new Tt(Ae.paint_fill["fill-translate"]), "fill-translate-anchor": new Tt(Ae.paint_fill["fill-translate-anchor"]), "fill-pattern": new sc(Ae.paint_fill["fill-pattern"]) });
        }, get layout() {
          return Mr = Mr || new za({ "fill-sort-key": new Ot(Ae.layout_fill["fill-sort-key"]) });
        } };
        class Hm extends rr {
          constructor(t) {
            super(t, $m);
          }
          recalculate(t, n) {
            super.recalculate(t, n);
            const l = this.paint._values["fill-outline-color"];
            l.value.kind === "constant" && l.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t) {
            return new yn(t);
          }
          queryRadius() {
            return Qh(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, geometry: n, transform: l, pixelsToTileUnits: p }) {
            return pf(Jc(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -l.bearingInRadians, p), n);
          }
          isTileClipped() {
            return !0;
          }
        }
        const Xm = fn([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Sy = fn([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: gp } = Xm;
        class xa {
          constructor(t, n, l, p, v) {
            this.properties = {}, this.extent = l, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = p, this._values = v, t.readFields(to, this, n);
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos, l = [];
            let p, v = 1, x = 0, T = 0, E = 0;
            for (; t.pos < n; ) {
              if (x <= 0) {
                const k = t.readVarint();
                v = 7 & k, x = k >> 3;
              }
              if (x--, v === 1 || v === 2) T += t.readSVarint(), E += t.readSVarint(), v === 1 && (p && l.push(p), p = []), p && p.push(new O(T, E));
              else {
                if (v !== 7) throw new Error(`unknown command ${v}`);
                p && p.push(p[0].clone());
              }
            }
            return p && l.push(p), l;
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos;
            let l = 1, p = 0, v = 0, x = 0, T = 1 / 0, E = -1 / 0, k = 1 / 0, D = -1 / 0;
            for (; t.pos < n; ) {
              if (p <= 0) {
                const N = t.readVarint();
                l = 7 & N, p = N >> 3;
              }
              if (p--, l === 1 || l === 2) v += t.readSVarint(), x += t.readSVarint(), v < T && (T = v), v > E && (E = v), x < k && (k = x), x > D && (D = x);
              else if (l !== 7) throw new Error(`unknown command ${l}`);
            }
            return [T, k, E, D];
          }
          toGeoJSON(t, n, l) {
            const p = this.extent * Math.pow(2, l), v = this.extent * t, x = this.extent * n, T = this.loadGeometry();
            function E(q) {
              return [360 * (q.x + v) / p - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (q.y + x) / p) * Math.PI)) - 90];
            }
            function k(q) {
              return q.map(E);
            }
            let D;
            if (this.type === 1) {
              const q = [];
              for (const Z of T) q.push(Z[0]);
              const G = k(q);
              D = q.length === 1 ? { type: "Point", coordinates: G[0] } : { type: "MultiPoint", coordinates: G };
            } else if (this.type === 2) {
              const q = T.map(k);
              D = q.length === 1 ? { type: "LineString", coordinates: q[0] } : { type: "MultiLineString", coordinates: q };
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const q = (function(Z) {
                  const X = Z.length;
                  if (X <= 1) return [Z];
                  const ee = [];
                  let se, xe;
                  for (let de = 0; de < X; de++) {
                    const ge = Ym(Z[de]);
                    ge !== 0 && (xe === void 0 && (xe = ge < 0), xe === ge < 0 ? (se && ee.push(se), se = [Z[de]]) : se && se.push(Z[de]));
                  }
                  return se && ee.push(se), ee;
                })(T), G = [];
                for (const Z of q) G.push(Z.map(k));
                D = G.length === 1 ? { type: "Polygon", coordinates: G[0] } : { type: "MultiPolygon", coordinates: G };
              }
            }
            const N = { type: "Feature", geometry: D, properties: this.properties };
            return this.id != null && (N.id = this.id), N;
          }
        }
        function to(a, t, n) {
          a === 1 ? t.id = n.readVarint() : a === 2 ? (function(l, p) {
            const v = l.readVarint() + l.pos;
            for (; l.pos < v; ) {
              const x = p._keys[l.readVarint()], T = p._values[l.readVarint()];
              p.properties[x] = T;
            }
          })(n, t) : a === 3 ? t.type = n.readVarint() : a === 4 && (t._geometry = n.pos);
        }
        function Ym(a) {
          let t = 0;
          for (let n, l, p = 0, v = a.length, x = v - 1; p < v; x = p++) n = a[p], l = a[x], t += (l.x - n.x) * (n.y + l.y);
          return t;
        }
        xa.types = ["Unknown", "Point", "LineString", "Polygon"];
        class Ar {
          constructor(t, n) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(Km, this, n), this.length = this._features.length;
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const n = this._pbf.readVarint() + this._pbf.pos;
            return new xa(this._pbf, n, this.extent, this._keys, this._values);
          }
        }
        function Km(a, t, n) {
          a === 15 ? t.version = n.readVarint() : a === 1 ? t.name = n.readString() : a === 5 ? t.extent = n.readVarint() : a === 2 ? t._features.push(n.pos) : a === 3 ? t._keys.push(n.readString()) : a === 4 && t._values.push((function(l) {
            let p = null;
            const v = l.readVarint() + l.pos;
            for (; l.pos < v; ) {
              const x = l.readVarint() >> 3;
              p = x === 1 ? l.readString() : x === 2 ? l.readFloat() : x === 3 ? l.readDouble() : x === 4 ? l.readVarint64() : x === 5 ? l.readVarint() : x === 6 ? l.readSVarint() : x === 7 ? l.readBoolean() : null;
            }
            if (p == null) throw new Error("unknown feature value");
            return p;
          })(n));
        }
        class qo {
          constructor(t, n) {
            this.layers = t.readFields(gc, {}, n);
          }
        }
        function gc(a, t, n) {
          if (a === 3) {
            const l = new Ar(n, n.readVarint() + n.pos);
            l.length && (t[l.name] = l);
          }
        }
        const io = Math.pow(2, 13);
        function yc(a, t, n, l, p, v, x, T) {
          a.emplaceBack(t, n, 2 * Math.floor(l * io) + x, p * io * 2, v * io * 2, Math.round(T));
        }
        class sd {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new ze(), this.centroidVertexArray = new ue(), this.indexArray = new qi(), this.programConfigurations = new or(t.layers, t.zoom), this.segments = new Qt(), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, l) {
            this.features = [], this.hasPattern = pp("fill-extrusion", this.layers, n);
            for (const { feature: p, id: v, index: x, sourceLayerIndex: T } of t) {
              const E = this.layers[0]._featureFilter.needGeometry, k = Fr(p, E);
              if (!this.layers[0]._featureFilter.filter(new Li(this.zoom, { globalState: this.globalState }), k, l)) continue;
              const D = { id: v, sourceLayerIndex: T, index: x, geometry: E ? k.geometry : Ds(p), properties: p.properties, type: p.type, patterns: {} };
              this.hasPattern ? this.features.push(td("fill-extrusion", this.layers, D, this.zoom, n)) : this.addFeature(D, D.geometry, x, l, {}, n.subdivisionGranularity), n.featureIndex.insert(p, D.geometry, x, T, this.index, !0);
            }
          }
          addFeatures(t, n, l) {
            for (const p of this.features) {
              const { geometry: v } = p;
              this.addFeature(p, v, p.index, n, l, t.subdivisionGranularity);
            }
          }
          update(t, n, l) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, l);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, gp), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Sy.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t, n, l, p, v, x) {
            for (const T of Wl(n, 500)) {
              const E = { x: 0, y: 0, sampleCount: 0 }, k = this.layoutVertexArray.length;
              this.processPolygon(E, p, t, T, x);
              const D = this.layoutVertexArray.length - k, N = Math.floor(E.x / E.sampleCount), q = Math.floor(E.y / E.sampleCount);
              for (let G = 0; G < D; G++) this.centroidVertexArray.emplaceBack(N, q);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, l, v, p);
          }
          processPolygon(t, n, l, p, v) {
            if (p.length < 1 || _c(p[0])) return;
            for (const N of p) N.length !== 0 && no(t, N);
            const x = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, T = v.fill.getGranularityForZoomLevel(n.z), E = xa.types[l.type] === "Polygon";
            for (const N of p) {
              if (N.length === 0 || _c(N)) continue;
              const q = En(N, T, E);
              this._generateSideFaces(q, x);
            }
            if (!E) return;
            const k = Rf(p, n, T, !1), D = this.layoutVertexArray;
            Df(((N, q) => {
              yc(D, N, q, 0, 0, 1, 1, 0);
            }), this.segments, this.layoutVertexArray, this.indexArray, k.verticesFlattened, k.indicesTriangles);
          }
          _generateSideFaces(t, n) {
            let l = 0;
            for (let p = 1; p < t.length; p++) {
              const v = t[p], x = t[p - 1];
              if (Wm(v, x)) continue;
              n.segment.vertexLength + 4 > Qt.MAX_VERTEX_ARRAY_LENGTH && (n.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const T = v.sub(x)._perp()._unit(), E = x.dist(v);
              l + E > 32768 && (l = 0), yc(this.layoutVertexArray, v.x, v.y, T.x, T.y, 0, 0, l), yc(this.layoutVertexArray, v.x, v.y, T.x, T.y, 0, 1, l), l += E, yc(this.layoutVertexArray, x.x, x.y, T.x, T.y, 0, 0, l), yc(this.layoutVertexArray, x.x, x.y, T.x, T.y, 0, 1, l);
              const k = n.segment.vertexLength;
              this.indexArray.emplaceBack(k, k + 2, k + 1), this.indexArray.emplaceBack(k + 1, k + 2, k + 3), n.segment.vertexLength += 4, n.segment.primitiveLength += 2;
            }
          }
        }
        function no(a, t) {
          for (let n = 0; n < t.length; n++) {
            const l = t[n];
            n === t.length - 1 && t[0].x === l.x && t[0].y === l.y || (a.x += l.x, a.y += l.y, a.sampleCount++);
          }
        }
        function Wm(a, t) {
          return a.x === t.x && (a.x < 0 || a.x > at) || a.y === t.y && (a.y < 0 || a.y > at);
        }
        function _c(a) {
          return a.every(((t) => t.x < 0)) || a.every(((t) => t.x > at)) || a.every(((t) => t.y < 0)) || a.every(((t) => t.y > at));
        }
        let nh;
        xt("FillExtrusionBucket", sd, { omit: ["layers", "features"] });
        var od = { get paint() {
          return nh = nh || new za({ "fill-extrusion-opacity": new Tt(Ae["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Ot(Ae["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Tt(Ae["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Tt(Ae["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new sc(Ae["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Ot(Ae["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Ot(Ae["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Tt(Ae["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class ah extends rr {
          constructor(t) {
            super(t, od);
          }
          createBucket(t) {
            return new sd(t);
          }
          queryRadius() {
            return Qh(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: l, geometry: p, transform: v, pixelsToTileUnits: x, pixelPosMatrix: T }) {
            const E = Jc(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -v.bearingInRadians, x), k = this.paint.get("fill-extrusion-height").evaluate(n, l), D = this.paint.get("fill-extrusion-base").evaluate(n, l), N = (function(G, Z) {
              const X = [];
              for (const ee of G) {
                const se = [ee.x, ee.y, 0, 1];
                Cn(se, se, Z), X.push(new O(se[0] / se[3], se[1] / se[3]));
              }
              return X;
            })(E, T), q = (function(G, Z, X, ee) {
              const se = [], xe = [], de = ee[8] * Z, ge = ee[9] * Z, Ie = ee[10] * Z, Fe = ee[11] * Z, Je = ee[8] * X, gt = ee[9] * X, ut = ee[10] * X, yt = ee[11] * X;
              for (const kt of G) {
                const mt = [], pt = [];
                for (const Xe of kt) {
                  const Bt = Xe.x, $t = Xe.y, Rt = ee[0] * Bt + ee[4] * $t + ee[12], Ct = ee[1] * Bt + ee[5] * $t + ee[13], li = ee[2] * Bt + ee[6] * $t + ee[14], Mn = ee[3] * Bt + ee[7] * $t + ee[15], Gn = li + Ie, wa = Mn + Fe, Zr = Rt + Je, cr = Ct + gt, na = li + ut, hn = Mn + yt, aa = new O((Rt + de) / wa, (Ct + ge) / wa);
                  aa.z = Gn / wa, mt.push(aa);
                  const Zn = new O(Zr / hn, cr / hn);
                  Zn.z = na / hn, pt.push(Zn);
                }
                se.push(mt), xe.push(pt);
              }
              return [se, xe];
            })(p, D, k, T);
            return (function(G, Z, X) {
              let ee = 1 / 0;
              pf(X, Z) && (ee = Lf(X, Z[0]));
              for (let se = 0; se < Z.length; se++) {
                const xe = Z[se], de = G[se];
                for (let ge = 0; ge < xe.length - 1; ge++) {
                  const Ie = xe[ge], Fe = [Ie, xe[ge + 1], de[ge + 1], de[ge], Ie];
                  hf(X, Fe) && (ee = Math.min(ee, Lf(X, Fe)));
                }
              }
              return ee !== 1 / 0 && ee;
            })(q[0], q[1], N);
          }
        }
        function rh(a, t) {
          return a.x * t.x + a.y * t.y;
        }
        function Lf(a, t) {
          if (a.length === 1) {
            let n = 0;
            const l = t[n++];
            let p;
            for (; !p || l.equals(p); ) if (p = t[n++], !p) return 1 / 0;
            for (; n < t.length; n++) {
              const v = t[n], x = a[0], T = p.sub(l), E = v.sub(l), k = x.sub(l), D = rh(T, T), N = rh(T, E), q = rh(E, E), G = rh(k, T), Z = rh(k, E), X = D * q - N * N, ee = (q * G - N * Z) / X, se = (D * Z - N * G) / X, xe = l.z * (1 - ee - se) + p.z * ee + v.z * se;
              if (isFinite(xe)) return xe;
            }
            return 1 / 0;
          }
          {
            let n = 1 / 0;
            for (const l of t) n = Math.min(n, l.z);
            return n;
          }
        }
        const ld = fn([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Jm } = ld, yp = fn([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Qm } = yp, Ty = Math.cos(Math.PI / 180 * 37.5), eg = Math.pow(2, 14) / 0.5;
        class ji {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((n) => {
              this.gradients[n.id] = {};
            })), this.layoutVertexArray = new Pe(), this.layoutVertexArray2 = new Le(), this.indexArray = new qi(), this.programConfigurations = new or(t.layers, t.zoom), this.segments = new Qt(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, l) {
            this.hasPattern = pp("line", this.layers, n);
            const p = this.layers[0].layout.get("line-sort-key"), v = !p.isConstant(), x = [];
            for (const { feature: T, id: E, index: k, sourceLayerIndex: D } of t) {
              const N = this.layers[0]._featureFilter.needGeometry, q = Fr(T, N);
              if (!this.layers[0]._featureFilter.filter(new Li(this.zoom, { globalState: this.globalState }), q, l)) continue;
              const G = v ? p.evaluate(q, {}, l) : void 0, Z = { id: E, properties: T.properties, type: T.type, sourceLayerIndex: D, index: k, geometry: N ? q.geometry : Ds(T), patterns: {}, sortKey: G };
              x.push(Z);
            }
            v && x.sort(((T, E) => T.sortKey - E.sortKey));
            for (const T of x) {
              const { geometry: E, index: k, sourceLayerIndex: D } = T;
              if (this.hasPattern) {
                const N = td("line", this.layers, T, this.zoom, n);
                this.patternFeatures.push(N);
              } else this.addFeature(T, E, k, l, {}, n.subdivisionGranularity);
              n.featureIndex.insert(t[k].feature, E, k, D, this.index);
            }
          }
          update(t, n, l) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, l);
          }
          addFeatures(t, n, l) {
            for (const p of this.patternFeatures) this.addFeature(p, p.geometry, p.index, n, l, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Qm)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Jm), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
          }
          addFeature(t, n, l, p, v, x) {
            const T = this.layers[0].layout, E = T.get("line-join").evaluate(t, {}), k = T.get("line-cap"), D = T.get("line-miter-limit"), N = T.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const q of n) this.addLine(q, t, E, k, D, N, p, x);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, l, v, p);
          }
          addLine(t, n, l, p, v, x, T, E) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = En(t, T ? E.line.getGranularityForZoomLevel(T.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let de = 0; de < t.length - 1; de++) this.totalDistance += t[de].dist(t[de + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const k = xa.types[n.type] === "Polygon";
            let D = t.length;
            for (; D >= 2 && t[D - 1].equals(t[D - 2]); ) D--;
            let N = 0;
            for (; N < D - 1 && t[N].equals(t[N + 1]); ) N++;
            if (D < (k ? 3 : 2)) return;
            l === "bevel" && (v = 1.05);
            const q = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, G = this.segments.prepareSegment(10 * D, this.layoutVertexArray, this.indexArray);
            let Z, X, ee, se, xe;
            this.e1 = this.e2 = -1, k && (Z = t[D - 2], xe = t[N].sub(Z)._unit()._perp());
            for (let de = N; de < D; de++) {
              if (ee = de === D - 1 ? k ? t[N + 1] : void 0 : t[de + 1], ee && t[de].equals(ee)) continue;
              xe && (se = xe), Z && (X = Z), Z = t[de], xe = ee ? ee.sub(Z)._unit()._perp() : se, se = se || xe;
              let ge = se.add(xe);
              ge.x === 0 && ge.y === 0 || ge._unit();
              const Ie = se.x * xe.x + se.y * xe.y, Fe = ge.x * xe.x + ge.y * xe.y, Je = Fe !== 0 ? 1 / Fe : 1 / 0, gt = 2 * Math.sqrt(2 - 2 * Fe), ut = Fe < Ty && X && ee, yt = se.x * xe.y - se.y * xe.x > 0;
              if (ut && de > N) {
                const pt = Z.dist(X);
                if (pt > 2 * q) {
                  const Xe = Z.sub(Z.sub(X)._mult(q / pt)._round());
                  this.updateDistance(X, Xe), this.addCurrentVertex(Xe, se, 0, 0, G), X = Xe;
                }
              }
              const kt = X && ee;
              let mt = kt ? l : k ? "butt" : p;
              if (kt && mt === "round" && (Je < x ? mt = "miter" : Je <= 2 && (mt = "fakeround")), mt === "miter" && Je > v && (mt = "bevel"), mt === "bevel" && (Je > 2 && (mt = "flipbevel"), Je < v && (mt = "miter")), X && this.updateDistance(X, Z), mt === "miter") ge._mult(Je), this.addCurrentVertex(Z, ge, 0, 0, G);
              else if (mt === "flipbevel") {
                if (Je > 100) ge = xe.mult(-1);
                else {
                  const pt = Je * se.add(xe).mag() / se.sub(xe).mag();
                  ge._perp()._mult(pt * (yt ? -1 : 1));
                }
                this.addCurrentVertex(Z, ge, 0, 0, G), this.addCurrentVertex(Z, ge.mult(-1), 0, 0, G);
              } else if (mt === "bevel" || mt === "fakeround") {
                const pt = -Math.sqrt(Je * Je - 1), Xe = yt ? pt : 0, Bt = yt ? 0 : pt;
                if (X && this.addCurrentVertex(Z, se, Xe, Bt, G), mt === "fakeround") {
                  const $t = Math.round(180 * gt / Math.PI / 20);
                  for (let Rt = 1; Rt < $t; Rt++) {
                    let Ct = Rt / $t;
                    if (Ct !== 0.5) {
                      const Mn = Ct - 0.5;
                      Ct += Ct * Mn * (Ct - 1) * ((1.0904 + Ie * (Ie * (3.55645 - 1.43519 * Ie) - 3.2452)) * Mn * Mn + (0.848013 + Ie * (0.215638 * Ie - 1.06021)));
                    }
                    const li = xe.sub(se)._mult(Ct)._add(se)._unit()._mult(yt ? -1 : 1);
                    this.addHalfVertex(Z, li.x, li.y, !1, yt, 0, G);
                  }
                }
                ee && this.addCurrentVertex(Z, xe, -Xe, -Bt, G);
              } else if (mt === "butt") this.addCurrentVertex(Z, ge, 0, 0, G);
              else if (mt === "square") {
                const pt = X ? 1 : -1;
                this.addCurrentVertex(Z, ge, pt, pt, G);
              } else mt === "round" && (X && (this.addCurrentVertex(Z, se, 0, 0, G), this.addCurrentVertex(Z, se, 1, 1, G, !0)), ee && (this.addCurrentVertex(Z, xe, -1, -1, G, !0), this.addCurrentVertex(Z, xe, 0, 0, G)));
              if (ut && de < D - 1) {
                const pt = Z.dist(ee);
                if (pt > 2 * q) {
                  const Xe = Z.add(ee.sub(Z)._mult(q / pt)._round());
                  this.updateDistance(Z, Xe), this.addCurrentVertex(Xe, xe, 0, 0, G), Z = Xe;
                }
              }
            }
          }
          addCurrentVertex(t, n, l, p, v, x = !1) {
            const T = n.y * p - n.x, E = -n.y - n.x * p;
            this.addHalfVertex(t, n.x + n.y * l, n.y - n.x * l, x, !1, l, v), this.addHalfVertex(t, T, E, x, !0, -p, v), this.distance > eg / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, n, l, p, v, x));
          }
          addHalfVertex({ x: t, y: n }, l, p, v, x, T, E) {
            const k = 0.5 * (this.lineClips ? this.scaledDistance * (eg - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (v ? 1 : 0), (n << 1) + (x ? 1 : 0), Math.round(63 * l) + 128, Math.round(63 * p) + 128, 1 + (T === 0 ? 0 : T < 0 ? -1 : 1) | (63 & k) << 2, k >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const D = E.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, D, this.e2), E.primitiveLength++), x ? this.e2 = D : this.e1 = D;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t, n) {
            this.distance += t.dist(n), this.updateScaledDistance();
          }
        }
        let sn, Mi;
        xt("LineBucket", ji, { omit: ["layers", "patternFeatures"] });
        var Pi = { get paint() {
          return Mi = Mi || new za({ "line-opacity": new Ot(Ae.paint_line["line-opacity"]), "line-color": new Ot(Ae.paint_line["line-color"]), "line-translate": new Tt(Ae.paint_line["line-translate"]), "line-translate-anchor": new Tt(Ae.paint_line["line-translate-anchor"]), "line-width": new Ot(Ae.paint_line["line-width"]), "line-gap-width": new Ot(Ae.paint_line["line-gap-width"]), "line-offset": new Ot(Ae.paint_line["line-offset"]), "line-blur": new Ot(Ae.paint_line["line-blur"]), "line-dasharray": new xr(Ae.paint_line["line-dasharray"]), "line-pattern": new sc(Ae.paint_line["line-pattern"]), "line-gradient": new Sl(Ae.paint_line["line-gradient"]) });
        }, get layout() {
          return sn = sn || new za({ "line-cap": new Tt(Ae.layout_line["line-cap"]), "line-join": new Ot(Ae.layout_line["line-join"]), "line-miter-limit": new Tt(Ae.layout_line["line-miter-limit"]), "line-round-limit": new Tt(Ae.layout_line["line-round-limit"]), "line-sort-key": new Ot(Ae.layout_line["line-sort-key"]) });
        } };
        class en extends Ot {
          possiblyEvaluate(t, n) {
            return n = new Li(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition }), super.possiblyEvaluate(t, n);
          }
          evaluate(t, n, l, p) {
            return n = Ii({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(t, n, l, p);
          }
        }
        let lr;
        class mu extends rr {
          constructor(t) {
            super(t, Pi), this.gradientVersion = 0, lr || (lr = new en(Pi.paint.properties["line-width"].specification), lr.useIntegerZoom = !0);
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const n = this.gradientExpression();
              this.stepInterpolant = !!(function(l) {
                return l._styleExpression !== void 0;
              })(n) && n._styleExpression.expression instanceof pn, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t, n) {
            super.recalculate(t, n), this.paint._values["line-floorwidth"] = lr.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
          }
          createBucket(t) {
            return new ji(t);
          }
          queryRadius(t) {
            const n = t, l = vc(pu("line-width", this, n), pu("line-gap-width", this, n)), p = pu("line-offset", this, n);
            return l / 2 + Math.abs(p) + Qh(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: l, geometry: p, transform: v, pixelsToTileUnits: x }) {
            const T = Jc(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -v.bearingInRadians, x), E = x / 2 * vc(this.paint.get("line-width").evaluate(n, l), this.paint.get("line-gap-width").evaluate(n, l)), k = this.paint.get("line-offset").evaluate(n, l);
            return k && (p = (function(D, N) {
              const q = [];
              for (let G = 0; G < D.length; G++) {
                const Z = D[G], X = [];
                for (let ee = 0; ee < Z.length; ee++) {
                  const se = Z[ee - 1], xe = Z[ee], de = Z[ee + 1], ge = ee === 0 ? new O(0, 0) : xe.sub(se)._unit()._perp(), Ie = ee === Z.length - 1 ? new O(0, 0) : de.sub(xe)._unit()._perp(), Fe = ge._add(Ie)._unit(), Je = Fe.x * Ie.x + Fe.y * Ie.y;
                  Je !== 0 && Fe._mult(1 / Je), X.push(Fe._mult(N)._add(xe));
                }
                q.push(X);
              }
              return q;
            })(p, k * x)), (function(D, N, q) {
              for (let G = 0; G < N.length; G++) {
                const Z = N[G];
                if (D.length >= 3) {
                  for (let X = 0; X < Z.length; X++) if (hc(D, Z[X])) return !0;
                }
                if (ff(D, Z, q)) return !0;
              }
              return !1;
            })(T, p, E);
          }
          isTileClipped() {
            return !0;
          }
        }
        function vc(a, t) {
          return t > 0 ? t + 2 * a : a;
        }
        const Of = fn([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), El = fn([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        fn([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const qn = fn([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        fn([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Cl = fn([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), xc = fn([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function Bf(a, t, n) {
          return a.sections.forEach(((l) => {
            l.text = (function(p, v, x) {
              const T = v.layout.get("text-transform").evaluate(x, {});
              return T === "uppercase" ? p = p.toLocaleUpperCase() : T === "lowercase" && (p = p.toLocaleLowerCase()), Br.applyArabicShaping && (p = Br.applyArabicShaping(p)), p;
            })(l.text, t, n);
          })), a;
        }
        fn([{ name: "triangle", components: 3, type: "Uint16" }]), fn([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), fn([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), fn([{ type: "Float32", name: "offsetX" }]), fn([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), fn([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const Za = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
        var Tn = 24;
        const bc = 4294967296, Er = 1 / bc, _p = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class sh {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(t, n, l = this.length) {
            for (; this.pos < l; ) {
              const p = this.readVarint(), v = p >> 3, x = this.pos;
              this.type = 7 & p, t(v, n, this), this.pos === x && this.skip(p);
            }
            return n;
          }
          readMessage(t, n) {
            return this.readFields(t, n, this.readVarint() + this.pos);
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, t;
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, t;
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * bc;
            return this.pos += 8, t;
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * bc;
            return this.pos += 8, t;
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, t;
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, t;
          }
          readVarint(t) {
            const n = this.buf;
            let l, p;
            return p = n[this.pos++], l = 127 & p, p < 128 ? l : (p = n[this.pos++], l |= (127 & p) << 7, p < 128 ? l : (p = n[this.pos++], l |= (127 & p) << 14, p < 128 ? l : (p = n[this.pos++], l |= (127 & p) << 21, p < 128 ? l : (p = n[this.pos], l |= (15 & p) << 28, (function(v, x, T) {
              const E = T.buf;
              let k, D;
              if (D = E[T.pos++], k = (112 & D) >> 4, D < 128 || (D = E[T.pos++], k |= (127 & D) << 3, D < 128) || (D = E[T.pos++], k |= (127 & D) << 10, D < 128) || (D = E[T.pos++], k |= (127 & D) << 17, D < 128) || (D = E[T.pos++], k |= (127 & D) << 24, D < 128) || (D = E[T.pos++], k |= (1 & D) << 31, D < 128)) return wc(v, k, x);
              throw new Error("Expected varint not more than 10 bytes");
            })(l, t, this)))));
          }
          readVarint64() {
            return this.readVarint(!0);
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2;
          }
          readBoolean() {
            return !!this.readVarint();
          }
          readString() {
            const t = this.readVarint() + this.pos, n = this.pos;
            return this.pos = t, t - n >= 12 && _p ? _p.decode(this.buf.subarray(n, t)) : (function(l, p, v) {
              let x = "", T = p;
              for (; T < v; ) {
                const E = l[T];
                let k, D, N, q = null, G = E > 239 ? 4 : E > 223 ? 3 : E > 191 ? 2 : 1;
                if (T + G > v) break;
                G === 1 ? E < 128 && (q = E) : G === 2 ? (k = l[T + 1], (192 & k) == 128 && (q = (31 & E) << 6 | 63 & k, q <= 127 && (q = null))) : G === 3 ? (k = l[T + 1], D = l[T + 2], (192 & k) == 128 && (192 & D) == 128 && (q = (15 & E) << 12 | (63 & k) << 6 | 63 & D, (q <= 2047 || q >= 55296 && q <= 57343) && (q = null))) : G === 4 && (k = l[T + 1], D = l[T + 2], N = l[T + 3], (192 & k) == 128 && (192 & D) == 128 && (192 & N) == 128 && (q = (15 & E) << 18 | (63 & k) << 12 | (63 & D) << 6 | 63 & N, (q <= 65535 || q >= 1114112) && (q = null))), q === null ? (q = 65533, G = 1) : q > 65535 && (q -= 65536, x += String.fromCharCode(q >>> 10 & 1023 | 55296), q = 56320 | 1023 & q), x += String.fromCharCode(q), T += G;
              }
              return x;
            })(this.buf, n, t);
          }
          readBytes() {
            const t = this.readVarint() + this.pos, n = this.buf.subarray(this.pos, t);
            return this.pos = t, n;
          }
          readPackedVarint(t = [], n) {
            const l = this.readPackedEnd();
            for (; this.pos < l; ) t.push(this.readVarint(n));
            return t;
          }
          readPackedSVarint(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSVarint());
            return t;
          }
          readPackedBoolean(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readBoolean());
            return t;
          }
          readPackedFloat(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFloat());
            return t;
          }
          readPackedDouble(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readDouble());
            return t;
          }
          readPackedFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFixed32());
            return t;
          }
          readPackedSFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSFixed32());
            return t;
          }
          readPackedFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFixed64());
            return t;
          }
          readPackedSFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSFixed64());
            return t;
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(t) {
            const n = 7 & t;
            if (n === 0) for (; this.buf[this.pos++] > 127; ) ;
            else if (n === 2) this.pos = this.readVarint() + this.pos;
            else if (n === 5) this.pos += 4;
            else {
              if (n !== 1) throw new Error(`Unimplemented type: ${n}`);
              this.pos += 8;
            }
          }
          writeTag(t, n) {
            this.writeVarint(t << 3 | n);
          }
          realloc(t) {
            let n = this.length || 16;
            for (; n < this.pos + t; ) n *= 2;
            if (n !== this.length) {
              const l = new Uint8Array(n);
              l.set(this.buf), this.buf = l, this.dataView = new DataView(l.buffer), this.length = n;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4;
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4;
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * Er), !0), this.pos += 8;
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * Er), !0), this.pos += 8;
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(n, l) {
              let p, v;
              if (n >= 0 ? (p = n % 4294967296 | 0, v = n / 4294967296 | 0) : (p = ~(-n % 4294967296), v = ~(-n / 4294967296), 4294967295 ^ p ? p = p + 1 | 0 : (p = 0, v = v + 1 | 0)), n >= 18446744073709552e3 || n < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              l.realloc(10), (function(x, T, E) {
                E.buf[E.pos++] = 127 & x | 128, x >>>= 7, E.buf[E.pos++] = 127 & x | 128, x >>>= 7, E.buf[E.pos++] = 127 & x | 128, x >>>= 7, E.buf[E.pos++] = 127 & x | 128, E.buf[E.pos] = 127 & (x >>>= 7);
              })(p, 0, l), (function(x, T) {
                const E = (7 & x) << 4;
                T.buf[T.pos++] |= E | ((x >>>= 3) ? 128 : 0), x && (T.buf[T.pos++] = 127 & x | ((x >>>= 7) ? 128 : 0), x && (T.buf[T.pos++] = 127 & x | ((x >>>= 7) ? 128 : 0), x && (T.buf[T.pos++] = 127 & x | ((x >>>= 7) ? 128 : 0), x && (T.buf[T.pos++] = 127 & x | ((x >>>= 7) ? 128 : 0), x && (T.buf[T.pos++] = 127 & x)))));
              })(v, l);
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
          }
          writeBoolean(t) {
            this.writeVarint(+t);
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const n = this.pos;
            this.pos = (function(p, v, x) {
              for (let T, E, k = 0; k < v.length; k++) {
                if (T = v.charCodeAt(k), T > 55295 && T < 57344) {
                  if (!E) {
                    T > 56319 || k + 1 === v.length ? (p[x++] = 239, p[x++] = 191, p[x++] = 189) : E = T;
                    continue;
                  }
                  if (T < 56320) {
                    p[x++] = 239, p[x++] = 191, p[x++] = 189, E = T;
                    continue;
                  }
                  T = E - 55296 << 10 | T - 56320 | 65536, E = null;
                } else E && (p[x++] = 239, p[x++] = 191, p[x++] = 189, E = null);
                T < 128 ? p[x++] = T : (T < 2048 ? p[x++] = T >> 6 | 192 : (T < 65536 ? p[x++] = T >> 12 | 224 : (p[x++] = T >> 18 | 240, p[x++] = T >> 12 & 63 | 128), p[x++] = T >> 6 & 63 | 128), p[x++] = 63 & T | 128);
              }
              return x;
            })(this.buf, t, this.pos);
            const l = this.pos - n;
            l >= 128 && ud(n, l, this), this.pos = n - 1, this.writeVarint(l), this.pos += l;
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4;
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8;
          }
          writeBytes(t) {
            const n = t.length;
            this.writeVarint(n), this.realloc(n);
            for (let l = 0; l < n; l++) this.buf[this.pos++] = t[l];
          }
          writeRawMessage(t, n) {
            this.pos++;
            const l = this.pos;
            t(n, this);
            const p = this.pos - l;
            p >= 128 && ud(l, p, this), this.pos = l - 1, this.writeVarint(p), this.pos += p;
          }
          writeMessage(t, n, l) {
            this.writeTag(t, 2), this.writeRawMessage(n, l);
          }
          writePackedVarint(t, n) {
            n.length && this.writeMessage(t, vp, n);
          }
          writePackedSVarint(t, n) {
            n.length && this.writeMessage(t, gu, n);
          }
          writePackedBoolean(t, n) {
            n.length && this.writeMessage(t, oh, n);
          }
          writePackedFloat(t, n) {
            n.length && this.writeMessage(t, ba, n);
          }
          writePackedDouble(t, n) {
            n.length && this.writeMessage(t, yu, n);
          }
          writePackedFixed32(t, n) {
            n.length && this.writeMessage(t, zl, n);
          }
          writePackedSFixed32(t, n) {
            n.length && this.writeMessage(t, Nf, n);
          }
          writePackedFixed64(t, n) {
            n.length && this.writeMessage(t, jf, n);
          }
          writePackedSFixed64(t, n) {
            n.length && this.writeMessage(t, tg, n);
          }
          writeBytesField(t, n) {
            this.writeTag(t, 2), this.writeBytes(n);
          }
          writeFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeFixed32(n);
          }
          writeSFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeSFixed32(n);
          }
          writeFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeFixed64(n);
          }
          writeSFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeSFixed64(n);
          }
          writeVarintField(t, n) {
            this.writeTag(t, 0), this.writeVarint(n);
          }
          writeSVarintField(t, n) {
            this.writeTag(t, 0), this.writeSVarint(n);
          }
          writeStringField(t, n) {
            this.writeTag(t, 2), this.writeString(n);
          }
          writeFloatField(t, n) {
            this.writeTag(t, 5), this.writeFloat(n);
          }
          writeDoubleField(t, n) {
            this.writeTag(t, 1), this.writeDouble(n);
          }
          writeBooleanField(t, n) {
            this.writeVarintField(t, +n);
          }
        }
        function wc(a, t, n) {
          return n ? 4294967296 * t + (a >>> 0) : 4294967296 * (t >>> 0) + (a >>> 0);
        }
        function ud(a, t, n) {
          const l = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          n.realloc(l);
          for (let p = n.pos - 1; p >= a; p--) n.buf[p + l] = n.buf[p];
        }
        function vp(a, t) {
          for (let n = 0; n < a.length; n++) t.writeVarint(a[n]);
        }
        function gu(a, t) {
          for (let n = 0; n < a.length; n++) t.writeSVarint(a[n]);
        }
        function ba(a, t) {
          for (let n = 0; n < a.length; n++) t.writeFloat(a[n]);
        }
        function yu(a, t) {
          for (let n = 0; n < a.length; n++) t.writeDouble(a[n]);
        }
        function oh(a, t) {
          for (let n = 0; n < a.length; n++) t.writeBoolean(a[n]);
        }
        function zl(a, t) {
          for (let n = 0; n < a.length; n++) t.writeFixed32(a[n]);
        }
        function Nf(a, t) {
          for (let n = 0; n < a.length; n++) t.writeSFixed32(a[n]);
        }
        function jf(a, t) {
          for (let n = 0; n < a.length; n++) t.writeFixed64(a[n]);
        }
        function tg(a, t) {
          for (let n = 0; n < a.length; n++) t.writeSFixed64(a[n]);
        }
        function cd(a, t, n) {
          a === 1 && n.readMessage(Uf, t);
        }
        function Uf(a, t, n) {
          if (a === 3) {
            const { id: l, bitmap: p, width: v, height: x, left: T, top: E, advance: k } = n.readMessage(is, {});
            t.push({ id: l, bitmap: new Qc({ width: v + 6, height: x + 6 }, p), metrics: { width: v, height: x, left: T, top: E, advance: k } });
          }
        }
        function is(a, t, n) {
          a === 1 ? t.id = n.readVarint() : a === 2 ? t.bitmap = n.readBytes() : a === 3 ? t.width = n.readVarint() : a === 4 ? t.height = n.readVarint() : a === 5 ? t.left = n.readSVarint() : a === 6 ? t.top = n.readSVarint() : a === 7 && (t.advance = n.readVarint());
        }
        function Ff(a) {
          let t = 0, n = 0;
          for (const x of a) t += x.w * x.h, n = Math.max(n, x.w);
          a.sort(((x, T) => T.h - x.h));
          const l = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), n), h: 1 / 0 }];
          let p = 0, v = 0;
          for (const x of a) for (let T = l.length - 1; T >= 0; T--) {
            const E = l[T];
            if (!(x.w > E.w || x.h > E.h)) {
              if (x.x = E.x, x.y = E.y, v = Math.max(v, x.y + x.h), p = Math.max(p, x.x + x.w), x.w === E.w && x.h === E.h) {
                const k = l.pop();
                k && T < l.length && (l[T] = k);
              } else x.h === E.h ? (E.x += x.w, E.w -= x.w) : x.w === E.w ? (E.y += x.h, E.h -= x.h) : (l.push({ x: E.x + x.w, y: E.y, w: E.w - x.w, h: x.h }), E.y += x.h, E.h -= x.h);
              break;
            }
          }
          return { w: p, h: v, fill: t / (p * v) || 0 };
        }
        class ur {
          constructor(t, { pixelRatio: n, version: l, stretchX: p, stretchY: v, content: x, textFitWidth: T, textFitHeight: E }) {
            this.paddedRect = t, this.pixelRatio = n, this.stretchX = p, this.stretchY = v, this.content = x, this.version = l, this.textFitWidth = T, this.textFitHeight = E;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class Vf {
          constructor(t, n) {
            const l = {}, p = {};
            this.haveRenderCallbacks = [];
            const v = [];
            this.addImages(t, l, v), this.addImages(n, p, v);
            const { w: x, h: T } = Ff(v), E = new ka({ width: x || 1, height: T || 1 });
            for (const k in t) {
              const D = t[k], N = l[k].paddedRect;
              ka.copy(D.data, E, { x: 0, y: 0 }, { x: N.x + 1, y: N.y + 1 }, D.data);
            }
            for (const k in n) {
              const D = n[k], N = p[k].paddedRect, q = N.x + 1, G = N.y + 1, Z = D.data.width, X = D.data.height;
              ka.copy(D.data, E, { x: 0, y: 0 }, { x: q, y: G }, D.data), ka.copy(D.data, E, { x: 0, y: X - 1 }, { x: q, y: G - 1 }, { width: Z, height: 1 }), ka.copy(D.data, E, { x: 0, y: 0 }, { x: q, y: G + X }, { width: Z, height: 1 }), ka.copy(D.data, E, { x: Z - 1, y: 0 }, { x: q - 1, y: G }, { width: 1, height: X }), ka.copy(D.data, E, { x: 0, y: 0 }, { x: q + Z, y: G }, { width: 1, height: X });
            }
            this.image = E, this.iconPositions = l, this.patternPositions = p;
          }
          addImages(t, n, l) {
            for (const p in t) {
              const v = t[p], x = { x: 0, y: 0, w: v.data.width + 2, h: v.data.height + 2 };
              l.push(x), n[p] = new ur(x, v), v.hasRenderCallback && this.haveRenderCallbacks.push(p);
            }
          }
          patchUpdatedImages(t, n) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const l in t.updatedImages) this.patchUpdatedImage(this.iconPositions[l], t.getImage(l), n), this.patchUpdatedImage(this.patternPositions[l], t.getImage(l), n);
          }
          patchUpdatedImage(t, n, l) {
            if (!t || !n || t.version === n.version) return;
            t.version = n.version;
            const [p, v] = t.tl;
            l.update(n.data, void 0, { x: p, y: v });
          }
        }
        var Pl;
        xt("ImagePosition", ur), xt("ImageAtlas", Vf), S.ao = void 0, (Pl = S.ao || (S.ao = {}))[Pl.none = 0] = "none", Pl[Pl.horizontal = 1] = "horizontal", Pl[Pl.vertical = 2] = "vertical", Pl[Pl.horizontalOnly = 3] = "horizontalOnly";
        class hd {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(t, n, l) {
            const p = new hd();
            return p.scale = t || 1, p.fontStack = n, p.verticalAlign = l || "bottom", p;
          }
          static forImage(t, n) {
            const l = new hd();
            return l.imageName = t, l.verticalAlign = n || "bottom", l;
          }
        }
        class ns {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t, n) {
            const l = new ns();
            for (let p = 0; p < t.sections.length; p++) {
              const v = t.sections[p];
              v.image ? l.addImageSection(v) : l.addTextSection(v, n);
            }
            return l;
          }
          length() {
            return this.text.length;
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]];
          }
          getSectionIndex(t) {
            return this.sectionIndex[t];
          }
          getCharCode(t) {
            return this.text.charCodeAt(t);
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let n = "";
              for (let l = 0; l < t.length; l++) {
                const p = t.charCodeAt(l + 1) || null, v = t.charCodeAt(l - 1) || null;
                n += p && ac(p) && !Za[t[l + 1]] || v && ac(v) && !Za[t[l - 1]] || !Za[t[l]] ? t[l] : Za[t[l]];
              }
              return n;
            })(this.text);
          }
          trim() {
            let t = 0;
            for (let l = 0; l < this.text.length && lh[this.text.charCodeAt(l)]; l++) t++;
            let n = this.text.length;
            for (let l = this.text.length - 1; l >= 0 && l >= t && lh[this.text.charCodeAt(l)]; l--) n--;
            this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n);
          }
          substring(t, n) {
            const l = new ns();
            return l.text = this.text.substring(t, n), l.sectionIndex = this.sectionIndex.slice(t, n), l.sections = this.sections, l;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, n) => Math.max(t, this.sections[n].scale)), 0);
          }
          getMaxImageSize(t) {
            let n = 0, l = 0;
            for (let p = 0; p < this.length(); p++) {
              const v = this.getSection(p);
              if (v.imageName) {
                const x = t[v.imageName];
                if (!x) continue;
                const T = x.displaySize;
                n = Math.max(n, T[0]), l = Math.max(l, T[1]);
              }
            }
            return { maxImageWidth: n, maxImageHeight: l };
          }
          addTextSection(t, n) {
            this.text += t.text, this.sections.push(hd.forText(t.scale, t.fontStack || n, t.verticalAlign));
            const l = this.sections.length - 1;
            for (let p = 0; p < t.text.length; ++p) this.sectionIndex.push(l);
          }
          addImageSection(t) {
            const n = t.image ? t.image.name : "";
            if (n.length === 0) return void $i("Can't add FormattedSection with an empty image.");
            const l = this.getNextImageSectionCharCode();
            l ? (this.text += String.fromCharCode(l), this.sections.push(hd.forImage(n, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : $i("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Sc(a, t, n, l, p, v, x, T, E, k, D, N, q, G, Z) {
          const X = ns.fromFeature(a, p);
          let ee;
          N === S.ao.vertical && X.verticalizePunctuation();
          const { processBidirectionalText: se, processStyledBidirectionalText: xe } = Br;
          if (se && X.sections.length === 1) {
            ee = [];
            const Ie = se(X.toString(), Zf(X, k, v, t, l, G));
            for (const Fe of Ie) {
              const Je = new ns();
              Je.text = Fe, Je.sections = X.sections;
              for (let gt = 0; gt < Fe.length; gt++) Je.sectionIndex.push(0);
              ee.push(Je);
            }
          } else if (xe) {
            ee = [];
            const Ie = xe(X.text, X.sectionIndex, Zf(X, k, v, t, l, G));
            for (const Fe of Ie) {
              const Je = new ns();
              Je.text = Fe[0], Je.sectionIndex = Fe[1], Je.sections = X.sections, ee.push(Je);
            }
          } else ee = (function(Ie, Fe) {
            const Je = [], gt = Ie.text;
            let ut = 0;
            for (const yt of Fe) Je.push(Ie.substring(ut, yt)), ut = yt;
            return ut < gt.length && Je.push(Ie.substring(ut, gt.length)), Je;
          })(X, Zf(X, k, v, t, l, G));
          const de = [], ge = { positionedLines: de, text: X.toString(), top: D[1], bottom: D[1], left: D[0], right: D[0], writingMode: N, iconsInText: !1, verticalizable: !1 };
          return (function(Ie, Fe, Je, gt, ut, yt, kt, mt, pt, Xe, Bt, $t) {
            let Rt = 0, Ct = 0, li = 0, Mn = 0;
            const Gn = mt === "right" ? 1 : mt === "left" ? 0 : 0.5, wa = Tn / $t;
            let Zr = 0;
            for (const hn of ut) {
              hn.trim();
              const aa = hn.getMaxScale(), Zn = { positionedGlyphs: [], lineOffset: 0 };
              Ie.positionedLines[Zr] = Zn;
              const Sa = Zn.positionedGlyphs;
              let hr = 0;
              if (!hn.length()) {
                Ct += yt, ++Zr;
                continue;
              }
              const zr = My(gt, hn, wa);
              for (let Da = 0; Da < hn.length(); Da++) {
                const Fn = hn.getSection(Da), ra = hn.getSectionIndex(Da), Hn = hn.getCharCode(Da), nn = ag(pt, Bt, Hn);
                let Ri;
                if (Fn.imageName) {
                  if (Ie.iconsInText = !0, Fn.scale = Fn.scale * wa, Ri = bp(Fn, nn, aa, zr, gt), !Ri) continue;
                  hr = Math.max(hr, Ri.imageOffset);
                } else if (Ri = ch(Fn, Hn, nn, zr, Fe, Je), !Ri) continue;
                const { rect: La, metrics: Xo, baselineOffset: Pr } = Ri;
                Sa.push({ glyph: Hn, imageName: Fn.imageName, x: Rt, y: Ct + Pr + -17, vertical: nn, scale: Fn.scale, fontStack: Fn.fontStack, sectionIndex: ra, metrics: Xo, rect: La }), nn ? (Ie.verticalizable = !0, Rt += (Fn.imageName ? Xo.advance : Tn) * Fn.scale + Xe) : Rt += Xo.advance * Fn.scale + Xe;
              }
              Sa.length !== 0 && (li = Math.max(Rt - Xe, li), rg(Sa, 0, Sa.length - 1, Gn)), Rt = 0, Zn.lineOffset = Math.max(hr, (aa - 1) * Tn);
              const $n = yt * aa + hr;
              Ct += $n, Mn = Math.max($n, Mn), ++Zr;
            }
            const { horizontalAlign: cr, verticalAlign: na } = $f(kt);
            (function(hn, aa, Zn, Sa, hr, zr, $n, Da, Fn) {
              const ra = (aa - Zn) * hr;
              let Hn = 0;
              Hn = zr !== $n ? -Da * Sa - -17 : -Sa * Fn * $n + 0.5 * $n;
              for (const nn of hn) for (const Ri of nn.positionedGlyphs) Ri.x += ra, Ri.y += Hn;
            })(Ie.positionedLines, Gn, cr, na, li, Mn, yt, Ct, ut.length), Ie.top += -na * Ct, Ie.bottom = Ie.top + Ct, Ie.left += -cr * li, Ie.right = Ie.left + li;
          })(ge, t, n, l, ee, x, T, E, N, k, q, Z), !(function(Ie) {
            for (const Fe of Ie) if (Fe.positionedGlyphs.length !== 0) return !1;
            return !0;
          })(de) && ge;
        }
        const lh = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, uh = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, ig = { 40: !0 };
        function qf(a, t, n, l, p, v) {
          if (t.imageName) {
            const x = l[t.imageName];
            return x ? x.displaySize[0] * t.scale * Tn / v + p : 0;
          }
          {
            const x = n[t.fontStack], T = x && x[a];
            return T ? T.metrics.advance * t.scale + p : 0;
          }
        }
        function Gf(a, t, n, l) {
          const p = Math.pow(a - t, 2);
          return l ? a < t ? p / 2 : 2 * p : p + Math.abs(n) * n;
        }
        function ng(a, t, n) {
          let l = 0;
          return a === 10 && (l -= 1e4), n && (l += 150), a !== 40 && a !== 65288 || (l += 50), t !== 41 && t !== 65289 || (l += 50), l;
        }
        function dd(a, t, n, l, p, v) {
          let x = null, T = Gf(t, n, p, v);
          for (const E of l) {
            const k = Gf(t - E.x, n, p, v) + E.badness;
            k <= T && (x = E, T = k);
          }
          return { index: a, x: t, priorBreak: x, badness: T };
        }
        function xp(a) {
          return a ? xp(a.priorBreak).concat(a.index) : [];
        }
        function Zf(a, t, n, l, p, v) {
          if (!a) return [];
          const x = [], T = (function(N, q, G, Z, X, ee) {
            let se = 0;
            for (let xe = 0; xe < N.length(); xe++) {
              const de = N.getSection(xe);
              se += qf(N.getCharCode(xe), de, Z, X, q, ee);
            }
            return se / Math.max(1, Math.ceil(se / G));
          })(a, t, n, l, p, v), E = a.text.indexOf("") >= 0;
          let k = 0;
          for (let N = 0; N < a.length(); N++) {
            const q = a.getSection(N), G = a.getCharCode(N);
            if (lh[G] || (k += qf(G, q, l, p, t, v)), N < a.length() - 1) {
              const Z = !((D = G) < 11904) && (!!mi["CJK Compatibility Forms"](D) || !!mi["CJK Compatibility"](D) || !!mi["CJK Strokes"](D) || !!mi["CJK Symbols and Punctuation"](D) || !!mi["Enclosed CJK Letters and Months"](D) || !!mi["Halfwidth and Fullwidth Forms"](D) || !!mi["Ideographic Description Characters"](D) || !!mi["Vertical Forms"](D) || Ro.test(String.fromCodePoint(D)));
              (uh[G] || Z || q.imageName || N !== a.length() - 2 && ig[a.getCharCode(N + 1)]) && x.push(dd(N + 1, k, T, x, ng(G, a.getCharCode(N + 1), Z && E), !1));
            }
          }
          var D;
          return xp(dd(a.length(), k, T, x, 0, !0));
        }
        function $f(a) {
          let t = 0.5, n = 0.5;
          switch (a) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0;
          }
          switch (a) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              n = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              n = 0;
          }
          return { horizontalAlign: t, verticalAlign: n };
        }
        function My(a, t, n) {
          const l = t.getMaxScale() * Tn, { maxImageWidth: p, maxImageHeight: v } = t.getMaxImageSize(a), x = Math.max(l, v * n);
          return { verticalLineContentWidth: Math.max(l, p * n), horizontalLineContentHeight: x };
        }
        function Hf(a) {
          switch (a) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function ag(a, t, n) {
          return !(a === S.ao.horizontal || !t && !bl(n) || t && (lh[n] || (l = n, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(l)))));
          var l;
        }
        function ch(a, t, n, l, p, v) {
          const x = v[a.fontStack], T = (function(k, D, N, q) {
            if (k && k.rect) return k;
            const G = D[N.fontStack], Z = G && G[q];
            return Z ? { rect: null, metrics: Z.metrics } : null;
          })(x && x[t], p, a, t);
          if (T === null) return null;
          let E;
          if (n) E = l.verticalLineContentWidth - a.scale * Tn;
          else {
            const k = Hf(a.verticalAlign);
            E = (l.horizontalLineContentHeight - a.scale * Tn) * k;
          }
          return { rect: T.rect, metrics: T.metrics, baselineOffset: E };
        }
        function bp(a, t, n, l, p) {
          const v = p[a.imageName];
          if (!v) return null;
          const x = v.paddedRect, T = v.displaySize, E = { width: T[0], height: T[1], left: 1, top: -3, advance: t ? T[1] : T[0] };
          let k;
          if (t) k = l.verticalLineContentWidth - T[1] * a.scale;
          else {
            const D = Hf(a.verticalAlign);
            k = (l.horizontalLineContentHeight - T[1] * a.scale) * D;
          }
          return { rect: x, metrics: E, baselineOffset: k, imageOffset: (t ? T[0] : T[1]) * a.scale - Tn * n };
        }
        function rg(a, t, n, l) {
          if (l === 0) return;
          const p = a[n], v = (a[n].x + p.metrics.advance * p.scale) * l;
          for (let x = t; x <= n; x++) a[x].x -= v;
        }
        function sg(a, t, n) {
          const { horizontalAlign: l, verticalAlign: p } = $f(n), v = t[0] - a.displaySize[0] * l, x = t[1] - a.displaySize[1] * p;
          return { image: a, top: x, bottom: x + a.displaySize[1], left: v, right: v + a.displaySize[0] };
        }
        function Xf(a) {
          var t, n;
          let l = a.left, p = a.top, v = a.right - l, x = a.bottom - p;
          const T = (t = a.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", E = (n = a.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink", k = (a.image.content[2] - a.image.content[0]) / (a.image.content[3] - a.image.content[1]);
          if (E === "proportional") {
            if (T === "stretchOnly" && v / x < k || T === "proportional") {
              const D = Math.ceil(x * k);
              l *= D / v, v = D;
            }
          } else if (T === "proportional" && E === "stretchOnly" && k !== 0 && v / x > k) {
            const D = Math.ceil(v / k);
            p *= D / x, x = D;
          }
          return { x1: l, y1: p, x2: l + v, y2: p + x };
        }
        function Yf(a, t, n, l, p, v) {
          const x = a.image;
          let T;
          if (x.content) {
            const ee = x.content, se = x.pixelRatio || 1;
            T = [ee[0] / se, ee[1] / se, x.displaySize[0] - ee[2] / se, x.displaySize[1] - ee[3] / se];
          }
          const E = t.left * v, k = t.right * v;
          let D, N, q, G;
          n === "width" || n === "both" ? (G = p[0] + E - l[3], N = p[0] + k + l[1]) : (G = p[0] + (E + k - x.displaySize[0]) / 2, N = G + x.displaySize[0]);
          const Z = t.top * v, X = t.bottom * v;
          return n === "height" || n === "both" ? (D = p[1] + Z - l[0], q = p[1] + X + l[2]) : (D = p[1] + (Z + X - x.displaySize[1]) / 2, q = D + x.displaySize[1]), { image: x, top: D, right: N, bottom: q, left: G, collisionPadding: T };
        }
        const Go = 128, Il = 32640;
        function pd(a, t) {
          const { expression: n } = t;
          if (n.kind === "constant") return { kind: "constant", layoutSize: n.evaluate(new Li(a + 1)) };
          if (n.kind === "source") return { kind: "source" };
          {
            const { zoomStops: l, interpolationType: p } = n;
            let v = 0;
            for (; v < l.length && l[v] <= a; ) v++;
            v = Math.max(0, v - 1);
            let x = v;
            for (; x < l.length && l[x] < a + 1; ) x++;
            x = Math.min(l.length - 1, x);
            const T = l[v], E = l[x];
            return n.kind === "composite" ? { kind: "composite", minZoom: T, maxZoom: E, interpolationType: p } : { kind: "camera", minZoom: T, maxZoom: E, minSize: n.evaluate(new Li(T)), maxSize: n.evaluate(new Li(E)), interpolationType: p };
          }
        }
        function wp(a, t, n) {
          let l = "never";
          const p = a.get(t);
          return p ? l = p : a.get(n) && (l = "always"), l;
        }
        const og = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Gi(a, t, n, l, p, v, x, T, E, k, D, N, q) {
          const G = T ? Math.min(Il, Math.round(T[0])) : 0, Z = T ? Math.min(Il, Math.round(T[1])) : 0;
          a.emplaceBack(t, n, Math.round(32 * l), Math.round(32 * p), v, x, (G << 1) + (E ? 1 : 0), Z, 16 * k, 16 * D, 256 * N, 256 * q);
        }
        function fd(a, t, n) {
          a.emplaceBack(t.x, t.y, n), a.emplaceBack(t.x, t.y, n), a.emplaceBack(t.x, t.y, n), a.emplaceBack(t.x, t.y, n);
        }
        function Ay(a) {
          for (const t of a.sections) if (Do(t.text)) return !0;
          return !1;
        }
        class Sp {
          constructor(t) {
            this.layoutVertexArray = new ct(), this.indexArray = new qi(), this.programConfigurations = t, this.segments = new Qt(), this.dynamicLayoutVertexArray = new We(), this.opacityVertexArray = new At(), this.hasVisibleVertices = !1, this.placedSymbolArray = new $();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(t, n, l, p) {
            this.isEmpty() || (l && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Of.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, El.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, og, !0), this.opacityVertexBuffer.itemSize = 1), (l || p) && this.programConfigurations.upload(t));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        xt("SymbolBuffers", Sp);
        class Kf {
          constructor(t, n, l) {
            this.layoutVertexArray = new t(), this.layoutAttributes = n, this.indexArray = new l(), this.segments = new Qt(), this.collisionVertexArray = new zi();
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, qn.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        xt("CollisionBuffers", Kf);
        class hh {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((x) => x.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const n = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = pd(this.zoom, n["text-size"]), this.iconSizeData = pd(this.zoom, n["icon-size"]);
            const l = this.layers[0].layout, p = l.get("symbol-sort-key"), v = l.get("symbol-z-order");
            this.canOverlap = wp(l, "text-overlap", "text-allow-overlap") !== "never" || wp(l, "icon-overlap", "icon-allow-overlap") !== "never" || l.get("text-ignore-placement") || l.get("icon-ignore-placement"), this.sortFeaturesByKey = v !== "viewport-y" && !p.isConstant(), this.sortFeaturesByY = (v === "viewport-y" || v === "auto" && !this.sortFeaturesByKey) && this.canOverlap, l.get("symbol-placement") === "point" && (this.writingModes = l.get("text-writing-mode").map(((x) => S.ao[x]))), this.stateDependentLayerIds = this.layers.filter(((x) => x.isStateDependent())).map(((x) => x.id)), this.sourceID = t.sourceID;
          }
          createArrays() {
            this.text = new Sp(new or(this.layers, this.zoom, ((t) => /^text/.test(t)))), this.icon = new Sp(new or(this.layers, this.zoom, ((t) => /^icon/.test(t)))), this.glyphOffsetArray = new ne(), this.lineVertexArray = new re(), this.symbolInstances = new te(), this.textAnchorOffsets = new oe();
          }
          calculateGlyphDependencies(t, n, l, p, v) {
            for (let x = 0; x < t.length; x++) if (n[t.charCodeAt(x)] = !0, (l || p) && v) {
              const T = Za[t.charAt(x)];
              T && (n[T.charCodeAt(0)] = !0);
            }
          }
          populate(t, n, l) {
            const p = this.layers[0], v = p.layout, x = v.get("text-font"), T = v.get("text-field"), E = v.get("icon-image"), k = (T.value.kind !== "constant" || T.value.value instanceof ga && !T.value.value.isEmpty() || T.value.value.toString().length > 0) && (x.value.kind !== "constant" || x.value.value.length > 0), D = E.value.kind !== "constant" || !!E.value.value || Object.keys(E.parameters).length > 0, N = v.get("symbol-sort-key");
            if (this.features = [], !k && !D) return;
            const q = n.iconDependencies, G = n.glyphDependencies, Z = n.availableImages, X = new Li(this.zoom, { globalState: this.globalState });
            for (const { feature: ee, id: se, index: xe, sourceLayerIndex: de } of t) {
              const ge = p._featureFilter.needGeometry, Ie = Fr(ee, ge);
              if (!p._featureFilter.filter(X, Ie, l)) continue;
              let Fe, Je;
              if (ge || (Ie.geometry = Ds(ee)), k) {
                const ut = p.getValueAndResolveTokens("text-field", Ie, l, Z), yt = ga.factory(ut), kt = this.hasRTLText = this.hasRTLText || Ay(yt);
                (!kt || Br.getRTLTextPluginStatus() === "unavailable" || kt && Br.isParsed()) && (Fe = Bf(yt, p, Ie));
              }
              if (D) {
                const ut = p.getValueAndResolveTokens("icon-image", Ie, l, Z);
                Je = ut instanceof Ln ? ut : Ln.fromString(ut);
              }
              if (!Fe && !Je) continue;
              const gt = this.sortFeaturesByKey ? N.evaluate(Ie, {}, l) : void 0;
              if (this.features.push({ id: se, text: Fe, icon: Je, index: xe, sourceLayerIndex: de, geometry: Ie.geometry, properties: ee.properties, type: xa.types[ee.type], sortKey: gt }), Je && (q[Je.name] = !0), Fe) {
                const ut = x.evaluate(Ie, {}, l).join(","), yt = v.get("text-rotation-alignment") !== "viewport" && v.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(S.ao.vertical) >= 0;
                for (const kt of Fe.sections) if (kt.image) q[kt.image.name] = !0;
                else {
                  const mt = nc(Fe.toString()), pt = kt.fontStack || ut, Xe = G[pt] = G[pt] || {};
                  this.calculateGlyphDependencies(kt.text, Xe, yt, this.allowVerticalPlacement, mt);
                }
              }
            }
            v.get("symbol-placement") === "line" && (this.features = (function(ee) {
              const se = {}, xe = {}, de = [];
              let ge = 0;
              function Ie(ut) {
                de.push(ee[ut]), ge++;
              }
              function Fe(ut, yt, kt) {
                const mt = xe[ut];
                return delete xe[ut], xe[yt] = mt, de[mt].geometry[0].pop(), de[mt].geometry[0] = de[mt].geometry[0].concat(kt[0]), mt;
              }
              function Je(ut, yt, kt) {
                const mt = se[yt];
                return delete se[yt], se[ut] = mt, de[mt].geometry[0].shift(), de[mt].geometry[0] = kt[0].concat(de[mt].geometry[0]), mt;
              }
              function gt(ut, yt, kt) {
                const mt = kt ? yt[0][yt[0].length - 1] : yt[0][0];
                return `${ut}:${mt.x}:${mt.y}`;
              }
              for (let ut = 0; ut < ee.length; ut++) {
                const yt = ee[ut], kt = yt.geometry, mt = yt.text ? yt.text.toString() : null;
                if (!mt) {
                  Ie(ut);
                  continue;
                }
                const pt = gt(mt, kt), Xe = gt(mt, kt, !0);
                if (pt in xe && Xe in se && xe[pt] !== se[Xe]) {
                  const Bt = Je(pt, Xe, kt), $t = Fe(pt, Xe, de[Bt].geometry);
                  delete se[pt], delete xe[Xe], xe[gt(mt, de[$t].geometry, !0)] = $t, de[Bt].geometry = null;
                } else pt in xe ? Fe(pt, Xe, kt) : Xe in se ? Je(pt, Xe, kt) : (Ie(ut), se[pt] = ge - 1, xe[Xe] = ge - 1);
              }
              return de.filter(((ut) => ut.geometry));
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((ee, se) => ee.sortKey - se.sortKey));
          }
          update(t, n, l) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, n, this.layers, l), this.icon.programConfigurations.updatePaintArrays(t, n, this.layers, l));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t, n) {
            const l = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let p = t.dist(n[t.segment + 1]), v = t.dist(n[t.segment]);
              const x = {};
              for (let T = t.segment + 1; T < n.length; T++) x[T] = { x: n[T].x, y: n[T].y, tileUnitDistanceFromAnchor: p }, T < n.length - 1 && (p += n[T + 1].dist(n[T]));
              for (let T = t.segment || 0; T >= 0; T--) x[T] = { x: n[T].x, y: n[T].y, tileUnitDistanceFromAnchor: v }, T > 0 && (v += n[T - 1].dist(n[T]));
              for (let T = 0; T < n.length; T++) {
                const E = x[T];
                this.lineVertexArray.emplaceBack(E.x, E.y, E.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: l, lineLength: this.lineVertexArray.length - l };
          }
          addSymbols(t, n, l, p, v, x, T, E, k, D, N, q) {
            const G = t.indexArray, Z = t.layoutVertexArray, X = t.segments.prepareSegment(4 * n.length, Z, G, this.canOverlap ? x.sortKey : void 0), ee = this.glyphOffsetArray.length, se = X.vertexLength, xe = this.allowVerticalPlacement && T === S.ao.vertical ? Math.PI / 2 : 0, de = x.text && x.text.sections;
            for (let ge = 0; ge < n.length; ge++) {
              const { tl: Ie, tr: Fe, bl: Je, br: gt, tex: ut, pixelOffsetTL: yt, pixelOffsetBR: kt, minFontScaleX: mt, minFontScaleY: pt, glyphOffset: Xe, isSDF: Bt, sectionIndex: $t } = n[ge], Rt = X.vertexLength, Ct = Xe[1];
              Gi(Z, E.x, E.y, Ie.x, Ct + Ie.y, ut.x, ut.y, l, Bt, yt.x, yt.y, mt, pt), Gi(Z, E.x, E.y, Fe.x, Ct + Fe.y, ut.x + ut.w, ut.y, l, Bt, kt.x, yt.y, mt, pt), Gi(Z, E.x, E.y, Je.x, Ct + Je.y, ut.x, ut.y + ut.h, l, Bt, yt.x, kt.y, mt, pt), Gi(Z, E.x, E.y, gt.x, Ct + gt.y, ut.x + ut.w, ut.y + ut.h, l, Bt, kt.x, kt.y, mt, pt), fd(t.dynamicLayoutVertexArray, E, xe), G.emplaceBack(Rt, Rt + 2, Rt + 1), G.emplaceBack(Rt + 1, Rt + 2, Rt + 3), X.vertexLength += 4, X.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Xe[0]), ge !== n.length - 1 && $t === n[ge + 1].sectionIndex || t.programConfigurations.populatePaintArrays(Z.length, x, x.index, {}, q, de && de[$t]);
            }
            t.placedSymbolArray.emplaceBack(E.x, E.y, ee, this.glyphOffsetArray.length - ee, se, k, D, E.segment, l ? l[0] : 0, l ? l[1] : 0, p[0], p[1], T, 0, !1, 0, N);
          }
          _addCollisionDebugVertex(t, n, l, p, v, x) {
            return n.emplaceBack(0, 0), t.emplaceBack(l.x, l.y, p, v, Math.round(x.x), Math.round(x.y));
          }
          addCollisionDebugVertices(t, n, l, p, v, x, T) {
            const E = v.segments.prepareSegment(4, v.layoutVertexArray, v.indexArray), k = E.vertexLength, D = v.layoutVertexArray, N = v.collisionVertexArray, q = T.anchorX, G = T.anchorY;
            this._addCollisionDebugVertex(D, N, x, q, G, new O(t, n)), this._addCollisionDebugVertex(D, N, x, q, G, new O(l, n)), this._addCollisionDebugVertex(D, N, x, q, G, new O(l, p)), this._addCollisionDebugVertex(D, N, x, q, G, new O(t, p)), E.vertexLength += 4;
            const Z = v.indexArray;
            Z.emplaceBack(k, k + 1), Z.emplaceBack(k + 1, k + 2), Z.emplaceBack(k + 2, k + 3), Z.emplaceBack(k + 3, k), E.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t, n, l, p) {
            for (let v = t; v < n; v++) {
              const x = this.collisionBoxArray.get(v);
              this.addCollisionDebugVertices(x.x1, x.y1, x.x2, x.y2, p ? this.textCollisionBox : this.iconCollisionBox, x.anchorPoint, l);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Kf(ai, Cl.members, Ni), this.iconCollisionBox = new Kf(ai, Cl.members, Ni);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const n = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, !1), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, !1);
            }
          }
          _deserializeCollisionBoxesForSymbol(t, n, l, p, v, x, T, E, k) {
            const D = {};
            for (let N = n; N < l; N++) {
              const q = t.get(N);
              D.textBox = { x1: q.x1, y1: q.y1, x2: q.x2, y2: q.y2, anchorPointX: q.anchorPointX, anchorPointY: q.anchorPointY }, D.textFeatureIndex = q.featureIndex;
              break;
            }
            for (let N = p; N < v; N++) {
              const q = t.get(N);
              D.verticalTextBox = { x1: q.x1, y1: q.y1, x2: q.x2, y2: q.y2, anchorPointX: q.anchorPointX, anchorPointY: q.anchorPointY }, D.verticalTextFeatureIndex = q.featureIndex;
              break;
            }
            for (let N = x; N < T; N++) {
              const q = t.get(N);
              D.iconBox = { x1: q.x1, y1: q.y1, x2: q.x2, y2: q.y2, anchorPointX: q.anchorPointX, anchorPointY: q.anchorPointY }, D.iconFeatureIndex = q.featureIndex;
              break;
            }
            for (let N = E; N < k; N++) {
              const q = t.get(N);
              D.verticalIconBox = { x1: q.x1, y1: q.y1, x2: q.x2, y2: q.y2, anchorPointX: q.anchorPointX, anchorPointY: q.anchorPointY }, D.verticalIconFeatureIndex = q.featureIndex;
              break;
            }
            return D;
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let n = 0; n < this.symbolInstances.length; n++) {
              const l = this.symbolInstances.get(n);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, l.textBoxStartIndex, l.textBoxEndIndex, l.verticalTextBoxStartIndex, l.verticalTextBoxEndIndex, l.iconBoxStartIndex, l.iconBoxEndIndex, l.verticalIconBoxStartIndex, l.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t, n) {
            const l = t.placedSymbolArray.get(n), p = l.vertexStartIndex + 4 * l.numGlyphs;
            for (let v = l.vertexStartIndex; v < p; v += 4) t.indexArray.emplaceBack(v, v + 2, v + 1), t.indexArray.emplaceBack(v + 1, v + 2, v + 3);
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const n = Math.sin(t), l = Math.cos(t), p = [], v = [], x = [];
            for (let T = 0; T < this.symbolInstances.length; ++T) {
              x.push(T);
              const E = this.symbolInstances.get(T);
              p.push(0 | Math.round(n * E.anchorX + l * E.anchorY)), v.push(E.featureIndex);
            }
            return x.sort(((T, E) => p[T] - p[E] || v[E] - v[T])), x;
          }
          addToSortKeyRanges(t, n) {
            const l = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            l && l.sortKey === n ? l.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const n of this.symbolInstanceIndexes) {
                const l = this.symbolInstances.get(n);
                this.featureSortOrder.push(l.featureIndex), [l.rightJustifiedTextSymbolIndex, l.centerJustifiedTextSymbolIndex, l.leftJustifiedTextSymbolIndex].forEach(((p, v, x) => {
                  p >= 0 && x.indexOf(p) === v && this.addIndicesForPlacedSymbol(this.text, p);
                })), l.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, l.verticalPlacedTextSymbolIndex), l.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, l.placedIconSymbolIndex), l.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, l.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let lg, md;
        xt("SymbolBucket", hh, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), hh.MAX_GLYPHS = 65535, hh.addDynamicAttributes = fd;
        var _u = { get paint() {
          return md = md || new za({ "icon-opacity": new Ot(Ae.paint_symbol["icon-opacity"]), "icon-color": new Ot(Ae.paint_symbol["icon-color"]), "icon-halo-color": new Ot(Ae.paint_symbol["icon-halo-color"]), "icon-halo-width": new Ot(Ae.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Ot(Ae.paint_symbol["icon-halo-blur"]), "icon-translate": new Tt(Ae.paint_symbol["icon-translate"]), "icon-translate-anchor": new Tt(Ae.paint_symbol["icon-translate-anchor"]), "text-opacity": new Ot(Ae.paint_symbol["text-opacity"]), "text-color": new Ot(Ae.paint_symbol["text-color"], { runtimeType: Kn, getOverride: (a) => a.textColor, hasOverride: (a) => !!a.textColor }), "text-halo-color": new Ot(Ae.paint_symbol["text-halo-color"]), "text-halo-width": new Ot(Ae.paint_symbol["text-halo-width"]), "text-halo-blur": new Ot(Ae.paint_symbol["text-halo-blur"]), "text-translate": new Tt(Ae.paint_symbol["text-translate"]), "text-translate-anchor": new Tt(Ae.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return lg = lg || new za({ "symbol-placement": new Tt(Ae.layout_symbol["symbol-placement"]), "symbol-spacing": new Tt(Ae.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Tt(Ae.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Ot(Ae.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Tt(Ae.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Tt(Ae.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Tt(Ae.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Tt(Ae.layout_symbol["icon-ignore-placement"]), "icon-optional": new Tt(Ae.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Tt(Ae.layout_symbol["icon-rotation-alignment"]), "icon-size": new Ot(Ae.layout_symbol["icon-size"]), "icon-text-fit": new Tt(Ae.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Tt(Ae.layout_symbol["icon-text-fit-padding"]), "icon-image": new Ot(Ae.layout_symbol["icon-image"]), "icon-rotate": new Ot(Ae.layout_symbol["icon-rotate"]), "icon-padding": new Ot(Ae.layout_symbol["icon-padding"]), "icon-keep-upright": new Tt(Ae.layout_symbol["icon-keep-upright"]), "icon-offset": new Ot(Ae.layout_symbol["icon-offset"]), "icon-anchor": new Ot(Ae.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Tt(Ae.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Tt(Ae.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Tt(Ae.layout_symbol["text-rotation-alignment"]), "text-field": new Ot(Ae.layout_symbol["text-field"]), "text-font": new Ot(Ae.layout_symbol["text-font"]), "text-size": new Ot(Ae.layout_symbol["text-size"]), "text-max-width": new Ot(Ae.layout_symbol["text-max-width"]), "text-line-height": new Tt(Ae.layout_symbol["text-line-height"]), "text-letter-spacing": new Ot(Ae.layout_symbol["text-letter-spacing"]), "text-justify": new Ot(Ae.layout_symbol["text-justify"]), "text-radial-offset": new Ot(Ae.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Tt(Ae.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Ot(Ae.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Ot(Ae.layout_symbol["text-anchor"]), "text-max-angle": new Tt(Ae.layout_symbol["text-max-angle"]), "text-writing-mode": new Tt(Ae.layout_symbol["text-writing-mode"]), "text-rotate": new Ot(Ae.layout_symbol["text-rotate"]), "text-padding": new Tt(Ae.layout_symbol["text-padding"]), "text-keep-upright": new Tt(Ae.layout_symbol["text-keep-upright"]), "text-transform": new Ot(Ae.layout_symbol["text-transform"]), "text-offset": new Ot(Ae.layout_symbol["text-offset"]), "text-allow-overlap": new Tt(Ae.layout_symbol["text-allow-overlap"]), "text-overlap": new Tt(Ae.layout_symbol["text-overlap"]), "text-ignore-placement": new Tt(Ae.layout_symbol["text-ignore-placement"]), "text-optional": new Tt(Ae.layout_symbol["text-optional"]) });
        } };
        class Tp {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : fr, this.defaultValue = t;
          }
          evaluate(t) {
            if (t.formattedSection) {
              const n = this.defaultValue.property.overrides;
              if (n && n.hasOverride(t.formattedSection)) return n.getOverride(t.formattedSection);
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        xt("FormatSectionOverride", Tp, { omit: ["defaultValue"] });
        class Tc extends rr {
          constructor(t) {
            super(t, _u);
          }
          recalculate(t, n) {
            if (super.recalculate(t, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const l = this.layout.get("text-writing-mode");
              if (l) {
                const p = [];
                for (const v of l) p.indexOf(v) < 0 && p.push(v);
                this.layout._values["text-writing-mode"] = p;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t, n, l, p) {
            const v = this.layout.get(t).evaluate(n, {}, l, p), x = this._unevaluatedLayout._values[t];
            return x.isDataDriven() || Ju(x.value) || !v ? v : (function(T, E) {
              return E.replace(/{([^{}]+)}/g, ((k, D) => T && D in T ? String(T[D]) : ""));
            })(n.properties, v);
          }
          createBucket(t) {
            return new hh(t);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t of _u.paint.overridableProperties) {
              if (!Tc.hasPaintOverride(this.layout, t)) continue;
              const n = this.paint.get(t), l = new Tp(n), p = new Wu(l, n.property.specification);
              let v = null;
              v = n.value.kind === "constant" || n.value.kind === "source" ? new tu("source", p) : new tr("composite", p, n.value.zoomStops), this.paint._values[t] = new Nr(n.property, v, n.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t, n, l) {
            return !(!this.layout || n.isDataDriven() || l.isDataDriven()) && Tc.hasPaintOverride(this.layout, t);
          }
          static hasPaintOverride(t, n) {
            const l = t.get("text-field"), p = _u.paint.properties[n];
            let v = !1;
            const x = (T) => {
              for (const E of T) if (p.overrides && p.overrides.hasOverride(E)) return void (v = !0);
            };
            if (l.value.kind === "constant" && l.value.value instanceof ga) x(l.value.value.sections);
            else if (l.value.kind === "source") {
              const T = (k) => {
                v || (k instanceof cs && Ut(k.value) === ss ? x(k.value.sections) : k instanceof ul ? x(k.sections) : k.eachChild(T));
              }, E = l.value;
              E._styleExpression && T(E._styleExpression.expression);
            }
            return v;
          }
        }
        let Mp;
        var vu = { get paint() {
          return Mp = Mp || new za({ "background-color": new Tt(Ae.paint_background["background-color"]), "background-pattern": new xr(Ae.paint_background["background-pattern"]), "background-opacity": new Tt(Ae.paint_background["background-opacity"]) });
        } };
        class Zo extends rr {
          constructor(t) {
            super(t, vu);
          }
        }
        let dh;
        var Ey = { get paint() {
          return dh = dh || new za({ "raster-opacity": new Tt(Ae.paint_raster["raster-opacity"]), "raster-hue-rotate": new Tt(Ae.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Tt(Ae.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Tt(Ae.paint_raster["raster-brightness-max"]), "raster-saturation": new Tt(Ae.paint_raster["raster-saturation"]), "raster-contrast": new Tt(Ae.paint_raster["raster-contrast"]), "raster-resampling": new Tt(Ae.paint_raster["raster-resampling"]), "raster-fade-duration": new Tt(Ae.paint_raster["raster-fade-duration"]) });
        } };
        class ug extends rr {
          constructor(t) {
            super(t, Ey);
          }
        }
        class cg extends rr {
          constructor(t) {
            super(t, {}), this.onAdd = (n) => {
              this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl);
            }, this.onRemove = (n) => {
              this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl);
            }, this.implementation = t;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return !1;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class hg {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle();
            }), 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const dg = { once: !0 }, Wf = 63710088e-1;
        class $o {
          constructor(t, n) {
            if (isNaN(t) || isNaN(n)) throw new Error(`Invalid LngLat object: (${t}, ${n})`);
            if (this.lng = +t, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new $o(si(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t) {
            const n = Math.PI / 180, l = this.lat * n, p = t.lat * n, v = Math.sin(l) * Math.sin(p) + Math.cos(l) * Math.cos(p) * Math.cos((t.lng - this.lng) * n);
            return Wf * Math.acos(Math.min(v, 1));
          }
          static convert(t) {
            if (t instanceof $o) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new $o(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new $o(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const Jf = 2 * Math.PI * Wf;
        function Qf(a) {
          return Jf * Math.cos(a * Math.PI / 180);
        }
        function pg(a) {
          return (180 + a) / 360;
        }
        function Ap(a) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a * Math.PI / 360))) / 360;
        }
        function Ep(a, t) {
          return a / Qf(t);
        }
        function em(a) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90;
        }
        function fg(a, t) {
          return a * Qf(em(t));
        }
        class kl {
          constructor(t, n, l = 0) {
            this.x = +t, this.y = +n, this.z = +l;
          }
          static fromLngLat(t, n = 0) {
            const l = $o.convert(t);
            return new kl(pg(l.lng), Ap(l.lat), Ep(n, l.lat));
          }
          toLngLat() {
            return new $o(360 * this.x - 180, em(this.y));
          }
          toAltitude() {
            return fg(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Jf * (t = em(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t;
          }
        }
        function mg(a, t, n) {
          var l = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
          return [a * l - 2 * Math.PI * 6378137 / 2, t * l - 2 * Math.PI * 6378137 / 2];
        }
        class Cp {
          constructor(t, n, l) {
            if (!(function(p, v, x) {
              return !(p < 0 || p > 25 || x < 0 || x >= Math.pow(2, p) || v < 0 || v >= Math.pow(2, p));
            })(t, n, l)) throw new Error(`x=${n}, y=${l}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
            this.z = t, this.x = n, this.y = l, this.key = Rl(0, t, t, n, l);
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y;
          }
          url(t, n, l) {
            const p = (x = this.y, T = this.z, E = mg(256 * (v = this.x), 256 * (x = Math.pow(2, T) - x - 1), T), k = mg(256 * (v + 1), 256 * (x + 1), T), E[0] + "," + E[1] + "," + k[0] + "," + k[1]);
            var v, x, T, E, k;
            const D = (function(N, q, G) {
              let Z, X = "";
              for (let ee = N; ee > 0; ee--) Z = 1 << ee - 1, X += (q & Z ? 1 : 0) + (G & Z ? 2 : 0);
              return X;
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(l === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, D).replace(/{bbox-epsg-3857}/g, p);
          }
          isChildOf(t) {
            const n = this.z - t.z;
            return n > 0 && t.x === this.x >> n && t.y === this.y >> n;
          }
          getTilePoint(t) {
            const n = Math.pow(2, this.z);
            return new O((t.x * n - this.x) * at, (t.y * n - this.y) * at);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class Ai {
          constructor(t, n) {
            this.wrap = t, this.canonical = n, this.key = Rl(t, n.z, n.z, n.x, n.y);
          }
        }
        class Cr {
          constructor(t, n, l, p, v) {
            if (this.terrainRttPosMatrix32f = null, t < l) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${l}`);
            this.overscaledZ = t, this.wrap = n, this.canonical = new Cp(l, +p, +v), this.key = Rl(n, t, l, p, v);
          }
          clone() {
            return new Cr(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const n = this.canonical.z - t;
            return t > this.canonical.z ? new Cr(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Cr(t, this.wrap, t, this.canonical.x >> n, this.canonical.y >> n);
          }
          calculateScaledKey(t, n) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const l = this.canonical.z - t;
            return t > this.canonical.z ? Rl(this.wrap * +n, t, this.canonical.z, this.canonical.x, this.canonical.y) : Rl(this.wrap * +n, t, t, this.canonical.x >> l, this.canonical.y >> l);
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap) return !1;
            const n = this.canonical.z - t.canonical.z;
            return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> n && t.canonical.y === this.canonical.y >> n;
          }
          children(t) {
            if (this.overscaledZ >= t) return [new Cr(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const n = this.canonical.z + 1, l = 2 * this.canonical.x, p = 2 * this.canonical.y;
            return [new Cr(n, this.wrap, n, l, p), new Cr(n, this.wrap, n, l + 1, p), new Cr(n, this.wrap, n, l, p + 1), new Cr(n, this.wrap, n, l + 1, p + 1)];
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
          }
          wrapped() {
            return new Cr(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t) {
            return new Cr(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new Ai(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new kl(t.x - this.wrap, t.y));
          }
        }
        function Rl(a, t, n, l, p) {
          (a *= 2) < 0 && (a = -1 * a - 1);
          const v = 1 << n;
          return (v * v * a + v * p + l).toString(36) + n.toString(36) + t.toString(36);
        }
        function Mc(a, t) {
          return t ? a.properties[t] : a.id;
        }
        xt("CanonicalTileID", Cp), xt("OverscaledTileID", Cr, { omit: ["terrainRttPosMatrix32f"] });
        class xu {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this;
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(t) {
            return this.expandBy(-t);
          }
          map(t) {
            const n = new xu();
            return n.extend(t(new O(this.minX, this.minY))), n.extend(t(new O(this.maxX, this.minY))), n.extend(t(new O(this.minX, this.maxY))), n.extend(t(new O(this.maxX, this.maxY))), n;
          }
          static fromPoints(t) {
            const n = new xu();
            for (const l of t) n.extend(l);
            return n;
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY;
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY;
          }
        }
        class zp {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let n = 0; n < t.length; n++) {
              const l = t[n];
              this._stringToNumber[l] = n, this._numberToString[n] = l;
            }
          }
          encode(t) {
            return this._stringToNumber[t];
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t];
          }
        }
        class ph {
          constructor(t, n, l, p, v) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = n, t._x = l, t._y = p, this.properties = t.properties, this.id = v;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t) {
            this._geometry = t;
          }
          toJSON() {
            const t = { geometry: this.geometry };
            for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (t[n] = this[n]);
            return t;
          }
        }
        class gd {
          constructor(t, n) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new ru(at, 16, 0), this.grid3D = new ru(at, 16, 0), this.featureIndexArray = new ye(), this.promoteId = n;
          }
          insert(t, n, l, p, v, x) {
            const T = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(l, p, v);
            const E = x ? this.grid3D : this.grid;
            for (let k = 0; k < n.length; k++) {
              const D = n[k], N = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let q = 0; q < D.length; q++) {
                const G = D[q];
                N[0] = Math.min(N[0], G.x), N[1] = Math.min(N[1], G.y), N[2] = Math.max(N[2], G.x), N[3] = Math.max(N[3], G.y);
              }
              N[0] < at && N[1] < at && N[2] >= 0 && N[3] >= 0 && E.insert(T, N[0], N[1], N[2], N[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new qo(new sh(this.rawTileData)).layers, this.sourceLayerCoder = new zp(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t, n, l, p) {
            this.loadVTLayers();
            const v = t.params, x = at / t.tileSize / t.scale, T = nr(v.filter), E = t.queryGeometry, k = t.queryPadding * x, D = xu.fromPoints(E), N = this.grid.query(D.minX - k, D.minY - k, D.maxX + k, D.maxY + k), q = xu.fromPoints(t.cameraQueryGeometry).expandBy(k), G = this.grid3D.query(q.minX, q.minY, q.maxX, q.maxY, ((ee, se, xe, de) => (function(ge, Ie, Fe, Je, gt) {
              for (const yt of ge) if (Ie <= yt.x && Fe <= yt.y && Je >= yt.x && gt >= yt.y) return !0;
              const ut = [new O(Ie, Fe), new O(Ie, gt), new O(Je, gt), new O(Je, Fe)];
              if (ge.length > 2) {
                for (const yt of ut) if (hc(ge, yt)) return !0;
              }
              for (let yt = 0; yt < ge.length - 1; yt++) if (jm(ge[yt], ge[yt + 1], ut)) return !0;
              return !1;
            })(t.cameraQueryGeometry, ee - k, se - k, xe + k, de + k)));
            for (const ee of G) N.push(ee);
            N.sort(yg);
            const Z = {};
            let X;
            for (let ee = 0; ee < N.length; ee++) {
              const se = N[ee];
              if (se === X) continue;
              X = se;
              const xe = this.featureIndexArray.get(se);
              let de = null;
              this.loadMatchingFeature(Z, xe.bucketIndex, xe.sourceLayerIndex, xe.featureIndex, T, v.layers, v.availableImages, n, l, p, ((ge, Ie, Fe) => (de || (de = Ds(ge)), Ie.queryIntersectsFeature({ queryGeometry: E, feature: ge, featureState: Fe, geometry: de, zoom: this.z, transform: t.transform, pixelsToTileUnits: x, pixelPosMatrix: t.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t.getElevation }))));
            }
            return Z;
          }
          loadMatchingFeature(t, n, l, p, v, x, T, E, k, D, N) {
            const q = this.bucketLayerIDs[n];
            if (x && !q.some(((ee) => x.has(ee)))) return;
            const G = this.sourceLayerCoder.decode(l), Z = this.vtLayers[G].feature(p);
            if (v.needGeometry) {
              const ee = Fr(Z, !0);
              if (!v.filter(new Li(this.tileID.overscaledZ), ee, this.tileID.canonical)) return;
            } else if (!v.filter(new Li(this.tileID.overscaledZ), Z)) return;
            const X = this.getId(Z, G);
            for (let ee = 0; ee < q.length; ee++) {
              const se = q[ee];
              if (x && !x.has(se)) continue;
              const xe = E[se];
              if (!xe) continue;
              let de = {};
              X && D && (de = D.getState(xe.sourceLayer || "_geojsonTileLayer", X));
              const ge = Ii({}, k[se]);
              ge.paint = gg(ge.paint, xe.paint, Z, de, T), ge.layout = gg(ge.layout, xe.layout, Z, de, T);
              const Ie = !N || N(Z, xe, de);
              if (!Ie) continue;
              const Fe = new ph(Z, this.z, this.x, this.y, X);
              Fe.layer = ge;
              let Je = t[se];
              Je === void 0 && (Je = t[se] = []), Je.push({ featureIndex: p, feature: Fe, intersectionZ: Ie });
            }
          }
          lookupSymbolFeatures(t, n, l, p, v, x, T, E) {
            const k = {};
            this.loadVTLayers();
            const D = nr(v);
            for (const N of t) this.loadMatchingFeature(k, l, p, N, D, x, T, E, n);
            return k;
          }
          hasLayer(t) {
            for (const n of this.bucketLayerIDs) for (const l of n) if (t === l) return !0;
            return !1;
          }
          getId(t, n) {
            var l;
            let p = t.id;
            return this.promoteId && (p = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof p == "boolean" && (p = Number(p)), p === void 0 && (!((l = t.properties) === null || l === void 0) && l.cluster) && this.promoteId && (p = Number(t.properties.cluster_id))), p;
          }
        }
        function gg(a, t, n, l, p) {
          return Ta(a, ((v, x) => {
            const T = t instanceof Oo ? t.get(x) : null;
            return T && T.evaluate ? T.evaluate(n, l, p) : T;
          }));
        }
        function yg(a, t) {
          return t - a;
        }
        function _g(a, t, n, l, p) {
          const v = [];
          for (let x = 0; x < a.length; x++) {
            const T = a[x];
            let E;
            for (let k = 0; k < T.length - 1; k++) {
              let D = T[k], N = T[k + 1];
              D.x < t && N.x < t || (D.x < t ? D = new O(t, D.y + (t - D.x) / (N.x - D.x) * (N.y - D.y))._round() : N.x < t && (N = new O(t, D.y + (t - D.x) / (N.x - D.x) * (N.y - D.y))._round()), D.y < n && N.y < n || (D.y < n ? D = new O(D.x + (n - D.y) / (N.y - D.y) * (N.x - D.x), n)._round() : N.y < n && (N = new O(D.x + (n - D.y) / (N.y - D.y) * (N.x - D.x), n)._round()), D.x >= l && N.x >= l || (D.x >= l ? D = new O(l, D.y + (l - D.x) / (N.x - D.x) * (N.y - D.y))._round() : N.x >= l && (N = new O(l, D.y + (l - D.x) / (N.x - D.x) * (N.y - D.y))._round()), D.y >= p && N.y >= p || (D.y >= p ? D = new O(D.x + (p - D.y) / (N.y - D.y) * (N.x - D.x), p)._round() : N.y >= p && (N = new O(D.x + (p - D.y) / (N.y - D.y) * (N.x - D.x), p)._round()), E && D.equals(E[E.length - 1]) || (E = [D], v.push(E)), E.push(N)))));
            }
          }
          return v;
        }
        xt("FeatureIndex", gd, { omit: ["rawTileData", "sourceLayerCoder"] });
        class bu extends O {
          constructor(t, n, l, p) {
            super(t, n), this.angle = l, p !== void 0 && (this.segment = p);
          }
          clone() {
            return new bu(this.x, this.y, this.angle, this.segment);
          }
        }
        function tm(a, t, n, l, p) {
          if (t.segment === void 0 || n === 0) return !0;
          let v = t, x = t.segment + 1, T = 0;
          for (; T > -n / 2; ) {
            if (x--, x < 0) return !1;
            T -= a[x].dist(v), v = a[x];
          }
          T += a[x].dist(a[x + 1]), x++;
          const E = [];
          let k = 0;
          for (; T < n / 2; ) {
            const D = a[x], N = a[x + 1];
            if (!N) return !1;
            let q = a[x - 1].angleTo(D) - D.angleTo(N);
            for (q = Math.abs((q + 3 * Math.PI) % (2 * Math.PI) - Math.PI), E.push({ distance: T, angleDelta: q }), k += q; T - E[0].distance > l; ) k -= E.shift().angleDelta;
            if (k > p) return !1;
            x++, T += D.dist(N);
          }
          return !0;
        }
        function im(a) {
          let t = 0;
          for (let n = 0; n < a.length - 1; n++) t += a[n].dist(a[n + 1]);
          return t;
        }
        function tn(a, t, n) {
          return a ? 0.6 * t * n : 0;
        }
        function Pp(a, t) {
          return Math.max(a ? a.right - a.left : 0, t ? t.right - t.left : 0);
        }
        function $a(a, t, n, l, p, v) {
          const x = tn(n, p, v), T = Pp(n, l) * v;
          let E = 0;
          const k = im(a) / 2;
          for (let D = 0; D < a.length - 1; D++) {
            const N = a[D], q = a[D + 1], G = N.dist(q);
            if (E + G > k) {
              const Z = (k - E) / G, X = ps.number(N.x, q.x, Z), ee = ps.number(N.y, q.y, Z), se = new bu(X, ee, q.angleTo(N), D);
              return se._round(), !x || tm(a, se, T, x, t) ? se : void 0;
            }
            E += G;
          }
        }
        function Cy(a, t, n, l, p, v, x, T, E) {
          const k = tn(l, v, x), D = Pp(l, p), N = D * x, q = a[0].x === 0 || a[0].x === E || a[0].y === 0 || a[0].y === E;
          return t - N < t / 4 && (t = N + t / 4), nm(a, q ? t / 2 * T % t : (D / 2 + 2 * v) * x * T % t, t, k, n, N, q, !1, E);
        }
        function nm(a, t, n, l, p, v, x, T, E) {
          const k = v / 2, D = im(a);
          let N = 0, q = t - n, G = [];
          for (let Z = 0; Z < a.length - 1; Z++) {
            const X = a[Z], ee = a[Z + 1], se = X.dist(ee), xe = ee.angleTo(X);
            for (; q + n < N + se; ) {
              q += n;
              const de = (q - N) / se, ge = ps.number(X.x, ee.x, de), Ie = ps.number(X.y, ee.y, de);
              if (ge >= 0 && ge < E && Ie >= 0 && Ie < E && q - k >= 0 && q + k <= D) {
                const Fe = new bu(ge, Ie, xe, Z);
                Fe._round(), l && !tm(a, Fe, v, l, p) || G.push(Fe);
              }
            }
            N += se;
          }
          return T || G.length || x || (G = nm(a, N / 2, n, l, p, v, x, !0, E)), G;
        }
        function vg(a, t, n, l) {
          const p = [], v = a.image, x = v.pixelRatio, T = v.paddedRect.w - 2, E = v.paddedRect.h - 2;
          let k = { x1: a.left, y1: a.top, x2: a.right, y2: a.bottom };
          const D = v.stretchX || [[0, T]], N = v.stretchY || [[0, E]], q = (Xe, Bt) => Xe + Bt[1] - Bt[0], G = D.reduce(q, 0), Z = N.reduce(q, 0), X = T - G, ee = E - Z;
          let se = 0, xe = G, de = 0, ge = Z, Ie = 0, Fe = X, Je = 0, gt = ee;
          if (v.content && l) {
            const Xe = v.content, Bt = Xe[2] - Xe[0], $t = Xe[3] - Xe[1];
            (v.textFitWidth || v.textFitHeight) && (k = Xf(a)), se = fh(D, 0, Xe[0]), de = fh(N, 0, Xe[1]), xe = fh(D, Xe[0], Xe[2]), ge = fh(N, Xe[1], Xe[3]), Ie = Xe[0] - se, Je = Xe[1] - de, Fe = Bt - xe, gt = $t - ge;
          }
          const ut = k.x1, yt = k.y1, kt = k.x2 - ut, mt = k.y2 - yt, pt = (Xe, Bt, $t, Rt) => {
            const Ct = Ac(Xe.stretch - se, xe, kt, ut), li = yd(Xe.fixed - Ie, Fe, Xe.stretch, G), Mn = Ac(Bt.stretch - de, ge, mt, yt), Gn = yd(Bt.fixed - Je, gt, Bt.stretch, Z), wa = Ac($t.stretch - se, xe, kt, ut), Zr = yd($t.fixed - Ie, Fe, $t.stretch, G), cr = Ac(Rt.stretch - de, ge, mt, yt), na = yd(Rt.fixed - Je, gt, Rt.stretch, Z), hn = new O(Ct, Mn), aa = new O(wa, Mn), Zn = new O(wa, cr), Sa = new O(Ct, cr), hr = new O(li / x, Gn / x), zr = new O(Zr / x, na / x), $n = t * Math.PI / 180;
            if ($n) {
              const ra = Math.sin($n), Hn = Math.cos($n), nn = [Hn, -ra, ra, Hn];
              hn._matMult(nn), aa._matMult(nn), Sa._matMult(nn), Zn._matMult(nn);
            }
            const Da = Xe.stretch + Xe.fixed, Fn = Bt.stretch + Bt.fixed;
            return { tl: hn, tr: aa, bl: Sa, br: Zn, tex: { x: v.paddedRect.x + 1 + Da, y: v.paddedRect.y + 1 + Fn, w: $t.stretch + $t.fixed - Da, h: Rt.stretch + Rt.fixed - Fn }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: hr, pixelOffsetBR: zr, minFontScaleX: Fe / x / kt, minFontScaleY: gt / x / mt, isSDF: n };
          };
          if (l && (v.stretchX || v.stretchY)) {
            const Xe = Ip(D, X, G), Bt = Ip(N, ee, Z);
            for (let $t = 0; $t < Xe.length - 1; $t++) {
              const Rt = Xe[$t], Ct = Xe[$t + 1];
              for (let li = 0; li < Bt.length - 1; li++) p.push(pt(Rt, Bt[li], Ct, Bt[li + 1]));
            }
          } else p.push(pt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: T + 1 }, { fixed: 0, stretch: E + 1 }));
          return p;
        }
        function fh(a, t, n) {
          let l = 0;
          for (const p of a) l += Math.max(t, Math.min(n, p[1])) - Math.max(t, Math.min(n, p[0]));
          return l;
        }
        function Ip(a, t, n) {
          const l = [{ fixed: -1, stretch: 0 }];
          for (const [p, v] of a) {
            const x = l[l.length - 1];
            l.push({ fixed: p - x.stretch, stretch: x.stretch }), l.push({ fixed: p - x.stretch, stretch: x.stretch + (v - p) });
          }
          return l.push({ fixed: t + 1, stretch: n }), l;
        }
        function Ac(a, t, n, l) {
          return a / t * n + l;
        }
        function yd(a, t, n, l) {
          return a - t * n / l;
        }
        xt("Anchor", bu);
        class _d {
          constructor(t, n, l, p, v, x, T, E, k, D) {
            var N;
            if (this.boxStartIndex = t.length, k) {
              let q = x.top, G = x.bottom;
              const Z = x.collisionPadding;
              Z && (q -= Z[1], G += Z[3]);
              let X = G - q;
              X > 0 && (X = Math.max(10, X), this.circleDiameter = X);
            } else {
              const q = !((N = x.image) === null || N === void 0) && N.content && (x.image.textFitWidth || x.image.textFitHeight) ? Xf(x) : { x1: x.left, y1: x.top, x2: x.right, y2: x.bottom };
              q.y1 = q.y1 * T - E[0], q.y2 = q.y2 * T + E[2], q.x1 = q.x1 * T - E[3], q.x2 = q.x2 * T + E[1];
              const G = x.collisionPadding;
              if (G && (q.x1 -= G[0] * T, q.y1 -= G[1] * T, q.x2 += G[2] * T, q.y2 += G[3] * T), D) {
                const Z = new O(q.x1, q.y1), X = new O(q.x2, q.y1), ee = new O(q.x1, q.y2), se = new O(q.x2, q.y2), xe = D * Math.PI / 180;
                Z._rotate(xe), X._rotate(xe), ee._rotate(xe), se._rotate(xe), q.x1 = Math.min(Z.x, X.x, ee.x, se.x), q.x2 = Math.max(Z.x, X.x, ee.x, se.x), q.y1 = Math.min(Z.y, X.y, ee.y, se.y), q.y2 = Math.max(Z.y, X.y, ee.y, se.y);
              }
              t.emplaceBack(n.x, n.y, q.x1, q.y1, q.x2, q.y2, l, p, v);
            }
            this.boxEndIndex = t.length;
          }
        }
        class am {
          constructor(t = [], n = (l, p) => l < p ? -1 : l > p ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = n, this.length > 0) for (let l = (this.length >> 1) - 1; l >= 0; l--) this._down(l);
          }
          push(t) {
            this.data.push(t), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0], n = this.data.pop();
            return --this.length > 0 && (this.data[0] = n, this._down(0)), t;
          }
          peek() {
            return this.data[0];
          }
          _up(t) {
            const { data: n, compare: l } = this, p = n[t];
            for (; t > 0; ) {
              const v = t - 1 >> 1, x = n[v];
              if (l(p, x) >= 0) break;
              n[t] = x, t = v;
            }
            n[t] = p;
          }
          _down(t) {
            const { data: n, compare: l } = this, p = this.length >> 1, v = n[t];
            for (; t < p; ) {
              let x = 1 + (t << 1);
              const T = x + 1;
              if (T < this.length && l(n[T], n[x]) < 0 && (x = T), l(n[x], v) >= 0) break;
              n[t] = n[x], t = x;
            }
            n[t] = v;
          }
        }
        function rm(a, t = 1, n = !1) {
          const l = xu.fromPoints(a[0]), p = Math.min(l.width(), l.height());
          let v = p / 2;
          const x = new am([], zy), { minX: T, minY: E, maxX: k, maxY: D } = l;
          if (p === 0) return new O(T, E);
          for (let G = T; G < k; G += p) for (let Z = E; Z < D; Z += p) x.push(new Ec(G + v, Z + v, v, a));
          let N = (function(G) {
            let Z = 0, X = 0, ee = 0;
            const se = G[0];
            for (let xe = 0, de = se.length, ge = de - 1; xe < de; ge = xe++) {
              const Ie = se[xe], Fe = se[ge], Je = Ie.x * Fe.y - Fe.x * Ie.y;
              X += (Ie.x + Fe.x) * Je, ee += (Ie.y + Fe.y) * Je, Z += 3 * Je;
            }
            return new Ec(X / Z, ee / Z, 0, G);
          })(a), q = x.length;
          for (; x.length; ) {
            const G = x.pop();
            (G.d > N.d || !N.d) && (N = G, n && console.log("found best %d after %d probes", Math.round(1e4 * G.d) / 1e4, q)), G.max - N.d <= t || (v = G.h / 2, x.push(new Ec(G.p.x - v, G.p.y - v, v, a)), x.push(new Ec(G.p.x + v, G.p.y - v, v, a)), x.push(new Ec(G.p.x - v, G.p.y + v, v, a)), x.push(new Ec(G.p.x + v, G.p.y + v, v, a)), q += 4);
          }
          return n && (console.log(`num probes: ${q}`), console.log(`best distance: ${N.d}`)), N.p;
        }
        function zy(a, t) {
          return t.max - a.max;
        }
        function Ec(a, t, n, l) {
          this.p = new O(a, t), this.h = n, this.d = (function(p, v) {
            let x = !1, T = 1 / 0;
            for (let E = 0; E < v.length; E++) {
              const k = v[E];
              for (let D = 0, N = k.length, q = N - 1; D < N; q = D++) {
                const G = k[D], Z = k[q];
                G.y > p.y != Z.y > p.y && p.x < (Z.x - G.x) * (p.y - G.y) / (Z.y - G.y) + G.x && (x = !x), T = Math.min(T, du(p, G, Z));
              }
            }
            return (x ? 1 : -1) * Math.sqrt(T);
          })(this.p, l), this.max = this.d + this.h * Math.SQRT2;
        }
        var Ra;
        S.aE = void 0, (Ra = S.aE || (S.aE = {}))[Ra.center = 1] = "center", Ra[Ra.left = 2] = "left", Ra[Ra.right = 3] = "right", Ra[Ra.top = 4] = "top", Ra[Ra.bottom = 5] = "bottom", Ra[Ra["top-left"] = 6] = "top-left", Ra[Ra["top-right"] = 7] = "top-right", Ra[Ra["bottom-left"] = 8] = "bottom-left", Ra[Ra["bottom-right"] = 9] = "bottom-right";
        const kp = Number.POSITIVE_INFINITY;
        function xg(a, t) {
          return t[1] !== kp ? (function(n, l, p) {
            let v = 0, x = 0;
            switch (l = Math.abs(l), p = Math.abs(p), n) {
              case "top-right":
              case "top-left":
              case "top":
                x = p - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                x = 7 - p;
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
              case "right":
                v = -l;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                v = l;
            }
            return [v, x];
          })(a, t[0], t[1]) : (function(n, l) {
            let p = 0, v = 0;
            l < 0 && (l = 0);
            const x = l / Math.SQRT2;
            switch (n) {
              case "top-right":
              case "top-left":
                v = x - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                v = 7 - x;
                break;
              case "bottom":
                v = 7 - l;
                break;
              case "top":
                v = l - 7;
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
                p = -x;
                break;
              case "top-left":
              case "bottom-left":
                p = x;
                break;
              case "left":
                p = l;
                break;
              case "right":
                p = -l;
            }
            return [p, v];
          })(a, t[0]);
        }
        function bg(a, t, n) {
          var l;
          const p = a.layout, v = (l = p.get("text-variable-anchor-offset")) === null || l === void 0 ? void 0 : l.evaluate(t, {}, n);
          if (v) {
            const T = v.values, E = [];
            for (let k = 0; k < T.length; k += 2) {
              const D = E[k] = T[k], N = T[k + 1].map(((q) => q * Tn));
              D.startsWith("top") ? N[1] -= 7 : D.startsWith("bottom") && (N[1] += 7), E[k + 1] = N;
            }
            return new Wn(E);
          }
          const x = p.get("text-variable-anchor");
          if (x) {
            let T;
            T = a._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [p.get("text-radial-offset").evaluate(t, {}, n) * Tn, kp] : p.get("text-offset").evaluate(t, {}, n).map(((k) => k * Tn));
            const E = [];
            for (const k of x) E.push(k, xg(k, T));
            return new Wn(E);
          }
          return null;
        }
        function Ho(a) {
          switch (a) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function wg(a, t, n, l, p, v, x, T, E, k, D, N) {
          let q = v.textMaxSize.evaluate(t, {});
          q === void 0 && (q = x);
          const G = a.layers[0].layout, Z = G.get("icon-offset").evaluate(t, {}, D), X = Rp(n.horizontal), ee = x / 24, se = a.tilePixelRatio * ee, xe = a.tilePixelRatio * q / 24, de = a.tilePixelRatio * T, ge = a.tilePixelRatio * G.get("symbol-spacing"), Ie = G.get("text-padding") * a.tilePixelRatio, Fe = (function($t, Rt, Ct, li = 1) {
            const Mn = $t.get("icon-padding").evaluate(Rt, {}, Ct), Gn = Mn && Mn.values;
            return [Gn[0] * li, Gn[1] * li, Gn[2] * li, Gn[3] * li];
          })(G, t, D, a.tilePixelRatio), Je = G.get("text-max-angle") / 180 * Math.PI, gt = G.get("text-rotation-alignment") !== "viewport" && G.get("symbol-placement") !== "point", ut = G.get("icon-rotation-alignment") === "map" && G.get("symbol-placement") !== "point", yt = G.get("symbol-placement"), kt = ge / 2, mt = G.get("icon-text-fit");
          let pt;
          l && mt !== "none" && (a.allowVerticalPlacement && n.vertical && (pt = Yf(l, n.vertical, mt, G.get("icon-text-fit-padding"), Z, ee)), X && (l = Yf(l, X, mt, G.get("icon-text-fit-padding"), Z, ee)));
          const Xe = D ? N.line.getGranularityForZoomLevel(D.z) : 1, Bt = ($t, Rt) => {
            Rt.x < 0 || Rt.x >= at || Rt.y < 0 || Rt.y >= at || (function(Ct, li, Mn, Gn, wa, Zr, cr, na, hn, aa, Zn, Sa, hr, zr, $n, Da, Fn, ra, Hn, nn, Ri, La, Xo, Pr, wu) {
              const gh = Ct.addToLineVertexArray(li, Mn);
              let Su, Yo, yh, zc, wd = 0, om = 0, Tg = 0, Sd = 0, _h = -1, Up = -1;
              const $r = {};
              let lm = Tl("");
              if (Ct.allowVerticalPlacement && Gn.vertical) {
                const Ze = na.layout.get("text-rotate").evaluate(Ri, {}, Pr) + 90;
                yh = new _d(hn, li, aa, Zn, Sa, Gn.vertical, hr, zr, $n, Ze), cr && (zc = new _d(hn, li, aa, Zn, Sa, cr, Fn, ra, $n, Ze));
              }
              if (wa) {
                const Ze = na.layout.get("icon-rotate").evaluate(Ri, {}), Ke = na.layout.get("icon-text-fit") !== "none", Ne = vg(wa, Ze, Xo, Ke), Ve = cr ? vg(cr, Ze, Xo, Ke) : void 0;
                Yo = new _d(hn, li, aa, Zn, Sa, wa, Fn, ra, !1, Ze), wd = 4 * Ne.length;
                const zt = Ct.iconSizeData;
                let Nt = null;
                zt.kind === "source" ? (Nt = [Go * na.layout.get("icon-size").evaluate(Ri, {})], Nt[0] > Il && $i(`${Ct.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : zt.kind === "composite" && (Nt = [Go * La.compositeIconSizes[0].evaluate(Ri, {}, Pr), Go * La.compositeIconSizes[1].evaluate(Ri, {}, Pr)], (Nt[0] > Il || Nt[1] > Il) && $i(`${Ct.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Ct.addSymbols(Ct.icon, Ne, Nt, nn, Hn, Ri, S.ao.none, li, gh.lineStartIndex, gh.lineLength, -1, Pr), _h = Ct.icon.placedSymbolArray.length - 1, Ve && (om = 4 * Ve.length, Ct.addSymbols(Ct.icon, Ve, Nt, nn, Hn, Ri, S.ao.vertical, li, gh.lineStartIndex, gh.lineLength, -1, Pr), Up = Ct.icon.placedSymbolArray.length - 1);
              }
              const Fp = Object.keys(Gn.horizontal);
              for (const Ze of Fp) {
                const Ke = Gn.horizontal[Ze];
                if (!Su) {
                  lm = Tl(Ke.text);
                  const Ve = na.layout.get("text-rotate").evaluate(Ri, {}, Pr);
                  Su = new _d(hn, li, aa, Zn, Sa, Ke, hr, zr, $n, Ve);
                }
                const Ne = Ke.positionedLines.length === 1;
                if (Tg += sm(Ct, li, Ke, Zr, na, $n, Ri, Da, gh, Gn.vertical ? S.ao.horizontal : S.ao.horizontalOnly, Ne ? Fp : [Ze], $r, _h, La, Pr), Ne) break;
              }
              Gn.vertical && (Sd += sm(Ct, li, Gn.vertical, Zr, na, $n, Ri, Da, gh, S.ao.vertical, ["vertical"], $r, Up, La, Pr));
              const Vp = Su ? Su.boxStartIndex : Ct.collisionBoxArray.length, Mg = Su ? Su.boxEndIndex : Ct.collisionBoxArray.length, Iy = yh ? yh.boxStartIndex : Ct.collisionBoxArray.length, qp = yh ? yh.boxEndIndex : Ct.collisionBoxArray.length, i = Yo ? Yo.boxStartIndex : Ct.collisionBoxArray.length, s = Yo ? Yo.boxEndIndex : Ct.collisionBoxArray.length, h = zc ? zc.boxStartIndex : Ct.collisionBoxArray.length, g = zc ? zc.boxEndIndex : Ct.collisionBoxArray.length;
              let A = -1;
              const I = (Ze, Ke) => Ze && Ze.circleDiameter ? Math.max(Ze.circleDiameter, Ke) : Ke;
              A = I(Su, A), A = I(yh, A), A = I(Yo, A), A = I(zc, A);
              const F = A > -1 ? 1 : 0;
              F && (A *= wu / Tn), Ct.glyphOffsetArray.length >= hh.MAX_GLYPHS && $i("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Ri.sortKey !== void 0 && Ct.addToSortKeyRanges(Ct.symbolInstances.length, Ri.sortKey);
              const W = bg(na, Ri, Pr), [_e, Be] = (function(Ze, Ke) {
                const Ne = Ze.length, Ve = Ke?.values;
                if (Ve?.length > 0) for (let zt = 0; zt < Ve.length; zt += 2) {
                  const Nt = Ve[zt + 1];
                  Ze.emplaceBack(S.aE[Ve[zt]], Nt[0], Nt[1]);
                }
                return [Ne, Ze.length];
              })(Ct.textAnchorOffsets, W);
              Ct.symbolInstances.emplaceBack(li.x, li.y, $r.right >= 0 ? $r.right : -1, $r.center >= 0 ? $r.center : -1, $r.left >= 0 ? $r.left : -1, $r.vertical || -1, _h, Up, lm, Vp, Mg, Iy, qp, i, s, h, g, aa, Tg, Sd, wd, om, F, 0, hr, A, _e, Be);
            })(a, Rt, $t, n, l, p, pt, a.layers[0], a.collisionBoxArray, t.index, t.sourceLayerIndex, a.index, se, [Ie, Ie, Ie, Ie], gt, E, de, Fe, ut, Z, t, v, k, D, x);
          };
          if (yt === "line") for (const $t of _g(t.geometry, 0, 0, at, at)) {
            const Rt = En($t, Xe), Ct = Cy(Rt, ge, Je, n.vertical || X, l, 24, xe, a.overscaling, at);
            for (const li of Ct) X && Py(a, X.text, kt, li) || Bt(Rt, li);
          }
          else if (yt === "line-center") {
            for (const $t of t.geometry) if ($t.length > 1) {
              const Rt = En($t, Xe), Ct = $a(Rt, Je, n.vertical || X, l, 24, xe);
              Ct && Bt(Rt, Ct);
            }
          } else if (t.type === "Polygon") for (const $t of Wl(t.geometry, 0)) {
            const Rt = rm($t, 16);
            Bt(En($t[0], Xe, !0), new bu(Rt.x, Rt.y, 0));
          }
          else if (t.type === "LineString") for (const $t of t.geometry) {
            const Rt = En($t, Xe);
            Bt(Rt, new bu(Rt[0].x, Rt[0].y, 0));
          }
          else if (t.type === "Point") for (const $t of t.geometry) for (const Rt of $t) Bt([Rt], new bu(Rt.x, Rt.y, 0));
        }
        function sm(a, t, n, l, p, v, x, T, E, k, D, N, q, G, Z) {
          const X = (function(xe, de, ge, Ie, Fe, Je, gt, ut) {
            const yt = Ie.layout.get("text-rotate").evaluate(Je, {}) * Math.PI / 180, kt = [];
            for (const mt of de.positionedLines) for (const pt of mt.positionedGlyphs) {
              if (!pt.rect) continue;
              const Xe = pt.rect || {};
              let Bt = 4, $t = !0, Rt = 1, Ct = 0;
              const li = (Fe || ut) && pt.vertical, Mn = pt.metrics.advance * pt.scale / 2;
              if (ut && de.verticalizable && (Ct = mt.lineOffset / 2 - (pt.imageName ? -(Tn - pt.metrics.width * pt.scale) / 2 : (pt.scale - 1) * Tn)), pt.imageName) {
                const ra = gt[pt.imageName];
                $t = ra.sdf, Rt = ra.pixelRatio, Bt = 1 / Rt;
              }
              const Gn = Fe ? [pt.x + Mn, pt.y] : [0, 0];
              let wa = Fe ? [0, 0] : [pt.x + Mn + ge[0], pt.y + ge[1] - Ct], Zr = [0, 0];
              li && (Zr = wa, wa = [0, 0]);
              const cr = pt.metrics.isDoubleResolution ? 2 : 1, na = (pt.metrics.left - Bt) * pt.scale - Mn + wa[0], hn = (-pt.metrics.top - Bt) * pt.scale + wa[1], aa = na + Xe.w / cr * pt.scale / Rt, Zn = hn + Xe.h / cr * pt.scale / Rt, Sa = new O(na, hn), hr = new O(aa, hn), zr = new O(na, Zn), $n = new O(aa, Zn);
              if (li) {
                const ra = new O(-Mn, Mn - -17), Hn = -Math.PI / 2, nn = 12 - Mn, Ri = new O(22 - nn, -(pt.imageName ? nn : 0)), La = new O(...Zr);
                Sa._rotateAround(Hn, ra)._add(Ri)._add(La), hr._rotateAround(Hn, ra)._add(Ri)._add(La), zr._rotateAround(Hn, ra)._add(Ri)._add(La), $n._rotateAround(Hn, ra)._add(Ri)._add(La);
              }
              if (yt) {
                const ra = Math.sin(yt), Hn = Math.cos(yt), nn = [Hn, -ra, ra, Hn];
                Sa._matMult(nn), hr._matMult(nn), zr._matMult(nn), $n._matMult(nn);
              }
              const Da = new O(0, 0), Fn = new O(0, 0);
              kt.push({ tl: Sa, tr: hr, bl: zr, br: $n, tex: Xe, writingMode: de.writingMode, glyphOffset: Gn, sectionIndex: pt.sectionIndex, isSDF: $t, pixelOffsetTL: Da, pixelOffsetBR: Fn, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return kt;
          })(0, n, T, p, v, x, l, a.allowVerticalPlacement), ee = a.textSizeData;
          let se = null;
          ee.kind === "source" ? (se = [Go * p.layout.get("text-size").evaluate(x, {})], se[0] > Il && $i(`${a.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : ee.kind === "composite" && (se = [Go * G.compositeTextSizes[0].evaluate(x, {}, Z), Go * G.compositeTextSizes[1].evaluate(x, {}, Z)], (se[0] > Il || se[1] > Il) && $i(`${a.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), a.addSymbols(a.text, X, se, T, v, x, k, t, E.lineStartIndex, E.lineLength, q, Z);
          for (const xe of D) N[xe] = a.text.placedSymbolArray.length - 1;
          return 4 * X.length;
        }
        function Rp(a) {
          for (const t in a) return a[t];
          return null;
        }
        function Py(a, t, n, l) {
          const p = a.compareText;
          if (t in p) {
            const v = p[t];
            for (let x = v.length - 1; x >= 0; x--) if (l.dist(v[x]) < n) return !0;
          } else p[t] = [];
          return p[t].push(l), !1;
        }
        const Sg = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Dp {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [n, l] = new Uint8Array(t, 0, 2);
            if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const p = l >> 4;
            if (p !== 1) throw new Error(`Got v${p} data when expected v1.`);
            const v = Sg[15 & l];
            if (!v) throw new Error("Unrecognized array type.");
            const [x] = new Uint16Array(t, 2, 1), [T] = new Uint32Array(t, 4, 1);
            return new Dp(T, x, v, t);
          }
          constructor(t, n = 64, l = Float64Array, p) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = l, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const v = Sg.indexOf(this.ArrayType), x = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, T = t * this.IndexArrayType.BYTES_PER_ELEMENT, E = (8 - T % 8) % 8;
            if (v < 0) throw new Error(`Unexpected typed array class: ${l}.`);
            p && p instanceof ArrayBuffer ? (this.data = p, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + T + E, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + x + T + E), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + T + E, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + v]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
          }
          add(t, n) {
            const l = this._pos >> 1;
            return this.ids[l] = l, this.coords[this._pos++] = t, this.coords[this._pos++] = n, l;
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return vd(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
          }
          range(t, n, l, p) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: v, coords: x, nodeSize: T } = this, E = [0, v.length - 1, 0], k = [];
            for (; E.length; ) {
              const D = E.pop() || 0, N = E.pop() || 0, q = E.pop() || 0;
              if (N - q <= T) {
                for (let ee = q; ee <= N; ee++) {
                  const se = x[2 * ee], xe = x[2 * ee + 1];
                  se >= t && se <= l && xe >= n && xe <= p && k.push(v[ee]);
                }
                continue;
              }
              const G = q + N >> 1, Z = x[2 * G], X = x[2 * G + 1];
              Z >= t && Z <= l && X >= n && X <= p && k.push(v[G]), (D === 0 ? t <= Z : n <= X) && (E.push(q), E.push(G - 1), E.push(1 - D)), (D === 0 ? l >= Z : p >= X) && (E.push(G + 1), E.push(N), E.push(1 - D));
            }
            return k;
          }
          within(t, n, l) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: p, coords: v, nodeSize: x } = this, T = [0, p.length - 1, 0], E = [], k = l * l;
            for (; T.length; ) {
              const D = T.pop() || 0, N = T.pop() || 0, q = T.pop() || 0;
              if (N - q <= x) {
                for (let ee = q; ee <= N; ee++) Op(v[2 * ee], v[2 * ee + 1], t, n) <= k && E.push(p[ee]);
                continue;
              }
              const G = q + N >> 1, Z = v[2 * G], X = v[2 * G + 1];
              Op(Z, X, t, n) <= k && E.push(p[G]), (D === 0 ? t - l <= Z : n - l <= X) && (T.push(q), T.push(G - 1), T.push(1 - D)), (D === 0 ? t + l >= Z : n + l >= X) && (T.push(G + 1), T.push(N), T.push(1 - D));
            }
            return E;
          }
        }
        function vd(a, t, n, l, p, v) {
          if (p - l <= n) return;
          const x = l + p >> 1;
          Lp(a, t, x, l, p, v), vd(a, t, n, l, x - 1, 1 - v), vd(a, t, n, x + 1, p, 1 - v);
        }
        function Lp(a, t, n, l, p, v) {
          for (; p > l; ) {
            if (p - l > 600) {
              const k = p - l + 1, D = n - l + 1, N = Math.log(k), q = 0.5 * Math.exp(2 * N / 3), G = 0.5 * Math.sqrt(N * q * (k - q) / k) * (D - k / 2 < 0 ? -1 : 1);
              Lp(a, t, n, Math.max(l, Math.floor(n - D * q / k + G)), Math.min(p, Math.floor(n + (k - D) * q / k + G)), v);
            }
            const x = t[2 * n + v];
            let T = l, E = p;
            for (xd(a, t, l, n), t[2 * p + v] > x && xd(a, t, l, p); T < E; ) {
              for (xd(a, t, T, E), T++, E--; t[2 * T + v] < x; ) T++;
              for (; t[2 * E + v] > x; ) E--;
            }
            t[2 * l + v] === x ? xd(a, t, l, E) : (E++, xd(a, t, E, p)), E <= n && (l = E + 1), n <= E && (p = E - 1);
          }
        }
        function xd(a, t, n, l) {
          qr(a, n, l), qr(t, 2 * n, 2 * l), qr(t, 2 * n + 1, 2 * l + 1);
        }
        function qr(a, t, n) {
          const l = a[t];
          a[t] = a[n], a[n] = l;
        }
        function Op(a, t, n, l) {
          const p = a - n, v = t - l;
          return p * p + v * v;
        }
        var Bp;
        S.cx = void 0, (Bp = S.cx || (S.cx = {})).create = "create", Bp.load = "load", Bp.fullLoad = "fullLoad";
        let bd = null, mh = [];
        const Cc = 1e3 / 60, Gr = "loadTime", Np = "fullLoadTime", jp = { mark(a) {
          performance.mark(a);
        }, frame(a) {
          const t = a;
          bd != null && mh.push(t - bd), bd = t;
        }, clearMetrics() {
          bd = null, mh = [], performance.clearMeasures(Gr), performance.clearMeasures(Np);
          for (const a in S.cx) performance.clearMarks(S.cx[a]);
        }, getPerformanceMetrics() {
          performance.measure(Gr, S.cx.create, S.cx.load), performance.measure(Np, S.cx.create, S.cx.fullLoad);
          const a = performance.getEntriesByName(Gr)[0].duration, t = performance.getEntriesByName(Np)[0].duration, n = mh.length, l = 1 / (mh.reduce(((v, x) => v + x), 0) / n / 1e3), p = mh.filter(((v) => v > Cc)).reduce(((v, x) => v + (x - Cc) / Cc), 0);
          return { loadTime: a, fullLoadTime: t, fps: l, percentDroppedFrames: p / (n + p) * 100, totalFrames: n };
        } };
        S.$ = at, S.A = nt, S.B = function([a, t, n]) {
          return t += 90, t *= Math.PI / 180, n *= Math.PI / 180, { x: a * Math.cos(t) * Math.sin(n), y: a * Math.sin(t) * Math.sin(n), z: a * Math.cos(n) };
        }, S.C = ps, S.D = Tt, S.E = Mt, S.F = Li, S.G = As, S.H = function(a) {
          if (Xa == null) {
            const t = a.navigator ? a.navigator.userAgent : null;
            Xa = !!a.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
          }
          return Xa;
        }, S.I = ur, S.J = class {
          constructor(a, t) {
            this.target = a, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new hg((() => this.process())), this.subscription = ho(this.target, "message", ((n) => this.receive(n)), !1), this.globalScope = dr(self) ? a : window;
          }
          registerMessageHandler(a, t) {
            this.messageHandlers[a] = t;
          }
          sendAsync(a, t) {
            return new Promise(((n, l) => {
              const p = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), v = t ? ho(t.signal, "abort", (() => {
                v?.unsubscribe(), delete this.resolveRejects[p];
                const E = { id: p, type: "<cancel>", origin: location.origin, targetMapId: a.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(E);
              }), dg) : null;
              this.resolveRejects[p] = { resolve: (E) => {
                v?.unsubscribe(), n(E);
              }, reject: (E) => {
                v?.unsubscribe(), l(E);
              } };
              const x = [], T = Object.assign(Object.assign({}, a), { id: p, sourceMapId: this.mapId, origin: location.origin, data: ko(a.data, x) });
              this.target.postMessage(T, { transfer: x });
            }));
          }
          receive(a) {
            const t = a.data, n = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[n];
                const l = this.abortControllers[n];
                return delete this.abortControllers[n], void (l && l.abort());
              }
              if (dr(self) || t.mustQueue) return this.tasks[n] = t, this.taskQueue.push(n), void this.invoker.trigger();
              this.processTask(n, t);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const a = this.taskQueue.shift(), t = this.tasks[a];
            delete this.tasks[a], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(a, t);
          }
          processTask(a, t) {
            return u(this, void 0, void 0, (function* () {
              if (t.type === "<response>") {
                const p = this.resolveRejects[a];
                return delete this.resolveRejects[a], p ? void (t.error ? p.reject(Es(t.error)) : p.resolve(Es(t.data))) : void 0;
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(a, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const n = Es(t.data), l = new AbortController();
              this.abortControllers[a] = l;
              try {
                const p = yield this.messageHandlers[t.type](t.sourceMapId, n, l);
                this.completeTask(a, null, p);
              } catch (p) {
                this.completeTask(a, p);
              }
            }));
          }
          completeTask(a, t, n) {
            const l = [];
            delete this.abortControllers[a];
            const p = { id: a, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? ko(t) : null, data: ko(n, l) };
            this.target.postMessage(p, { transfer: l });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, S.K = Q, S.L = function() {
          var a = new nt(16);
          return nt != Float32Array && (a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0), a[0] = 1, a[5] = 1, a[10] = 1, a[15] = 1, a;
        }, S.M = function(a, t, n) {
          var l, p, v, x, T, E, k, D, N, q, G, Z, X = n[0], ee = n[1], se = n[2];
          return t === a ? (a[12] = t[0] * X + t[4] * ee + t[8] * se + t[12], a[13] = t[1] * X + t[5] * ee + t[9] * se + t[13], a[14] = t[2] * X + t[6] * ee + t[10] * se + t[14], a[15] = t[3] * X + t[7] * ee + t[11] * se + t[15]) : (p = t[1], v = t[2], x = t[3], T = t[4], E = t[5], k = t[6], D = t[7], N = t[8], q = t[9], G = t[10], Z = t[11], a[0] = l = t[0], a[1] = p, a[2] = v, a[3] = x, a[4] = T, a[5] = E, a[6] = k, a[7] = D, a[8] = N, a[9] = q, a[10] = G, a[11] = Z, a[12] = l * X + T * ee + N * se + t[12], a[13] = p * X + E * ee + q * se + t[13], a[14] = v * X + k * ee + G * se + t[14], a[15] = x * X + D * ee + Z * se + t[15]), a;
        }, S.N = function(a, t, n) {
          var l = n[0], p = n[1], v = n[2];
          return a[0] = t[0] * l, a[1] = t[1] * l, a[2] = t[2] * l, a[3] = t[3] * l, a[4] = t[4] * p, a[5] = t[5] * p, a[6] = t[6] * p, a[7] = t[7] * p, a[8] = t[8] * v, a[9] = t[9] * v, a[10] = t[10] * v, a[11] = t[11] * v, a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15], a;
        }, S.O = function(a, t, n) {
          var l = t[0], p = t[1], v = t[2], x = t[3], T = t[4], E = t[5], k = t[6], D = t[7], N = t[8], q = t[9], G = t[10], Z = t[11], X = t[12], ee = t[13], se = t[14], xe = t[15], de = n[0], ge = n[1], Ie = n[2], Fe = n[3];
          return a[0] = de * l + ge * T + Ie * N + Fe * X, a[1] = de * p + ge * E + Ie * q + Fe * ee, a[2] = de * v + ge * k + Ie * G + Fe * se, a[3] = de * x + ge * D + Ie * Z + Fe * xe, a[4] = (de = n[4]) * l + (ge = n[5]) * T + (Ie = n[6]) * N + (Fe = n[7]) * X, a[5] = de * p + ge * E + Ie * q + Fe * ee, a[6] = de * v + ge * k + Ie * G + Fe * se, a[7] = de * x + ge * D + Ie * Z + Fe * xe, a[8] = (de = n[8]) * l + (ge = n[9]) * T + (Ie = n[10]) * N + (Fe = n[11]) * X, a[9] = de * p + ge * E + Ie * q + Fe * ee, a[10] = de * v + ge * k + Ie * G + Fe * se, a[11] = de * x + ge * D + Ie * Z + Fe * xe, a[12] = (de = n[12]) * l + (ge = n[13]) * T + (Ie = n[14]) * N + (Fe = n[15]) * X, a[13] = de * p + ge * E + Ie * q + Fe * ee, a[14] = de * v + ge * k + Ie * G + Fe * se, a[15] = de * x + ge * D + Ie * Z + Fe * xe, a;
        }, S.P = O, S.Q = function(a, t) {
          const n = {};
          for (let l = 0; l < t.length; l++) {
            const p = t[l];
            p in a && (n[p] = a[p]);
          }
          return n;
        }, S.R = ka, S.S = $o, S.T = ed, S.U = Ap, S.V = pg, S.W = ft, S.X = ht, S.Y = Os, S.Z = Cr, S._ = u, S.a = H, S.a$ = vn, S.a0 = function(a, t) {
          var n, l, p, v;
          if (!a) return t ?? {};
          if (!t) return a;
          const x = Object.assign({}, a);
          if (t.removeAll && (x.removeAll = !0), t.remove) {
            const T = new Set(x.remove ? x.remove.concat(t.remove) : t.remove);
            x.remove = Array.from(T.values());
          }
          if (t.add) {
            const T = x.add ? x.add.concat(t.add) : t.add, E = new Map(T.map(((k) => [k.id, k])));
            x.add = Array.from(E.values());
          }
          if (t.update) {
            const T = new Map((n = x.update) === null || n === void 0 ? void 0 : n.map(((E) => [E.id, E])));
            for (const E of t.update) {
              const k = (l = T.get(E.id)) !== null && l !== void 0 ? l : { id: E.id };
              E.newGeometry && (k.newGeometry = E.newGeometry), E.addOrUpdateProperties && (k.addOrUpdateProperties = ((p = k.addOrUpdateProperties) !== null && p !== void 0 ? p : []).concat(E.addOrUpdateProperties)), E.removeProperties && (k.removeProperties = ((v = k.removeProperties) !== null && v !== void 0 ? v : []).concat(E.removeProperties)), E.removeAllProperties && (k.removeAllProperties = !0), T.set(E.id, k);
            }
            x.update = Array.from(T.values());
          }
          return x;
        }, S.a1 = kl, S.a2 = xu, S.a3 = 25, S.a4 = Cp, S.a5 = (a) => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise(((n) => {
            t.onloadstart = () => {
              n(t);
            };
            for (const l of a) {
              const p = window.document.createElement("source");
              Ee(l) || (t.crossOrigin = "Anonymous"), p.src = l, t.appendChild(p);
            }
          }));
        }, S.a6 = ot, S.a7 = function() {
          return xi++;
        }, S.a8 = B, S.a9 = hh, S.aA = function(a) {
          let t = 1 / 0, n = 1 / 0, l = -1 / 0, p = -1 / 0;
          for (const v of a) t = Math.min(t, v.x), n = Math.min(n, v.y), l = Math.max(l, v.x), p = Math.max(p, v.y);
          return [t, n, l, p];
        }, S.aB = Tn, S.aC = Et, S.aD = function(a, t, n, l, p = !1) {
          if (!n[0] && !n[1]) return [0, 0];
          const v = p ? l === "map" ? -a.bearingInRadians : 0 : l === "viewport" ? a.bearingInRadians : 0;
          if (v) {
            const x = Math.sin(v), T = Math.cos(v);
            n = [n[0] * T - n[1] * x, n[0] * x + n[1] * T];
          }
          return [p ? n[0] : Et(t, n[0], a.zoom), p ? n[1] : Et(t, n[1], a.zoom)];
        }, S.aF = wp, S.aG = Ho, S.aH = $f, S.aI = Dp, S.aJ = fn, S.aK = rd, S.aL = ue, S.aM = Qt, S.aN = qi, S.aO = si, S.aP = po, S.aQ = fg, S.aR = Dt, S.aS = Ht, S.aT = function(a) {
          var t = new nt(3);
          return t[0] = a[0], t[1] = a[1], t[2] = a[2], t;
        }, S.aU = function(a, t, n) {
          return a[0] = t[0] - n[0], a[1] = t[1] - n[1], a[2] = t[2] - n[2], a;
        }, S.aV = function(a, t) {
          var n = t[0], l = t[1], p = t[2], v = n * n + l * l + p * p;
          return v > 0 && (v = 1 / Math.sqrt(v)), a[0] = t[0] * v, a[1] = t[1] * v, a[2] = t[2] * v, a;
        }, S.aW = Xt, S.aX = function(a, t) {
          return a[0] * t[0] + a[1] * t[1] + a[2] * t[2];
        }, S.aY = function(a, t, n) {
          return a[0] = t[0] * n[0], a[1] = t[1] * n[1], a[2] = t[2] * n[2], a[3] = t[3] * n[3], a;
        }, S.aZ = rt, S.a_ = function(a, t, n) {
          const l = t[0] * n[0] + t[1] * n[1] + t[2] * n[2];
          return l === 0 ? null : (-(a[0] * n[0] + a[1] * n[1] + a[2] * n[2]) - n[3]) / l;
        }, S.aa = nr, S.ab = Fr, S.ac = ph, S.ad = function(a) {
          const t = {};
          if (a.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((n, l, p, v) => {
            const x = p || v;
            return t[l] = !x || x.toLowerCase(), "";
          })), t["max-age"]) {
            const n = parseInt(t["max-age"], 10);
            isNaN(n) ? delete t["max-age"] : t["max-age"] = n;
          }
          return t;
        }, S.ae = Yn, S.af = function(a) {
          return Math.pow(2, a);
        }, S.ag = Re, S.ah = Vt, S.ai = 85.051129, S.aj = Ep, S.ak = function(a) {
          return Math.log(a) / Math.LN2;
        }, S.al = function(a) {
          var t = a[0], n = a[1];
          return t * t + n * n;
        }, S.am = function(a, t) {
          const n = [];
          for (const l in a) l in t || n.push(l);
          return n;
        }, S.an = function(a, t) {
          let n = 0, l = 0;
          if (a.kind === "constant") l = a.layoutSize;
          else if (a.kind !== "source") {
            const { interpolationType: p, minZoom: v, maxZoom: x } = a, T = p ? Vt(ca.interpolationFactor(p, t, v, x), 0, 1) : 0;
            a.kind === "camera" ? l = ps.number(a.minSize, a.maxSize, T) : n = T;
          }
          return { uSizeT: n, uSize: l };
        }, S.ap = function(a, { uSize: t, uSizeT: n }, { lowerSize: l, upperSize: p }) {
          return a.kind === "source" ? l / Go : a.kind === "composite" ? ps.number(l / Go, p / Go, n) : t;
        }, S.aq = function(a, t) {
          var n = t[0], l = t[1], p = t[2], v = t[3], x = t[4], T = t[5], E = t[6], k = t[7], D = t[8], N = t[9], q = t[10], G = t[11], Z = t[12], X = t[13], ee = t[14], se = t[15], xe = n * T - l * x, de = n * E - p * x, ge = n * k - v * x, Ie = l * E - p * T, Fe = l * k - v * T, Je = p * k - v * E, gt = D * X - N * Z, ut = D * ee - q * Z, yt = D * se - G * Z, kt = N * ee - q * X, mt = N * se - G * X, pt = q * se - G * ee, Xe = xe * pt - de * mt + ge * kt + Ie * yt - Fe * ut + Je * gt;
          return Xe ? (a[0] = (T * pt - E * mt + k * kt) * (Xe = 1 / Xe), a[1] = (p * mt - l * pt - v * kt) * Xe, a[2] = (X * Je - ee * Fe + se * Ie) * Xe, a[3] = (q * Fe - N * Je - G * Ie) * Xe, a[4] = (E * yt - x * pt - k * ut) * Xe, a[5] = (n * pt - p * yt + v * ut) * Xe, a[6] = (ee * ge - Z * Je - se * de) * Xe, a[7] = (D * Je - q * ge + G * de) * Xe, a[8] = (x * mt - T * yt + k * gt) * Xe, a[9] = (l * yt - n * mt - v * gt) * Xe, a[10] = (Z * Fe - X * ge + se * xe) * Xe, a[11] = (N * ge - D * Fe - G * xe) * Xe, a[12] = (T * ut - x * kt - E * gt) * Xe, a[13] = (n * kt - l * ut + p * gt) * Xe, a[14] = (X * de - Z * Ie - ee * xe) * Xe, a[15] = (D * Ie - N * de + q * xe) * Xe, a) : null;
        }, S.ar = vt, S.as = function(a) {
          return Math.hypot(a[0], a[1]);
        }, S.at = function(a) {
          return a[0] = 0, a[1] = 0, a;
        }, S.au = function(a, t, n) {
          return a[0] = t[0] * n, a[1] = t[1] * n, a;
        }, S.av = fd, S.aw = Cn, S.ax = function(a, t, n, l) {
          const p = t.y - a.y, v = t.x - a.x, x = l.y - n.y, T = l.x - n.x, E = x * v - T * p;
          if (E === 0) return null;
          const k = (T * (a.y - n.y) - x * (a.x - n.x)) / E;
          return new O(a.x + k * v, a.y + k * p);
        }, S.ay = _g, S.az = hf, S.b = Ya, S.b$ = class extends y {
        }, S.b0 = function(a, t, n) {
          return a[0] = t[0] * n, a[1] = t[1] * n, a[2] = t[2] * n, a[3] = t[3] * n, a;
        }, S.b1 = function(a, t) {
          return a[0] * t[0] + a[1] * t[1] + a[2] * t[2] + a[3];
        }, S.b2 = Ai, S.b3 = Rl, S.b4 = function(a, t, n, l, p) {
          var v, x = 1 / Math.tan(t / 2);
          return a[0] = x / n, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = x, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[11] = -1, a[12] = 0, a[13] = 0, a[15] = 0, p != null && p !== 1 / 0 ? (a[10] = (p + l) * (v = 1 / (l - p)), a[14] = 2 * p * l * v) : (a[10] = -1, a[14] = -2 * l), a;
        }, S.b5 = function(a) {
          var t = new nt(16);
          return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t[9] = a[9], t[10] = a[10], t[11] = a[11], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15], t;
        }, S.b6 = function(a, t, n) {
          var l = Math.sin(n), p = Math.cos(n), v = t[0], x = t[1], T = t[2], E = t[3], k = t[4], D = t[5], N = t[6], q = t[7];
          return t !== a && (a[8] = t[8], a[9] = t[9], a[10] = t[10], a[11] = t[11], a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15]), a[0] = v * p + k * l, a[1] = x * p + D * l, a[2] = T * p + N * l, a[3] = E * p + q * l, a[4] = k * p - v * l, a[5] = D * p - x * l, a[6] = N * p - T * l, a[7] = q * p - E * l, a;
        }, S.b7 = function(a, t, n) {
          var l = Math.sin(n), p = Math.cos(n), v = t[4], x = t[5], T = t[6], E = t[7], k = t[8], D = t[9], N = t[10], q = t[11];
          return t !== a && (a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15]), a[4] = v * p + k * l, a[5] = x * p + D * l, a[6] = T * p + N * l, a[7] = E * p + q * l, a[8] = k * p - v * l, a[9] = D * p - x * l, a[10] = N * p - T * l, a[11] = q * p - E * l, a;
        }, S.b8 = function() {
          const a = new Float32Array(16);
          return Re(a), a;
        }, S.b9 = function() {
          const a = new Float64Array(16);
          return Re(a), a;
        }, S.bA = function(a, t) {
          const n = fe(a, 360), l = fe(t, 360), p = l - n, v = l > n ? p - 360 : p + 360;
          return Math.abs(p) < Math.abs(v) ? p : v;
        }, S.bB = function(a) {
          return a[0] = 0, a[1] = 0, a[2] = 0, a;
        }, S.bC = function(a, t, n, l) {
          const p = Math.sqrt(a * a + t * t), v = Math.sqrt(n * n + l * l);
          a /= p, t /= p, n /= v, l /= v;
          const x = Math.acos(a * n + t * l);
          return -t * n + a * l > 0 ? x : -x;
        }, S.bD = function(a, t) {
          const n = fe(a, 2 * Math.PI), l = fe(t, 2 * Math.PI);
          return Math.min(Math.abs(n - l), Math.abs(n - l + 2 * Math.PI), Math.abs(n - l - 2 * Math.PI));
        }, S.bE = function() {
          const a = {}, t = Ae.$version;
          for (const n in Ae.$root) {
            const l = Ae.$root[n];
            if (l.required) {
              let p = null;
              p = n === "version" ? t : l.type === "array" ? [] : {}, p != null && (a[n] = p);
            }
          }
          return a;
        }, S.bF = vl, S.bG = me, S.bH = function a(t, n) {
          if (Array.isArray(t)) {
            if (!Array.isArray(n) || t.length !== n.length) return !1;
            for (let l = 0; l < t.length; l++) if (!a(t[l], n[l])) return !1;
            return !0;
          }
          if (typeof t == "object" && t !== null && n !== null) {
            if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length) return !1;
            for (const l in t) if (!a(t[l], n[l])) return !1;
            return !0;
          }
          return t === n;
        }, S.bI = function(a) {
          a = a.slice();
          const t = /* @__PURE__ */ Object.create(null);
          for (let n = 0; n < a.length; n++) t[a[n].id] = a[n];
          for (let n = 0; n < a.length; n++) "ref" in a[n] && (a[n] = ri(a[n], t[a[n].ref]));
          return a;
        }, S.bJ = function(a) {
          if (a.type === "custom") return new cg(a);
          switch (a.type) {
            case "background":
              return new Zo(a);
            case "circle":
              return new _f(a);
            case "color-relief":
              return new Af(a);
            case "fill":
              return new Hm(a);
            case "fill-extrusion":
              return new ah(a);
            case "heatmap":
              return new up(a);
            case "hillshade":
              return new Vm(a);
            case "line":
              return new mu(a);
            case "raster":
              return new ug(a);
            case "symbol":
              return new Tc(a);
          }
        }, S.bK = oa, S.bL = function(a, t) {
          if (!a) return [{ command: "setStyle", args: [t] }];
          let n = [];
          try {
            if (!It(a.version, t.version)) return [{ command: "setStyle", args: [t] }];
            It(a.center, t.center) || n.push({ command: "setCenter", args: [t.center] }), It(a.state, t.state) || n.push({ command: "setGlobalState", args: [t.state] }), It(a.centerAltitude, t.centerAltitude) || n.push({ command: "setCenterAltitude", args: [t.centerAltitude] }), It(a.zoom, t.zoom) || n.push({ command: "setZoom", args: [t.zoom] }), It(a.bearing, t.bearing) || n.push({ command: "setBearing", args: [t.bearing] }), It(a.pitch, t.pitch) || n.push({ command: "setPitch", args: [t.pitch] }), It(a.roll, t.roll) || n.push({ command: "setRoll", args: [t.roll] }), It(a.sprite, t.sprite) || n.push({ command: "setSprite", args: [t.sprite] }), It(a.glyphs, t.glyphs) || n.push({ command: "setGlyphs", args: [t.glyphs] }), It(a.transition, t.transition) || n.push({ command: "setTransition", args: [t.transition] }), It(a.light, t.light) || n.push({ command: "setLight", args: [t.light] }), It(a.terrain, t.terrain) || n.push({ command: "setTerrain", args: [t.terrain] }), It(a.sky, t.sky) || n.push({ command: "setSky", args: [t.sky] }), It(a.projection, t.projection) || n.push({ command: "setProjection", args: [t.projection] });
            const l = {}, p = [];
            (function(x, T, E, k) {
              let D;
              for (D in T = T || {}, x = x || {}) Object.prototype.hasOwnProperty.call(x, D) && (Object.prototype.hasOwnProperty.call(T, D) || Pn(D, E, k));
              for (D in T) Object.prototype.hasOwnProperty.call(T, D) && (Object.prototype.hasOwnProperty.call(x, D) ? It(x[D], T[D]) || (x[D].type === "geojson" && T[D].type === "geojson" && In(x, T, D) ? ti(E, { command: "setGeoJSONSourceData", args: [D, T[D].data] }) : xn(D, T, E, k)) : Yi(D, T, E));
            })(a.sources, t.sources, p, l);
            const v = [];
            a.layers && a.layers.forEach(((x) => {
              "source" in x && l[x.source] ? n.push({ command: "removeLayer", args: [x.id] }) : v.push(x);
            })), n = n.concat(p), (function(x, T, E) {
              T = T || [];
              const k = (x = x || []).map(_i), D = T.map(_i), N = x.reduce(kn, {}), q = T.reduce(kn, {}), G = k.slice(), Z = /* @__PURE__ */ Object.create(null);
              let X, ee, se, xe, de;
              for (let ge = 0, Ie = 0; ge < k.length; ge++) X = k[ge], Object.prototype.hasOwnProperty.call(q, X) ? Ie++ : (ti(E, { command: "removeLayer", args: [X] }), G.splice(G.indexOf(X, Ie), 1));
              for (let ge = 0, Ie = 0; ge < D.length; ge++) X = D[D.length - 1 - ge], G[G.length - 1 - ge] !== X && (Object.prototype.hasOwnProperty.call(N, X) ? (ti(E, { command: "removeLayer", args: [X] }), G.splice(G.lastIndexOf(X, G.length - Ie), 1)) : Ie++, xe = G[G.length - ge], ti(E, { command: "addLayer", args: [q[X], xe] }), G.splice(G.length - ge, 0, X), Z[X] = !0);
              for (let ge = 0; ge < D.length; ge++) if (X = D[ge], ee = N[X], se = q[X], !Z[X] && !It(ee, se)) if (It(ee.source, se.source) && It(ee["source-layer"], se["source-layer"]) && It(ee.type, se.type)) {
                for (de in ci(ee.layout, se.layout, E, X, null, "setLayoutProperty"), ci(ee.paint, se.paint, E, X, null, "setPaintProperty"), It(ee.filter, se.filter) || ti(E, { command: "setFilter", args: [X, se.filter] }), It(ee.minzoom, se.minzoom) && It(ee.maxzoom, se.maxzoom) || ti(E, { command: "setLayerZoomRange", args: [X, se.minzoom, se.maxzoom] }), ee) Object.prototype.hasOwnProperty.call(ee, de) && de !== "layout" && de !== "paint" && de !== "filter" && de !== "metadata" && de !== "minzoom" && de !== "maxzoom" && (de.indexOf("paint.") === 0 ? ci(ee[de], se[de], E, X, de.slice(6), "setPaintProperty") : It(ee[de], se[de]) || ti(E, { command: "setLayerProperty", args: [X, de, se[de]] }));
                for (de in se) Object.prototype.hasOwnProperty.call(se, de) && !Object.prototype.hasOwnProperty.call(ee, de) && de !== "layout" && de !== "paint" && de !== "filter" && de !== "metadata" && de !== "minzoom" && de !== "maxzoom" && (de.indexOf("paint.") === 0 ? ci(ee[de], se[de], E, X, de.slice(6), "setPaintProperty") : It(ee[de], se[de]) || ti(E, { command: "setLayerProperty", args: [X, de, se[de]] }));
              } else ti(E, { command: "removeLayer", args: [X] }), xe = G[G.lastIndexOf(X) + 1], ti(E, { command: "addLayer", args: [se, xe] });
            })(v, t.layers, n);
          } catch (l) {
            console.warn("Unable to compute style diff:", l), n = [{ command: "setStyle", args: [t] }];
          }
          return n;
        }, S.bM = function(a) {
          const t = [], n = a.id;
          return n === void 0 && t.push({ message: `layers.${n}: missing required property "id"` }), a.render === void 0 && t.push({ message: `layers.${n}: missing required method "render"` }), a.renderingMode && a.renderingMode !== "2d" && a.renderingMode !== "3d" && t.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), t;
        }, S.bN = Ta, S.bO = bi, S.bP = class extends va {
          constructor(a, t) {
            super(a, t), this.current = 0;
          }
          set(a) {
            this.current !== a && (this.current = a, this.gl.uniform1i(this.location, a));
          }
        }, S.bQ = jn, S.bR = class extends va {
          constructor(a, t) {
            super(a, t), this.current = Sr;
          }
          set(a) {
            if (a[12] !== this.current[12] || a[0] !== this.current[0]) return this.current = a, void this.gl.uniformMatrix4fv(this.location, !1, a);
            for (let t = 1; t < 16; t++) if (a[t] !== this.current[t]) {
              this.current = a, this.gl.uniformMatrix4fv(this.location, !1, a);
              break;
            }
          }
        }, S.bS = Nn, S.bT = class extends va {
          constructor(a, t) {
            super(a, t), this.current = [0, 0, 0];
          }
          set(a) {
            a[0] === this.current[0] && a[1] === this.current[1] && a[2] === this.current[2] || (this.current = a, this.gl.uniform3f(this.location, a[0], a[1], a[2]));
          }
        }, S.bU = class extends va {
          constructor(a, t) {
            super(a, t), this.current = [0, 0];
          }
          set(a) {
            a[0] === this.current[0] && a[1] === this.current[1] || (this.current = a, this.gl.uniform2f(this.location, a[0], a[1]));
          }
        }, S.bV = De, S.bW = function(a, t) {
          var n = Math.sin(t), l = Math.cos(t);
          return a[0] = l, a[1] = n, a[2] = 0, a[3] = -n, a[4] = l, a[5] = 0, a[6] = 0, a[7] = 0, a[8] = 1, a;
        }, S.bX = function(a, t, n) {
          var l = t[0], p = t[1], v = t[2];
          return a[0] = l * n[0] + p * n[3] + v * n[6], a[1] = l * n[1] + p * n[4] + v * n[7], a[2] = l * n[2] + p * n[5] + v * n[8], a;
        }, S.bY = function(a, t, n, l, p, v, x) {
          var T = 1 / (t - n), E = 1 / (l - p), k = 1 / (v - x);
          return a[0] = -2 * T, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = -2 * E, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 2 * k, a[11] = 0, a[12] = (t + n) * T, a[13] = (p + l) * E, a[14] = (x + v) * k, a[15] = 1, a;
        }, S.bZ = class extends va {
          constructor(a, t) {
            super(a, t), this.current = new Array();
          }
          set(a) {
            if (a != this.current) {
              this.current = a;
              const t = new Float32Array(4 * a.length);
              for (let n = 0; n < a.length; n++) t[4 * n] = a[n].r, t[4 * n + 1] = a[n].g, t[4 * n + 2] = a[n].b, t[4 * n + 3] = a[n].a;
              this.gl.uniform4fv(this.location, t);
            }
          }
        }, S.b_ = class extends va {
          constructor(a, t) {
            super(a, t), this.current = new Array();
          }
          set(a) {
            if (a != this.current) {
              this.current = a;
              const t = new Float32Array(a);
              this.gl.uniform1fv(this.location, t);
            }
          }
        }, S.ba = function() {
          return new Float64Array(16);
        }, S.bb = function(a, t, n) {
          const l = new Float64Array(4);
          return He(l, a, t - 90, n), l;
        }, S.bc = function(a, t, n, l) {
          var p, v, x, T, E, k = t[0], D = t[1], N = t[2], q = t[3], G = n[0], Z = n[1], X = n[2], ee = n[3];
          return (v = k * G + D * Z + N * X + q * ee) < 0 && (v = -v, G = -G, Z = -Z, X = -X, ee = -ee), 1 - v > it ? (p = Math.acos(v), x = Math.sin(p), T = Math.sin((1 - l) * p) / x, E = Math.sin(l * p) / x) : (T = 1 - l, E = l), a[0] = T * k + E * G, a[1] = T * D + E * Z, a[2] = T * N + E * X, a[3] = T * q + E * ee, a;
        }, S.bd = function(a) {
          const t = new Float64Array(9);
          var n, l, p, v, x, T, E, k, D, N, q, G, Z, X, ee, se, xe, de;
          N = (p = (l = a)[0]) * (E = p + p), q = (v = l[1]) * E, Z = (x = l[2]) * E, X = x * (k = v + v), se = (T = l[3]) * E, xe = T * k, de = T * (D = x + x), (n = t)[0] = 1 - (G = v * k) - (ee = x * D), n[3] = q - de, n[6] = Z + xe, n[1] = q + de, n[4] = 1 - N - ee, n[7] = X - se, n[2] = Z - xe, n[5] = X + se, n[8] = 1 - N - G;
          const ge = po(-Math.asin(Vt(t[2], -1, 1)));
          let Ie, Fe;
          return Math.hypot(t[5], t[8]) < 1e-3 ? (Ie = 0, Fe = -po(Math.atan2(t[3], t[4]))) : (Ie = po(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), Fe = po(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), { roll: Ie, pitch: ge + 90, bearing: Fe };
        }, S.be = function(a, t) {
          return a.roll == t.roll && a.pitch == t.pitch && a.bearing == t.bearing;
        }, S.bf = di, S.bg = eo, S.bh = Vr, S.bi = An, S.bj = Al, S.bk = Ue, S.bl = et, S.bm = ua, S.bn = function(a, t, n, l, p) {
          return Ue(l, p, Vt((a - t) / (n - t), 0, 1));
        }, S.bo = fe, S.bp = function() {
          return new Float64Array(3);
        }, S.bq = function(a, t, n, l) {
          return a[0] = t[0] + n[0] * l, a[1] = t[1] + n[1] * l, a[2] = t[2] + n[2] * l, a;
        }, S.br = He, S.bs = function(a, t, n) {
          var l = n[0], p = n[1], v = n[2], x = t[0], T = t[1], E = t[2], k = p * E - v * T, D = v * x - l * E, N = l * T - p * x, q = p * N - v * D, G = v * k - l * N, Z = l * D - p * k, X = 2 * n[3];
          return D *= X, N *= X, G *= 2, Z *= 2, a[0] = x + (k *= X) + (q *= 2), a[1] = T + D + G, a[2] = E + N + Z, a;
        }, S.bt = function(a, t, n) {
          const l = (p = [a[0], a[1], a[2], t[0], t[1], t[2], n[0], n[1], n[2]])[0] * ((D = p[8]) * (x = p[4]) - (T = p[5]) * (k = p[7])) + p[1] * (-D * (v = p[3]) + T * (E = p[6])) + p[2] * (k * v - x * E);
          var p, v, x, T, E, k, D;
          if (l === 0) return null;
          const N = Xt([], [t[0], t[1], t[2]], [n[0], n[1], n[2]]), q = Xt([], [n[0], n[1], n[2]], [a[0], a[1], a[2]]), G = Xt([], [a[0], a[1], a[2]], [t[0], t[1], t[2]]), Z = Dt([], N, -a[3]);
          return Ht(Z, Z, Dt([], q, -t[3])), Ht(Z, Z, Dt([], G, -n[3])), Dt(Z, Z, 1 / l), Z;
        }, S.bu = Wf, S.bv = function() {
          return new Float64Array(4);
        }, S.bw = function(a, t, n, l) {
          var p = [], v = [];
          return p[0] = t[0] - n[0], p[1] = t[1] - n[1], p[2] = t[2] - n[2], v[0] = p[0] * Math.cos(l) - p[1] * Math.sin(l), v[1] = p[0] * Math.sin(l) + p[1] * Math.cos(l), v[2] = p[2], a[0] = v[0] + n[0], a[1] = v[1] + n[1], a[2] = v[2] + n[2], a;
        }, S.bx = function(a, t, n, l) {
          var p = [], v = [];
          return p[0] = t[0] - n[0], p[1] = t[1] - n[1], p[2] = t[2] - n[2], v[0] = p[0], v[1] = p[1] * Math.cos(l) - p[2] * Math.sin(l), v[2] = p[1] * Math.sin(l) + p[2] * Math.cos(l), a[0] = v[0] + n[0], a[1] = v[1] + n[1], a[2] = v[2] + n[2], a;
        }, S.by = function(a, t, n, l) {
          var p = [], v = [];
          return p[0] = t[0] - n[0], p[1] = t[1] - n[1], p[2] = t[2] - n[2], v[0] = p[2] * Math.sin(l) + p[0] * Math.cos(l), v[1] = p[1], v[2] = p[2] * Math.cos(l) - p[0] * Math.sin(l), a[0] = v[0] + n[0], a[1] = v[1] + n[1], a[2] = v[2] + n[2], a;
        }, S.bz = function(a, t, n) {
          var l = Math.sin(n), p = Math.cos(n), v = t[0], x = t[1], T = t[2], E = t[3], k = t[8], D = t[9], N = t[10], q = t[11];
          return t !== a && (a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15]), a[0] = v * p - k * l, a[1] = x * p - D * l, a[2] = T * p - N * l, a[3] = E * p - q * l, a[8] = v * l + k * p, a[9] = x * l + D * p, a[10] = T * l + N * p, a[11] = E * l + q * p, a;
        }, S.c = be, S.c0 = xc, S.c1 = class extends r {
        }, S.c2 = wf, S.c3 = function(a) {
          return a <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
        }, S.c4 = bf, S.c5 = function(a, t, n) {
          var l = t[0], p = t[1], v = t[2], x = n[3] * l + n[7] * p + n[11] * v + n[15];
          return a[0] = (n[0] * l + n[4] * p + n[8] * v + n[12]) / (x = x || 1), a[1] = (n[1] * l + n[5] * p + n[9] * v + n[13]) / x, a[2] = (n[2] * l + n[6] * p + n[10] * v + n[14]) / x, a;
        }, S.c6 = class extends Sn {
        }, S.c7 = class extends R {
        }, S.c8 = function(a, t) {
          return a[0] === t[0] && a[1] === t[1] && a[2] === t[2] && a[3] === t[3] && a[4] === t[4] && a[5] === t[5] && a[6] === t[6] && a[7] === t[7] && a[8] === t[8] && a[9] === t[9] && a[10] === t[10] && a[11] === t[11] && a[12] === t[12] && a[13] === t[13] && a[14] === t[14] && a[15] === t[15];
        }, S.c9 = function(a, t) {
          var n = a[0], l = a[1], p = a[2], v = a[3], x = a[4], T = a[5], E = a[6], k = a[7], D = a[8], N = a[9], q = a[10], G = a[11], Z = a[12], X = a[13], ee = a[14], se = a[15], xe = t[0], de = t[1], ge = t[2], Ie = t[3], Fe = t[4], Je = t[5], gt = t[6], ut = t[7], yt = t[8], kt = t[9], mt = t[10], pt = t[11], Xe = t[12], Bt = t[13], $t = t[14], Rt = t[15];
          return Math.abs(n - xe) <= it * Math.max(1, Math.abs(n), Math.abs(xe)) && Math.abs(l - de) <= it * Math.max(1, Math.abs(l), Math.abs(de)) && Math.abs(p - ge) <= it * Math.max(1, Math.abs(p), Math.abs(ge)) && Math.abs(v - Ie) <= it * Math.max(1, Math.abs(v), Math.abs(Ie)) && Math.abs(x - Fe) <= it * Math.max(1, Math.abs(x), Math.abs(Fe)) && Math.abs(T - Je) <= it * Math.max(1, Math.abs(T), Math.abs(Je)) && Math.abs(E - gt) <= it * Math.max(1, Math.abs(E), Math.abs(gt)) && Math.abs(k - ut) <= it * Math.max(1, Math.abs(k), Math.abs(ut)) && Math.abs(D - yt) <= it * Math.max(1, Math.abs(D), Math.abs(yt)) && Math.abs(N - kt) <= it * Math.max(1, Math.abs(N), Math.abs(kt)) && Math.abs(q - mt) <= it * Math.max(1, Math.abs(q), Math.abs(mt)) && Math.abs(G - pt) <= it * Math.max(1, Math.abs(G), Math.abs(pt)) && Math.abs(Z - Xe) <= it * Math.max(1, Math.abs(Z), Math.abs(Xe)) && Math.abs(X - Bt) <= it * Math.max(1, Math.abs(X), Math.abs(Bt)) && Math.abs(ee - $t) <= it * Math.max(1, Math.abs(ee), Math.abs($t)) && Math.abs(se - Rt) <= it * Math.max(1, Math.abs(se), Math.abs(Rt));
        }, S.cA = function(a, t) {
          H.REGISTERED_PROTOCOLS[a] = t;
        }, S.cB = function(a) {
          delete H.REGISTERED_PROTOCOLS[a];
        }, S.cC = function(a, t) {
          const n = {};
          for (let p = 0; p < a.length; p++) {
            const v = t && t[a[p].id] || ln(a[p]);
            t && (t[a[p].id] = v);
            let x = n[v];
            x || (x = n[v] = []), x.push(a[p]);
          }
          const l = [];
          for (const p in n) l.push(n[p]);
          return l;
        }, S.cD = xt, S.cE = zp, S.cF = gd, S.cG = Vf, S.cH = function(a) {
          a.bucket.createArrays(), a.bucket.tilePixelRatio = at / (512 * a.bucket.overscaling), a.bucket.compareText = {}, a.bucket.iconsNeedLinear = !1;
          const t = a.bucket.layers[0], n = t.layout, l = t._unevaluatedLayout._values, p = { layoutIconSize: l["icon-size"].possiblyEvaluate(new Li(a.bucket.zoom + 1), a.canonical), layoutTextSize: l["text-size"].possiblyEvaluate(new Li(a.bucket.zoom + 1), a.canonical), textMaxSize: l["text-size"].possiblyEvaluate(new Li(18)) };
          if (a.bucket.textSizeData.kind === "composite") {
            const { minZoom: k, maxZoom: D } = a.bucket.textSizeData;
            p.compositeTextSizes = [l["text-size"].possiblyEvaluate(new Li(k), a.canonical), l["text-size"].possiblyEvaluate(new Li(D), a.canonical)];
          }
          if (a.bucket.iconSizeData.kind === "composite") {
            const { minZoom: k, maxZoom: D } = a.bucket.iconSizeData;
            p.compositeIconSizes = [l["icon-size"].possiblyEvaluate(new Li(k), a.canonical), l["icon-size"].possiblyEvaluate(new Li(D), a.canonical)];
          }
          const v = n.get("text-line-height") * Tn, x = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point", T = n.get("text-keep-upright"), E = n.get("text-size");
          for (const k of a.bucket.features) {
            const D = n.get("text-font").evaluate(k, {}, a.canonical).join(","), N = E.evaluate(k, {}, a.canonical), q = p.layoutTextSize.evaluate(k, {}, a.canonical), G = p.layoutIconSize.evaluate(k, {}, a.canonical), Z = { horizontal: {}, vertical: void 0 }, X = k.text;
            let ee, se = [0, 0];
            if (X) {
              const ge = X.toString(), Ie = n.get("text-letter-spacing").evaluate(k, {}, a.canonical) * Tn, Fe = xl(ge) ? Ie : 0, Je = n.get("text-anchor").evaluate(k, {}, a.canonical), gt = bg(t, k, a.canonical);
              if (!gt) {
                const mt = n.get("text-radial-offset").evaluate(k, {}, a.canonical);
                se = mt ? xg(Je, [mt * Tn, kp]) : n.get("text-offset").evaluate(k, {}, a.canonical).map(((pt) => pt * Tn));
              }
              let ut = x ? "center" : n.get("text-justify").evaluate(k, {}, a.canonical);
              const yt = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(k, {}, a.canonical) * Tn : 1 / 0, kt = () => {
                a.bucket.allowVerticalPlacement && nc(ge) && (Z.vertical = Sc(X, a.glyphMap, a.glyphPositions, a.imagePositions, D, yt, v, Je, "left", Fe, se, S.ao.vertical, !0, q, N));
              };
              if (!x && gt) {
                const mt = /* @__PURE__ */ new Set();
                if (ut === "auto") for (let Xe = 0; Xe < gt.values.length; Xe += 2) mt.add(Ho(gt.values[Xe]));
                else mt.add(ut);
                let pt = !1;
                for (const Xe of mt) if (!Z.horizontal[Xe]) if (pt) Z.horizontal[Xe] = Z.horizontal[0];
                else {
                  const Bt = Sc(X, a.glyphMap, a.glyphPositions, a.imagePositions, D, yt, v, "center", Xe, Fe, se, S.ao.horizontal, !1, q, N);
                  Bt && (Z.horizontal[Xe] = Bt, pt = Bt.positionedLines.length === 1);
                }
                kt();
              } else {
                ut === "auto" && (ut = Ho(Je));
                const mt = Sc(X, a.glyphMap, a.glyphPositions, a.imagePositions, D, yt, v, Je, ut, Fe, se, S.ao.horizontal, !1, q, N);
                mt && (Z.horizontal[ut] = mt), kt(), nc(ge) && x && T && (Z.vertical = Sc(X, a.glyphMap, a.glyphPositions, a.imagePositions, D, yt, v, Je, ut, Fe, se, S.ao.vertical, !1, q, N));
              }
            }
            let xe = !1;
            if (k.icon && k.icon.name) {
              const ge = a.imageMap[k.icon.name];
              ge && (ee = sg(a.imagePositions[k.icon.name], n.get("icon-offset").evaluate(k, {}, a.canonical), n.get("icon-anchor").evaluate(k, {}, a.canonical)), xe = !!ge.sdf, a.bucket.sdfIcons === void 0 ? a.bucket.sdfIcons = xe : a.bucket.sdfIcons !== xe && $i("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (ge.pixelRatio !== a.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (a.bucket.iconsNeedLinear = !0));
            }
            const de = Rp(Z.horizontal) || Z.vertical;
            a.bucket.iconsInText = !!de && de.iconsInText, (de || ee) && wg(a.bucket, k, Z, ee, a.imageMap, p, q, G, se, xe, a.canonical, a.subdivisionGranularity);
          }
          a.showCollisionBoxes && a.bucket.generateCollisionDebugBuffers();
        }, S.cI = ji, S.cJ = yn, S.cK = sd, S.cL = qo, S.cM = sh, S.cN = class {
          constructor(a) {
            this._marks = { start: [a.url, "start"].join("#"), end: [a.url, "end"].join("#"), measure: a.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let a = performance.getEntriesByName(this._marks.measure);
            return a.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), a = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), a;
          }
        }, S.cO = function(a, t, n, l, p) {
          return u(this, void 0, void 0, (function* () {
            if (ht()) try {
              return yield Os(a, t, n, l, p);
            } catch {
            }
            return (function(v, x, T, E, k) {
              const D = v.width, N = v.height;
              Xr && Yr || (Xr = new OffscreenCanvas(D, N), Yr = Xr.getContext("2d", { willReadFrequently: !0 })), Xr.width = D, Xr.height = N, Yr.drawImage(v, 0, 0, D, N);
              const q = Yr.getImageData(x, T, E, k);
              return Yr.clearRect(0, 0, D, N), q.data;
            })(a, t, n, l, p);
          }));
        }, S.cP = hp, S.cQ = U, S.cR = Ar, S.cS = xa, S.cT = ml, S.cU = function(a, t) {
          const n = /* @__PURE__ */ new Map();
          if (a != null) if (a.type === "Feature") n.set(Mc(a, t), a);
          else for (const l of a.features) n.set(Mc(l, t), l);
          return n;
        }, S.cV = function(a, t) {
          if (a == null) return !0;
          if (a.type === "Feature") return Mc(a, t) != null;
          if (a.type === "FeatureCollection") {
            const n = /* @__PURE__ */ new Set();
            for (const l of a.features) {
              const p = Mc(l, t);
              if (p == null || n.has(p)) return !1;
              n.add(p);
            }
            return !0;
          }
          return !1;
        }, S.cW = function(a, t, n) {
          var l, p, v, x;
          if (t.removeAll && a.clear(), t.remove) for (const T of t.remove) a.delete(T);
          if (t.add) for (const T of t.add) {
            const E = Mc(T, n);
            E != null && a.set(E, T);
          }
          if (t.update) for (const T of t.update) {
            let E = a.get(T.id);
            if (E == null) continue;
            const k = !T.removeAllProperties && (((l = T.removeProperties) === null || l === void 0 ? void 0 : l.length) > 0 || ((p = T.addOrUpdateProperties) === null || p === void 0 ? void 0 : p.length) > 0);
            if ((T.newGeometry || T.removeAllProperties || k) && (E = Object.assign({}, E), a.set(T.id, E), k && (E.properties = Object.assign({}, E.properties))), T.newGeometry && (E.geometry = T.newGeometry), T.removeAllProperties) E.properties = {};
            else if (((v = T.removeProperties) === null || v === void 0 ? void 0 : v.length) > 0) for (const D of T.removeProperties) Object.prototype.hasOwnProperty.call(E.properties, D) && delete E.properties[D];
            if (((x = T.addOrUpdateProperties) === null || x === void 0 ? void 0 : x.length) > 0) for (const { key: D, value: N } of T.addOrUpdateProperties) E.properties[D] = N;
          }
        }, S.cX = Br, S.ca = function(a, t) {
          return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a[8] = t[8], a[9] = t[9], a[10] = t[10], a[11] = t[11], a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15], a;
        }, S.cb = (a) => a.type === "symbol", S.cc = (a) => a.type === "circle", S.cd = (a) => a.type === "heatmap", S.ce = (a) => a.type === "line", S.cf = (a) => a.type === "fill", S.cg = (a) => a.type === "fill-extrusion", S.ch = (a) => a.type === "hillshade", S.ci = (a) => a.type === "color-relief", S.cj = (a) => a.type === "raster", S.ck = (a) => a.type === "background", S.cl = (a) => a.type === "custom", S.cm = dt, S.cn = function(a, t, n) {
          const l = Gt(t.x - n.x, t.y - n.y), p = Gt(a.x - n.x, a.y - n.y);
          var v, x;
          return po(Math.atan2(l[0] * p[1] - l[1] * p[0], (v = l)[0] * (x = p)[0] + v[1] * x[1]));
        }, S.co = Pt, S.cp = function(a, t) {
          return Ns[t] && (a instanceof MouseEvent || a instanceof WheelEvent);
        }, S.cq = function(a, t) {
          return Bs[t] && "touches" in a;
        }, S.cr = function(a) {
          return Bs[a] || Ns[a];
        }, S.cs = function(a, t, n) {
          var l = t[0], p = t[1];
          return a[0] = n[0] * l + n[4] * p + n[12], a[1] = n[1] * l + n[5] * p + n[13], a;
        }, S.ct = function(a, t) {
          const { x: n, y: l } = kl.fromLngLat(t);
          return !(a < 0 || a > 25 || l < 0 || l >= 1 || n < 0 || n >= 1);
        }, S.cu = function(a, t) {
          return a[0] = t[0], a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = t[1], a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = t[2], a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
        }, S.cv = class extends da {
        }, S.cw = jp, S.cy = function(a) {
          return a.message === js;
        }, S.cz = le, S.d = Ee, S.e = Ii, S.f = (a) => u(void 0, void 0, void 0, (function* () {
          if (a.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(a)], { type: "image/png" });
          try {
            return createImageBitmap(t);
          } catch (n) {
            throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        })), S.g = Y, S.h = (a) => new Promise(((t, n) => {
          const l = new Image();
          l.onload = () => {
            t(l), URL.revokeObjectURL(l.src), l.onload = null, window.requestAnimationFrame((() => {
              l.src = pr;
            }));
          }, l.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const p = new Blob([new Uint8Array(a)], { type: "image/png" });
          l.src = a.byteLength ? URL.createObjectURL(p) : pr;
        })), S.i = dr, S.j = (a, t) => ve(Ii(a, { type: "json" }), t), S.k = Ye, S.l = tt, S.m = ve, S.n = (a, t) => ve(Ii(a, { type: "arrayBuffer" }), t), S.o = function(a) {
          return new sh(a).readFields(cd, []);
        }, S.p = Ff, S.q = Qc, S.r = za, S.s = ho, S.t = Ws, S.u = mi, S.v = Ae, S.w = $i, S.x = au, S.y = tc, S.z = Po;
      })), M("worker", ["./shared"], (function(S) {
        class u {
          constructor(H) {
            this.keyCache = {}, H && this.replace(H);
          }
          replace(H) {
            this._layerConfigs = {}, this._layers = {}, this.update(H, []);
          }
          update(H, Y) {
            for (const le of H) {
              this._layerConfigs[le.id] = le;
              const me = this._layers[le.id] = S.bJ(le);
              me._featureFilter = S.aa(me.filter), this.keyCache[le.id] && delete this.keyCache[le.id];
            }
            for (const le of Y) delete this.keyCache[le], delete this._layerConfigs[le], delete this._layers[le];
            this.familiesBySource = {};
            const Q = S.cC(Object.values(this._layerConfigs), this.keyCache);
            for (const le of Q) {
              const me = le.map(((Ye) => this._layers[Ye.id])), ve = me[0];
              if (ve.visibility === "none") continue;
              const Ee = ve.source || "";
              let Te = this.familiesBySource[Ee];
              Te || (Te = this.familiesBySource[Ee] = {});
              const Ge = ve.sourceLayer || "_geojsonTileLayer";
              let tt = Te[Ge];
              tt || (tt = Te[Ge] = []), tt.push(me);
            }
          }
        }
        class O {
          constructor(H) {
            const Y = {}, Q = [];
            for (const Ee in H) {
              const Te = H[Ee], Ge = Y[Ee] = {};
              for (const tt in Te) {
                const Ye = Te[+tt];
                if (!Ye || Ye.bitmap.width === 0 || Ye.bitmap.height === 0) continue;
                const Mt = { x: 0, y: 0, w: Ye.bitmap.width + 2, h: Ye.bitmap.height + 2 };
                Q.push(Mt), Ge[tt] = { rect: Mt, metrics: Ye.metrics };
              }
            }
            const { w: le, h: me } = S.p(Q), ve = new S.q({ width: le || 1, height: me || 1 });
            for (const Ee in H) {
              const Te = H[Ee];
              for (const Ge in Te) {
                const tt = Te[+Ge];
                if (!tt || tt.bitmap.width === 0 || tt.bitmap.height === 0) continue;
                const Ye = Y[Ee][Ge].rect;
                S.q.copy(tt.bitmap, ve, { x: 0, y: 0 }, { x: Ye.x + 1, y: Ye.y + 1 }, tt.bitmap);
              }
            }
            this.image = ve, this.positions = Y;
          }
        }
        S.cD("GlyphAtlas", O);
        class U {
          constructor(H) {
            this.tileID = new S.Z(H.tileID.overscaledZ, H.tileID.wrap, H.tileID.canonical.z, H.tileID.canonical.x, H.tileID.canonical.y), this.uid = H.uid, this.zoom = H.zoom, this.pixelRatio = H.pixelRatio, this.tileSize = H.tileSize, this.source = H.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = H.showCollisionBoxes, this.collectResourceTiming = !!H.collectResourceTiming, this.returnDependencies = !!H.returnDependencies, this.promoteId = H.promoteId, this.inFlightDependencies = [], this.globalState = H.globalState;
          }
          parse(H, Y, Q, le, me) {
            return S._(this, void 0, void 0, (function* () {
              this.status = "parsing", this.data = H, this.collisionBoxArray = new S.a8();
              const ve = new S.cE(Object.keys(H.layers).sort()), Ee = new S.cF(this.tileID, this.promoteId);
              Ee.bucketLayerIDs = [];
              const Te = {}, Ge = { featureIndex: Ee, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: Q, subdivisionGranularity: me }, tt = Y.familiesBySource[this.source];
              for (const ci in tt) {
                const _i = H.layers[ci];
                if (!_i) continue;
                _i.version === 1 && S.w(`Vector tile source "${this.source}" layer "${ci}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const kn = ve.encode(ci), ot = [];
                for (let la = 0; la < _i.length; la++) {
                  const dn = _i.feature(la), Us = Ee.getId(dn, ci);
                  ot.push({ feature: dn, id: Us, index: la, sourceLayerIndex: kn });
                }
                for (const la of tt[ci]) {
                  const dn = la[0];
                  dn.source !== this.source && S.w(`layer.source = ${dn.source} does not equal this.source = ${this.source}`), dn.minzoom && this.zoom < Math.floor(dn.minzoom) || dn.maxzoom && this.zoom >= dn.maxzoom || dn.visibility !== "none" && (K(la, this.zoom, Q), (Te[dn.id] = dn.createBucket({ index: Ee.bucketLayerIDs.length, layers: la, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: kn, sourceID: this.source, globalState: this.globalState })).populate(ot, Ge, this.tileID.canonical), Ee.bucketLayerIDs.push(la.map(((Us) => Us.id))));
                }
              }
              const Ye = S.bN(Ge.glyphDependencies, ((ci) => Object.keys(ci).map(Number)));
              this.inFlightDependencies.forEach(((ci) => ci?.abort())), this.inFlightDependencies = [];
              let Mt = Promise.resolve({});
              if (Object.keys(Ye).length) {
                const ci = new AbortController();
                this.inFlightDependencies.push(ci), Mt = le.sendAsync({ type: "GG", data: { stacks: Ye, source: this.source, tileID: this.tileID, type: "glyphs" } }, ci);
              }
              const Ae = Object.keys(Ge.iconDependencies);
              let qt = Promise.resolve({});
              if (Ae.length) {
                const ci = new AbortController();
                this.inFlightDependencies.push(ci), qt = le.sendAsync({ type: "GI", data: { icons: Ae, source: this.source, tileID: this.tileID, type: "icons" } }, ci);
              }
              const ri = Object.keys(Ge.patternDependencies);
              let It = Promise.resolve({});
              if (ri.length) {
                const ci = new AbortController();
                this.inFlightDependencies.push(ci), It = le.sendAsync({ type: "GI", data: { icons: ri, source: this.source, tileID: this.tileID, type: "patterns" } }, ci);
              }
              const [ti, Yi, Pn] = yield Promise.all([Mt, qt, It]), xn = new O(ti), In = new S.cG(Yi, Pn);
              for (const ci in Te) {
                const _i = Te[ci];
                _i instanceof S.a9 ? (K(_i.layers, this.zoom, Q), S.cH({ bucket: _i, glyphMap: ti, glyphPositions: xn.positions, imageMap: Yi, imagePositions: In.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: Ge.subdivisionGranularity })) : _i.hasPattern && (_i instanceof S.cI || _i instanceof S.cJ || _i instanceof S.cK) && (K(_i.layers, this.zoom, Q), _i.addFeatures(Ge, this.tileID.canonical, In.patternPositions));
              }
              return this.status = "done", { buckets: Object.values(Te).filter(((ci) => !ci.isEmpty())), featureIndex: Ee, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: xn.image, imageAtlas: In, glyphMap: this.returnDependencies ? ti : null, iconMap: this.returnDependencies ? Yi : null, glyphPositions: this.returnDependencies ? xn.positions : null };
            }));
          }
        }
        function K(be, H, Y) {
          const Q = new S.F(H);
          for (const le of be) le.recalculate(Q, Y);
        }
        class ae {
          constructor(H, Y, Q) {
            this.actor = H, this.layerIndex = Y, this.availableImages = Q, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(H, Y) {
            return S._(this, void 0, void 0, (function* () {
              const Q = yield S.n(H.request, Y);
              try {
                return { vectorTile: new S.cL(new S.cM(Q.data)), rawData: Q.data, cacheControl: Q.cacheControl, expires: Q.expires };
              } catch (le) {
                const me = new Uint8Array(Q.data);
                let ve = `Unable to parse the tile at ${H.request.url}, `;
                throw ve += me[0] === 31 && me[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${le.message}`, new Error(ve);
              }
            }));
          }
          loadTile(H) {
            return S._(this, void 0, void 0, (function* () {
              const Y = H.uid, Q = !!(H && H.request && H.request.collectResourceTiming) && new S.cN(H.request), le = new U(H);
              this.loading[Y] = le;
              const me = new AbortController();
              le.abort = me;
              try {
                const ve = yield this.loadVectorTile(H, me);
                if (delete this.loading[Y], !ve) return null;
                const Ee = ve.rawData, Te = {};
                ve.expires && (Te.expires = ve.expires), ve.cacheControl && (Te.cacheControl = ve.cacheControl);
                const Ge = {};
                if (Q) {
                  const Ye = Q.finish();
                  Ye && (Ge.resourceTiming = JSON.parse(JSON.stringify(Ye)));
                }
                le.vectorTile = ve.vectorTile;
                const tt = le.parse(ve.vectorTile, this.layerIndex, this.availableImages, this.actor, H.subdivisionGranularity);
                this.loaded[Y] = le, this.fetching[Y] = { rawTileData: Ee, cacheControl: Te, resourceTiming: Ge };
                try {
                  const Ye = yield tt;
                  return S.e({ rawTileData: Ee.slice(0) }, Ye, Te, Ge);
                } finally {
                  delete this.fetching[Y];
                }
              } catch (ve) {
                throw delete this.loading[Y], le.status = "done", this.loaded[Y] = le, ve;
              }
            }));
          }
          reloadTile(H) {
            return S._(this, void 0, void 0, (function* () {
              const Y = H.uid;
              if (!this.loaded || !this.loaded[Y]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const Q = this.loaded[Y];
              if (Q.showCollisionBoxes = H.showCollisionBoxes, Q.globalState = H.globalState, Q.status === "parsing") {
                const le = yield Q.parse(Q.vectorTile, this.layerIndex, this.availableImages, this.actor, H.subdivisionGranularity);
                let me;
                if (this.fetching[Y]) {
                  const { rawTileData: ve, cacheControl: Ee, resourceTiming: Te } = this.fetching[Y];
                  delete this.fetching[Y], me = S.e({ rawTileData: ve.slice(0) }, le, Ee, Te);
                } else me = le;
                return me;
              }
              if (Q.status === "done" && Q.vectorTile) return Q.parse(Q.vectorTile, this.layerIndex, this.availableImages, this.actor, H.subdivisionGranularity);
            }));
          }
          abortTile(H) {
            return S._(this, void 0, void 0, (function* () {
              const Y = this.loading, Q = H.uid;
              Y && Y[Q] && Y[Q].abort && (Y[Q].abort.abort(), delete Y[Q]);
            }));
          }
          removeTile(H) {
            return S._(this, void 0, void 0, (function* () {
              this.loaded && this.loaded[H.uid] && delete this.loaded[H.uid];
            }));
          }
        }
        class he {
          constructor() {
            this.loaded = {};
          }
          loadTile(H) {
            return S._(this, void 0, void 0, (function* () {
              const { uid: Y, encoding: Q, rawImageData: le, redFactor: me, greenFactor: ve, blueFactor: Ee, baseShift: Te } = H, Ge = le.width + 2, tt = le.height + 2, Ye = S.b(le) ? new S.R({ width: Ge, height: tt }, yield S.cO(le, -1, -1, Ge, tt)) : le, Mt = new S.cP(Y, Ye, Q, me, ve, Ee, Te);
              return this.loaded = this.loaded || {}, this.loaded[Y] = Mt, Mt;
            }));
          }
          removeTile(H) {
            const Y = this.loaded, Q = H.uid;
            Y && Y[Q] && delete Y[Q];
          }
        }
        var J, ke, qe = (function() {
          if (ke) return J;
          function be(Y, Q) {
            if (Y.length !== 0) {
              H(Y[0], Q);
              for (var le = 1; le < Y.length; le++) H(Y[le], !Q);
            }
          }
          function H(Y, Q) {
            for (var le = 0, me = 0, ve = 0, Ee = Y.length, Te = Ee - 1; ve < Ee; Te = ve++) {
              var Ge = (Y[ve][0] - Y[Te][0]) * (Y[Te][1] + Y[ve][1]), tt = le + Ge;
              me += Math.abs(le) >= Math.abs(Ge) ? le - tt + Ge : Ge - tt + le, le = tt;
            }
            le + me >= 0 != !!Q && Y.reverse();
          }
          return ke = 1, J = function Y(Q, le) {
            var me, ve = Q && Q.type;
            if (ve === "FeatureCollection") for (me = 0; me < Q.features.length; me++) Y(Q.features[me], le);
            else if (ve === "GeometryCollection") for (me = 0; me < Q.geometries.length; me++) Y(Q.geometries[me], le);
            else if (ve === "Feature") Y(Q.geometry, le);
            else if (ve === "Polygon") be(Q.coordinates, le);
            else if (ve === "MultiPolygon") for (me = 0; me < Q.coordinates.length; me++) be(Q.coordinates[me], le);
            return Q;
          };
        })(), ft = S.cQ(qe);
        class ht extends S.cS {
          constructor(H, Y) {
            super(new S.cM(), 0, Y, [], []), this.feature = H, this.type = H.type, this.properties = H.tags ? H.tags : {}, "id" in H && (typeof H.id == "string" ? this.id = parseInt(H.id, 10) : typeof H.id != "number" || isNaN(H.id) || (this.id = H.id));
          }
          loadGeometry() {
            const H = [], Y = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const Q of Y) {
              const le = [];
              for (const me of Q) le.push(new S.P(me[0], me[1]));
              H.push(le);
            }
            return H;
          }
        }
        class it extends S.cR {
          constructor(H, Y) {
            super(new S.cM()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = Y ? Y.version : 1, this.extent = Y ? Y.extent : 4096, this.length = H.length, this.features = H;
          }
          feature(H) {
            return new ht(this.features[H], this.extent);
          }
        }
        function nt(be, H) {
          H.writeVarintField(15, be.version || 1), H.writeStringField(1, be.name || ""), H.writeVarintField(5, be.extent || 4096);
          const Y = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let me = 0; me < be.length; me++) Y.feature = be.feature(me), H.writeMessage(2, De, Y);
          const Q = Y.keys;
          for (const me of Q) H.writeStringField(3, me);
          const le = Y.values;
          for (const me of le) H.writeMessage(4, Ht, me);
        }
        function De(be, H) {
          if (!be.feature) return;
          const Y = be.feature;
          Y.id !== void 0 && H.writeVarintField(1, Y.id), H.writeMessage(2, Re, be), H.writeVarintField(3, Y.type), H.writeMessage(4, wt, Y);
        }
        function Re(be, H) {
          for (const Y in be.feature?.properties) {
            let Q = be.feature.properties[Y], le = be.keycache[Y];
            if (Q === null) continue;
            le === void 0 && (be.keys.push(Y), le = be.keys.length - 1, be.keycache[Y] = le), H.writeVarint(le), typeof Q != "string" && typeof Q != "boolean" && typeof Q != "number" && (Q = JSON.stringify(Q));
            const me = typeof Q + ":" + Q;
            let ve = be.valuecache[me];
            ve === void 0 && (be.values.push(Q), ve = be.values.length - 1, be.valuecache[me] = ve), H.writeVarint(ve);
          }
        }
        function $e(be, H) {
          return (H << 3) + (7 & be);
        }
        function rt(be) {
          return be << 1 ^ be >> 31;
        }
        function wt(be, H) {
          const Y = be.loadGeometry(), Q = be.type;
          let le = 0, me = 0;
          for (const ve of Y) {
            let Ee = 1;
            Q === 1 && (Ee = ve.length), H.writeVarint($e(1, Ee));
            const Te = Q === 3 ? ve.length - 1 : ve.length;
            for (let Ge = 0; Ge < Te; Ge++) {
              Ge === 1 && Q !== 1 && H.writeVarint($e(2, Te - 1));
              const tt = ve[Ge].x - le, Ye = ve[Ge].y - me;
              H.writeVarint(rt(tt)), H.writeVarint(rt(Ye)), le += tt, me += Ye;
            }
            be.type === 3 && H.writeVarint($e(7, 1));
          }
        }
        function Ht(be, H) {
          const Y = typeof be;
          Y === "string" ? H.writeStringField(1, be) : Y === "boolean" ? H.writeBooleanField(7, be) : Y === "number" && (be % 1 != 0 ? H.writeDoubleField(3, be) : be < 0 ? H.writeSVarintField(6, be) : H.writeVarintField(5, be));
        }
        const Dt = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (be) => be }, Xt = Math.fround || (pi = new Float32Array(1), (be) => (pi[0] = +be, pi[0]));
        var pi;
        class vn {
          constructor(H) {
            this.options = Object.assign(Object.create(Dt), H), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(H) {
            const { log: Y, minZoom: Q, maxZoom: le } = this.options;
            Y && console.time("total time");
            const me = `prepare ${H.length} points`;
            Y && console.time(me), this.points = H;
            const ve = [];
            for (let Te = 0; Te < H.length; Te++) {
              const Ge = H[Te];
              if (!Ge.geometry) continue;
              const [tt, Ye] = Ge.geometry.coordinates, Mt = Xt(He(tt)), Ae = Xt(vt(Ye));
              ve.push(Mt, Ae, 1 / 0, Te, -1, 1), this.options.reduce && ve.push(0);
            }
            let Ee = this.trees[le + 1] = this._createTree(ve);
            Y && console.timeEnd(me);
            for (let Te = le; Te >= Q; Te--) {
              const Ge = +Date.now();
              Ee = this.trees[Te] = this._createTree(this._cluster(Ee, Te)), Y && console.log("z%d: %d clusters in %dms", Te, Ee.numItems, +Date.now() - Ge);
            }
            return Y && console.timeEnd("total time"), this;
          }
          getClusters(H, Y) {
            let Q = ((H[0] + 180) % 360 + 360) % 360 - 180;
            const le = Math.max(-90, Math.min(90, H[1]));
            let me = H[2] === 180 ? 180 : ((H[2] + 180) % 360 + 360) % 360 - 180;
            const ve = Math.max(-90, Math.min(90, H[3]));
            if (H[2] - H[0] >= 360) Q = -180, me = 180;
            else if (Q > me) {
              const Ye = this.getClusters([Q, le, 180, ve], Y), Mt = this.getClusters([-180, le, me, ve], Y);
              return Ye.concat(Mt);
            }
            const Ee = this.trees[this._limitZoom(Y)], Te = Ee.range(He(Q), vt(ve), He(me), vt(le)), Ge = Ee.data, tt = [];
            for (const Ye of Te) {
              const Mt = this.stride * Ye;
              tt.push(Ge[Mt + 5] > 1 ? Cn(Ge, Mt, this.clusterProps) : this.points[Ge[Mt + 3]]);
            }
            return tt;
          }
          getChildren(H) {
            const Y = this._getOriginId(H), Q = this._getOriginZoom(H), le = "No cluster with the specified id.", me = this.trees[Q];
            if (!me) throw new Error(le);
            const ve = me.data;
            if (Y * this.stride >= ve.length) throw new Error(le);
            const Ee = this.options.radius / (this.options.extent * Math.pow(2, Q - 1)), Te = me.within(ve[Y * this.stride], ve[Y * this.stride + 1], Ee), Ge = [];
            for (const tt of Te) {
              const Ye = tt * this.stride;
              ve[Ye + 4] === H && Ge.push(ve[Ye + 5] > 1 ? Cn(ve, Ye, this.clusterProps) : this.points[ve[Ye + 3]]);
            }
            if (Ge.length === 0) throw new Error(le);
            return Ge;
          }
          getLeaves(H, Y, Q) {
            const le = [];
            return this._appendLeaves(le, H, Y = Y || 10, Q = Q || 0, 0), le;
          }
          getTile(H, Y, Q) {
            const le = this.trees[this._limitZoom(H)], me = Math.pow(2, H), { extent: ve, radius: Ee } = this.options, Te = Ee / ve, Ge = (Q - Te) / me, tt = (Q + 1 + Te) / me, Ye = { features: [] };
            return this._addTileFeatures(le.range((Y - Te) / me, Ge, (Y + 1 + Te) / me, tt), le.data, Y, Q, me, Ye), Y === 0 && this._addTileFeatures(le.range(1 - Te / me, Ge, 1, tt), le.data, me, Q, me, Ye), Y === me - 1 && this._addTileFeatures(le.range(0, Ge, Te / me, tt), le.data, -1, Q, me, Ye), Ye.features.length ? Ye : null;
          }
          getClusterExpansionZoom(H) {
            let Y = this._getOriginZoom(H) - 1;
            for (; Y <= this.options.maxZoom; ) {
              const Q = this.getChildren(H);
              if (Y++, Q.length !== 1) break;
              H = Q[0].properties.cluster_id;
            }
            return Y;
          }
          _appendLeaves(H, Y, Q, le, me) {
            const ve = this.getChildren(Y);
            for (const Ee of ve) {
              const Te = Ee.properties;
              if (Te && Te.cluster ? me + Te.point_count <= le ? me += Te.point_count : me = this._appendLeaves(H, Te.cluster_id, Q, le, me) : me < le ? me++ : H.push(Ee), H.length === Q) break;
            }
            return me;
          }
          _createTree(H) {
            const Y = new S.aI(H.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let Q = 0; Q < H.length; Q += this.stride) Y.add(H[Q], H[Q + 1]);
            return Y.finish(), Y.data = H, Y;
          }
          _addTileFeatures(H, Y, Q, le, me, ve) {
            for (const Ee of H) {
              const Te = Ee * this.stride, Ge = Y[Te + 5] > 1;
              let tt, Ye, Mt;
              if (Ge) tt = zn(Y, Te, this.clusterProps), Ye = Y[Te], Mt = Y[Te + 1];
              else {
                const ri = this.points[Y[Te + 3]];
                tt = ri.properties;
                const [It, ti] = ri.geometry.coordinates;
                Ye = He(It), Mt = vt(ti);
              }
              const Ae = { type: 1, geometry: [[Math.round(this.options.extent * (Ye * me - Q)), Math.round(this.options.extent * (Mt * me - le))]], tags: tt };
              let qt;
              qt = Ge || this.options.generateId ? Y[Te + 3] : this.points[Y[Te + 3]].id, qt !== void 0 && (Ae.id = qt), ve.features.push(Ae);
            }
          }
          _limitZoom(H) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+H), this.options.maxZoom + 1));
          }
          _cluster(H, Y) {
            const { radius: Q, extent: le, reduce: me, minPoints: ve } = this.options, Ee = Q / (le * Math.pow(2, Y)), Te = H.data, Ge = [], tt = this.stride;
            for (let Ye = 0; Ye < Te.length; Ye += tt) {
              if (Te[Ye + 2] <= Y) continue;
              Te[Ye + 2] = Y;
              const Mt = Te[Ye], Ae = Te[Ye + 1], qt = H.within(Te[Ye], Te[Ye + 1], Ee), ri = Te[Ye + 5];
              let It = ri;
              for (const ti of qt) {
                const Yi = ti * tt;
                Te[Yi + 2] > Y && (It += Te[Yi + 5]);
              }
              if (It > ri && It >= ve) {
                let ti, Yi = Mt * ri, Pn = Ae * ri, xn = -1;
                const In = (Ye / tt << 5) + (Y + 1) + this.points.length;
                for (const ci of qt) {
                  const _i = ci * tt;
                  if (Te[_i + 2] <= Y) continue;
                  Te[_i + 2] = Y;
                  const kn = Te[_i + 5];
                  Yi += Te[_i] * kn, Pn += Te[_i + 1] * kn, Te[_i + 4] = In, me && (ti || (ti = this._map(Te, Ye, !0), xn = this.clusterProps.length, this.clusterProps.push(ti)), me(ti, this._map(Te, _i)));
                }
                Te[Ye + 4] = In, Ge.push(Yi / It, Pn / It, 1 / 0, In, -1, It), me && Ge.push(xn);
              } else {
                for (let ti = 0; ti < tt; ti++) Ge.push(Te[Ye + ti]);
                if (It > 1) for (const ti of qt) {
                  const Yi = ti * tt;
                  if (!(Te[Yi + 2] <= Y)) {
                    Te[Yi + 2] = Y;
                    for (let Pn = 0; Pn < tt; Pn++) Ge.push(Te[Yi + Pn]);
                  }
                }
              }
            }
            return Ge;
          }
          _getOriginId(H) {
            return H - this.points.length >> 5;
          }
          _getOriginZoom(H) {
            return (H - this.points.length) % 32;
          }
          _map(H, Y, Q) {
            if (H[Y + 5] > 1) {
              const ve = this.clusterProps[H[Y + 6]];
              return Q ? Object.assign({}, ve) : ve;
            }
            const le = this.points[H[Y + 3]].properties, me = this.options.map(le);
            return Q && me === le ? Object.assign({}, me) : me;
          }
        }
        function Cn(be, H, Y) {
          return { type: "Feature", id: be[H + 3], properties: zn(be, H, Y), geometry: { type: "Point", coordinates: [(Q = be[H], 360 * (Q - 0.5)), Gt(be[H + 1])] } };
          var Q;
        }
        function zn(be, H, Y) {
          const Q = be[H + 5], le = Q >= 1e4 ? `${Math.round(Q / 1e3)}k` : Q >= 1e3 ? Math.round(Q / 100) / 10 + "k" : Q, me = be[H + 6], ve = me === -1 ? {} : Object.assign({}, Y[me]);
          return Object.assign(ve, { cluster: !0, cluster_id: be[H + 3], point_count: Q, point_count_abbreviated: le });
        }
        function He(be) {
          return be / 360 + 0.5;
        }
        function vt(be) {
          const H = Math.sin(be * Math.PI / 180), Y = 0.5 - 0.25 * Math.log((1 + H) / (1 - H)) / Math.PI;
          return Y < 0 ? 0 : Y > 1 ? 1 : Y;
        }
        function Gt(be) {
          const H = (180 - 360 * be) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(H)) / Math.PI - 90;
        }
        function at(be, H, Y, Q) {
          let le = Q;
          const me = H + (Y - H >> 1);
          let ve, Ee = Y - H;
          const Te = be[H], Ge = be[H + 1], tt = be[Y], Ye = be[Y + 1];
          for (let Mt = H + 3; Mt < Y; Mt += 3) {
            const Ae = Et(be[Mt], be[Mt + 1], Te, Ge, tt, Ye);
            if (Ae > le) ve = Mt, le = Ae;
            else if (Ae === le) {
              const qt = Math.abs(Mt - me);
              qt < Ee && (ve = Mt, Ee = qt);
            }
          }
          le > Q && (ve - H > 3 && at(be, H, ve, Q), be[ve + 2] = le, Y - ve > 3 && at(be, ve, Y, Q));
        }
        function Et(be, H, Y, Q, le, me) {
          let ve = le - Y, Ee = me - Q;
          if (ve !== 0 || Ee !== 0) {
            const Te = ((be - Y) * ve + (H - Q) * Ee) / (ve * ve + Ee * Ee);
            Te > 1 ? (Y = le, Q = me) : Te > 0 && (Y += ve * Te, Q += Ee * Te);
          }
          return ve = be - Y, Ee = H - Q, ve * ve + Ee * Ee;
        }
        function fe(be, H, Y, Q) {
          const le = { id: be ?? null, type: H, geometry: Y, tags: Q, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (H === "Point" || H === "MultiPoint" || H === "LineString") Ue(le, Y);
          else if (H === "Polygon") Ue(le, Y[0]);
          else if (H === "MultiLineString") for (const me of Y) Ue(le, me);
          else if (H === "MultiPolygon") for (const me of Y) Ue(le, me[0]);
          return le;
        }
        function Ue(be, H) {
          for (let Y = 0; Y < H.length; Y += 3) be.minX = Math.min(be.minX, H[Y]), be.minY = Math.min(be.minY, H[Y + 1]), be.maxX = Math.max(be.maxX, H[Y]), be.maxY = Math.max(be.maxY, H[Y + 1]);
        }
        function et(be, H, Y, Q) {
          if (!H.geometry) return;
          const le = H.geometry.coordinates;
          if (le && le.length === 0) return;
          const me = H.geometry.type, ve = Math.pow(Y.tolerance / ((1 << Y.maxZoom) * Y.extent), 2);
          let Ee = [], Te = H.id;
          if (Y.promoteId ? Te = H.properties[Y.promoteId] : Y.generateId && (Te = Q || 0), me === "Point") dt(le, Ee);
          else if (me === "MultiPoint") for (const Ge of le) dt(Ge, Ee);
          else if (me === "LineString") Pt(le, Ee, ve, !1);
          else if (me === "MultiLineString") {
            if (Y.lineMetrics) {
              for (const Ge of le) Ee = [], Pt(Ge, Ee, ve, !1), be.push(fe(Te, "LineString", Ee, H.properties));
              return;
            }
            Vt(le, Ee, ve, !1);
          } else if (me === "Polygon") Vt(le, Ee, ve, !0);
          else {
            if (me !== "MultiPolygon") {
              if (me === "GeometryCollection") {
                for (const Ge of H.geometry.geometries) et(be, { id: Te, geometry: Ge, properties: H.properties }, Y, Q);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const Ge of le) {
              const tt = [];
              Vt(Ge, tt, ve, !0), Ee.push(tt);
            }
          }
          be.push(fe(Te, me, Ee, H.properties));
        }
        function dt(be, H) {
          H.push(si(be[0]), Ii(be[1]), 0);
        }
        function Pt(be, H, Y, Q) {
          let le, me, ve = 0;
          for (let Te = 0; Te < be.length; Te++) {
            const Ge = si(be[Te][0]), tt = Ii(be[Te][1]);
            H.push(Ge, tt, 0), Te > 0 && (ve += Q ? (le * tt - Ge * me) / 2 : Math.sqrt(Math.pow(Ge - le, 2) + Math.pow(tt - me, 2))), le = Ge, me = tt;
          }
          const Ee = H.length - 3;
          H[2] = 1, at(H, 0, Ee, Y), H[Ee + 2] = 1, H.size = Math.abs(ve), H.start = 0, H.end = H.size;
        }
        function Vt(be, H, Y, Q) {
          for (let le = 0; le < be.length; le++) {
            const me = [];
            Pt(be[le], me, Y, Q), H.push(me);
          }
        }
        function si(be) {
          return be / 360 + 0.5;
        }
        function Ii(be) {
          const H = Math.sin(be * Math.PI / 180), Y = 0.5 - 0.25 * Math.log((1 + H) / (1 - H)) / Math.PI;
          return Y < 0 ? 0 : Y > 1 ? 1 : Y;
        }
        function xi(be, H, Y, Q, le, me, ve, Ee) {
          if (Q /= H, me >= (Y /= H) && ve < Q) return be;
          if (ve < Y || me >= Q) return null;
          const Te = [];
          for (const Ge of be) {
            const tt = Ge.geometry;
            let Ye = Ge.type;
            const Mt = le === 0 ? Ge.minX : Ge.minY, Ae = le === 0 ? Ge.maxX : Ge.maxY;
            if (Mt >= Y && Ae < Q) {
              Te.push(Ge);
              continue;
            }
            if (Ae < Y || Mt >= Q) continue;
            let qt = [];
            if (Ye === "Point" || Ye === "MultiPoint") Ta(tt, qt, Y, Q, le);
            else if (Ye === "LineString") bi(tt, qt, Y, Q, le, !1, Ee.lineMetrics);
            else if (Ye === "MultiLineString") an(tt, qt, Y, Q, le, !1);
            else if (Ye === "Polygon") an(tt, qt, Y, Q, le, !0);
            else if (Ye === "MultiPolygon") for (const ri of tt) {
              const It = [];
              an(ri, It, Y, Q, le, !0), It.length && qt.push(It);
            }
            if (qt.length) {
              if (Ee.lineMetrics && Ye === "LineString") {
                for (const ri of qt) Te.push(fe(Ge.id, Ye, ri, Ge.tags));
                continue;
              }
              Ye !== "LineString" && Ye !== "MultiLineString" || (qt.length === 1 ? (Ye = "LineString", qt = qt[0]) : Ye = "MultiLineString"), Ye !== "Point" && Ye !== "MultiPoint" || (Ye = qt.length === 3 ? "Point" : "MultiPoint"), Te.push(fe(Ge.id, Ye, qt, Ge.tags));
            }
          }
          return Te.length ? Te : null;
        }
        function Ta(be, H, Y, Q, le) {
          for (let me = 0; me < be.length; me += 3) {
            const ve = be[me + le];
            ve >= Y && ve <= Q && $i(H, be[me], be[me + 1], be[me + 2]);
          }
        }
        function bi(be, H, Y, Q, le, me, ve) {
          let Ee = oa(be);
          const Te = le === 0 ? ma : dr;
          let Ge, tt, Ye = be.start;
          for (let It = 0; It < be.length - 3; It += 3) {
            const ti = be[It], Yi = be[It + 1], Pn = be[It + 2], xn = be[It + 3], In = be[It + 4], ci = le === 0 ? ti : Yi, _i = le === 0 ? xn : In;
            let kn = !1;
            ve && (Ge = Math.sqrt(Math.pow(ti - xn, 2) + Math.pow(Yi - In, 2))), ci < Y ? _i > Y && (tt = Te(Ee, ti, Yi, xn, In, Y), ve && (Ee.start = Ye + Ge * tt)) : ci > Q ? _i < Q && (tt = Te(Ee, ti, Yi, xn, In, Q), ve && (Ee.start = Ye + Ge * tt)) : $i(Ee, ti, Yi, Pn), _i < Y && ci >= Y && (tt = Te(Ee, ti, Yi, xn, In, Y), kn = !0), _i > Q && ci <= Q && (tt = Te(Ee, ti, Yi, xn, In, Q), kn = !0), !me && kn && (ve && (Ee.end = Ye + Ge * tt), H.push(Ee), Ee = oa(be)), ve && (Ye += Ge);
          }
          let Mt = be.length - 3;
          const Ae = be[Mt], qt = be[Mt + 1], ri = le === 0 ? Ae : qt;
          ri >= Y && ri <= Q && $i(Ee, Ae, qt, be[Mt + 2]), Mt = Ee.length - 3, me && Mt >= 3 && (Ee[Mt] !== Ee[0] || Ee[Mt + 1] !== Ee[1]) && $i(Ee, Ee[0], Ee[1], Ee[2]), Ee.length && H.push(Ee);
        }
        function oa(be) {
          const H = [];
          return H.size = be.size, H.start = be.start, H.end = be.end, H;
        }
        function an(be, H, Y, Q, le, me) {
          for (const ve of be) bi(ve, H, Y, Q, le, me, !1);
        }
        function $i(be, H, Y, Q) {
          be.push(H, Y, Q);
        }
        function ma(be, H, Y, Q, le, me) {
          const ve = (me - H) / (Q - H);
          return $i(be, me, Y + (le - Y) * ve, 1), ve;
        }
        function dr(be, H, Y, Q, le, me) {
          const ve = (me - Y) / (le - Y);
          return $i(be, H + (Q - H) * ve, me, 1), ve;
        }
        function Xa(be, H) {
          const Y = [];
          for (let Q = 0; Q < be.length; Q++) {
            const le = be[Q], me = le.type;
            let ve;
            if (me === "Point" || me === "MultiPoint" || me === "LineString") ve = Ya(le.geometry, H);
            else if (me === "MultiLineString" || me === "Polygon") {
              ve = [];
              for (const Ee of le.geometry) ve.push(Ya(Ee, H));
            } else if (me === "MultiPolygon") {
              ve = [];
              for (const Ee of le.geometry) {
                const Te = [];
                for (const Ge of Ee) Te.push(Ya(Ge, H));
                ve.push(Te);
              }
            }
            Y.push(fe(le.id, me, ve, le.tags));
          }
          return Y;
        }
        function Ya(be, H) {
          const Y = [];
          Y.size = be.size, be.start !== void 0 && (Y.start = be.start, Y.end = be.end);
          for (let Q = 0; Q < be.length; Q += 3) Y.push(be[Q] + H, be[Q + 1], be[Q + 2]);
          return Y;
        }
        function pr(be, H) {
          if (be.transformed) return be;
          const Y = 1 << be.z, Q = be.x, le = be.y;
          for (const me of be.features) {
            const ve = me.geometry, Ee = me.type;
            if (me.geometry = [], Ee === 1) for (let Te = 0; Te < ve.length; Te += 2) me.geometry.push(Os(ve[Te], ve[Te + 1], H, Y, Q, le));
            else for (let Te = 0; Te < ve.length; Te++) {
              const Ge = [];
              for (let tt = 0; tt < ve[Te].length; tt += 2) Ge.push(Os(ve[Te][tt], ve[Te][tt + 1], H, Y, Q, le));
              me.geometry.push(Ge);
            }
          }
          return be.transformed = !0, be;
        }
        function Os(be, H, Y, Q, le, me) {
          return [Math.round(Y * (be * Q - le)), Math.round(Y * (H * Q - me))];
        }
        function Xr(be, H, Y, Q, le) {
          const me = H === le.maxZoom ? 0 : le.tolerance / ((1 << H) * le.extent), ve = { features: [], numPoints: 0, numSimplified: 0, numFeatures: be.length, source: null, x: Y, y: Q, z: H, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const Ee of be) Yr(ve, Ee, me, le);
          return ve;
        }
        function Yr(be, H, Y, Q) {
          const le = H.geometry, me = H.type, ve = [];
          if (be.minX = Math.min(be.minX, H.minX), be.minY = Math.min(be.minY, H.minY), be.maxX = Math.max(be.maxX, H.maxX), be.maxY = Math.max(be.maxY, H.maxY), me === "Point" || me === "MultiPoint") for (let Ee = 0; Ee < le.length; Ee += 3) ve.push(le[Ee], le[Ee + 1]), be.numPoints++, be.numSimplified++;
          else if (me === "LineString") ho(ve, le, be, Y, !1, !1);
          else if (me === "MultiLineString" || me === "Polygon") for (let Ee = 0; Ee < le.length; Ee++) ho(ve, le[Ee], be, Y, me === "Polygon", Ee === 0);
          else if (me === "MultiPolygon") for (let Ee = 0; Ee < le.length; Ee++) {
            const Te = le[Ee];
            for (let Ge = 0; Ge < Te.length; Ge++) ho(ve, Te[Ge], be, Y, !0, Ge === 0);
          }
          if (ve.length) {
            let Ee = H.tags || null;
            if (me === "LineString" && Q.lineMetrics) {
              Ee = {};
              for (const Ge in H.tags) Ee[Ge] = H.tags[Ge];
              Ee.mapbox_clip_start = le.start / le.size, Ee.mapbox_clip_end = le.end / le.size;
            }
            const Te = { geometry: ve, type: me === "Polygon" || me === "MultiPolygon" ? 3 : me === "LineString" || me === "MultiLineString" ? 2 : 1, tags: Ee };
            H.id !== null && (Te.id = H.id), be.features.push(Te);
          }
        }
        function ho(be, H, Y, Q, le, me) {
          const ve = Q * Q;
          if (Q > 0 && H.size < (le ? ve : Q)) return void (Y.numPoints += H.length / 3);
          const Ee = [];
          for (let Te = 0; Te < H.length; Te += 3) (Q === 0 || H[Te + 2] > ve) && (Y.numSimplified++, Ee.push(H[Te], H[Te + 1])), Y.numPoints++;
          le && (function(Te, Ge) {
            let tt = 0;
            for (let Ye = 0, Mt = Te.length, Ae = Mt - 2; Ye < Mt; Ae = Ye, Ye += 2) tt += (Te[Ye] - Te[Ae]) * (Te[Ye + 1] + Te[Ae + 1]);
            if (tt > 0 === Ge) for (let Ye = 0, Mt = Te.length; Ye < Mt / 2; Ye += 2) {
              const Ae = Te[Ye], qt = Te[Ye + 1];
              Te[Ye] = Te[Mt - 2 - Ye], Te[Ye + 1] = Te[Mt - 1 - Ye], Te[Mt - 2 - Ye] = Ae, Te[Mt - 1 - Ye] = qt;
            }
          })(Ee, me), be.push(Ee);
        }
        const Yn = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
        class po {
          constructor(H, Y) {
            const Q = (Y = this.options = (function(me, ve) {
              for (const Ee in ve) me[Ee] = ve[Ee];
              return me;
            })(Object.create(Yn), Y)).debug;
            if (Q && console.time("preprocess data"), Y.maxZoom < 0 || Y.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (Y.promoteId && Y.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let le = (function(me, ve) {
              const Ee = [];
              if (me.type === "FeatureCollection") for (let Te = 0; Te < me.features.length; Te++) et(Ee, me.features[Te], ve, Te);
              else et(Ee, me.type === "Feature" ? me : { geometry: me }, ve);
              return Ee;
            })(H, Y);
            this.tiles = {}, this.tileCoords = [], Q && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", Y.indexMaxZoom, Y.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), le = (function(me, ve) {
              const Ee = ve.buffer / ve.extent;
              let Te = me;
              const Ge = xi(me, 1, -1 - Ee, Ee, 0, -1, 2, ve), tt = xi(me, 1, 1 - Ee, 2 + Ee, 0, -1, 2, ve);
              return (Ge || tt) && (Te = xi(me, 1, -Ee, 1 + Ee, 0, -1, 2, ve) || [], Ge && (Te = Xa(Ge, 1).concat(Te)), tt && (Te = Te.concat(Xa(tt, -1)))), Te;
            })(le, Y), le.length && this.splitTile(le, 0, 0, 0), Q && (le.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(H, Y, Q, le, me, ve, Ee) {
            const Te = [H, Y, Q, le], Ge = this.options, tt = Ge.debug;
            for (; Te.length; ) {
              le = Te.pop(), Q = Te.pop(), Y = Te.pop(), H = Te.pop();
              const Ye = 1 << Y, Mt = Bs(Y, Q, le);
              let Ae = this.tiles[Mt];
              if (!Ae && (tt > 1 && console.time("creation"), Ae = this.tiles[Mt] = Xr(H, Y, Q, le, Ge), this.tileCoords.push({ z: Y, x: Q, y: le }), tt)) {
                tt > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", Y, Q, le, Ae.numFeatures, Ae.numPoints, Ae.numSimplified), console.timeEnd("creation"));
                const kn = `z${Y}`;
                this.stats[kn] = (this.stats[kn] || 0) + 1, this.total++;
              }
              if (Ae.source = H, me == null) {
                if (Y === Ge.indexMaxZoom || Ae.numPoints <= Ge.indexMaxPoints) continue;
              } else {
                if (Y === Ge.maxZoom || Y === me) continue;
                if (me != null) {
                  const kn = me - Y;
                  if (Q !== ve >> kn || le !== Ee >> kn) continue;
                }
              }
              if (Ae.source = null, H.length === 0) continue;
              tt > 1 && console.time("clipping");
              const qt = 0.5 * Ge.buffer / Ge.extent, ri = 0.5 - qt, It = 0.5 + qt, ti = 1 + qt;
              let Yi = null, Pn = null, xn = null, In = null, ci = xi(H, Ye, Q - qt, Q + It, 0, Ae.minX, Ae.maxX, Ge), _i = xi(H, Ye, Q + ri, Q + ti, 0, Ae.minX, Ae.maxX, Ge);
              H = null, ci && (Yi = xi(ci, Ye, le - qt, le + It, 1, Ae.minY, Ae.maxY, Ge), Pn = xi(ci, Ye, le + ri, le + ti, 1, Ae.minY, Ae.maxY, Ge), ci = null), _i && (xn = xi(_i, Ye, le - qt, le + It, 1, Ae.minY, Ae.maxY, Ge), In = xi(_i, Ye, le + ri, le + ti, 1, Ae.minY, Ae.maxY, Ge), _i = null), tt > 1 && console.timeEnd("clipping"), Te.push(Yi || [], Y + 1, 2 * Q, 2 * le), Te.push(Pn || [], Y + 1, 2 * Q, 2 * le + 1), Te.push(xn || [], Y + 1, 2 * Q + 1, 2 * le), Te.push(In || [], Y + 1, 2 * Q + 1, 2 * le + 1);
            }
          }
          getTile(H, Y, Q) {
            H = +H, Y = +Y, Q = +Q;
            const le = this.options, { extent: me, debug: ve } = le;
            if (H < 0 || H > 24) return null;
            const Ee = 1 << H, Te = Bs(H, Y = Y + Ee & Ee - 1, Q);
            if (this.tiles[Te]) return pr(this.tiles[Te], me);
            ve > 1 && console.log("drilling down to z%d-%d-%d", H, Y, Q);
            let Ge, tt = H, Ye = Y, Mt = Q;
            for (; !Ge && tt > 0; ) tt--, Ye >>= 1, Mt >>= 1, Ge = this.tiles[Bs(tt, Ye, Mt)];
            return Ge && Ge.source ? (ve > 1 && (console.log("found parent tile z%d-%d-%d", tt, Ye, Mt), console.time("drilling down")), this.splitTile(Ge.source, tt, Ye, Mt, H, Y, Q), ve > 1 && console.timeEnd("drilling down"), this.tiles[Te] ? pr(this.tiles[Te], me) : null) : null;
          }
        }
        function Bs(be, H, Y) {
          return 32 * ((1 << be) * Y + H) + be;
        }
        class Ns extends ae {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile(H, Y) {
            return S._(this, void 0, void 0, (function* () {
              const Q = H.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const le = this._geoJSONIndex.getTile(Q.z, Q.x, Q.y);
              if (!le) return null;
              const me = new it(le.features, { version: 2, extent: S.$ });
              let ve = (function(Ee) {
                const Te = new S.cM();
                return (function(Ge, tt) {
                  for (const Ye in Ge.layers) tt.writeMessage(3, nt, Ge.layers[Ye]);
                })(Ee, Te), Te.finish();
              })(me);
              return ve.byteOffset === 0 && ve.byteLength === ve.buffer.byteLength || (ve = new Uint8Array(ve)), { vectorTile: me, rawData: ve.buffer };
            }));
          }
          loadData(H) {
            return S._(this, void 0, void 0, (function* () {
              var Y;
              (Y = this._pendingRequest) === null || Y === void 0 || Y.abort();
              const Q = !!(H && H.request && H.request.collectResourceTiming) && new S.cN(H.request);
              this._pendingRequest = new AbortController();
              try {
                this._pendingData = this.loadAndProcessGeoJSON(H, this._pendingRequest);
                const le = yield this._pendingData;
                this._geoJSONIndex = H.cluster ? new vn((function({ superclusterOptions: ve, clusterProperties: Ee }) {
                  if (!Ee || !ve) return ve;
                  const Te = {}, Ge = {}, tt = { accumulated: null, zoom: 0 }, Ye = { properties: null }, Mt = Object.keys(Ee);
                  for (const Ae of Mt) {
                    const [qt, ri] = Ee[Ae], It = S.cT(ri), ti = S.cT(typeof qt == "string" ? [qt, ["accumulated"], ["get", Ae]] : qt);
                    Te[Ae] = It.value, Ge[Ae] = ti.value;
                  }
                  return ve.map = (Ae) => {
                    Ye.properties = Ae;
                    const qt = {};
                    for (const ri of Mt) qt[ri] = Te[ri].evaluate(tt, Ye);
                    return qt;
                  }, ve.reduce = (Ae, qt) => {
                    Ye.properties = qt;
                    for (const ri of Mt) tt.accumulated = Ae[ri], Ae[ri] = Ge[ri].evaluate(tt, Ye);
                  }, ve;
                })(H)).load(le.features) : (function(ve, Ee) {
                  return new po(ve, Ee);
                })(le, H.geojsonVtOptions), this.loaded = {};
                const me = { data: le };
                if (Q) {
                  const ve = Q.finish();
                  ve && (me.resourceTiming = {}, me.resourceTiming[H.source] = JSON.parse(JSON.stringify(ve)));
                }
                return me;
              } catch (le) {
                if (delete this._pendingRequest, S.cy(le)) return { abandoned: !0 };
                throw le;
              }
            }));
          }
          getData() {
            return S._(this, void 0, void 0, (function* () {
              return this._pendingData;
            }));
          }
          reloadTile(H) {
            const Y = this.loaded;
            return Y && Y[H.uid] ? super.reloadTile(H) : this.loadTile(H);
          }
          loadAndProcessGeoJSON(H, Y) {
            return S._(this, void 0, void 0, (function* () {
              let Q = yield this.loadGeoJSON(H, Y);
              if (delete this._pendingRequest, typeof Q != "object") throw new Error(`Input data given to '${H.source}' is not a valid GeoJSON object.`);
              if (ft(Q, !0), H.filter) {
                const le = S.cT(H.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                if (le.result === "error") throw new Error(le.value.map(((ve) => `${ve.key}: ${ve.message}`)).join(", "));
                Q = { type: "FeatureCollection", features: Q.features.filter(((ve) => le.value.evaluate({ zoom: 0 }, ve))) };
              }
              return Q;
            }));
          }
          loadGeoJSON(H, Y) {
            return S._(this, void 0, void 0, (function* () {
              const { promoteId: Q } = H;
              if (H.request) {
                const le = yield S.j(H.request, Y);
                return this._dataUpdateable = S.cV(le.data, Q) ? S.cU(le.data, Q) : void 0, le.data;
              }
              if (typeof H.data == "string") try {
                const le = JSON.parse(H.data);
                return this._dataUpdateable = S.cV(le, Q) ? S.cU(le, Q) : void 0, le;
              } catch {
                throw new Error(`Input data given to '${H.source}' is not a valid GeoJSON object.`);
              }
              if (!H.dataDiff) throw new Error(`Input data given to '${H.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${H.source}`);
              return S.cW(this._dataUpdateable, H.dataDiff, Q), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            }));
          }
          removeSource(H) {
            return S._(this, void 0, void 0, (function* () {
              this._pendingRequest && this._pendingRequest.abort();
            }));
          }
          getClusterExpansionZoom(H) {
            return this._geoJSONIndex.getClusterExpansionZoom(H.clusterId);
          }
          getClusterChildren(H) {
            return this._geoJSONIndex.getChildren(H.clusterId);
          }
          getClusterLeaves(H) {
            return this._geoJSONIndex.getLeaves(H.clusterId, H.limit, H.offset);
          }
        }
        class js {
          constructor(H) {
            this.self = H, this.actor = new S.J(H), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (Y, Q) => {
              if (this.externalWorkerSourceTypes[Y]) throw new Error(`Worker source with name "${Y}" already registered.`);
              this.externalWorkerSourceTypes[Y] = Q;
            }, this.self.addProtocol = S.cA, this.self.removeProtocol = S.cB, this.self.registerRTLTextPlugin = (Y) => {
              S.cX.setMethods(Y);
            }, this.actor.registerMessageHandler("LDT", ((Y, Q) => this._getDEMWorkerSource(Y, Q.source).loadTile(Q))), this.actor.registerMessageHandler("RDT", ((Y, Q) => S._(this, void 0, void 0, (function* () {
              this._getDEMWorkerSource(Y, Q.source).removeTile(Q);
            })))), this.actor.registerMessageHandler("GCEZ", ((Y, Q) => S._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Y, Q.type, Q.source).getClusterExpansionZoom(Q);
            })))), this.actor.registerMessageHandler("GCC", ((Y, Q) => S._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Y, Q.type, Q.source).getClusterChildren(Q);
            })))), this.actor.registerMessageHandler("GCL", ((Y, Q) => S._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Y, Q.type, Q.source).getClusterLeaves(Q);
            })))), this.actor.registerMessageHandler("LD", ((Y, Q) => this._getWorkerSource(Y, Q.type, Q.source).loadData(Q))), this.actor.registerMessageHandler("GD", ((Y, Q) => this._getWorkerSource(Y, Q.type, Q.source).getData())), this.actor.registerMessageHandler("LT", ((Y, Q) => this._getWorkerSource(Y, Q.type, Q.source).loadTile(Q))), this.actor.registerMessageHandler("RT", ((Y, Q) => this._getWorkerSource(Y, Q.type, Q.source).reloadTile(Q))), this.actor.registerMessageHandler("AT", ((Y, Q) => this._getWorkerSource(Y, Q.type, Q.source).abortTile(Q))), this.actor.registerMessageHandler("RMT", ((Y, Q) => this._getWorkerSource(Y, Q.type, Q.source).removeTile(Q))), this.actor.registerMessageHandler("RS", ((Y, Q) => S._(this, void 0, void 0, (function* () {
              if (!this.workerSources[Y] || !this.workerSources[Y][Q.type] || !this.workerSources[Y][Q.type][Q.source]) return;
              const le = this.workerSources[Y][Q.type][Q.source];
              delete this.workerSources[Y][Q.type][Q.source], le.removeSource !== void 0 && le.removeSource(Q);
            })))), this.actor.registerMessageHandler("RM", ((Y) => S._(this, void 0, void 0, (function* () {
              delete this.layerIndexes[Y], delete this.availableImages[Y], delete this.workerSources[Y], delete this.demWorkerSources[Y];
            })))), this.actor.registerMessageHandler("SR", ((Y, Q) => S._(this, void 0, void 0, (function* () {
              this.referrer = Q;
            })))), this.actor.registerMessageHandler("SRPS", ((Y, Q) => this._syncRTLPluginState(Y, Q))), this.actor.registerMessageHandler("IS", ((Y, Q) => S._(this, void 0, void 0, (function* () {
              this.self.importScripts(Q);
            })))), this.actor.registerMessageHandler("SI", ((Y, Q) => this._setImages(Y, Q))), this.actor.registerMessageHandler("UL", ((Y, Q) => S._(this, void 0, void 0, (function* () {
              this._getLayerIndex(Y).update(Q.layers, Q.removedIds);
            })))), this.actor.registerMessageHandler("SL", ((Y, Q) => S._(this, void 0, void 0, (function* () {
              this._getLayerIndex(Y).replace(Q);
            }))));
          }
          _setImages(H, Y) {
            return S._(this, void 0, void 0, (function* () {
              this.availableImages[H] = Y;
              for (const Q in this.workerSources[H]) {
                const le = this.workerSources[H][Q];
                for (const me in le) le[me].availableImages = Y;
              }
            }));
          }
          _syncRTLPluginState(H, Y) {
            return S._(this, void 0, void 0, (function* () {
              return yield S.cX.syncState(Y, this.self.importScripts);
            }));
          }
          _getAvailableImages(H) {
            let Y = this.availableImages[H];
            return Y || (Y = []), Y;
          }
          _getLayerIndex(H) {
            let Y = this.layerIndexes[H];
            return Y || (Y = this.layerIndexes[H] = new u()), Y;
          }
          _getWorkerSource(H, Y, Q) {
            if (this.workerSources[H] || (this.workerSources[H] = {}), this.workerSources[H][Y] || (this.workerSources[H][Y] = {}), !this.workerSources[H][Y][Q]) {
              const le = { sendAsync: (me, ve) => (me.targetMapId = H, this.actor.sendAsync(me, ve)) };
              switch (Y) {
                case "vector":
                  this.workerSources[H][Y][Q] = new ae(le, this._getLayerIndex(H), this._getAvailableImages(H));
                  break;
                case "geojson":
                  this.workerSources[H][Y][Q] = new Ns(le, this._getLayerIndex(H), this._getAvailableImages(H));
                  break;
                default:
                  this.workerSources[H][Y][Q] = new this.externalWorkerSourceTypes[Y](le, this._getLayerIndex(H), this._getAvailableImages(H));
              }
            }
            return this.workerSources[H][Y][Q];
          }
          _getDEMWorkerSource(H, Y) {
            return this.demWorkerSources[H] || (this.demWorkerSources[H] = {}), this.demWorkerSources[H][Y] || (this.demWorkerSources[H][Y] = new he()), this.demWorkerSources[H][Y];
          }
        }
        return S.i(self) && (self.worker = new js(self)), js;
      })), M("index", ["exports", "./shared"], (function(S, u) {
        var O = "5.6.2";
        function U() {
          var y = new u.A(4);
          return u.A != Float32Array && (y[1] = 0, y[2] = 0), y[0] = 1, y[3] = 1, y;
        }
        let K, ae;
        const he = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(y, e, r) {
          const c = requestAnimationFrame(((_) => {
            f(), e(_);
          })), { unsubscribe: f } = u.s(y.signal, "abort", (() => {
            f(), cancelAnimationFrame(c), r(u.c());
          }), !1);
        }, frameAsync(y) {
          return new Promise(((e, r) => {
            this.frame(y, e, r);
          }));
        }, getImageData(y, e = 0) {
          return this.getImageCanvasContext(y).getImageData(-e, -e, y.width + 2 * e, y.height + 2 * e);
        }, getImageCanvasContext(y) {
          const e = window.document.createElement("canvas"), r = e.getContext("2d", { willReadFrequently: !0 });
          if (!r) throw new Error("failed to create canvas 2d context");
          return e.width = y.width, e.height = y.height, r.drawImage(y, 0, 0, y.width, y.height), r;
        }, resolveURL: (y) => (K || (K = document.createElement("a")), K.href = y, K.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (ae == null && (ae = matchMedia("(prefers-reduced-motion: reduce)")), ae.matches);
        } };
        class J {
          static testProp(e) {
            if (!J.docStyle) return e[0];
            for (let r = 0; r < e.length; r++) if (e[r] in J.docStyle) return e[r];
            return e[0];
          }
          static create(e, r, c) {
            const f = window.document.createElement(e);
            return r !== void 0 && (f.className = r), c && c.appendChild(f), f;
          }
          static createNS(e, r) {
            return window.document.createElementNS(e, r);
          }
          static disableDrag() {
            J.docStyle && J.selectProp && (J.userSelect = J.docStyle[J.selectProp], J.docStyle[J.selectProp] = "none");
          }
          static enableDrag() {
            J.docStyle && J.selectProp && (J.docStyle[J.selectProp] = J.userSelect);
          }
          static setTransform(e, r) {
            e.style[J.transformProp] = r;
          }
          static addEventListener(e, r, c, f = {}) {
            e.addEventListener(r, c, "passive" in f ? f : f.capture);
          }
          static removeEventListener(e, r, c, f = {}) {
            e.removeEventListener(r, c, "passive" in f ? f : f.capture);
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", J.suppressClickInternal, !0);
          }
          static suppressClick() {
            window.addEventListener("click", J.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", J.suppressClickInternal, !0);
            }), 0);
          }
          static getScale(e) {
            const r = e.getBoundingClientRect();
            return { x: r.width / e.offsetWidth || 1, y: r.height / e.offsetHeight || 1, boundingClientRect: r };
          }
          static getPoint(e, r, c) {
            const f = r.boundingClientRect;
            return new u.P((c.clientX - f.left) / r.x - e.clientLeft, (c.clientY - f.top) / r.y - e.clientTop);
          }
          static mousePos(e, r) {
            const c = J.getScale(e);
            return J.getPoint(e, c, r);
          }
          static touchPos(e, r) {
            const c = [], f = J.getScale(e);
            for (let _ = 0; _ < r.length; _++) c.push(J.getPoint(e, f, r[_]));
            return c;
          }
          static mouseButton(e) {
            return e.button;
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e);
          }
          static sanitize(e) {
            const r = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"), c = r.querySelectorAll("script");
            for (const f of c) f.remove();
            return J.clean(r), r.innerHTML;
          }
          static isPossiblyDangerous(e, r) {
            const c = r.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !c.includes("javascript:") && !c.includes("data:")) || !!e.startsWith("on") || void 0;
          }
          static clean(e) {
            const r = e.children;
            for (const c of r) J.removeAttributes(c), J.clean(c);
          }
          static removeAttributes(e) {
            for (const { name: r, value: c } of e.attributes) J.isPossiblyDangerous(r, c) && e.removeAttribute(r);
          }
        }
        J.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, J.selectProp = J.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), J.transformProp = J.testProp(["transform", "WebkitTransform"]);
        const ke = { supported: !1, testSupport: function(y) {
          !ht && ft && (it ? nt(y) : qe = y);
        } };
        let qe, ft, ht = !1, it = !1;
        function nt(y) {
          const e = y.createTexture();
          y.bindTexture(y.TEXTURE_2D, e);
          try {
            if (y.texImage2D(y.TEXTURE_2D, 0, y.RGBA, y.RGBA, y.UNSIGNED_BYTE, ft), y.isContextLost()) return;
            ke.supported = !0;
          } catch {
          }
          y.deleteTexture(e), ht = !0;
        }
        var De;
        typeof document < "u" && (ft = document.createElement("img"), ft.onload = () => {
          qe && nt(qe), qe = null, it = !0;
        }, ft.onerror = () => {
          ht = !0, qe = null;
        }, ft.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(y) {
          let e, r, c, f;
          y.resetRequestQueue = () => {
            e = [], r = 0, c = 0, f = {};
          }, y.addThrottleControl = (P) => {
            const R = c++;
            return f[R] = P, R;
          }, y.removeThrottleControl = (P) => {
            delete f[P], w();
          }, y.getImage = (P, R, L = !0) => new Promise(((j, B) => {
            ke.supported && (P.headers || (P.headers = {}), P.headers.accept = "image/webp,*/*"), u.e(P, { type: "image" }), e.push({ abortController: R, requestParameters: P, supportImageRefresh: L, state: "queued", onError: (V) => {
              B(V);
            }, onSuccess: (V) => {
              j(V);
            } }), w();
          }));
          const _ = (P) => u._(this, void 0, void 0, (function* () {
            P.state = "running";
            const { requestParameters: R, supportImageRefresh: L, onError: j, onSuccess: B, abortController: V } = P, $ = L === !1 && !u.i(self) && !u.g(R.url) && (!R.headers || Object.keys(R.headers).reduce(((ne, re) => ne && re === "accept"), !0));
            r++;
            const ie = $ ? C(R, V) : u.m(R, V);
            try {
              const ne = yield ie;
              delete P.abortController, P.state = "completed", ne.data instanceof HTMLImageElement || u.b(ne.data) ? B(ne) : ne.data && B({ data: yield (te = ne.data, typeof createImageBitmap == "function" ? u.f(te) : u.h(te)), cacheControl: ne.cacheControl, expires: ne.expires });
            } catch (ne) {
              delete P.abortController, j(ne);
            } finally {
              r--, w();
            }
            var te;
          })), w = () => {
            const P = (() => {
              for (const R of Object.keys(f)) if (f[R]()) return !0;
              return !1;
            })() ? u.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : u.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let R = r; R < P && e.length > 0; R++) {
              const L = e.shift();
              L.abortController.signal.aborted ? R-- : _(L);
            }
          }, C = (P, R) => new Promise(((L, j) => {
            const B = new Image(), V = P.url, $ = P.credentials;
            $ && $ === "include" ? B.crossOrigin = "use-credentials" : ($ && $ === "same-origin" || !u.d(V)) && (B.crossOrigin = "anonymous"), R.signal.addEventListener("abort", (() => {
              B.src = "", j(u.c());
            })), B.fetchPriority = "high", B.onload = () => {
              B.onerror = B.onload = null, L({ data: B });
            }, B.onerror = () => {
              B.onerror = B.onload = null, R.signal.aborted || j(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, B.src = V;
          }));
        })(De || (De = {})), De.resetRequestQueue();
        class Re {
          constructor(e) {
            this._transformRequestFn = e ?? null;
          }
          transformRequest(e, r) {
            return this._transformRequestFn && this._transformRequestFn(e, r) || { url: e };
          }
          setTransformRequest(e) {
            this._transformRequestFn = e;
          }
        }
        function $e(y) {
          const e = [];
          if (typeof y == "string") e.push({ id: "default", url: y });
          else if (y && y.length > 0) {
            const r = [];
            for (const { id: c, url: f } of y) {
              const _ = `${c}${f}`;
              r.indexOf(_) === -1 && (r.push(_), e.push({ id: c, url: f }));
            }
          }
          return e;
        }
        function rt(y, e, r) {
          try {
            const c = new URL(y);
            return c.pathname += `${e}${r}`, c.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${y}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function wt(y) {
          const { userImage: e } = y;
          return !!(e && e.render && e.render()) && (y.data.replace(new Uint8Array(e.data.buffer)), !0);
        }
        class Ht extends u.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new u.R({ width: 1, height: 1 }), this.dirty = !0;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const { ids: r, promiseResolve: c } of this.requestors) c(this._getImagesForIds(r));
              this.requestors = [];
            }
          }
          getImage(e) {
            const r = this.images[e];
            if (r && !r.data && r.spriteData) {
              const c = r.spriteData;
              r.data = new u.R({ width: c.width, height: c.height }, c.context.getImageData(c.x, c.y, c.width, c.height).data), r.spriteData = null;
            }
            return r;
          }
          addImage(e, r) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, r) && (this.images[e] = r);
          }
          _validate(e, r) {
            let c = !0;
            const f = r.data || r.spriteData;
            return this._validateStretch(r.stretchX, f && f.width) || (this.fire(new u.k(new Error(`Image "${e}" has invalid "stretchX" value`))), c = !1), this._validateStretch(r.stretchY, f && f.height) || (this.fire(new u.k(new Error(`Image "${e}" has invalid "stretchY" value`))), c = !1), this._validateContent(r.content, r) || (this.fire(new u.k(new Error(`Image "${e}" has invalid "content" value`))), c = !1), c;
          }
          _validateStretch(e, r) {
            if (!e) return !0;
            let c = 0;
            for (const f of e) {
              if (f[0] < c || f[1] < f[0] || r < f[1]) return !1;
              c = f[1];
            }
            return !0;
          }
          _validateContent(e, r) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const c = r.spriteData, f = c && c.width || r.data.width, _ = c && c.height || r.data.height;
            return !(e[0] < 0 || f < e[0] || e[1] < 0 || _ < e[1] || e[2] < 0 || f < e[2] || e[3] < 0 || _ < e[3] || e[2] < e[0] || e[3] < e[1]);
          }
          updateImage(e, r, c = !0) {
            const f = this.getImage(e);
            if (c && (f.data.width !== r.data.width || f.data.height !== r.data.height)) throw new Error(`size mismatch between old image (${f.data.width}x${f.data.height}) and new image (${r.data.width}x${r.data.height}).`);
            r.version = f.version + 1, this.images[e] = r, this.updatedImages[e] = !0;
          }
          removeImage(e) {
            const r = this.images[e];
            delete this.images[e], delete this.patterns[e], r.userImage && r.userImage.onRemove && r.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e) {
            return new Promise(((r, c) => {
              let f = !0;
              if (!this.isLoaded()) for (const _ of e) this.images[_] || (f = !1);
              this.isLoaded() || f ? r(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: r });
            }));
          }
          _getImagesForIds(e) {
            const r = {};
            for (const c of e) {
              let f = this.getImage(c);
              f || (this.fire(new u.l("styleimagemissing", { id: c })), f = this.getImage(c)), f ? r[c] = { data: f.data.clone(), pixelRatio: f.pixelRatio, sdf: f.sdf, version: f.version, stretchX: f.stretchX, stretchY: f.stretchY, content: f.content, textFitWidth: f.textFitWidth, textFitHeight: f.textFitHeight, hasRenderCallback: !!(f.userImage && f.userImage.render) } : u.w(`Image "${c}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return r;
          }
          getPixelSize() {
            const { width: e, height: r } = this.atlasImage;
            return { width: e, height: r };
          }
          getPattern(e) {
            const r = this.patterns[e], c = this.getImage(e);
            if (!c) return null;
            if (r && r.position.version === c.version) return r.position;
            if (r) r.position.version = c.version;
            else {
              const f = { w: c.data.width + 2, h: c.data.height + 2, x: 0, y: 0 }, _ = new u.I(f, c);
              this.patterns[e] = { bin: f, position: _ };
            }
            return this._updatePatternAtlas(), this.patterns[e].position;
          }
          bind(e) {
            const r = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new u.T(e, this.atlasImage, r.RGBA), this.atlasTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e = [];
            for (const _ in this.patterns) e.push(this.patterns[_].bin);
            const { w: r, h: c } = u.p(e), f = this.atlasImage;
            f.resize({ width: r || 1, height: c || 1 });
            for (const _ in this.patterns) {
              const { bin: w } = this.patterns[_], C = w.x + 1, P = w.y + 1, R = this.getImage(_).data, L = R.width, j = R.height;
              u.R.copy(R, f, { x: 0, y: 0 }, { x: C, y: P }, { width: L, height: j }), u.R.copy(R, f, { x: 0, y: j - 1 }, { x: C, y: P - 1 }, { width: L, height: 1 }), u.R.copy(R, f, { x: 0, y: 0 }, { x: C, y: P + j }, { width: L, height: 1 }), u.R.copy(R, f, { x: L - 1, y: 0 }, { x: C - 1, y: P }, { width: 1, height: j }), u.R.copy(R, f, { x: 0, y: 0 }, { x: C + L, y: P }, { width: 1, height: j });
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e) {
            for (const r of e) {
              if (this.callbackDispatchedThisFrame[r]) continue;
              this.callbackDispatchedThisFrame[r] = !0;
              const c = this.getImage(r);
              c || u.w(`Image with ID: "${r}" was not found`), wt(c) && this.updateImage(r, c);
            }
          }
        }
        const Dt = 1e20;
        function Xt(y, e, r, c, f, _, w, C, P) {
          for (let R = e; R < e + c; R++) pi(y, r * _ + R, _, f, w, C, P);
          for (let R = r; R < r + f; R++) pi(y, R * _ + e, 1, c, w, C, P);
        }
        function pi(y, e, r, c, f, _, w) {
          _[0] = 0, w[0] = -Dt, w[1] = Dt, f[0] = y[e];
          for (let C = 1, P = 0, R = 0; C < c; C++) {
            f[C] = y[e + C * r];
            const L = C * C;
            do {
              const j = _[P];
              R = (f[C] - f[j] + L - j * j) / (C - j) / 2;
            } while (R <= w[P] && --P > -1);
            P++, _[P] = C, w[P] = R, w[P + 1] = Dt;
          }
          for (let C = 0, P = 0; C < c; C++) {
            for (; w[P + 1] < C; ) P++;
            const R = _[P], L = C - R;
            y[e + C * r] = f[R] + L * L;
          }
        }
        class vn {
          constructor(e, r) {
            this.requestManager = e, this.localIdeographFontFamily = r, this.entries = {};
          }
          setURL(e) {
            this.url = e;
          }
          getGlyphs(e) {
            return u._(this, void 0, void 0, (function* () {
              const r = [];
              for (const _ in e) for (const w of e[_]) r.push(this._getAndCacheGlyphsPromise(_, w));
              const c = yield Promise.all(r), f = {};
              for (const { stack: _, id: w, glyph: C } of c) f[_] || (f[_] = {}), f[_][w] = C && { id: C.id, bitmap: C.bitmap.clone(), metrics: C.metrics };
              return f;
            }));
          }
          _getAndCacheGlyphsPromise(e, r) {
            return u._(this, void 0, void 0, (function* () {
              let c = this.entries[e];
              c || (c = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
              let f = c.glyphs[r];
              if (f !== void 0) return { stack: e, id: r, glyph: f };
              if (f = this._tinySDF(c, e, r), f) return c.glyphs[r] = f, { stack: e, id: r, glyph: f };
              const _ = Math.floor(r / 256);
              if (256 * _ > 65535) throw new Error("glyphs > 65535 not supported");
              if (c.ranges[_]) return { stack: e, id: r, glyph: f };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!c.requests[_]) {
                const C = vn.loadGlyphRange(e, _, this.url, this.requestManager);
                c.requests[_] = C;
              }
              const w = yield c.requests[_];
              for (const C in w) this._doesCharSupportLocalGlyph(+C) || (c.glyphs[+C] = w[+C]);
              return c.ranges[_] = !0, { stack: e, id: r, glyph: w[r] || null };
            }));
          }
          _doesCharSupportLocalGlyph(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || u.u["CJK Unified Ideographs"](e) || u.u["Hangul Syllables"](e) || u.u.Hiragana(e) || u.u.Katakana(e) || u.u["CJK Symbols and Punctuation"](e) || u.u["Halfwidth and Fullwidth Forms"](e));
          }
          _tinySDF(e, r, c) {
            const f = this.localIdeographFontFamily;
            if (!f || !this._doesCharSupportLocalGlyph(c)) return;
            let _ = e.tinySDF;
            if (!_) {
              let C = "400";
              /bold/i.test(r) ? C = "900" : /medium/i.test(r) ? C = "500" : /light/i.test(r) && (C = "200"), _ = e.tinySDF = new vn.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: f, fontWeight: C });
            }
            const w = _.draw(String.fromCharCode(c));
            return { id: c, bitmap: new u.q({ width: w.width || 60, height: w.height || 60 }, w.data), metrics: { width: w.glyphWidth / 2 || 24, height: w.glyphHeight / 2 || 24, left: w.glyphLeft / 2 + 0.5 || 0, top: w.glyphTop / 2 - 27.5 || -8, advance: w.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
          }
        }
        vn.loadGlyphRange = function(y, e, r, c) {
          return u._(this, void 0, void 0, (function* () {
            const f = 256 * e, _ = f + 255, w = c.transformRequest(r.replace("{fontstack}", y).replace("{range}", `${f}-${_}`), "Glyphs"), C = yield u.n(w, new AbortController());
            if (!C || !C.data) throw new Error(`Could not load glyph range. range: ${e}, ${f}-${_}`);
            const P = {};
            for (const R of u.o(C.data)) P[R.id] = R;
            return P;
          }));
        }, vn.TinySDF = class {
          constructor({ fontSize: y = 24, buffer: e = 3, radius: r = 8, cutoff: c = 0.25, fontFamily: f = "sans-serif", fontWeight: _ = "normal", fontStyle: w = "normal", lang: C = null } = {}) {
            this.buffer = e, this.cutoff = c, this.radius = r, this.lang = C;
            const P = this.size = y + 4 * e, R = this._createCanvas(P), L = this.ctx = R.getContext("2d", { willReadFrequently: !0 });
            L.font = `${w} ${_} ${y}px ${f}`, L.textBaseline = "alphabetic", L.textAlign = "left", L.fillStyle = "black", this.gridOuter = new Float64Array(P * P), this.gridInner = new Float64Array(P * P), this.f = new Float64Array(P), this.z = new Float64Array(P + 1), this.v = new Uint16Array(P);
          }
          _createCanvas(y) {
            const e = document.createElement("canvas");
            return e.width = e.height = y, e;
          }
          draw(y) {
            const { width: e, actualBoundingBoxAscent: r, actualBoundingBoxDescent: c, actualBoundingBoxLeft: f, actualBoundingBoxRight: _ } = this.ctx.measureText(y), w = Math.ceil(r), C = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(_ - f))), P = Math.min(this.size - this.buffer, w + Math.ceil(c)), R = C + 2 * this.buffer, L = P + 2 * this.buffer, j = Math.max(R * L, 0), B = new Uint8ClampedArray(j), V = { data: B, width: R, height: L, glyphWidth: C, glyphHeight: P, glyphTop: w, glyphLeft: 0, glyphAdvance: e };
            if (C === 0 || P === 0) return V;
            const { ctx: $, buffer: ie, gridInner: te, gridOuter: ne } = this;
            this.lang && ($.lang = this.lang), $.clearRect(ie, ie, C, P), $.fillText(y, ie, ie + w);
            const re = $.getImageData(ie, ie, C, P);
            ne.fill(Dt, 0, j), te.fill(0, 0, j);
            for (let ce = 0; ce < P; ce++) for (let oe = 0; oe < C; oe++) {
              const pe = re.data[4 * (ce * C + oe) + 3] / 255;
              if (pe === 0) continue;
              const ye = (ce + ie) * R + oe + ie;
              if (pe === 1) ne[ye] = 0, te[ye] = Dt;
              else {
                const ue = 0.5 - pe;
                ne[ye] = ue > 0 ? ue * ue : 0, te[ye] = ue < 0 ? ue * ue : 0;
              }
            }
            Xt(ne, 0, 0, R, L, R, this.f, this.v, this.z), Xt(te, ie, ie, C, P, R, this.f, this.v, this.z);
            for (let ce = 0; ce < j; ce++) {
              const oe = Math.sqrt(ne[ce]) - Math.sqrt(te[ce]);
              B[ce] = Math.round(255 - 255 * (oe / this.radius + this.cutoff));
            }
            return V;
          }
        };
        class Cn {
          constructor() {
            this.specification = u.v.light.position;
          }
          possiblyEvaluate(e, r) {
            return u.B(e.expression.evaluate(r));
          }
          interpolate(e, r, c) {
            return { x: u.C.number(e.x, r.x, c), y: u.C.number(e.y, r.y, c), z: u.C.number(e.z, r.z, c) };
          }
        }
        let zn;
        class He extends u.E {
          constructor(e) {
            super(), zn = zn || new u.r({ anchor: new u.D(u.v.light.anchor), position: new Cn(), color: new u.D(u.v.light.color), intensity: new u.D(u.v.light.intensity) }), this._transitionable = new u.t(zn), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e, r = {}) {
            if (!this._validate(u.x, e, r)) for (const c in e) {
              const f = e[c];
              c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), f) : this._transitionable.setValue(c, f);
            }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, r, c) {
            return (!c || c.validate !== !1) && u.y(this, e.call(u.z, { value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: u.v }));
          }
        }
        const vt = new u.r({ "sky-color": new u.D(u.v.sky["sky-color"]), "horizon-color": new u.D(u.v.sky["horizon-color"]), "fog-color": new u.D(u.v.sky["fog-color"]), "fog-ground-blend": new u.D(u.v.sky["fog-ground-blend"]), "horizon-fog-blend": new u.D(u.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new u.D(u.v.sky["sky-horizon-blend"]), "atmosphere-blend": new u.D(u.v.sky["atmosphere-blend"]) });
        class Gt extends u.E {
          constructor(e) {
            super(), this._transitionable = new u.t(vt), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new u.F(0));
          }
          setSky(e, r = {}) {
            if (!this._validate(u.G, e, r)) {
              e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const c in e) {
                const f = e[c];
                c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), f) : this._transitionable.setValue(c, f);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, r, c = {}) {
            return c?.validate !== !1 && u.y(this, e.call(u.z, u.e({ value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: u.v })));
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
          }
        }
        class at {
          constructor(e, r) {
            this.width = e, this.height = r, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(e, r) {
            const c = e.join(",") + String(r);
            return this.dashEntry[c] || (this.dashEntry[c] = this.addDash(e, r)), this.dashEntry[c];
          }
          getDashRanges(e, r, c) {
            const f = [];
            let _ = e.length % 2 == 1 ? -e[e.length - 1] * c : 0, w = e[0] * c, C = !0;
            f.push({ left: _, right: w, isDash: C, zeroLength: e[0] === 0 });
            let P = e[0];
            for (let R = 1; R < e.length; R++) {
              C = !C;
              const L = e[R];
              _ = P * c, P += L, w = P * c, f.push({ left: _, right: w, isDash: C, zeroLength: L === 0 });
            }
            return f;
          }
          addRoundDash(e, r, c) {
            const f = r / 2;
            for (let _ = -c; _ <= c; _++) {
              const w = this.width * (this.nextRow + c + _);
              let C = 0, P = e[C];
              for (let R = 0; R < this.width; R++) {
                R / P.right > 1 && (P = e[++C]);
                const L = Math.abs(R - P.left), j = Math.abs(R - P.right), B = Math.min(L, j);
                let V;
                const $ = _ / c * (f + 1);
                if (P.isDash) {
                  const ie = f - Math.abs($);
                  V = Math.sqrt(B * B + ie * ie);
                } else V = f - Math.sqrt(B * B + $ * $);
                this.data[w + R] = Math.max(0, Math.min(255, V + 128));
              }
            }
          }
          addRegularDash(e) {
            for (let C = e.length - 1; C >= 0; --C) {
              const P = e[C], R = e[C + 1];
              P.zeroLength ? e.splice(C, 1) : R && R.isDash === P.isDash && (R.left = P.left, e.splice(C, 1));
            }
            const r = e[0], c = e[e.length - 1];
            r.isDash === c.isDash && (r.left = c.left - this.width, c.right = r.right + this.width);
            const f = this.width * this.nextRow;
            let _ = 0, w = e[_];
            for (let C = 0; C < this.width; C++) {
              C / w.right > 1 && (w = e[++_]);
              const P = Math.abs(C - w.left), R = Math.abs(C - w.right), L = Math.min(P, R);
              this.data[f + C] = Math.max(0, Math.min(255, (w.isDash ? L : -L) + 128));
            }
          }
          addDash(e, r) {
            const c = r ? 7 : 0, f = 2 * c + 1;
            if (this.nextRow + f > this.height) return u.w("LineAtlas out of space"), null;
            let _ = 0;
            for (let C = 0; C < e.length; C++) _ += e[C];
            if (_ !== 0) {
              const C = this.width / _, P = this.getDashRanges(e, this.width, C);
              r ? this.addRoundDash(P, C, c) : this.addRegularDash(P);
            }
            const w = { y: (this.nextRow + c + 0.5) / this.height, height: 2 * c / this.height, width: _ };
            return this.nextRow += f, this.dirty = !0, w;
          }
          bind(e) {
            const r = e.gl;
            this.texture ? (r.bindTexture(r.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, this.width, this.height, r.ALPHA, r.UNSIGNED_BYTE, this.data))) : (this.texture = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this.texture), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texImage2D(r.TEXTURE_2D, 0, r.ALPHA, this.width, this.height, 0, r.ALPHA, r.UNSIGNED_BYTE, this.data));
          }
        }
        const Et = "maplibre_preloaded_worker_pool";
        class fe {
          constructor() {
            this.active = {};
          }
          acquire(e) {
            if (!this.workers) for (this.workers = []; this.workers.length < fe.workerCount; ) this.workers.push(new Worker(u.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice();
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach(((r) => {
              r.terminate();
            })), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[Et];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const Ue = Math.floor(he.hardwareConcurrency / 2);
        let et, dt;
        function Pt() {
          return et || (et = new fe()), et;
        }
        fe.workerCount = u.H(globalThis) ? Math.max(Math.min(Ue, 3), 1) : 1;
        class Vt {
          constructor(e, r) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = r;
            const c = this.workerPool.acquire(r);
            for (let f = 0; f < c.length; f++) {
              const _ = new u.J(c[f], r);
              _.name = `Worker ${f}`, this.actors.push(_);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(e, r) {
            const c = [];
            for (const f of this.actors) c.push(f.sendAsync({ type: e, data: r }));
            return Promise.all(c);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(e = !0) {
            this.actors.forEach(((r) => {
              r.remove();
            })), this.actors = [], e && this.workerPool.release(this.id);
          }
          registerMessageHandler(e, r) {
            for (const c of this.actors) c.registerMessageHandler(e, r);
          }
        }
        function si() {
          return dt || (dt = new Vt(Pt(), u.K), dt.registerMessageHandler("GR", ((y, e, r) => u.m(e, r)))), dt;
        }
        function Ii(y, e) {
          const r = u.L();
          return u.M(r, r, [1, 1, 0]), u.N(r, r, [0.5 * y.width, 0.5 * y.height, 1]), y.calculatePosMatrix ? u.O(r, r, y.calculatePosMatrix(e.toUnwrapped())) : r;
        }
        function xi(y, e, r, c, f, _, w) {
          var C;
          const P = (function(B, V, $) {
            if (B) for (const ie of B) {
              const te = V[ie];
              if (te && te.source === $ && te.type === "fill-extrusion") return !0;
            }
            else for (const ie in V) {
              const te = V[ie];
              if (te.source === $ && te.type === "fill-extrusion") return !0;
            }
            return !1;
          })((C = f?.layers) !== null && C !== void 0 ? C : null, e, y.id), R = _.maxPitchScaleFactor(), L = y.tilesIn(c, R, P);
          L.sort(Ta);
          const j = [];
          for (const B of L) j.push({ wrappedTileID: B.tileID.wrapped().key, queryResults: B.tile.queryRenderedFeatures(e, r, y._state, B.queryGeometry, B.cameraQueryGeometry, B.scale, f, _, R, Ii(y.transform, B.tileID), w ? (V, $) => w(B.tileID, V, $) : void 0) });
          return (function(B, V) {
            for (const $ in B) for (const ie of B[$]) bi(ie, V);
            return B;
          })((function(B) {
            const V = {}, $ = {};
            for (const ie of B) {
              const te = ie.queryResults, ne = ie.wrappedTileID, re = $[ne] = $[ne] || {};
              for (const ce in te) {
                const oe = te[ce], pe = re[ce] = re[ce] || {}, ye = V[ce] = V[ce] || [];
                for (const ue of oe) pe[ue.featureIndex] || (pe[ue.featureIndex] = !0, ye.push(ue));
              }
            }
            return V;
          })(j), y);
        }
        function Ta(y, e) {
          const r = y.tileID, c = e.tileID;
          return r.overscaledZ - c.overscaledZ || r.canonical.y - c.canonical.y || r.wrap - c.wrap || r.canonical.x - c.canonical.x;
        }
        function bi(y, e) {
          const r = y.feature, c = e.getFeatureState(r.layer["source-layer"], r.id);
          r.source = r.layer.source, r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]), r.state = c;
        }
        function oa(y, e, r) {
          return u._(this, void 0, void 0, (function* () {
            let c = y;
            if (y.url ? c = (yield u.j(e.transformRequest(y.url, "Source"), r)).data : yield he.frameAsync(r), !c) return null;
            const f = u.Q(u.e(c, y), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in c && c.vector_layers && (f.vectorLayerIds = c.vector_layers.map(((_) => _.id))), f;
          }));
        }
        class an {
          constructor(e, r) {
            e && (r ? this.setSouthWest(e).setNorthEast(r) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
          }
          setNorthEast(e) {
            return this._ne = e instanceof u.S ? new u.S(e.lng, e.lat) : u.S.convert(e), this;
          }
          setSouthWest(e) {
            return this._sw = e instanceof u.S ? new u.S(e.lng, e.lat) : u.S.convert(e), this;
          }
          extend(e) {
            const r = this._sw, c = this._ne;
            let f, _;
            if (e instanceof u.S) f = e, _ = e;
            else {
              if (!(e instanceof an)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(an.convert(e)) : this.extend(u.S.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(u.S.convert(e)) : this;
              if (f = e._sw, _ = e._ne, !f || !_) return this;
            }
            return r || c ? (r.lng = Math.min(f.lng, r.lng), r.lat = Math.min(f.lat, r.lat), c.lng = Math.max(_.lng, c.lng), c.lat = Math.max(_.lat, c.lat)) : (this._sw = new u.S(f.lng, f.lat), this._ne = new u.S(_.lng, _.lat)), this;
          }
          getCenter() {
            return new u.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new u.S(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new u.S(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e) {
            const { lng: r, lat: c } = u.S.convert(e);
            let f = this._sw.lng <= r && r <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (f = this._sw.lng >= r && r >= this._ne.lng), this._sw.lat <= c && c <= this._ne.lat && f;
          }
          static convert(e) {
            return e instanceof an ? e : e && new an(e);
          }
          static fromLngLat(e, r = 0) {
            const c = 360 * r / 40075017, f = c / Math.cos(Math.PI / 180 * e.lat);
            return new an(new u.S(e.lng - f, e.lat - c), new u.S(e.lng + f, e.lat + c));
          }
          adjustAntiMeridian() {
            const e = new u.S(this._sw.lng, this._sw.lat), r = new u.S(this._ne.lng, this._ne.lat);
            return new an(e, e.lng > r.lng ? new u.S(r.lng + 360, r.lat) : r);
          }
        }
        class $i {
          constructor(e, r, c) {
            this.bounds = an.convert(this.validateBounds(e)), this.minzoom = r || 0, this.maxzoom = c || 24;
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
          }
          contains(e) {
            const r = Math.pow(2, e.z), c = Math.floor(u.V(this.bounds.getWest()) * r), f = Math.floor(u.U(this.bounds.getNorth()) * r), _ = Math.ceil(u.V(this.bounds.getEast()) * r), w = Math.ceil(u.U(this.bounds.getSouth()) * r);
            return e.x >= c && e.x < _ && e.y >= f && e.y < w;
          }
        }
        class ma extends u.E {
          constructor(e, r, c, f) {
            if (super(), this.id = e, this.dispatcher = c, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, u.e(this, u.Q(r, ["url", "scheme", "tileSize", "promoteId"])), this._options = u.e({ type: "vector" }, r), this._collectResourceTiming = r.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(f);
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !1, this.fire(new u.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const e = yield oa(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (u.e(this, e), e.bounds && (this.tileBounds = new $i(e.bounds, this.minzoom, this.maxzoom)), this.fire(new u.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new u.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (e) {
                this._tileJSONRequest = null, this.fire(new u.k(e));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return u.e({}, this._options);
          }
          loadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = { request: this.map._requestManager.transformRequest(r, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
              c.request.collectResourceTiming = this._collectResourceTiming;
              let f = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((_, w) => {
                  e.reloadPromise = { resolve: _, reject: w };
                }));
              } else e.actor = this.dispatcher.getActor(), f = "LT";
              e.abortController = new AbortController();
              try {
                const _ = yield e.actor.sendAsync({ type: f, data: c }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, _);
              } catch (_) {
                if (delete e.abortController, e.aborted) return;
                if (_ && _.status !== 404) throw _;
                this._afterTileLoadWorkerResponse(e, null);
              }
            }));
          }
          _afterTileLoadWorkerResponse(e, r) {
            if (r && r.resourceTiming && (e.resourceTiming = r.resourceTiming), r && this.map._refreshExpiredTiles && e.setExpiryData(r), e.loadVectorData(r, this.map.painter), e.reloadPromise) {
              const c = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(c.resolve).catch(c.reject);
            }
          }
          abortTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          unloadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          hasTransition() {
            return !1;
          }
        }
        class dr extends u.E {
          constructor(e, r, c, f) {
            super(), this.id = e, this.dispatcher = c, this.setEventedParent(f), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = u.e({ type: "raster" }, r), u.e(this, u.Q(r, ["url", "scheme", "tileSize"]));
          }
          load() {
            return u._(this, arguments, void 0, (function* (e = !1) {
              this._loaded = !1, this.fire(new u.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const r = yield oa(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, r && (u.e(this, r), r.bounds && (this.tileBounds = new $i(r.bounds, this.minzoom, this.maxzoom)), this.fire(new u.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new u.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e })));
              } catch (r) {
                this._tileJSONRequest = null, this.fire(new u.k(r));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0);
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          serialize() {
            return u.e({}, this._options);
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController();
              try {
                const c = yield De.getImage(this.map._requestManager.transformRequest(r, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (c && c.data) {
                  this.map._refreshExpiredTiles && (c.cacheControl || c.expires) && e.setExpiryData({ cacheControl: c.cacheControl, expires: c.expires });
                  const f = this.map.painter.context, _ = f.gl, w = c.data;
                  e.texture = this.map.painter.getTileTexture(w.width), e.texture ? e.texture.update(w, { useMipmap: !0 }) : (e.texture = new u.T(f, w, _.RGBA, { useMipmap: !0 }), e.texture.bind(_.LINEAR, _.CLAMP_TO_EDGE, _.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
                }
              } catch (c) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (c) throw e.state = "errored", c;
              }
            }));
          }
          abortTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController);
            }));
          }
          unloadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.texture && this.map.painter.saveTileTexture(e.texture);
            }));
          }
          hasTransition() {
            return !1;
          }
        }
        class Xa extends dr {
          constructor(e, r, c, f) {
            super(e, r, c, f), this.type = "raster-dem", this.maxzoom = 22, this._options = u.e({ type: "raster-dem" }, r), this.encoding = r.encoding || "mapbox", this.redFactor = r.redFactor, this.greenFactor = r.greenFactor, this.blueFactor = r.blueFactor, this.baseShift = r.baseShift;
          }
          loadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = this.map._requestManager.transformRequest(r, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
              try {
                const f = yield De.getImage(c, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (f && f.data) {
                  const _ = f.data;
                  this.map._refreshExpiredTiles && (f.cacheControl || f.expires) && e.setExpiryData({ cacheControl: f.cacheControl, expires: f.expires });
                  const w = u.b(_) && u.W() ? _ : yield this.readImageNow(_), C = { type: this.type, uid: e.uid, source: this.id, rawImageData: w, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const P = yield e.actor.sendAsync({ type: "LDT", data: C });
                    e.dem = P, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded";
                  }
                }
              } catch (f) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (f) throw e.state = "errored", f;
              }
            }));
          }
          readImageNow(e) {
            return u._(this, void 0, void 0, (function* () {
              if (typeof VideoFrame < "u" && u.X()) {
                const r = e.width + 2, c = e.height + 2;
                try {
                  return new u.R({ width: r, height: c }, yield u.Y(e, -1, -1, r, c));
                } catch {
                }
              }
              return he.getImageData(e, 1);
            }));
          }
          _getNeighboringTiles(e) {
            const r = e.canonical, c = Math.pow(2, r.z), f = (r.x - 1 + c) % c, _ = r.x === 0 ? e.wrap - 1 : e.wrap, w = (r.x + 1 + c) % c, C = r.x + 1 === c ? e.wrap + 1 : e.wrap, P = {};
            return P[new u.Z(e.overscaledZ, _, r.z, f, r.y).key] = { backfilled: !1 }, P[new u.Z(e.overscaledZ, C, r.z, w, r.y).key] = { backfilled: !1 }, r.y > 0 && (P[new u.Z(e.overscaledZ, _, r.z, f, r.y - 1).key] = { backfilled: !1 }, P[new u.Z(e.overscaledZ, e.wrap, r.z, r.x, r.y - 1).key] = { backfilled: !1 }, P[new u.Z(e.overscaledZ, C, r.z, w, r.y - 1).key] = { backfilled: !1 }), r.y + 1 < c && (P[new u.Z(e.overscaledZ, _, r.z, f, r.y + 1).key] = { backfilled: !1 }, P[new u.Z(e.overscaledZ, e.wrap, r.z, r.x, r.y + 1).key] = { backfilled: !1 }, P[new u.Z(e.overscaledZ, C, r.z, w, r.y + 1).key] = { backfilled: !1 }), P;
          }
          unloadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } }));
            }));
          }
        }
        class Ya extends u.E {
          constructor(e, r, c, f) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = { data: r.data }, this.actor = c.getActor(), this.setEventedParent(f), this._data = r.data, this._options = u.e({}, r), this._collectResourceTiming = r.collectResourceTiming, r.maxzoom !== void 0 && (this.maxzoom = r.maxzoom), r.type && (this.type = r.type), r.attribution && (this.attribution = r.attribution), this.promoteId = r.promoteId, r.clusterMaxZoom !== void 0 && this.maxzoom <= r.clusterMaxZoom && u.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${r.clusterMaxZoom}".`), this.workerOptions = u.e({ source: this.id, cluster: r.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(r.buffer !== void 0 ? r.buffer : 128), tolerance: this._pixelsToTileUnits(r.tolerance !== void 0 ? r.tolerance : 0.375), extent: u.$, maxZoom: this.maxzoom, lineMetrics: r.lineMetrics || !1, generateId: r.generateId || !1 }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(r.clusterMaxZoom), minPoints: Math.max(2, r.clusterMinPoints || 2), extent: u.$, radius: this._pixelsToTileUnits(r.clusterRadius || 50), log: !1, generateId: r.generateId || !1 }, clusterProperties: r.clusterProperties, filter: r.filter }, r.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _pixelsToTileUnits(e) {
            return e * (u.$ / this.tileSize);
          }
          _getClusterMaxZoom(e) {
            const r = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || u.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${r}"`), r;
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              yield this._updateWorkerData();
            }));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = { data: e }, this._updateWorkerData(), this;
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = u.a0(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this;
          }
          getData() {
            return u._(this, void 0, void 0, (function* () {
              const e = u.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: e });
            }));
          }
          getCoordinatesFromGeometry(e) {
            return e.type === "GeometryCollection" ? e.geometries.map(((r) => r.coordinates)).flat(1 / 0) : e.coordinates.flat(1 / 0);
          }
          getBounds() {
            return u._(this, void 0, void 0, (function* () {
              const e = new an(), r = yield this.getData();
              let c;
              switch (r.type) {
                case "FeatureCollection":
                  c = r.features.map(((f) => this.getCoordinatesFromGeometry(f.geometry))).flat(1 / 0);
                  break;
                case "Feature":
                  c = this.getCoordinatesFromGeometry(r.geometry);
                  break;
                default:
                  c = this.getCoordinatesFromGeometry(r);
              }
              if (c.length == 0) return e;
              for (let f = 0; f < c.length - 1; f += 2) e.extend([c[f], c[f + 1]]);
              return e;
            }));
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom))), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterLeaves(e, r, c) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: r, offset: c } });
          }
          _updateWorkerData() {
            return u._(this, void 0, void 0, (function* () {
              if (this._isUpdatingWorker) return;
              const { data: e, diff: r } = this._pendingWorkerUpdate;
              if (!e && !r) return void u.w(`No data or diff provided to GeoJSONSource ${this.id}.`);
              const c = u.e({ type: this.type }, this.workerOptions);
              e ? (typeof e == "string" ? (c.request = this.map._requestManager.transformRequest(he.resolveURL(e), "Source"), c.request.collectResourceTiming = this._collectResourceTiming) : c.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : r && (c.dataDiff = r, this._pendingWorkerUpdate.diff = void 0), this._isUpdatingWorker = !0, this.fire(new u.l("dataloading", { dataType: "source" }));
              try {
                const f = yield this.actor.sendAsync({ type: "LD", data: c });
                if (this._isUpdatingWorker = !1, this._removed || f.abandoned) return void this.fire(new u.l("dataabort", { dataType: "source" }));
                this._data = f.data;
                let _ = null;
                f.resourceTiming && f.resourceTiming[this.id] && (_ = f.resourceTiming[this.id].slice(0));
                const w = { dataType: "source" };
                this._collectResourceTiming && _ && _.length > 0 && u.e(w, { resourceTiming: _ }), this.fire(new u.l("data", Object.assign(Object.assign({}, w), { sourceDataType: "metadata" }))), this.fire(new u.l("data", Object.assign(Object.assign({}, w), { sourceDataType: "content" })));
              } catch (f) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new u.l("dataabort", { dataType: "source" }));
                this.fire(new u.k(f));
              } finally {
                (this._pendingWorkerUpdate.data || this._pendingWorkerUpdate.diff) && this._updateWorkerData();
              }
            }));
          }
          loaded() {
            return !this._isUpdatingWorker && this._pendingWorkerUpdate.data === void 0 && this._pendingWorkerUpdate.diff === void 0;
          }
          loadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              const r = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const c = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
              e.abortController = new AbortController();
              const f = yield this.actor.sendAsync({ type: r, data: c }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(f, this.map.painter, r === "RT");
            }));
          }
          abortTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0;
            }));
          }
          unloadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
            }));
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return u.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return !1;
          }
        }
        class pr extends u.E {
          constructor(e, r, c, f) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = c, this.coordinates = r.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(f), this.options = r;
          }
          load(e) {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !1, this.fire(new u.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const r = yield De.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, r && r.data && (this.image = r.data, e && (this.coordinates = e), this._finishLoading());
              } catch (r) {
                this._request = null, this._loaded = !0, this.fire(new u.k(r));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null;
            })), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new u.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(e) {
            this.coordinates = e;
            const r = e.map(u.a1.fromLngLat);
            var c;
            return this.tileID = (function(f) {
              const _ = u.a2.fromPoints(f), w = _.width(), C = _.height(), P = Math.max(w, C), R = Math.max(0, Math.floor(-Math.log(P) / Math.LN2)), L = Math.pow(2, R);
              return new u.a4(R, Math.floor((_.minX + _.maxX) / 2 * L), Math.floor((_.minY + _.maxY) / 2 * L));
            })(r), this.terrainTileRanges = this._getOverlappingTileRanges(r), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = r.map(((f) => this.tileID.getTilePoint(f)._round())), this.flippedWindingOrder = ((c = this.tileCoords)[1].x - c[0].x) * (c[2].y - c[0].y) - (c[1].y - c[0].y) * (c[2].x - c[0].x) < 0, this.fire(new u.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context, r = e.gl;
            this.texture || (this.texture = new u.T(e, this.image, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
            let c = !1;
            for (const f in this.tiles) {
              const _ = this.tiles[f];
              _.state !== "loaded" && (_.state = "loaded", _.texture = this.texture, c = !0);
            }
            c && this.fire(new u.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
            }));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return !1;
          }
          _getOverlappingTileRanges(e) {
            const { minX: r, minY: c, maxX: f, maxY: _ } = u.a2.fromPoints(e), w = {};
            for (let C = 0; C <= u.a3; C++) {
              const P = Math.pow(2, C), R = Math.floor(r * P), L = Math.floor(c * P), j = Math.floor(f * P), B = Math.floor(_ * P);
              w[C] = { minTileX: R, minTileY: L, maxTileX: j, maxTileY: B };
            }
            return w;
          }
        }
        class Os extends pr {
          constructor(e, r, c, f) {
            super(e, r, c, f), this.roundZoom = !0, this.type = "video", this.options = r;
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const r of e.urls) this.urls.push(this.map._requestManager.transformRequest(r, "Source").url);
              try {
                const r = yield u.a5(this.urls);
                if (this._loaded = !0, !r) return;
                this.video = r, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint();
                })), this.map && this.video.play(), this._finishLoading();
              } catch (r) {
                this.fire(new u.k(r));
              }
            }));
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e) {
            if (this.video) {
              const r = this.video.seekable;
              e < r.start(0) || e > r.end(0) ? this.fire(new u.k(new u.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${r.start(0)} and ${r.end(0)}-second mark.`))) : this.video.currentTime = e;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context, r = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE), r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, r.RGBA, r.UNSIGNED_BYTE, this.video)) : (this.texture = new u.T(e, this.video, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
            let c = !1;
            for (const f in this.tiles) {
              const _ = this.tiles[f];
              _.state !== "loaded" && (_.state = "loaded", _.texture = this.texture, c = !0);
            }
            c && this.fire(new u.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class Xr extends pr {
          constructor(e, r, c, f) {
            super(e, r, c, f), r.coordinates ? Array.isArray(r.coordinates) && r.coordinates.length === 4 && !r.coordinates.some(((_) => !Array.isArray(_) || _.length !== 2 || _.some(((w) => typeof w != "number")))) || this.fire(new u.k(new u.a6(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new u.k(new u.a6(`sources.${e}`, null, 'missing required property "coordinates"'))), r.animate && typeof r.animate != "boolean" && this.fire(new u.k(new u.a6(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), r.canvas ? typeof r.canvas == "string" || r.canvas instanceof HTMLCanvasElement || this.fire(new u.k(new u.a6(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new u.k(new u.a6(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = r, this.animate = r.animate === void 0 || r.animate;
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new u.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1);
              }, this._finishLoading());
            }));
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const r = this.map.painter.context, c = r.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new u.T(r, this.canvas, c.RGBA, { premultiply: !0 });
            let f = !1;
            for (const _ in this.tiles) {
              const w = this.tiles[_];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture, f = !0);
            }
            f && this.fire(new u.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;
            return !1;
          }
        }
        const Yr = {}, ho = (y) => {
          switch (y) {
            case "geojson":
              return Ya;
            case "image":
              return pr;
            case "raster":
              return dr;
            case "raster-dem":
              return Xa;
            case "vector":
              return ma;
            case "video":
              return Os;
            case "canvas":
              return Xr;
          }
          return Yr[y];
        }, Yn = "RTLPluginLoaded";
        class po extends u.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = si();
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch(((r) => {
              throw this.status = "error", r;
            }));
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(e) {
            return u._(this, arguments, void 0, (function* (r, c = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = he.resolveURL(r), !this.url) throw new Error(`requested url ${r} is invalid`);
              if (this.status === "unavailable") {
                if (!c) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            }));
          }
          _requestImport() {
            return u._(this, void 0, void 0, (function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new u.l(Yn));
            }));
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let Bs = null;
        function Ns() {
          return Bs || (Bs = new po()), Bs;
        }
        class js {
          constructor(e, r) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = u.a7(), this.uses = 0, this.tileSize = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(e) {
            const r = e + this.timeAdded;
            r < this.fadeEndTime || (this.fadeEndTime = r);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e, r, c) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(f, _) {
                const w = {};
                if (!_) return w;
                for (const C of f) {
                  const P = C.layerIds.map(((R) => _.getLayer(R))).filter(Boolean);
                  if (P.length !== 0) {
                    C.layers = P, C.stateDependentLayerIds && (C.stateDependentLayers = C.stateDependentLayerIds.map(((R) => P.filter(((L) => L.id === R))[0])));
                    for (const R of P) w[R.id] = C;
                  }
                }
                return w;
              })(e.buckets, r?.style), this.hasSymbolBuckets = !1;
              for (const f in this.buckets) {
                const _ = this.buckets[f];
                if (_ instanceof u.a9) {
                  if (this.hasSymbolBuckets = !0, !c) break;
                  _.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const f in this.buckets) {
                const _ = this.buckets[f];
                if (_ instanceof u.a9 && _.hasRTLText) {
                  this.hasRTLText = !0, Ns().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const f in this.buckets) {
                const _ = this.buckets[f];
                this.queryPadding = Math.max(this.queryPadding, r.style.getLayer(f).queryRadius(_));
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
            } else this.collisionBoxArray = new u.a8();
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(e) {
            return this.buckets[e.id];
          }
          upload(e) {
            for (const c in this.buckets) {
              const f = this.buckets[c];
              f.uploadPending() && f.upload(e);
            }
            const r = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new u.T(e, this.imageAtlas.image, r.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new u.T(e, this.glyphAtlasImage, r.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
          }
          queryRenderedFeatures(e, r, c, f, _, w, C, P, R, L, j) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: f, cameraQueryGeometry: _, scale: w, tileSize: this.tileSize, pixelPosMatrix: L, transform: P, params: C, queryPadding: this.queryPadding * R, getElevation: j }, e, r, c) : {};
          }
          querySourceFeatures(e, r) {
            const c = this.latestFeatureIndex;
            if (!c || !c.rawTileData) return;
            const f = c.loadVTLayers(), _ = r && r.sourceLayer ? r.sourceLayer : "", w = f._geojsonTileLayer || f[_];
            if (!w) return;
            const C = u.aa(r && r.filter), { z: P, x: R, y: L } = this.tileID.canonical, j = { z: P, x: R, y: L };
            for (let B = 0; B < w.length; B++) {
              const V = w.feature(B);
              if (C.needGeometry) {
                const te = u.ab(V, !0);
                if (!C.filter(new u.F(this.tileID.overscaledZ), te, this.tileID.canonical)) continue;
              } else if (!C.filter(new u.F(this.tileID.overscaledZ), V)) continue;
              const $ = c.getId(V, _), ie = new u.ac(V, P, R, L, $);
              ie.tile = j, e.push(ie);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e) {
            const r = this.expirationTime;
            if (e.cacheControl) {
              const c = u.ad(e.cacheControl);
              c["max-age"] && (this.expirationTime = Date.now() + 1e3 * c["max-age"]);
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const c = Date.now();
              let f = !1;
              if (this.expirationTime > c) f = !1;
              else if (r) if (this.expirationTime < r) f = !0;
              else {
                const _ = this.expirationTime - r;
                _ ? this.expirationTime = c + Math.max(_, 3e4) : f = !0;
              }
              else f = !0;
              f ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e, r) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const c = this.latestFeatureIndex.loadVTLayers();
            for (const f in this.buckets) {
              if (!r.style.hasLayer(f)) continue;
              const _ = this.buckets[f], w = _.layers[0].sourceLayer || "_geojsonTileLayer", C = c[w], P = e[w];
              if (!C || !P || Object.keys(P).length === 0) continue;
              _.update(P, C, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const R = r && r.style && r.style.getLayer(f);
              R && (this.queryPadding = Math.max(this.queryPadding, R.queryRadius(_)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < he.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e) {
            this.symbolFadeHoldUntil = he.now() + e;
          }
          setDependencies(e, r) {
            const c = {};
            for (const f of r) c[f] = !0;
            this.dependencies[e] = c;
          }
          hasDependency(e, r) {
            for (const c of e) {
              const f = this.dependencies[c];
              if (f) {
                for (const _ of r) if (f[_]) return !0;
              }
            }
            return !1;
          }
        }
        class be {
          constructor(e, r) {
            this.max = e, this.onRemove = r, this.reset();
          }
          reset() {
            for (const e in this.data) for (const r of this.data[e]) r.timeout && clearTimeout(r.timeout), this.onRemove(r.value);
            return this.data = {}, this.order = [], this;
          }
          add(e, r, c) {
            const f = e.wrapped().key;
            this.data[f] === void 0 && (this.data[f] = []);
            const _ = { value: r, timeout: void 0 };
            if (c !== void 0 && (_.timeout = setTimeout((() => {
              this.remove(e, _);
            }), c)), this.data[f].push(_), this.order.push(f), this.order.length > this.max) {
              const w = this._getAndRemoveByKey(this.order[0]);
              w && this.onRemove(w);
            }
            return this;
          }
          has(e) {
            return e.wrapped().key in this.data;
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
          }
          _getAndRemoveByKey(e) {
            const r = this.data[e].shift();
            return r.timeout && clearTimeout(r.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), r.value;
          }
          getByKey(e) {
            const r = this.data[e];
            return r ? r[0].value : null;
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null;
          }
          remove(e, r) {
            if (!this.has(e)) return this;
            const c = e.wrapped().key, f = r === void 0 ? 0 : this.data[c].indexOf(r), _ = this.data[c][f];
            return this.data[c].splice(f, 1), _.timeout && clearTimeout(_.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(_.value), this.order.splice(this.order.indexOf(c), 1), this;
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max; ) {
              const r = this._getAndRemoveByKey(this.order[0]);
              r && this.onRemove(r);
            }
            return this;
          }
          filter(e) {
            const r = [];
            for (const c in this.data) for (const f of this.data[c]) e(f.value) || r.push(f);
            for (const c of r) this.remove(c.value.tileID, c);
          }
        }
        class H {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e, r, c) {
            const f = String(r);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][f] = this.stateChanges[e][f] || {}, u.e(this.stateChanges[e][f], c), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const _ in this.state[e]) _ !== f && (this.deletedStates[e][_] = null);
            } else if (this.deletedStates[e] && this.deletedStates[e][f] === null) {
              this.deletedStates[e][f] = {};
              for (const _ in this.state[e][f]) c[_] || (this.deletedStates[e][f][_] = null);
            } else for (const _ in c) this.deletedStates[e] && this.deletedStates[e][f] && this.deletedStates[e][f][_] === null && delete this.deletedStates[e][f][_];
          }
          removeFeatureState(e, r, c) {
            if (this.deletedStates[e] === null) return;
            const f = String(r);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, c && r !== void 0) this.deletedStates[e][f] !== null && (this.deletedStates[e][f] = this.deletedStates[e][f] || {}, this.deletedStates[e][f][c] = null);
            else if (r !== void 0) if (this.stateChanges[e] && this.stateChanges[e][f]) for (c in this.deletedStates[e][f] = {}, this.stateChanges[e][f]) this.deletedStates[e][f][c] = null;
            else this.deletedStates[e][f] = null;
            else this.deletedStates[e] = null;
          }
          getState(e, r) {
            const c = String(r), f = u.e({}, (this.state[e] || {})[c], (this.stateChanges[e] || {})[c]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const _ = this.deletedStates[e][r];
              if (_ === null) return {};
              for (const w in _) delete f[w];
            }
            return f;
          }
          initializeTileState(e, r) {
            e.setFeatureState(this.state, r);
          }
          coalesceChanges(e, r) {
            const c = {};
            for (const f in this.stateChanges) {
              this.state[f] = this.state[f] || {};
              const _ = {};
              for (const w in this.stateChanges[f]) this.state[f][w] || (this.state[f][w] = {}), u.e(this.state[f][w], this.stateChanges[f][w]), _[w] = this.state[f][w];
              c[f] = _;
            }
            for (const f in this.deletedStates) {
              this.state[f] = this.state[f] || {};
              const _ = {};
              if (this.deletedStates[f] === null) for (const w in this.state[f]) _[w] = {}, this.state[f][w] = {};
              else for (const w in this.deletedStates[f]) {
                if (this.deletedStates[f][w] === null) this.state[f][w] = {};
                else for (const C of Object.keys(this.deletedStates[f][w])) delete this.state[f][w][C];
                _[w] = this.state[f][w];
              }
              c[f] = c[f] || {}, u.e(c[f], _);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(c).length !== 0) for (const f in e) e[f].setFeatureState(c, r);
          }
        }
        const Y = 89.25;
        function Q(y, e) {
          const r = u.ah(e.lat, -u.ai, u.ai);
          return new u.P(u.V(e.lng) * y, u.U(r) * y);
        }
        function le(y, e) {
          return new u.a1(e.x / y, e.y / y).toLngLat();
        }
        function me(y) {
          return y.cameraToCenterDistance * Math.min(0.85 * Math.tan(u.ae(90 - y.pitch)), Math.tan(u.ae(Y - y.pitch)));
        }
        function ve(y, e) {
          const r = y.canonical, c = e / u.af(r.z), f = r.x + Math.pow(2, r.z) * y.wrap, _ = u.ag(new Float64Array(16));
          return u.M(_, _, [f * c, r.y * c, 0]), u.N(_, _, [c / u.$, c / u.$, 1]), _;
        }
        function Ee(y, e, r, c, f) {
          const _ = u.a1.fromLngLat(y, e), w = f * u.aj(1, y.lat), C = w * Math.cos(u.ae(r)), P = Math.sqrt(w * w - C * C), R = P * Math.sin(u.ae(-c)), L = P * Math.cos(u.ae(-c));
          return new u.a1(_.x + R, _.y + L, _.z + C);
        }
        function Te(y, e, r) {
          const c = e.intersectsFrustum(y);
          if (!r || c === 0) return c;
          const f = e.intersectsPlane(r);
          return f === 0 ? 0 : c === 2 && f === 2 ? 2 : 1;
        }
        function Ge(y, e, r) {
          let c = 0;
          const f = (r - e) / 10;
          for (let _ = 0; _ < 10; _++) c += f * Math.pow(Math.cos(e + (_ + 0.5) / 10 * (r - e)), y);
          return c;
        }
        function tt(y, e) {
          return function(r, c, f, _, w) {
            const C = 2 * ((y - 1) / u.ak(Math.cos(u.ae(Y - w)) / Math.cos(u.ae(Y))) - 1), P = Math.acos(f / _), R = 2 * Ge(C - 1, 0, u.ae(w / 2)), L = Math.min(u.ae(Y), P + u.ae(w / 2)), j = Ge(C - 1, Math.min(L, P - u.ae(w / 2)), L), B = Math.atan(c / f), V = Math.hypot(c, f);
            let $ = r;
            return $ += u.ak(_ / V / Math.max(0.5, Math.cos(u.ae(w / 2)))), $ += C * u.ak(Math.cos(B)) / 2, $ -= u.ak(Math.max(1, j / R / e)) / 2, $;
          };
        }
        const Ye = tt(9.314, 3);
        function Mt(y, e) {
          const r = (e.roundZoom ? Math.round : Math.floor)(y.zoom + u.ak(y.tileSize / e.tileSize));
          return Math.max(0, r);
        }
        function Ae(y, e) {
          const r = y.getCameraFrustum(), c = y.getClippingPlane(), f = y.screenPointToMercatorCoordinate(y.getCameraPoint()), _ = u.a1.fromLngLat(y.center, y.elevation);
          f.z = _.z + Math.cos(y.pitchInRadians) * y.cameraToCenterDistance / y.worldSize;
          const w = y.getCoveringTilesDetailsProvider(), C = w.allowVariableZoom(y, e), P = Mt(y, e), R = e.minzoom || 0, L = e.maxzoom !== void 0 ? e.maxzoom : y.maxZoom, j = Math.min(Math.max(0, P), L), B = Math.pow(2, j), V = [B * f.x, B * f.y, 0], $ = [B * _.x, B * _.y, 0], ie = Math.hypot(_.x - f.x, _.y - f.y), te = Math.abs(_.z - f.z), ne = Math.hypot(ie, te), re = (pe) => ({ zoom: 0, x: 0, y: 0, wrap: pe, fullyVisible: !1 }), ce = [], oe = [];
          if (y.renderWorldCopies && w.allowWorldCopies()) for (let pe = 1; pe <= 3; pe++) ce.push(re(-pe)), ce.push(re(pe));
          for (ce.push(re(0)); ce.length > 0; ) {
            const pe = ce.pop(), ye = pe.x, ue = pe.y;
            let we = pe.fullyVisible;
            const Oe = { x: ye, y: ue, z: pe.zoom }, ze = w.getTileBoundingVolume(Oe, pe.wrap, y.elevation, e);
            if (!we) {
              const ct = Te(r, ze, c);
              if (ct === 0) continue;
              we = ct === 2;
            }
            const Pe = w.distanceToTile2d(f.x, f.y, Oe, ze);
            let Le = P;
            C && (Le = (e.calculateTileZoom || Ye)(y.zoom + u.ak(y.tileSize / e.tileSize), Pe, te, ne, y.fov)), Le = (e.roundZoom ? Math.round : Math.floor)(Le), Le = Math.max(0, Le);
            const lt = Math.min(Le, L);
            if (pe.wrap = w.getWrap(_, Oe, pe.wrap), pe.zoom >= lt) {
              if (pe.zoom < R) continue;
              const ct = j - pe.zoom, We = V[0] - 0.5 - (ye << ct), At = V[1] - 0.5 - (ue << ct), ai = e.reparseOverscaled ? Math.max(pe.zoom, Le) : pe.zoom;
              oe.push({ tileID: new u.Z(pe.zoom === L ? ai : pe.zoom, pe.wrap, pe.zoom, ye, ue), distanceSq: u.al([$[0] - 0.5 - ye, $[1] - 0.5 - ue]), tileDistanceToCamera: Math.sqrt(We * We + At * At) });
            } else for (let ct = 0; ct < 4; ct++) ce.push({ zoom: pe.zoom + 1, x: (ye << 1) + ct % 2, y: (ue << 1) + (ct >> 1), wrap: pe.wrap, fullyVisible: we });
          }
          return oe.sort(((pe, ye) => pe.distanceSq - ye.distanceSq)).map(((pe) => pe.tileID));
        }
        const qt = u.a2.fromPoints([new u.P(0, 0), new u.P(u.$, u.$)]);
        class ri extends u.E {
          constructor(e, r, c) {
            super(), this.id = e, this.dispatcher = c, this.on("data", ((f) => this._dataHandler(f))), this.on("dataloading", (() => {
              this._sourceErrored = !1;
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded();
            })), this._source = ((f, _, w, C) => {
              const P = new (ho(_.type))(f, _, w, C);
              if (P.id !== f) throw new Error(`Expected Source id to be ${f} instead of ${P.id}`);
              return P;
            })(e, r, c, this), this._tiles = {}, this._cache = new be(0, ((f) => this._unloadTile(f))), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new H(), this._didEmitContent = !1, this._updated = !1;
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const r = this._tiles[e];
              if (r.state !== "loaded" && r.state !== "errored") return !1;
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(e, r, c) {
            return u._(this, void 0, void 0, (function* () {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, r, c);
              } catch (f) {
                e.state = "errored", f.status !== 404 ? this._source.fire(new u.k(f, { tile: e })) : this.update(this.transform, this.terrain);
              }
            }));
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e);
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new u.l("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const r in this._tiles) {
              const c = this._tiles[r];
              c.upload(e), c.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map(((e) => e.tileID)).sort(It).map(((e) => e.key));
          }
          getRenderableIds(e) {
            const r = [];
            for (const c in this._tiles) this._isIdRenderable(c, e) && r.push(this._tiles[c]);
            return e ? r.sort(((c, f) => {
              const _ = c.tileID, w = f.tileID, C = new u.P(_.canonical.x, _.canonical.y)._rotate(-this.transform.bearingInRadians), P = new u.P(w.canonical.x, w.canonical.y)._rotate(-this.transform.bearingInRadians);
              return _.overscaledZ - w.overscaledZ || P.y - C.y || P.x - C.x;
            })).map(((c) => c.tileID.key)) : r.map(((c) => c.tileID)).sort(It).map(((c) => c.key));
          }
          hasRenderableParent(e) {
            const r = this.findLoadedParent(e, 0);
            return !!r && this._isIdRenderable(r.tileID.key);
          }
          _isIdRenderable(e, r) {
            return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (r || !this._tiles[e].holdingForFade());
          }
          reload(e) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const r in this._tiles) e ? this._reloadTile(r, "expired") : this._tiles[r].state !== "errored" && this._reloadTile(r, "reloading");
            }
          }
          _reloadTile(e, r) {
            return u._(this, void 0, void 0, (function* () {
              const c = this._tiles[e];
              c && (c.state !== "loading" && (c.state = r), yield this._loadTile(c, e, r));
            }));
          }
          _tileLoaded(e, r, c) {
            e.timeAdded = he.now(), c === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(r, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new u.l("data", { dataType: "source", tile: e, coord: e.tileID }));
          }
          _backfillDEM(e) {
            const r = this.getRenderableIds();
            for (let f = 0; f < r.length; f++) {
              const _ = r[f];
              if (e.neighboringTiles && e.neighboringTiles[_]) {
                const w = this.getTileByID(_);
                c(e, w), c(w, e);
              }
            }
            function c(f, _) {
              f.needsHillshadePrepare = !0, f.needsTerrainPrepare = !0;
              let w = _.tileID.canonical.x - f.tileID.canonical.x;
              const C = _.tileID.canonical.y - f.tileID.canonical.y, P = Math.pow(2, f.tileID.canonical.z), R = _.tileID.key;
              w === 0 && C === 0 || Math.abs(C) > 1 || (Math.abs(w) > 1 && (Math.abs(w + P) === 1 ? w += P : Math.abs(w - P) === 1 && (w -= P)), _.dem && f.dem && (f.dem.backfillBorder(_.dem, w, C), f.neighboringTiles && f.neighboringTiles[R] && (f.neighboringTiles[R].backfilled = !0)));
            }
          }
          getTile(e) {
            return this.getTileByID(e.key);
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          _retainLoadedChildren(e, r, c, f) {
            for (const _ in this._tiles) {
              let w = this._tiles[_];
              if (f[_] || !w.hasData() || w.tileID.overscaledZ <= r || w.tileID.overscaledZ > c) continue;
              let C = w.tileID;
              for (; w && w.tileID.overscaledZ > r + 1; ) {
                const R = w.tileID.scaledTo(w.tileID.overscaledZ - 1);
                w = this._tiles[R.key], w && w.hasData() && (C = R);
              }
              let P = C;
              for (; P.overscaledZ > r; ) if (P = P.scaledTo(P.overscaledZ - 1), e[P.key] || e[P.canonical.key]) {
                f[C.key] = C;
                break;
              }
            }
          }
          findLoadedParent(e, r) {
            if (e.key in this._loadedParentTiles) {
              const c = this._loadedParentTiles[e.key];
              return c && c.tileID.overscaledZ >= r ? c : null;
            }
            for (let c = e.overscaledZ - 1; c >= r; c--) {
              const f = e.scaledTo(c), _ = this._getLoadedTile(f);
              if (_) return _;
            }
          }
          findLoadedSibling(e) {
            return this._getLoadedTile(e);
          }
          _getLoadedTile(e) {
            const r = this._tiles[e.key];
            return r && r.hasData() ? r : this._cache.getByKey(e.wrapped().key);
          }
          updateCacheSize(e) {
            const r = Math.ceil(e.width / this._source.tileSize) + 1, c = Math.ceil(e.height / this._source.tileSize) + 1, f = Math.floor(r * c * (this._maxTileCacheZoomLevels === null ? u.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), _ = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, f) : f;
            this._cache.setMaxSize(_);
          }
          handleWrapJump(e) {
            const r = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, r) {
              const c = {};
              for (const f in this._tiles) {
                const _ = this._tiles[f];
                _.tileID = _.tileID.unwrapTo(_.tileID.wrap + r), c[_.tileID.key] = _;
              }
              this._tiles = c;
              for (const f in this._timers) clearTimeout(this._timers[f]), delete this._timers[f];
              for (const f in this._tiles) this._setTileReloadTimer(f, this._tiles[f]);
            }
          }
          _updateCoveredAndRetainedTiles(e, r, c, f, _, w) {
            const C = {}, P = {}, R = Object.keys(e), L = he.now();
            for (const j of R) {
              const B = e[j], V = this._tiles[j];
              if (!V || V.fadeEndTime !== 0 && V.fadeEndTime <= L) continue;
              const $ = this.findLoadedParent(B, r), ie = this.findLoadedSibling(B), te = $ || ie || null;
              te && (this._addTile(te.tileID), C[te.tileID.key] = te.tileID), P[j] = B;
            }
            this._retainLoadedChildren(P, f, c, e);
            for (const j in C) e[j] || (this._coveredTiles[j] = !0, e[j] = C[j]);
            if (w) {
              const j = {}, B = {};
              for (const V of _) this._tiles[V.key].hasData() ? j[V.key] = V : B[V.key] = V;
              for (const V in B) {
                const $ = B[V].children(this._source.maxzoom);
                this._tiles[$[0].key] && this._tiles[$[1].key] && this._tiles[$[2].key] && this._tiles[$[3].key] && (j[$[0].key] = e[$[0].key] = $[0], j[$[1].key] = e[$[1].key] = $[1], j[$[2].key] = e[$[2].key] = $[2], j[$[3].key] = e[$[3].key] = $[3], delete B[V]);
              }
              for (const V in B) {
                const $ = B[V], ie = this.findLoadedParent($, this._source.minzoom), te = this.findLoadedSibling($), ne = ie || te || null;
                if (ne) {
                  j[ne.tileID.key] = e[ne.tileID.key] = ne.tileID;
                  for (const re in j) j[re].isChildOf(ne.tileID) && delete j[re];
                }
              }
              for (const V in this._tiles) j[V] || (this._coveredTiles[V] = !0);
            }
          }
          update(e, r) {
            if (!this._sourceLoaded || this._paused) return;
            let c;
            this.transform = e, this.terrain = r, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? c = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(((L) => new u.Z(L.canonical.z, L.wrap, L.canonical.z, L.canonical.x, L.canonical.y))) : (c = Ae(e, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: r, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (c = c.filter(((L) => this._source.hasTile(L))))) : c = [];
            const f = Mt(e, this._source), _ = Math.max(f - ri.maxOverzooming, this._source.minzoom), w = Math.max(f + ri.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const L = {};
              for (const j of c) if (j.canonical.z > this._source.minzoom) {
                const B = j.scaledTo(j.canonical.z - 1);
                L[B.key] = B;
                const V = j.scaledTo(Math.max(this._source.minzoom, Math.min(j.canonical.z, 5)));
                L[V.key] = V;
              }
              c = c.concat(Object.values(L));
            }
            const C = c.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, C && this.fire(new u.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const P = this._updateRetainedTiles(c, f);
            ti(this._source.type) && this._updateCoveredAndRetainedTiles(P, _, w, f, c, r);
            for (const L in P) this._tiles[L].clearFadeHold();
            const R = u.am(this._tiles, P);
            for (const L of R) {
              const j = this._tiles[L];
              j.hasSymbolBuckets && !j.holdingForFade() ? j.setHoldDuration(this.map._fadeDuration) : j.hasSymbolBuckets && !j.symbolFadeFinished() || this._removeTile(L);
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
          }
          _updateRetainedTiles(e, r) {
            var c;
            const f = {}, _ = {}, w = Math.max(r - ri.maxOverzooming, this._source.minzoom), C = Math.max(r + ri.maxUnderzooming, this._source.minzoom), P = {};
            for (const R of e) {
              const L = this._addTile(R);
              f[R.key] = R, L.hasData() || r < this._source.maxzoom && (P[R.key] = R);
            }
            this._retainLoadedChildren(P, r, C, f);
            for (const R of e) {
              let L = this._tiles[R.key];
              if (L.hasData()) continue;
              if (r + 1 > this._source.maxzoom) {
                const B = R.children(this._source.maxzoom)[0], V = this.getTile(B);
                if (V && V.hasData()) {
                  f[B.key] = B;
                  continue;
                }
              } else {
                const B = R.children(this._source.maxzoom);
                if (f[B[0].key] && f[B[1].key] && f[B[2].key] && f[B[3].key]) continue;
              }
              let j = L.wasRequested();
              for (let B = R.overscaledZ - 1; B >= w; --B) {
                const V = R.scaledTo(B);
                if (_[V.key]) break;
                if (_[V.key] = !0, L = this.getTile(V), !L && j && (L = this._addTile(V)), L) {
                  const $ = L.hasData();
                  if (($ || !(!((c = this.map) === null || c === void 0) && c.cancelPendingTileRequestsWhileZooming) || j) && (f[V.key] = V), j = L.wasRequested(), $) break;
                }
              }
            }
            return f;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e in this._tiles) {
              const r = [];
              let c, f = this._tiles[e].tileID;
              for (; f.overscaledZ > 0; ) {
                if (f.key in this._loadedParentTiles) {
                  c = this._loadedParentTiles[f.key];
                  break;
                }
                r.push(f.key);
                const _ = f.scaledTo(f.overscaledZ - 1);
                if (c = this._getLoadedTile(_), c) break;
                f = _;
              }
              for (const _ of r) this._loadedParentTiles[_] = c;
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const e in this._tiles) {
              const r = this._tiles[e].tileID, c = this._getLoadedTile(r);
              this._loadedSiblingTiles[r.key] = c;
            }
          }
          _addTile(e) {
            let r = this._tiles[e.key];
            if (r) return r;
            r = this._cache.getAndRemove(e), r && (this._setTileReloadTimer(e.key, r), r.tileID = e, this._state.initializeTileState(r, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, r)));
            const c = r;
            return r || (r = new js(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(r, e.key, r.state)), r.uses++, this._tiles[e.key] = r, c || this._source.fire(new u.l("dataloading", { tile: r, coord: r.tileID, dataType: "source" })), r;
          }
          _setTileReloadTimer(e, r) {
            e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
            const c = r.getExpiryTimeout();
            c && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e];
            }), c));
          }
          refreshTiles(e) {
            for (const r in this._tiles) (this._isIdRenderable(r) || this._tiles[r].state == "errored") && e.some(((c) => c.equals(this._tiles[r].tileID.canonical))) && this._reloadTile(r, "expired");
          }
          _removeTile(e) {
            const r = this._tiles[e];
            r && (r.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), r.uses > 0 || (r.hasData() && r.state !== "reloading" ? this._cache.add(r.tileID, r, r.getExpiryTimeout()) : (r.aborted = !0, this._abortTile(r), this._unloadTile(r))));
          }
          _dataHandler(e) {
            const r = e.sourceDataType;
            e.dataType === "source" && r === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && e.dataType === "source" && r === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset();
          }
          tilesIn(e, r, c) {
            const f = [], _ = this.transform;
            if (!_) return f;
            const w = _.getCoveringTilesDetailsProvider().allowWorldCopies(), C = c ? _.getCameraQueryGeometry(e) : e, P = (V) => _.screenPointToMercatorCoordinate(V, this.terrain), R = this.transformBbox(e, P, !w), L = this.transformBbox(C, P, !w), j = this.getIds(), B = u.a2.fromPoints(L);
            for (let V = 0; V < j.length; V++) {
              const $ = this._tiles[j[V]];
              if ($.holdingForFade()) continue;
              const ie = w ? [$.tileID] : [$.tileID.unwrapTo(-1), $.tileID.unwrapTo(0)], te = Math.pow(2, _.zoom - $.tileID.overscaledZ), ne = r * $.queryPadding * u.$ / $.tileSize / te;
              for (const re of ie) {
                const ce = B.map(((oe) => re.getTilePoint(new u.a1(oe.x, oe.y))));
                if (ce.expandBy(ne), ce.intersects(qt)) {
                  const oe = R.map(((ye) => re.getTilePoint(ye))), pe = L.map(((ye) => re.getTilePoint(ye)));
                  f.push({ tile: $, tileID: w ? re : re.unwrapTo(0), queryGeometry: oe, cameraQueryGeometry: pe, scale: te });
                }
              }
            }
            return f;
          }
          transformBbox(e, r, c) {
            let f = e.map(r);
            if (c) {
              const _ = u.a2.fromPoints(e);
              _.shrinkBy(1e-3 * Math.min(_.width(), _.height()));
              const w = _.map(r);
              u.a2.fromPoints(f).covers(w) || (f = f.map(((C) => C.x > 0.5 ? new u.a1(C.x - 1, C.y, C.z) : C)));
            }
            return f;
          }
          getVisibleCoordinates(e) {
            const r = this.getRenderableIds(e).map(((c) => this._tiles[c].tileID));
            return this.transform && this.transform.populateCache(r), r;
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (ti(this._source.type)) {
              const e = he.now();
              for (const r in this._tiles) if (this._tiles[r].fadeEndTime >= e) return !0;
            }
            return !1;
          }
          setFeatureState(e, r, c) {
            this._state.updateState(e = e || "_geojsonTileLayer", r, c);
          }
          removeFeatureState(e, r, c) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", r, c);
          }
          getFeatureState(e, r) {
            return this._state.getState(e = e || "_geojsonTileLayer", r);
          }
          setDependencies(e, r, c) {
            const f = this._tiles[e];
            f && f.setDependencies(r, c);
          }
          reloadTilesForDependencies(e, r) {
            for (const c in this._tiles) this._tiles[c].hasDependency(e, r) && this._reloadTile(c, "reloading");
            this._cache.filter(((c) => !c.hasDependency(e, r)));
          }
        }
        function It(y, e) {
          const r = Math.abs(2 * y.wrap) - +(y.wrap < 0), c = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return y.overscaledZ - e.overscaledZ || c - r || e.canonical.y - y.canonical.y || e.canonical.x - y.canonical.x;
        }
        function ti(y) {
          return y === "raster" || y === "image" || y === "video";
        }
        ri.maxOverzooming = 10, ri.maxUnderzooming = 3;
        class Yi {
          constructor(e, r) {
            this.reset(e, r);
          }
          reset(e, r) {
            this.points = e || [], this._distances = [0];
            for (let c = 1; c < this.points.length; c++) this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(r || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = u.ah(e, 0, 1);
            let r = 1, c = this._distances[r];
            const f = e * this.paddedLength + this.padding;
            for (; c < f && r < this._distances.length; ) c = this._distances[++r];
            const _ = r - 1, w = this._distances[_], C = c - w, P = C > 0 ? (f - w) / C : 0;
            return this.points[_].mult(1 - P).add(this.points[r].mult(P));
          }
        }
        function Pn(y, e) {
          let r = !0;
          return y === "always" || y !== "never" && e !== "never" || (r = !1), r;
        }
        class xn {
          constructor(e, r, c) {
            const f = this.boxCells = [], _ = this.circleCells = [];
            this.xCellCount = Math.ceil(e / c), this.yCellCount = Math.ceil(r / c);
            for (let w = 0; w < this.xCellCount * this.yCellCount; w++) f.push([]), _.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = r, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / r, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e, r, c, f, _) {
            this._forEachCell(r, c, f, _, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(r), this.bboxes.push(c), this.bboxes.push(f), this.bboxes.push(_);
          }
          insertCircle(e, r, c, f) {
            this._forEachCell(r - f, c - f, r + f, c + f, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(r), this.circles.push(c), this.circles.push(f);
          }
          _insertBoxCell(e, r, c, f, _, w) {
            this.boxCells[_].push(w);
          }
          _insertCircleCell(e, r, c, f, _, w) {
            this.circleCells[_].push(w);
          }
          _query(e, r, c, f, _, w, C) {
            if (c < 0 || e > this.width || f < 0 || r > this.height) return [];
            const P = [];
            if (e <= 0 && r <= 0 && this.width <= c && this.height <= f) {
              if (_) return [{ key: null, x1: e, y1: r, x2: c, y2: f }];
              for (let R = 0; R < this.boxKeys.length; R++) P.push({ key: this.boxKeys[R], x1: this.bboxes[4 * R], y1: this.bboxes[4 * R + 1], x2: this.bboxes[4 * R + 2], y2: this.bboxes[4 * R + 3] });
              for (let R = 0; R < this.circleKeys.length; R++) {
                const L = this.circles[3 * R], j = this.circles[3 * R + 1], B = this.circles[3 * R + 2];
                P.push({ key: this.circleKeys[R], x1: L - B, y1: j - B, x2: L + B, y2: j + B });
              }
            } else this._forEachCell(e, r, c, f, this._queryCell, P, { hitTest: _, overlapMode: w, seenUids: { box: {}, circle: {} } }, C);
            return P;
          }
          query(e, r, c, f) {
            return this._query(e, r, c, f, !1, null);
          }
          hitTest(e, r, c, f, _, w) {
            return this._query(e, r, c, f, !0, _, w).length > 0;
          }
          hitTestCircle(e, r, c, f, _) {
            const w = e - c, C = e + c, P = r - c, R = r + c;
            if (C < 0 || w > this.width || R < 0 || P > this.height) return !1;
            const L = [];
            return this._forEachCell(w, P, C, R, this._queryCellCircle, L, { hitTest: !0, overlapMode: f, circle: { x: e, y: r, radius: c }, seenUids: { box: {}, circle: {} } }, _), L.length > 0;
          }
          _queryCell(e, r, c, f, _, w, C, P) {
            const { seenUids: R, hitTest: L, overlapMode: j } = C, B = this.boxCells[_];
            if (B !== null) {
              const $ = this.bboxes;
              for (const ie of B) if (!R.box[ie]) {
                R.box[ie] = !0;
                const te = 4 * ie, ne = this.boxKeys[ie];
                if (e <= $[te + 2] && r <= $[te + 3] && c >= $[te + 0] && f >= $[te + 1] && (!P || P(ne)) && (!L || !Pn(j, ne.overlapMode)) && (w.push({ key: ne, x1: $[te], y1: $[te + 1], x2: $[te + 2], y2: $[te + 3] }), L)) return !0;
              }
            }
            const V = this.circleCells[_];
            if (V !== null) {
              const $ = this.circles;
              for (const ie of V) if (!R.circle[ie]) {
                R.circle[ie] = !0;
                const te = 3 * ie, ne = this.circleKeys[ie];
                if (this._circleAndRectCollide($[te], $[te + 1], $[te + 2], e, r, c, f) && (!P || P(ne)) && (!L || !Pn(j, ne.overlapMode))) {
                  const re = $[te], ce = $[te + 1], oe = $[te + 2];
                  if (w.push({ key: ne, x1: re - oe, y1: ce - oe, x2: re + oe, y2: ce + oe }), L) return !0;
                }
              }
            }
            return !1;
          }
          _queryCellCircle(e, r, c, f, _, w, C, P) {
            const { circle: R, seenUids: L, overlapMode: j } = C, B = this.boxCells[_];
            if (B !== null) {
              const $ = this.bboxes;
              for (const ie of B) if (!L.box[ie]) {
                L.box[ie] = !0;
                const te = 4 * ie, ne = this.boxKeys[ie];
                if (this._circleAndRectCollide(R.x, R.y, R.radius, $[te + 0], $[te + 1], $[te + 2], $[te + 3]) && (!P || P(ne)) && !Pn(j, ne.overlapMode)) return w.push(!0), !0;
              }
            }
            const V = this.circleCells[_];
            if (V !== null) {
              const $ = this.circles;
              for (const ie of V) if (!L.circle[ie]) {
                L.circle[ie] = !0;
                const te = 3 * ie, ne = this.circleKeys[ie];
                if (this._circlesCollide($[te], $[te + 1], $[te + 2], R.x, R.y, R.radius) && (!P || P(ne)) && !Pn(j, ne.overlapMode)) return w.push(!0), !0;
              }
            }
          }
          _forEachCell(e, r, c, f, _, w, C, P) {
            const R = this._convertToXCellCoord(e), L = this._convertToYCellCoord(r), j = this._convertToXCellCoord(c), B = this._convertToYCellCoord(f);
            for (let V = R; V <= j; V++) for (let $ = L; $ <= B; $++) if (_.call(this, e, r, c, f, this.xCellCount * $ + V, w, C, P)) return;
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
          }
          _circlesCollide(e, r, c, f, _, w) {
            const C = f - e, P = _ - r, R = c + w;
            return R * R > C * C + P * P;
          }
          _circleAndRectCollide(e, r, c, f, _, w, C) {
            const P = (w - f) / 2, R = Math.abs(e - (f + P));
            if (R > P + c) return !1;
            const L = (C - _) / 2, j = Math.abs(r - (_ + L));
            if (j > L + c) return !1;
            if (R <= P || j <= L) return !0;
            const B = R - P, V = j - L;
            return B * B + V * V <= c * c;
          }
        }
        function In(y, e, r) {
          const c = u.L();
          if (!y) {
            const { vecSouth: j, vecEast: B } = _i(e), V = U();
            V[0] = B[0], V[1] = B[1], V[2] = j[0], V[3] = j[1], f = V, (L = (w = (_ = V)[0]) * (R = _[3]) - (P = _[2]) * (C = _[1])) && (f[0] = R * (L = 1 / L), f[1] = -C * L, f[2] = -P * L, f[3] = w * L), c[0] = V[0], c[1] = V[1], c[4] = V[2], c[5] = V[3];
          }
          var f, _, w, C, P, R, L;
          return u.N(c, c, [1 / r, 1 / r, 1]), c;
        }
        function ci(y, e, r, c) {
          if (y) {
            const f = u.L();
            if (!e) {
              const { vecSouth: _, vecEast: w } = _i(r);
              f[0] = w[0], f[1] = w[1], f[4] = _[0], f[5] = _[1];
            }
            return u.N(f, f, [c, c, 1]), f;
          }
          return r.pixelsToClipSpaceMatrix;
        }
        function _i(y) {
          const e = Math.cos(y.rollInRadians), r = Math.sin(y.rollInRadians), c = Math.cos(y.pitchInRadians), f = Math.cos(y.bearingInRadians), _ = Math.sin(y.bearingInRadians), w = u.ar();
          w[0] = -f * c * r - _ * e, w[1] = -_ * c * r + f * e;
          const C = u.as(w);
          C < 1e-9 ? u.at(w) : u.au(w, w, 1 / C);
          const P = u.ar();
          P[0] = f * c * e - _ * r, P[1] = _ * c * e + f * r;
          const R = u.as(P);
          return R < 1e-9 ? u.at(P) : u.au(P, P, 1 / R), { vecEast: P, vecSouth: w };
        }
        function kn(y, e, r, c) {
          let f;
          c ? (f = [y, e, c(y, e), 1], u.aw(f, f, r)) : (f = [y, e, 0, 1], os(f, f, r));
          const _ = f[3];
          return { point: new u.P(f[0] / _, f[1] / _), signedDistanceFromCamera: _, isOccluded: !1 };
        }
        function ot(y, e) {
          return 0.5 + y / e * 0.5;
        }
        function la(y, e) {
          return y.x >= -e[0] && y.x <= e[0] && y.y >= -e[1] && y.y <= e[1];
        }
        function dn(y, e, r, c, f, _, w, C, P, R, L, j, B) {
          const V = r ? y.textSizeData : y.iconSizeData, $ = u.an(V, e.transform.zoom), ie = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1], te = r ? y.text.dynamicLayoutVertexArray : y.icon.dynamicLayoutVertexArray;
          te.clear();
          const ne = y.lineVertexArray, re = r ? y.text.placedSymbolArray : y.icon.placedSymbolArray, ce = e.transform.width / e.transform.height;
          let oe = !1;
          for (let pe = 0; pe < re.length; pe++) {
            const ye = re.get(pe);
            if (ye.hidden || ye.writingMode === u.ao.vertical && !oe) {
              Ba(ye.numGlyphs, te);
              continue;
            }
            oe = !1;
            const ue = new u.P(ye.anchorX, ye.anchorY), we = { getElevation: B, pitchedLabelPlaneMatrix: c, lineVertexArray: ne, pitchWithMap: _, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: e.transform, tileAnchorPoint: ue, unwrappedTileID: P, width: R, height: L, translation: j }, Oe = fo(ye.anchorX, ye.anchorY, we);
            if (!la(Oe.point, ie)) {
              Ba(ye.numGlyphs, te);
              continue;
            }
            const ze = ot(e.transform.cameraToCenterDistance, Oe.signedDistanceFromCamera), Pe = u.ap(V, $, ye), Le = _ ? Pe * e.transform.getPitchedTextCorrection(ye.anchorX, ye.anchorY, P) / ze : Pe * ze, lt = st({ projectionContext: we, pitchedLabelPlaneMatrixInverse: f, symbol: ye, fontSize: Le, flip: !1, keepUpright: w, glyphOffsetArray: y.glyphOffsetArray, dynamicLayoutVertexArray: te, aspectRatio: ce, rotateToLine: C });
            oe = lt.useVertical, (lt.notEnoughRoom || oe || lt.needsFlipping && st({ projectionContext: we, pitchedLabelPlaneMatrixInverse: f, symbol: ye, fontSize: Le, flip: !0, keepUpright: w, glyphOffsetArray: y.glyphOffsetArray, dynamicLayoutVertexArray: te, aspectRatio: ce, rotateToLine: C }).notEnoughRoom) && Ba(ye.numGlyphs, te);
          }
          r ? y.text.dynamicLayoutVertexBuffer.updateData(te) : y.icon.dynamicLayoutVertexBuffer.updateData(te);
        }
        function Us(y, e, r, c, f, _, w, C) {
          const P = _.glyphStartIndex + _.numGlyphs, R = _.lineStartIndex, L = _.lineStartIndex + _.lineLength, j = e.getoffsetX(_.glyphStartIndex), B = e.getoffsetX(P - 1), V = ss(y * j, r, c, f, _.segment, R, L, C, w);
          if (!V) return null;
          const $ = ss(y * B, r, c, f, _.segment, R, L, C, w);
          return $ ? C.projectionCache.anyProjectionOccluded ? null : { first: V, last: $ } : null;
        }
        function fr(y, e, r, c) {
          return y === u.ao.horizontal && Math.abs(r.y - e.y) > Math.abs(r.x - e.x) * c ? { useVertical: !0 } : (y === u.ao.vertical ? e.y < r.y : e.x > r.x) ? { needsFlipping: !0 } : null;
        }
        function st(y) {
          const { projectionContext: e, pitchedLabelPlaneMatrixInverse: r, symbol: c, fontSize: f, flip: _, keepUpright: w, glyphOffsetArray: C, dynamicLayoutVertexArray: P, aspectRatio: R, rotateToLine: L } = y, j = f / 24, B = c.lineOffsetX * j, V = c.lineOffsetY * j;
          let $;
          if (c.numGlyphs > 1) {
            const ie = c.glyphStartIndex + c.numGlyphs, te = c.lineStartIndex, ne = c.lineStartIndex + c.lineLength, re = Us(j, C, B, V, _, c, L, e);
            if (!re) return { notEnoughRoom: !0 };
            const ce = al(re.first.point.x, re.first.point.y, e, r), oe = al(re.last.point.x, re.last.point.y, e, r);
            if (w && !_) {
              const pe = fr(c.writingMode, ce, oe, R);
              if (pe) return pe;
            }
            $ = [re.first];
            for (let pe = c.glyphStartIndex + 1; pe < ie - 1; pe++) {
              const ye = ss(j * C.getoffsetX(pe), B, V, _, c.segment, te, ne, e, L);
              if (!ye) return { notEnoughRoom: !0 };
              $.push(ye);
            }
            $.push(re.last);
          } else {
            if (w && !_) {
              const te = Kn(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point, ne = c.lineStartIndex + c.segment + 1, re = new u.P(e.lineVertexArray.getx(ne), e.lineVertexArray.gety(ne)), ce = Kn(re.x, re.y, e), oe = ce.signedDistanceFromCamera > 0 ? ce.point : Zt(e.tileAnchorPoint, re, te, 1, e), pe = al(te.x, te.y, e, r), ye = al(oe.x, oe.y, e, r), ue = fr(c.writingMode, pe, ye, R);
              if (ue) return ue;
            }
            const ie = ss(j * C.getoffsetX(c.glyphStartIndex), B, V, _, c.segment, c.lineStartIndex, c.lineStartIndex + c.lineLength, e, L);
            if (!ie || e.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
            $ = [ie];
          }
          for (const ie of $) u.av(P, ie.point, ie.angle);
          return {};
        }
        function Zt(y, e, r, c, f) {
          const _ = y.add(y.sub(e)._unit()), w = Kn(_.x, _.y, f).point, C = r.sub(w);
          return r.add(C._mult(c / C.mag()));
        }
        function Jt(y, e, r) {
          const c = e.projectionCache;
          if (c.projections[y]) return c.projections[y];
          const f = new u.P(e.lineVertexArray.getx(y), e.lineVertexArray.gety(y)), _ = Kn(f.x, f.y, e);
          if (_.signedDistanceFromCamera > 0) return c.projections[y] = _.point, c.anyProjectionOccluded = c.anyProjectionOccluded || _.isOccluded, _.point;
          const w = y - r.direction;
          return Zt(r.distanceFromAnchor === 0 ? e.tileAnchorPoint : new u.P(e.lineVertexArray.getx(w), e.lineVertexArray.gety(w)), f, r.previousVertex, r.absOffsetX - r.distanceFromAnchor + 1, e);
        }
        function Kn(y, e, r) {
          const c = y + r.translation[0], f = e + r.translation[1];
          let _;
          return r.pitchWithMap ? (_ = kn(c, f, r.pitchedLabelPlaneMatrix, r.getElevation), _.isOccluded = !1) : (_ = r.transform.projectTileCoordinates(c, f, r.unwrappedTileID, r.getElevation), _.point.x = (0.5 * _.point.x + 0.5) * r.width, _.point.y = (0.5 * -_.point.y + 0.5) * r.height), _;
        }
        function al(y, e, r, c) {
          if (r.pitchWithMap) {
            const f = [y, e, 0, 1];
            return u.aw(f, f, c), r.transform.projectTileCoordinates(f[0] / f[3], f[1] / f[3], r.unwrappedTileID, r.getElevation).point;
          }
          return { x: y / r.width * 2 - 1, y: 1 - e / r.height * 2 };
        }
        function fo(y, e, r) {
          return r.transform.projectTileCoordinates(y, e, r.unwrappedTileID, r.getElevation);
        }
        function ii(y, e, r) {
          return y._unit()._perp()._mult(e * r);
        }
        function mo(y, e, r, c, f, _, w, C, P) {
          if (C.projectionCache.offsets[y]) return C.projectionCache.offsets[y];
          const R = r.add(e);
          if (y + P.direction < c || y + P.direction >= f) return C.projectionCache.offsets[y] = R, R;
          const L = Jt(y + P.direction, C, P), j = ii(L.sub(r), w, P.direction), B = r.add(j), V = L.add(j);
          return C.projectionCache.offsets[y] = u.ax(_, R, B, V) || R, C.projectionCache.offsets[y];
        }
        function ss(y, e, r, c, f, _, w, C, P) {
          const R = c ? y - e : y + e;
          let L = R > 0 ? 1 : -1, j = 0;
          c && (L *= -1, j = Math.PI), L < 0 && (j += Math.PI);
          let B, V = L > 0 ? _ + f : _ + f + 1;
          C.projectionCache.cachedAnchorPoint ? B = C.projectionCache.cachedAnchorPoint : (B = Kn(C.tileAnchorPoint.x, C.tileAnchorPoint.y, C).point, C.projectionCache.cachedAnchorPoint = B);
          let $, ie, te = B, ne = B, re = 0, ce = 0;
          const oe = Math.abs(R), pe = [];
          let ye;
          for (; re + ce <= oe; ) {
            if (V += L, V < _ || V >= w) return null;
            re += ce, ne = te, ie = $;
            const Oe = { absOffsetX: oe, direction: L, distanceFromAnchor: re, previousVertex: ne };
            if (te = Jt(V, C, Oe), r === 0) pe.push(ne), ye = te.sub(ne);
            else {
              let ze;
              const Pe = te.sub(ne);
              ze = Pe.mag() === 0 ? ii(Jt(V + L, C, Oe).sub(te), r, L) : ii(Pe, r, L), ie || (ie = ne.add(ze)), $ = mo(V, ze, te, _, w, ie, r, C, Oe), pe.push(ie), ye = $.sub(ie);
            }
            ce = ye.mag();
          }
          const ue = ye._mult((oe - re) / ce)._add(ie || ne), we = j + Math.atan2(te.y - ne.y, te.x - ne.x);
          return pe.push(ue), { point: ue, angle: P ? we : 0, path: pe };
        }
        const Fs = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function Ba(y, e) {
          for (let r = 0; r < y; r++) {
            const c = e.length;
            e.resize(c + 4), e.float32.set(Fs, 3 * c);
          }
        }
        function os(y, e, r) {
          const c = e[0], f = e[1];
          return y[0] = r[0] * c + r[4] * f + r[12], y[1] = r[1] * c + r[5] * f + r[13], y[3] = r[3] * c + r[7] * f + r[15], y;
        }
        const Qi = 100;
        class Rn {
          constructor(e, r = new xn(e.width + 200, e.height + 200, 25), c = new xn(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = r, this.ignoredGrid = c, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Qi, this.screenBottomBoundary = e.height + Qi, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(e, r, c, f, _, w, C, P, R, L, j, B) {
            const V = this.projectAndGetPerspectiveRatio(e.anchorPointX + P[0], e.anchorPointY + P[1], _, L, B), $ = c * V.perspectiveRatio;
            let ie;
            if (w || C) ie = this._projectCollisionBox(e, $, f, _, w, C, P, V, L, j, B);
            else {
              const ye = V.x + (j ? j.x * $ : 0), ue = V.y + (j ? j.y * $ : 0);
              ie = { allPointsOccluded: !1, box: [ye + e.x1 * $, ue + e.y1 * $, ye + e.x2 * $, ue + e.y2 * $] };
            }
            const [te, ne, re, ce] = ie.box, oe = w ? ie.allPointsOccluded : V.isOccluded;
            let pe = oe;
            return pe || (pe = V.perspectiveRatio < this.perspectiveRatioCutoff), pe || (pe = !this.isInsideGrid(te, ne, re, ce)), pe || r !== "always" && this.grid.hitTest(te, ne, re, ce, r, R) ? { box: [te, ne, re, ce], placeable: !1, offscreen: !1, occluded: oe } : { box: [te, ne, re, ce], placeable: !0, offscreen: this.isOffscreen(te, ne, re, ce), occluded: oe };
          }
          placeCollisionCircles(e, r, c, f, _, w, C, P, R, L, j, B, V, $) {
            const ie = [], te = new u.P(r.anchorX, r.anchorY), ne = this.getPerspectiveRatio(te.x, te.y, w, $), re = (R ? _ * this.transform.getPitchedTextCorrection(r.anchorX, r.anchorY, w) / ne : _ * ne) / u.aB, ce = { getElevation: $, pitchedLabelPlaneMatrix: C, lineVertexArray: c, pitchWithMap: R, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: te, unwrappedTileID: w, width: this.transform.width, height: this.transform.height, translation: V }, oe = Us(re, f, r.lineOffsetX * re, r.lineOffsetY * re, !1, r, !1, ce);
            let pe = !1, ye = !1, ue = !0;
            if (oe) {
              const we = 0.5 * j * ne + B, Oe = new u.P(-100, -100), ze = new u.P(this.screenRightBoundary, this.screenBottomBoundary), Pe = new Yi(), Le = oe.first, lt = oe.last;
              let ct = [];
              for (let ai = Le.path.length - 1; ai >= 1; ai--) ct.push(Le.path[ai]);
              for (let ai = 1; ai < lt.path.length; ai++) ct.push(lt.path[ai]);
              const We = 2.5 * we;
              if (R) {
                const ai = this.projectPathToScreenSpace(ct, ce);
                ct = ai.some(((zi) => zi.signedDistanceFromCamera <= 0)) ? [] : ai.map(((zi) => zi.point));
              }
              let At = [];
              if (ct.length > 0) {
                const ai = ct[0].clone(), zi = ct[0].clone();
                for (let qi = 1; qi < ct.length; qi++) ai.x = Math.min(ai.x, ct[qi].x), ai.y = Math.min(ai.y, ct[qi].y), zi.x = Math.max(zi.x, ct[qi].x), zi.y = Math.max(zi.y, ct[qi].y);
                At = ai.x >= Oe.x && zi.x <= ze.x && ai.y >= Oe.y && zi.y <= ze.y ? [ct] : zi.x < Oe.x || ai.x > ze.x || zi.y < Oe.y || ai.y > ze.y ? [] : u.ay([ct], Oe.x, Oe.y, ze.x, ze.y);
              }
              for (const ai of At) {
                Pe.reset(ai, 0.25 * we);
                let zi = 0;
                zi = Pe.length <= 0.5 * we ? 1 : Math.ceil(Pe.paddedLength / We) + 1;
                for (let qi = 0; qi < zi; qi++) {
                  const Ni = qi / Math.max(zi - 1, 1), un = Pe.lerp(Ni), mn = un.x + Qi, Qt = un.y + Qi;
                  ie.push(mn, Qt, we, 0);
                  const Xi = mn - we, Bn = Qt - we, gn = mn + we, ta = Qt + we;
                  if (ue = ue && this.isOffscreen(Xi, Bn, gn, ta), ye = ye || this.isInsideGrid(Xi, Bn, gn, ta), e !== "always" && this.grid.hitTestCircle(mn, Qt, we, e, L) && (pe = !0, !P)) return { circles: [], offscreen: !1, collisionDetected: pe };
                }
              }
            }
            return { circles: !P && pe || !ye || ne < this.perspectiveRatioCutoff ? [] : ie, offscreen: ue, collisionDetected: pe };
          }
          projectPathToScreenSpace(e, r) {
            const c = (function(f, _) {
              const w = u.L();
              return u.aq(w, _.pitchedLabelPlaneMatrix), f.map(((C) => {
                const P = kn(C.x, C.y, w, _.getElevation), R = _.transform.projectTileCoordinates(P.point.x, P.point.y, _.unwrappedTileID, _.getElevation);
                return R.point.x = (0.5 * R.point.x + 0.5) * _.width, R.point.y = (0.5 * -R.point.y + 0.5) * _.height, R;
              }));
            })(e, r);
            return (function(f) {
              let _ = 0, w = 0, C = 0, P = 0;
              for (let R = 0; R < f.length; R++) f[R].isOccluded ? (C = R + 1, P = 0) : (P++, P > w && (w = P, _ = C));
              return f.slice(_, _ + w);
            })(c);
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const r = [], c = new u.a2();
            for (const j of e) {
              const B = new u.P(j.x + Qi, j.y + Qi);
              c.extend(B), r.push(B);
            }
            const { minX: f, minY: _, maxX: w, maxY: C } = c, P = this.grid.query(f, _, w, C).concat(this.ignoredGrid.query(f, _, w, C)), R = {}, L = {};
            for (const j of P) {
              const B = j.key;
              if (R[B.bucketInstanceId] === void 0 && (R[B.bucketInstanceId] = {}), R[B.bucketInstanceId][B.featureIndex]) continue;
              const V = [new u.P(j.x1, j.y1), new u.P(j.x2, j.y1), new u.P(j.x2, j.y2), new u.P(j.x1, j.y2)];
              u.az(r, V) && (R[B.bucketInstanceId][B.featureIndex] = !0, L[B.bucketInstanceId] === void 0 && (L[B.bucketInstanceId] = []), L[B.bucketInstanceId].push(B.featureIndex));
            }
            return L;
          }
          insertCollisionBox(e, r, c, f, _, w) {
            (c ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: f, featureIndex: _, collisionGroupID: w, overlapMode: r }, e[0], e[1], e[2], e[3]);
          }
          insertCollisionCircles(e, r, c, f, _, w) {
            const C = c ? this.ignoredGrid : this.grid, P = { bucketInstanceId: f, featureIndex: _, collisionGroupID: w, overlapMode: r };
            for (let R = 0; R < e.length; R += 4) C.insertCircle(P, e[R], e[R + 1], e[R + 2]);
          }
          projectAndGetPerspectiveRatio(e, r, c, f, _) {
            if (_) {
              let w;
              f ? (w = [e, r, f(e, r), 1], u.aw(w, w, _)) : (w = [e, r, 0, 1], os(w, w, _));
              const C = w[3];
              return { x: (w[0] / C + 1) / 2 * this.transform.width + Qi, y: (-w[1] / C + 1) / 2 * this.transform.height + Qi, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / C * 0.5, isOccluded: !1, signedDistanceFromCamera: C };
            }
            {
              const w = this.transform.projectTileCoordinates(e, r, c, f);
              return { x: (w.point.x + 1) / 2 * this.transform.width + Qi, y: (1 - w.point.y) / 2 * this.transform.height + Qi, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / w.signedDistanceFromCamera * 0.5, isOccluded: w.isOccluded, signedDistanceFromCamera: w.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(e, r, c, f) {
            const _ = this.transform.projectTileCoordinates(e, r, c, f);
            return 0.5 + this.transform.cameraToCenterDistance / _.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(e, r, c, f) {
            return c < Qi || e >= this.screenRightBoundary || f < Qi || r > this.screenBottomBoundary;
          }
          isInsideGrid(e, r, c, f) {
            return c >= 0 && e < this.gridRightBoundary && f >= 0 && r < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e = u.ag([]);
            return u.M(e, e, [-100, -100, 0]), e;
          }
          _projectCollisionBox(e, r, c, f, _, w, C, P, R, L, j) {
            let B = 1, V = 0, $ = 0, ie = 1;
            const te = e.anchorPointX + C[0], ne = e.anchorPointY + C[1];
            if (w && !_) {
              const ct = this.projectAndGetPerspectiveRatio(te + 1, ne, f, R, j), We = ct.x - P.x, At = Math.atan((ct.y - P.y) / We) + (We < 0 ? Math.PI : 0), ai = Math.sin(At), zi = Math.cos(At);
              B = zi, V = ai, $ = -ai, ie = zi;
            } else if (!w && _) {
              const ct = _i(this.transform);
              B = ct.vecEast[0], V = ct.vecEast[1], $ = ct.vecSouth[0], ie = ct.vecSouth[1];
            }
            let re = P.x, ce = P.y, oe = r;
            _ && (re = te, ce = ne, oe = Math.pow(2, -(this.transform.zoom - c.overscaledZ)), oe *= this.transform.getPitchedTextCorrection(te, ne, f), L || (oe *= u.ah(0.5 + P.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), L && (re += B * L.x * oe + $ * L.y * oe, ce += V * L.x * oe + ie * L.y * oe);
            const pe = e.x1 * oe, ye = e.x2 * oe, ue = (pe + ye) / 2, we = e.y1 * oe, Oe = e.y2 * oe, ze = (we + Oe) / 2, Pe = [{ offsetX: pe, offsetY: we }, { offsetX: ue, offsetY: we }, { offsetX: ye, offsetY: we }, { offsetX: ye, offsetY: ze }, { offsetX: ye, offsetY: Oe }, { offsetX: ue, offsetY: Oe }, { offsetX: pe, offsetY: Oe }, { offsetX: pe, offsetY: ze }];
            let Le = [];
            for (const { offsetX: ct, offsetY: We } of Pe) Le.push(new u.P(re + B * ct + $ * We, ce + V * ct + ie * We));
            let lt = !1;
            if (_) {
              const ct = Le.map(((We) => this.projectAndGetPerspectiveRatio(We.x, We.y, f, R, j)));
              lt = ct.some(((We) => !We.isOccluded)), Le = ct.map(((We) => new u.P(We.x, We.y)));
            } else lt = !0;
            return { box: u.aA(Le), allPointsOccluded: !lt };
          }
        }
        class Na {
          constructor(e, r, c, f) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? r : -r))) : f && c ? 1 : 0, this.placed = c;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class Hi {
          constructor(e, r, c, f, _) {
            this.text = new Na(e ? e.text : null, r, c, _), this.icon = new Na(e ? e.icon : null, r, f, _);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class go {
          constructor(e, r, c) {
            this.text = e, this.icon = r, this.skipFade = c;
          }
        }
        class ls {
          constructor(e, r, c, f, _) {
            this.bucketInstanceId = e, this.featureIndex = r, this.sourceLayerIndex = c, this.bucketIndex = f, this.tileID = _;
          }
        }
        class Mh {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e]) {
              const r = ++this.maxGroupID;
              this.collisionGroups[e] = { ID: r, predicate: (c) => c.collisionGroupID === r };
            }
            return this.collisionGroups[e];
          }
        }
        function Vs(y, e, r, c, f) {
          const { horizontalAlign: _, verticalAlign: w } = u.aH(y);
          return new u.P(-(_ - 0.5) * e + c[0] * f, -(w - 0.5) * r + c[1] * f);
        }
        class qs {
          constructor(e, r, c, f, _) {
            this.transform = e.clone(), this.terrain = r, this.collisionIndex = new Rn(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = c, this.retainedQueryData = {}, this.collisionGroups = new Mh(f), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = _, _ && (_.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(e) {
            const r = this.terrain;
            return r ? (c, f) => r.getElevation(e, c, f) : null;
          }
          getBucketParts(e, r, c, f) {
            const _ = c.getBucket(r), w = c.latestFeatureIndex;
            if (!_ || !w || r.id !== _.layerIds[0]) return;
            const C = c.collisionBoxArray, P = _.layers[0].layout, R = _.layers[0].paint, L = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ), j = c.tileSize / u.$, B = c.tileID.toUnwrapped(), V = P.get("text-rotation-alignment") === "map", $ = u.aC(c, 1, this.transform.zoom), ie = u.aD(this.collisionIndex.transform, c, R.get("text-translate"), R.get("text-translate-anchor")), te = u.aD(this.collisionIndex.transform, c, R.get("icon-translate"), R.get("icon-translate-anchor")), ne = In(V, this.transform, $);
            this.retainedQueryData[_.bucketInstanceId] = new ls(_.bucketInstanceId, w, _.sourceLayerIndex, _.index, c.tileID);
            const re = { bucket: _, layout: P, translationText: ie, translationIcon: te, unwrappedTileID: B, pitchedLabelPlaneMatrix: ne, scale: L, textPixelRatio: j, holdingForFade: c.holdingForFade(), collisionBoxArray: C, partiallyEvaluatedTextSize: u.an(_.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(_.sourceID) };
            if (f) for (const ce of _.sortKeyRanges) {
              const { sortKey: oe, symbolInstanceStart: pe, symbolInstanceEnd: ye } = ce;
              e.push({ sortKey: oe, symbolInstanceStart: pe, symbolInstanceEnd: ye, parameters: re });
            }
            else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: _.symbolInstances.length, parameters: re });
          }
          attemptAnchorPlacement(e, r, c, f, _, w, C, P, R, L, j, B, V, $, ie, te, ne, re, ce, oe) {
            const pe = u.aE[e.textAnchor], ye = [e.textOffset0, e.textOffset1], ue = Vs(pe, c, f, ye, _), we = this.collisionIndex.placeCollisionBox(r, B, P, R, L, C, w, te, j.predicate, ce, ue, oe);
            if ((!re || this.collisionIndex.placeCollisionBox(re, B, P, R, L, C, w, ne, j.predicate, ce, ue, oe).placeable) && we.placeable) {
              let Oe;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[V.crossTileID] && this.prevPlacement.placements[V.crossTileID] && this.prevPlacement.placements[V.crossTileID].text && (Oe = this.prevPlacement.variableOffsets[V.crossTileID].anchor), V.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[V.crossTileID] = { textOffset: ye, width: c, height: f, anchor: pe, textBoxScale: _, prevAnchor: Oe }, this.markUsedJustification($, pe, V, ie), $.allowVerticalPlacement && (this.markUsedOrientation($, ie, V), this.placedOrientations[V.crossTileID] = ie), { shift: ue, placedGlyphBoxes: we };
            }
          }
          placeLayerBucketPart(e, r, c) {
            const { bucket: f, layout: _, translationText: w, translationIcon: C, unwrappedTileID: P, pitchedLabelPlaneMatrix: R, textPixelRatio: L, holdingForFade: j, collisionBoxArray: B, partiallyEvaluatedTextSize: V, collisionGroup: $ } = e.parameters, ie = _.get("text-optional"), te = _.get("icon-optional"), ne = u.aF(_, "text-overlap", "text-allow-overlap"), re = ne === "always", ce = u.aF(_, "icon-overlap", "icon-allow-overlap"), oe = ce === "always", pe = _.get("text-rotation-alignment") === "map", ye = _.get("text-pitch-alignment") === "map", ue = _.get("icon-text-fit") !== "none", we = _.get("symbol-z-order") === "viewport-y", Oe = re && (oe || !f.hasIconData() || te), ze = oe && (re || !f.hasTextData() || ie);
            !f.collisionArrays && B && f.deserializeCollisionBoxes(B);
            const Pe = this.retainedQueryData[f.bucketInstanceId].tileID, Le = this._getTerrainElevationFunc(Pe), lt = this.transform.getFastPathSimpleProjectionMatrix(Pe), ct = (We, At, ai) => {
              var zi, qi;
              if (r[We.crossTileID]) return;
              if (j) return void (this.placements[We.crossTileID] = new go(!1, !1, !1));
              let Ni = !1, un = !1, mn = !0, Qt = null, Xi = { box: null, placeable: !1, offscreen: null, occluded: !1 }, Bn = { placeable: !1 }, gn = null, ta = null, pa = null, sr = 0, Qs = 0, Is = 0;
              At.textFeatureIndex ? sr = At.textFeatureIndex : We.useRuntimeCollisionCircles && (sr = We.featureIndex), At.verticalTextFeatureIndex && (Qs = At.verticalTextFeatureIndex);
              const hu = At.textBox;
              if (hu) {
                const Ga = (Nn) => {
                  let jn = u.ao.horizontal;
                  if (f.allowVerticalPlacement && !Nn && this.prevPlacement) {
                    const Sr = this.prevPlacement.placedOrientations[We.crossTileID];
                    Sr && (this.placedOrientations[We.crossTileID] = Sr, jn = Sr, this.markUsedOrientation(f, jn, We));
                  }
                  return jn;
                }, jr = (Nn, jn) => {
                  if (f.allowVerticalPlacement && We.numVerticalGlyphVertices > 0 && At.verticalTextBox) {
                    for (const Sr of f.writingModes) if (Sr === u.ao.vertical ? (Xi = jn(), Bn = Xi) : Xi = Nn(), Xi && Xi.placeable) break;
                  } else Xi = Nn();
                }, va = We.textAnchorOffsetStartIndex, eo = We.textAnchorOffsetEndIndex;
                if (eo === va) {
                  const Nn = (jn, Sr) => {
                    const Un = this.collisionIndex.placeCollisionBox(jn, ne, L, Pe, P, ye, pe, w, $.predicate, Le, void 0, lt);
                    return Un && Un.placeable && (this.markUsedOrientation(f, Sr, We), this.placedOrientations[We.crossTileID] = Sr), Un;
                  };
                  jr((() => Nn(hu, u.ao.horizontal)), (() => {
                    const jn = At.verticalTextBox;
                    return f.allowVerticalPlacement && We.numVerticalGlyphVertices > 0 && jn ? Nn(jn, u.ao.vertical) : { box: null, offscreen: null };
                  })), Ga(Xi && Xi.placeable);
                } else {
                  let Nn = u.aE[(qi = (zi = this.prevPlacement) === null || zi === void 0 ? void 0 : zi.variableOffsets[We.crossTileID]) === null || qi === void 0 ? void 0 : qi.anchor];
                  const jn = (Un, lc, Uo) => {
                    const ks = Un.x2 - Un.x1, Ur = Un.y2 - Un.y1, Rs = We.textBoxScale, Kh = ue && ce === "never" ? lc : null;
                    let or = null, sp = ne === "never" ? 1 : 2, Wh = "never";
                    Nn && sp++;
                    for (let uc = 0; uc < sp; uc++) {
                      for (let Fo = va; Fo < eo; Fo++) {
                        const Ds = f.textAnchorOffsets.get(Fo);
                        if (Nn && Ds.textAnchor !== Nn) continue;
                        const Fr = this.attemptAnchorPlacement(Ds, Un, ks, Ur, Rs, pe, ye, L, Pe, P, $, Wh, We, f, Uo, w, C, Kh, Le);
                        if (Fr && (or = Fr.placedGlyphBoxes, or && or.placeable)) return Ni = !0, Qt = Fr.shift, or;
                      }
                      Nn ? Nn = null : Wh = ne;
                    }
                    return c && !or && (or = { box: this.collisionIndex.placeCollisionBox(hu, "always", L, Pe, P, ye, pe, w, $.predicate, Le, void 0, lt).box, offscreen: !1, placeable: !1, occluded: !1 }), or;
                  };
                  jr((() => jn(hu, At.iconBox, u.ao.horizontal)), (() => {
                    const Un = At.verticalTextBox;
                    return f.allowVerticalPlacement && (!Xi || !Xi.placeable) && We.numVerticalGlyphVertices > 0 && Un ? jn(Un, At.verticalIconBox, u.ao.vertical) : { box: null, occluded: !0, offscreen: null };
                  })), Xi && (Ni = Xi.placeable, mn = Xi.offscreen);
                  const Sr = Ga(Xi && Xi.placeable);
                  if (!Ni && this.prevPlacement) {
                    const Un = this.prevPlacement.variableOffsets[We.crossTileID];
                    Un && (this.variableOffsets[We.crossTileID] = Un, this.markUsedJustification(f, Un.anchor, We, Sr));
                  }
                }
              }
              if (gn = Xi, Ni = gn && gn.placeable, mn = gn && gn.offscreen, We.useRuntimeCollisionCircles) {
                const Ga = f.text.placedSymbolArray.get(We.centerJustifiedTextSymbolIndex), jr = u.ap(f.textSizeData, V, Ga), va = _.get("text-padding");
                ta = this.collisionIndex.placeCollisionCircles(ne, Ga, f.lineVertexArray, f.glyphOffsetArray, jr, P, R, c, ye, $.predicate, We.collisionCircleDiameter, va, w, Le), ta.circles.length && ta.collisionDetected && !c && u.w("Collisions detected, but collision boxes are not shown"), Ni = re || ta.circles.length > 0 && !ta.collisionDetected, mn = mn && ta.offscreen;
              }
              if (At.iconFeatureIndex && (Is = At.iconFeatureIndex), At.iconBox) {
                const Ga = (jr) => this.collisionIndex.placeCollisionBox(jr, ce, L, Pe, P, ye, pe, C, $.predicate, Le, ue && Qt ? Qt : void 0, lt);
                Bn && Bn.placeable && At.verticalIconBox ? (pa = Ga(At.verticalIconBox), un = pa.placeable) : (pa = Ga(At.iconBox), un = pa.placeable), mn = mn && pa.offscreen;
              }
              const Tl = ie || We.numHorizontalGlyphVertices === 0 && We.numVerticalGlyphVertices === 0, No = te || We.numIconVertices === 0;
              Tl || No ? No ? Tl || (un = un && Ni) : Ni = un && Ni : un = Ni = un && Ni;
              const jo = un && pa.placeable;
              if (Ni && gn.placeable && this.collisionIndex.insertCollisionBox(gn.box, ne, _.get("text-ignore-placement"), f.bucketInstanceId, Bn && Bn.placeable && Qs ? Qs : sr, $.ID), jo && this.collisionIndex.insertCollisionBox(pa.box, ce, _.get("icon-ignore-placement"), f.bucketInstanceId, Is, $.ID), ta && Ni && this.collisionIndex.insertCollisionCircles(ta.circles, ne, _.get("text-ignore-placement"), f.bucketInstanceId, sr, $.ID), c && this.storeCollisionData(f.bucketInstanceId, ai, At, gn, pa, ta), We.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (f.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[We.crossTileID] = new go((Ni || Oe) && !gn?.occluded, (un || ze) && !pa?.occluded, mn || f.justReloaded), r[We.crossTileID] = !0;
            };
            if (we) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const We = f.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let At = We.length - 1; At >= 0; --At) {
                const ai = We[At];
                ct(f.symbolInstances.get(ai), f.collisionArrays[ai], ai);
              }
            } else for (let We = e.symbolInstanceStart; We < e.symbolInstanceEnd; We++) ct(f.symbolInstances.get(We), f.collisionArrays[We], We);
            f.justReloaded = !1;
          }
          storeCollisionData(e, r, c, f, _, w) {
            if (c.textBox || c.iconBox) {
              let C, P;
              this.collisionBoxArrays.has(e) ? C = this.collisionBoxArrays.get(e) : (C = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, C)), C.has(r) ? P = C.get(r) : (P = { text: null, icon: null }, C.set(r, P)), c.textBox && (P.text = f.box), c.iconBox && (P.icon = _.box);
            }
            if (w) {
              let C = this.collisionCircleArrays[e];
              C === void 0 && (C = this.collisionCircleArrays[e] = []);
              for (let P = 0; P < w.circles.length; P += 4) C.push(w.circles[P + 0] - Qi), C.push(w.circles[P + 1] - Qi), C.push(w.circles[P + 2]), C.push(w.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(e, r, c, f) {
            let _;
            _ = f === u.ao.vertical ? c.verticalPlacedTextSymbolIndex : { left: c.leftJustifiedTextSymbolIndex, center: c.centerJustifiedTextSymbolIndex, right: c.rightJustifiedTextSymbolIndex }[u.aG(r)];
            const w = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex, c.verticalPlacedTextSymbolIndex];
            for (const C of w) C >= 0 && (e.text.placedSymbolArray.get(C).crossTileID = _ >= 0 && C !== _ ? 0 : c.crossTileID);
          }
          markUsedOrientation(e, r, c) {
            const f = r === u.ao.horizontal || r === u.ao.horizontalOnly ? r : 0, _ = r === u.ao.vertical ? r : 0, w = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex];
            for (const C of w) e.text.placedSymbolArray.get(C).placedOrientation = f;
            c.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(c.verticalPlacedTextSymbolIndex).placedOrientation = _);
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const r = this.prevPlacement;
            let c = !1;
            this.prevZoomAdjustment = r ? r.zoomAdjustment(this.transform.zoom) : 0;
            const f = r ? r.symbolFadeChange(e) : 1, _ = r ? r.opacities : {}, w = r ? r.variableOffsets : {}, C = r ? r.placedOrientations : {};
            for (const P in this.placements) {
              const R = this.placements[P], L = _[P];
              L ? (this.opacities[P] = new Hi(L, f, R.text, R.icon), c = c || R.text !== L.text.placed || R.icon !== L.icon.placed) : (this.opacities[P] = new Hi(null, f, R.text, R.icon, R.skipFade), c = c || R.text || R.icon);
            }
            for (const P in _) {
              const R = _[P];
              if (!this.opacities[P]) {
                const L = new Hi(R, f, !1, !1);
                L.isHidden() || (this.opacities[P] = L, c = c || R.text.placed || R.icon.placed);
              }
            }
            for (const P in w) this.variableOffsets[P] || !this.opacities[P] || this.opacities[P].isHidden() || (this.variableOffsets[P] = w[P]);
            for (const P in C) this.placedOrientations[P] || !this.opacities[P] || this.opacities[P].isHidden() || (this.placedOrientations[P] = C[P]);
            if (r && r.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            c ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = r ? r.lastPlacementChangeTime : e);
          }
          updateLayerOpacities(e, r) {
            const c = {};
            for (const f of r) {
              const _ = f.getBucket(e);
              _ && f.latestFeatureIndex && e.id === _.layerIds[0] && this.updateBucketOpacities(_, f.tileID, c, f.collisionBoxArray);
            }
          }
          updateBucketOpacities(e, r, c, f) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const _ = e.layers[0], w = _.layout, C = new Hi(null, 0, !1, !1, !0), P = w.get("text-allow-overlap"), R = w.get("icon-allow-overlap"), L = _._unevaluatedLayout.hasValue("text-variable-anchor") || _._unevaluatedLayout.hasValue("text-variable-anchor-offset"), j = w.get("text-rotation-alignment") === "map", B = w.get("text-pitch-alignment") === "map", V = w.get("icon-text-fit") !== "none", $ = new Hi(null, 0, P && (R || !e.hasIconData() || w.get("icon-optional")), R && (P || !e.hasTextData() || w.get("text-optional")), !0);
            !e.collisionArrays && f && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(f);
            const ie = (ne, re, ce) => {
              for (let oe = 0; oe < re / 4; oe++) ne.opacityVertexArray.emplaceBack(ce);
              ne.hasVisibleVertices = ne.hasVisibleVertices || ce !== Gs;
            }, te = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let ne = 0; ne < e.symbolInstances.length; ne++) {
              const re = e.symbolInstances.get(ne), { numHorizontalGlyphVertices: ce, numVerticalGlyphVertices: oe, crossTileID: pe } = re;
              let ye = this.opacities[pe];
              c[pe] ? ye = C : ye || (ye = $, this.opacities[pe] = ye), c[pe] = !0;
              const ue = re.numIconVertices > 0, we = this.placedOrientations[re.crossTileID], Oe = we === u.ao.vertical, ze = we === u.ao.horizontal || we === u.ao.horizontalOnly;
              if (ce > 0 || oe > 0) {
                const Le = Rc(ye.text);
                ie(e.text, ce, Oe ? Gs : Le), ie(e.text, oe, ze ? Gs : Le);
                const lt = ye.text.isHidden();
                [re.rightJustifiedTextSymbolIndex, re.centerJustifiedTextSymbolIndex, re.leftJustifiedTextSymbolIndex].forEach(((At) => {
                  At >= 0 && (e.text.placedSymbolArray.get(At).hidden = lt || Oe ? 1 : 0);
                })), re.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(re.verticalPlacedTextSymbolIndex).hidden = lt || ze ? 1 : 0);
                const ct = this.variableOffsets[re.crossTileID];
                ct && this.markUsedJustification(e, ct.anchor, re, we);
                const We = this.placedOrientations[re.crossTileID];
                We && (this.markUsedJustification(e, "left", re, We), this.markUsedOrientation(e, We, re));
              }
              if (ue) {
                const Le = Rc(ye.icon), lt = !(V && re.verticalPlacedIconSymbolIndex && Oe);
                re.placedIconSymbolIndex >= 0 && (ie(e.icon, re.numIconVertices, lt ? Le : Gs), e.icon.placedSymbolArray.get(re.placedIconSymbolIndex).hidden = ye.icon.isHidden()), re.verticalPlacedIconSymbolIndex >= 0 && (ie(e.icon, re.numVerticalIconVertices, lt ? Gs : Le), e.icon.placedSymbolArray.get(re.verticalPlacedIconSymbolIndex).hidden = ye.icon.isHidden());
              }
              const Pe = te && te.has(ne) ? te.get(ne) : { text: null, icon: null };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const Le = e.collisionArrays[ne];
                if (Le) {
                  let lt = new u.P(0, 0);
                  if (Le.textBox || Le.verticalTextBox) {
                    let ct = !0;
                    if (L) {
                      const We = this.variableOffsets[pe];
                      We ? (lt = Vs(We.anchor, We.width, We.height, We.textOffset, We.textBoxScale), j && lt._rotate(B ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : ct = !1;
                    }
                    if (Le.textBox || Le.verticalTextBox) {
                      let We;
                      Le.textBox && (We = Oe), Le.verticalTextBox && (We = ze), Ah(e.textCollisionBox.collisionVertexArray, ye.text.placed, !ct || We, Pe.text, lt.x, lt.y);
                    }
                  }
                  if (Le.iconBox || Le.verticalIconBox) {
                    const ct = !!(!ze && Le.verticalIconBox);
                    let We;
                    Le.iconBox && (We = ct), Le.verticalIconBox && (We = !ct), Ah(e.iconCollisionBox.collisionVertexArray, ye.icon.placed, We, Pe.icon, V ? lt.x : 0, V ? lt.y : 0);
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]);
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5);
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e, r) {
            const c = this.zoomAtLastRecencyCheck === r ? 1 - this.zoomAdjustment(r) : 1;
            return this.zoomAtLastRecencyCheck = r, this.commitTime + this.fadeDuration * c > e;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function Ah(y, e, r, c, f, _) {
          c && c.length !== 0 || (c = [0, 0, 0, 0]);
          const w = c[0] - Qi, C = c[1] - Qi, P = c[2] - Qi, R = c[3] - Qi;
          y.emplaceBack(e ? 1 : 0, r ? 1 : 0, f || 0, _ || 0, w, C), y.emplaceBack(e ? 1 : 0, r ? 1 : 0, f || 0, _ || 0, P, C), y.emplaceBack(e ? 1 : 0, r ? 1 : 0, f || 0, _ || 0, P, R), y.emplaceBack(e ? 1 : 0, r ? 1 : 0, f || 0, _ || 0, w, R);
        }
        const ku = Math.pow(2, 25), Ru = Math.pow(2, 24), Ka = Math.pow(2, 17), mr = Math.pow(2, 16), qd = Math.pow(2, 9), nf = Math.pow(2, 8), Eh = Math.pow(2, 1);
        function Rc(y) {
          if (y.opacity === 0 && !y.placed) return 0;
          if (y.opacity === 1 && y.placed) return 4294967295;
          const e = y.placed ? 1 : 0, r = Math.floor(127 * y.opacity);
          return r * ku + e * Ru + r * Ka + e * mr + r * qd + e * nf + r * Eh + e;
        }
        const Gs = 0;
        class Ch {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e, r, c, f, _) {
            const w = this._bucketParts;
            for (; this._currentTileIndex < e.length; ) if (r.getBucketParts(w, f, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, _()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, w.sort(((C, P) => C.sortKey - P.sortKey))); this._currentPartIndex < w.length; ) if (r.placeLayerBucketPart(w[this._currentPartIndex], this._seenCrossTileIDs, c), this._currentPartIndex++, _()) return !0;
            return !1;
          }
        }
        class Wa {
          constructor(e, r, c, f, _, w, C, P) {
            this.placement = new qs(e, r, w, C, P), this._currentPlacementIndex = c.length - 1, this._forceFullPlacement = f, this._showCollisionBoxes = _, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e, r, c) {
            const f = he.now(), _ = () => !this._forceFullPlacement && he.now() - f > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const w = r[e[this._currentPlacementIndex]], C = this.placement.collisionIndex.transform.zoom;
              if (w.type === "symbol" && (!w.minzoom || w.minzoom <= C) && (!w.maxzoom || w.maxzoom > C)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Ch(w)), this._inProgressLayer.continuePlacement(c[w.source], this.placement, this._showCollisionBoxes, w, _)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(e) {
            return this.placement.commit(e), this.placement;
          }
        }
        const yo = 512 / u.$ / 2;
        class Dc {
          constructor(e, r, c) {
            this.tileID = e, this.bucketInstanceId = c, this._symbolsByKey = {};
            const f = /* @__PURE__ */ new Map();
            for (let _ = 0; _ < r.length; _++) {
              const w = r.get(_), C = w.key, P = f.get(C);
              P ? P.push(w) : f.set(C, [w]);
            }
            for (const [_, w] of f) {
              const C = { positions: w.map(((P) => ({ x: Math.floor(P.anchorX * yo), y: Math.floor(P.anchorY * yo) }))), crossTileIDs: w.map(((P) => P.crossTileID)) };
              if (C.positions.length > 128) {
                const P = new u.aI(C.positions.length, 16, Uint16Array);
                for (const { x: R, y: L } of C.positions) P.add(R, L);
                P.finish(), delete C.positions, C.index = P;
              }
              this._symbolsByKey[_] = C;
            }
          }
          getScaledCoordinates(e, r) {
            const { x: c, y: f, z: _ } = this.tileID.canonical, { x: w, y: C, z: P } = r.canonical, R = yo / Math.pow(2, P - _), L = (C * u.$ + e.anchorY) * R, j = f * u.$ * yo;
            return { x: Math.floor((w * u.$ + e.anchorX) * R - c * u.$ * yo), y: Math.floor(L - j) };
          }
          findMatches(e, r, c) {
            const f = this.tileID.canonical.z < r.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - r.canonical.z);
            for (let _ = 0; _ < e.length; _++) {
              const w = e.get(_);
              if (w.crossTileID) continue;
              const C = this._symbolsByKey[w.key];
              if (!C) continue;
              const P = this.getScaledCoordinates(w, r);
              if (C.index) {
                const R = C.index.range(P.x - f, P.y - f, P.x + f, P.y + f).sort();
                for (const L of R) {
                  const j = C.crossTileIDs[L];
                  if (!c[j]) {
                    c[j] = !0, w.crossTileID = j;
                    break;
                  }
                }
              } else if (C.positions) for (let R = 0; R < C.positions.length; R++) {
                const L = C.positions[R], j = C.crossTileIDs[R];
                if (Math.abs(L.x - P.x) <= f && Math.abs(L.y - P.y) <= f && !c[j]) {
                  c[j] = !0, w.crossTileID = j;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({ crossTileIDs: e }) => e));
          }
        }
        class Du {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Fl {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e) {
            const r = Math.round((e - this.lng) / 360);
            if (r !== 0) for (const c in this.indexes) {
              const f = this.indexes[c], _ = {};
              for (const w in f) {
                const C = f[w];
                C.tileID = C.tileID.unwrapTo(C.tileID.wrap + r), _[C.tileID.key] = C;
              }
              this.indexes[c] = _;
            }
            this.lng = e;
          }
          addBucket(e, r, c) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === r.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
            }
            for (let _ = 0; _ < r.symbolInstances.length; _++) r.symbolInstances.get(_).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const f = this.usedCrossTileIDs[e.overscaledZ];
            for (const _ in this.indexes) {
              const w = this.indexes[_];
              if (Number(_) > e.overscaledZ) for (const C in w) {
                const P = w[C];
                P.tileID.isChildOf(e) && P.findMatches(r.symbolInstances, e, f);
              }
              else {
                const C = w[e.scaledTo(Number(_)).key];
                C && C.findMatches(r.symbolInstances, e, f);
              }
            }
            for (let _ = 0; _ < r.symbolInstances.length; _++) {
              const w = r.symbolInstances.get(_);
              w.crossTileID || (w.crossTileID = c.generate(), f[w.crossTileID] = !0);
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Dc(e, r.symbolInstances, r.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(e, r) {
            for (const c of r.getCrossTileIDsLists()) for (const f of c) delete this.usedCrossTileIDs[e][f];
          }
          removeStaleBuckets(e) {
            let r = !1;
            for (const c in this.indexes) {
              const f = this.indexes[c];
              for (const _ in f) e[f[_].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, f[_]), delete f[_], r = !0);
            }
            return r;
          }
        }
        class rl {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Du(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e, r, c) {
            let f = this.layerIndexes[e.id];
            f === void 0 && (f = this.layerIndexes[e.id] = new Fl());
            let _ = !1;
            const w = {};
            f.handleWrapJump(c);
            for (const C of r) {
              const P = C.getBucket(e);
              P && e.id === P.layerIds[0] && (P.bucketInstanceId || (P.bucketInstanceId = ++this.maxBucketInstanceId), f.addBucket(C.tileID, P, this.crossTileIDs) && (_ = !0), w[P.bucketInstanceId] = !0);
            }
            return f.removeStaleBuckets(w) && (_ = !0), _;
          }
          pruneUnusedLayers(e) {
            const r = {};
            e.forEach(((c) => {
              r[c] = !0;
            }));
            for (const c in this.layerIndexes) r[c] || delete this.layerIndexes[c];
          }
        }
        var Vl = "void main() {fragColor=vec4(1.0);}";
        const Ma = { prelude: hi(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: hi("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: hi("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: hi(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: hi(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: hi(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: hi(Vl, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: hi(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: hi(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: hi("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: hi("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: hi(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: hi("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: hi(Vl, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: hi(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: hi(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: hi(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: hi(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: hi(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: hi(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: hi(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: hi(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: hi(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: hi(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: hi(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: hi(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: hi(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: hi(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: hi(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: hi(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: hi("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: hi("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: hi("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: hi("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: hi(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: hi("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function hi(y, e) {
          const r = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, c = e.match(/in ([\w]+) ([\w]+)/g), f = y.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), _ = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), w = _ ? _.concat(f) : f, C = {};
          return { fragmentSource: y = y.replace(r, ((P, R, L, j, B) => (C[B] = !0, R === "define" ? `
#ifndef HAS_UNIFORM_u_${B}
in ${L} ${j} ${B};
#else
uniform ${L} ${j} u_${B};
#endif
` : `
#ifdef HAS_UNIFORM_u_${B}
    ${L} ${j} ${B} = u_${B};
#endif
`))), vertexSource: e = e.replace(r, ((P, R, L, j, B) => {
            const V = j === "float" ? "vec2" : "vec4", $ = B.match(/color/) ? "color" : V;
            return C[B] ? R === "define" ? `
#ifndef HAS_UNIFORM_u_${B}
uniform lowp float u_${B}_t;
in ${L} ${V} a_${B};
out ${L} ${j} ${B};
#else
uniform ${L} ${j} u_${B};
#endif
` : $ === "vec4" ? `
#ifndef HAS_UNIFORM_u_${B}
    ${B} = a_${B};
#else
    ${L} ${j} ${B} = u_${B};
#endif
` : `
#ifndef HAS_UNIFORM_u_${B}
    ${B} = unpack_mix_${$}(a_${B}, u_${B}_t);
#else
    ${L} ${j} ${B} = u_${B};
#endif
` : R === "define" ? `
#ifndef HAS_UNIFORM_u_${B}
uniform lowp float u_${B}_t;
in ${L} ${V} a_${B};
#else
uniform ${L} ${j} u_${B};
#endif
` : $ === "vec4" ? `
#ifndef HAS_UNIFORM_u_${B}
    ${L} ${j} ${B} = a_${B};
#else
    ${L} ${j} ${B} = u_${B};
#endif
` : `
#ifndef HAS_UNIFORM_u_${B}
    ${L} ${j} ${B} = unpack_mix_${$}(a_${B}, u_${B}_t);
#else
    ${L} ${j} ${B} = u_${B};
#endif
`;
          })), staticAttributes: c, staticUniforms: w };
        }
        class _o {
          constructor(e, r, c) {
            this.vertexBuffer = e, this.indexBuffer = r, this.segments = c;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var Zs = u.aJ([{ name: "a_pos", type: "Int16", components: 2 }]);
        const Kr = "#define PROJECTION_MERCATOR", sl = "mercator";
        class di {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return !1;
          }
          get shaderVariantName() {
            return sl;
          }
          get shaderDefine() {
            return Kr;
          }
          get shaderPreludeCode() {
            return Ma.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return Ma.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return u.aK.noSubdivision;
          }
          get useGlobeControls() {
            return !1;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(e) {
          }
          getMeshFromTileID(e, r, c, f, _) {
            if (this._cachedMesh) return this._cachedMesh;
            const w = new u.aL();
            w.emplaceBack(0, 0), w.emplaceBack(u.$, 0), w.emplaceBack(0, u.$), w.emplaceBack(u.$, u.$);
            const C = e.createVertexBuffer(w, Zs.members), P = u.aM.simpleSegment(0, 0, 4, 2), R = new u.aN();
            R.emplaceBack(1, 0, 2), R.emplaceBack(1, 2, 3);
            const L = e.createIndexBuffer(R);
            return this._cachedMesh = new _o(C, L, P), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return !1;
          }
          setErrorQueryLatitudeDegrees(e) {
          }
        }
        class us {
          constructor(e = 0, r = 0, c = 0, f = 0) {
            if (isNaN(e) || e < 0 || isNaN(r) || r < 0 || isNaN(c) || c < 0 || isNaN(f) || f < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = r, this.left = c, this.right = f;
          }
          interpolate(e, r, c) {
            return r.top != null && e.top != null && (this.top = u.C.number(e.top, r.top, c)), r.bottom != null && e.bottom != null && (this.bottom = u.C.number(e.bottom, r.bottom, c)), r.left != null && e.left != null && (this.left = u.C.number(e.left, r.left, c)), r.right != null && e.right != null && (this.right = u.C.number(e.right, r.right, c)), this;
          }
          getCenter(e, r) {
            const c = u.ah((this.left + e - this.right) / 2, 0, e), f = u.ah((this.top + r - this.bottom) / 2, 0, r);
            return new u.P(c, f);
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
          }
          clone() {
            return new us(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function Rr(y, e) {
          if (!y.renderWorldCopies || y.lngRange) return;
          const r = e.lng - y.center.lng;
          e.lng += r > 180 ? -360 : r < -180 ? 360 : 0;
        }
        function ql(y) {
          return Math.max(0, Math.floor(y));
        }
        class ga {
          constructor(e, r, c, f, _, w) {
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = w === void 0 || !!w, this._minZoom = r || 0, this._maxZoom = c || 22, this._minPitch = f ?? 0, this._maxPitch = _ ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new u.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = ql(this._zoom), this._scale = u.af(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new us(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
          }
          apply(e, r, c) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = ql(this._zoom), this._scale = u.af(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new us(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !c && e.autoCalculateNearFarZ, r && this._constrain(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e;
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new u.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(e) {
            const r = u.aO(e, -180, 180) * Math.PI / 180;
            var c, f, _, w, C, P, R, L, j;
            this._bearingInRadians !== r && (this._unmodified = !1, this._bearingInRadians = r, this._calcMatrices(), this._rotationMatrix = U(), c = this._rotationMatrix, _ = -this._bearingInRadians, w = (f = this._rotationMatrix)[0], C = f[1], P = f[2], R = f[3], L = Math.sin(_), j = Math.cos(_), c[0] = w * j + P * L, c[1] = C * j + R * L, c[2] = w * -L + P * j, c[3] = C * -L + R * j);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(e) {
            const r = u.ah(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== r && (this._unmodified = !1, this._pitchInRadians = r, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(e) {
            const r = e / 180 * Math.PI;
            this._rollInRadians !== r && (this._unmodified = !1, this._rollInRadians = r, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return u.aP(this._fovInRadians);
          }
          setFov(e) {
            e = u.ah(e, 0.1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = u.ae(e), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(e) {
            const r = this.getConstrained(this._center, e).zoom;
            this._zoom !== r && (this._unmodified = !1, this._zoom = r, this._tileZoom = Math.max(0, Math.floor(r)), this._scale = u.af(r), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(e, r) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = r, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices();
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e);
          }
          interpolatePadding(e, r, c) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, r, c), this._constrain(), this._calcMatrices();
          }
          resize(e, r, c = !0) {
            this._width = e, this._height = r, c && this._constrain(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new an([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-u.ai, u.ai]);
          }
          getConstrained(e, r) {
            return this._callbacks.getConstrained(e, r);
          }
          getCameraQueryGeometry(e, r) {
            if (r.length === 1) return [r[0], e];
            {
              const { minX: c, minY: f, maxX: _, maxY: w } = u.a2.fromPoints(r).extend(e);
              return [new u.P(c, f), new u.P(_, f), new u.P(_, w), new u.P(c, w), new u.P(c, f)];
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified, { center: r, zoom: c } = this.getConstrained(this.center, this.zoom);
            this.setCenter(r), this.setZoom(c), this._unmodified = e, this._constraining = !1;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = u.ag(new Float64Array(16));
              u.N(e, e, [this._width / 2, -this._height / 2, 1]), u.M(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = u.ag(new Float64Array(16)), u.N(e, e, [1, -1, 1]), u.M(e, e, [-1, -1, 0]), u.N(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(e, r, c, f) {
            const _ = c !== void 0 ? c : this.bearing, w = f = f !== void 0 ? f : this.pitch, C = u.a1.fromLngLat(e, r), P = -Math.cos(u.ae(w)), R = Math.sin(u.ae(w)), L = R * Math.sin(u.ae(_)), j = -R * Math.cos(u.ae(_));
            let B = this.elevation;
            const V = r - B;
            let $;
            P * V >= 0 || Math.abs(P) < 0.1 ? ($ = 1e4, B = r + $ * P) : $ = -V / P;
            let ie, te, ne = u.aQ(1, C.y), re = 0;
            do {
              if (re += 1, re > 10) break;
              te = $ / ne, ie = new u.a1(C.x + L * te, C.y + j * te), ne = 1 / ie.meterInMercatorCoordinateUnits();
            } while (Math.abs($ - te * ne) > 1e-12);
            return { center: ie.toLngLat(), elevation: B, zoom: u.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / te / this.tileSize) };
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const r = u.aj(1, this.center.lat) * this.worldSize, c = this.cameraToCenterDistance / r, f = u.a1.fromLngLat(this.center, this.elevation), _ = Ee(this.center, this.elevation, this.pitch, this.bearing, c);
            this._elevation = e;
            const w = this.calculateCenterFromCameraLngLatAlt(_.toLngLat(), u.aQ(_.z, f.y), this.bearing, this.pitch);
            this._elevation = w.elevation, this._center = w.center, this.setZoom(w.zoom);
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new u.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const e = u.aj(1, this.center.lat) * this.worldSize;
            return Ee(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat();
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const r = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / r, e.canonical.y / r, 1 / r / u.$, 1 / r / u.$];
          }
        }
        class bn {
          constructor(e, r) {
            this.min = e, this.max = r, this.center = u.aR([], u.aS([], this.min, this.max), 0.5);
          }
          quadrant(e) {
            const r = [e % 2 == 0, e < 2], c = u.aT(this.min), f = u.aT(this.max);
            for (let _ = 0; _ < r.length; _++) c[_] = r[_] ? this.min[_] : this.center[_], f[_] = r[_] ? this.center[_] : this.max[_];
            return f[2] = this.max[2], new bn(c, f);
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
          }
          intersectsFrustum(e) {
            let r = !0;
            for (let c = 0; c < e.planes.length; c++) {
              const f = this.intersectsPlane(e.planes[c]);
              if (f === 0) return 0;
              f === 1 && (r = !1);
            }
            return r ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(e) {
            let r = e[3], c = e[3];
            for (let f = 0; f < 3; f++) e[f] > 0 ? (r += e[f] * this.min[f], c += e[f] * this.max[f]) : (c += e[f] * this.min[f], r += e[f] * this.max[f]);
            return r >= 0 ? 2 : c < 0 ? 0 : 1;
          }
        }
        class Vn {
          distanceToTile2d(e, r, c, f) {
            const _ = f.distanceX([e, r]), w = f.distanceY([e, r]);
            return Math.hypot(_, w);
          }
          getWrap(e, r, c) {
            return c;
          }
          getTileBoundingVolume(e, r, c, f) {
            var _, w;
            let C = 0, P = 0;
            if (f?.terrain) {
              const L = new u.Z(e.z, r, e.z, e.x, e.y), j = f.terrain.getMinMaxElevation(L);
              C = (_ = j.minElevation) !== null && _ !== void 0 ? _ : Math.min(0, c), P = (w = j.maxElevation) !== null && w !== void 0 ? w : Math.max(0, c);
            }
            const R = 1 << e.z;
            return new bn([r + e.x / R, e.y / R, C], [r + (e.x + 1) / R, (e.y + 1) / R, P]);
          }
          allowVariableZoom(e, r) {
            const c = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, f = u.ah(78.5 - c / 2, 0, 60);
            return !!r.terrain || e.pitch > f;
          }
          allowWorldCopies() {
            return !0;
          }
          prepareNextFrame() {
          }
        }
        class Dn {
          constructor(e, r, c) {
            this.points = e, this.planes = r, this.aabb = c;
          }
          static fromInvProjectionMatrix(e, r = 1, c = 0, f, _) {
            const w = _ ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], C = Math.pow(2, c), P = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(((B) => (function(V, $, ie, te) {
              const ne = u.aw([], V, $), re = 1 / ne[3] / ie * te;
              return u.aY(ne, ne, [re, re, 1 / ne[3], re]);
            })(B, e, r, C)));
            f && (function(B, V, $, ie) {
              const te = ie ? 4 : 0, ne = ie ? 0 : 4;
              let re = 0;
              const ce = [], oe = [];
              for (let ue = 0; ue < 4; ue++) {
                const we = u.aU([], B[ue + ne], B[ue + te]), Oe = u.aZ(we);
                u.aR(we, we, 1 / Oe), ce.push(Oe), oe.push(we);
              }
              for (let ue = 0; ue < 4; ue++) {
                const we = u.a_(B[ue + te], oe[ue], $);
                re = we !== null && we >= 0 ? Math.max(re, we) : Math.max(re, ce[ue]);
              }
              const pe = (function(ue, we) {
                const Oe = u.aU([], ue[we[0]], ue[we[1]]), ze = u.aU([], ue[we[2]], ue[we[1]]), Pe = [0, 0, 0, 0];
                return u.aV(Pe, u.aW([], Oe, ze)), Pe[3] = -u.aX(Pe, ue[we[0]]), Pe;
              })(B, V), ye = (function(ue, we) {
                const Oe = u.a$(ue), ze = u.b0([], ue, 1 / Oe), Pe = u.aU([], we, u.aR([], ze, u.aX(we, ze))), Le = u.a$(Pe);
                if (Le > 0) {
                  const lt = Math.sqrt(1 - ze[3] * ze[3]), ct = u.aR([], ze, -ze[3]), We = u.aS([], ct, u.aR([], Pe, lt / Le));
                  return u.b1(we, We);
                }
                return null;
              })($, pe);
              if (ye !== null) {
                const ue = ye / u.aX(oe[0], pe);
                re = Math.min(re, ue);
              }
              for (let ue = 0; ue < 4; ue++) {
                const we = Math.min(re, ce[ue]);
                B[ue + ne] = [B[ue + te][0] + oe[ue][0] * we, B[ue + te][1] + oe[ue][1] * we, B[ue + te][2] + oe[ue][2] * we, 1];
              }
            })(P, w[0], f, _);
            const R = w.map(((B) => {
              const V = u.aU([], P[B[0]], P[B[1]]), $ = u.aU([], P[B[2]], P[B[1]]), ie = u.aV([], u.aW([], V, $)), te = -u.aX(ie, P[B[1]]);
              return ie.concat(te);
            })), L = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], j = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const B of P) for (let V = 0; V < 3; V++) L[V] = Math.min(L[V], B[V]), j[V] = Math.max(j[V], B[V]);
            return new Dn(P, R, new bn(L, j));
          }
        }
        class Ui {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, r, c) {
            return this._helper.interpolatePadding(e, r, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, r, c = !0) {
            this._helper.resize(e, r, c);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, r) {
            this._helper.overrideNearFarZ(e, r);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e, r) {
          }
          constructor(e, r, c, f, _) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new ga({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (w, C) => this.getConstrained(w, C) }, e, r, c, f, _), this._coveringTilesDetailsProvider = new Vn();
          }
          clone() {
            const e = new Ui();
            return e.apply(this), e;
          }
          apply(e, r, c) {
            this._helper.apply(e, r, c);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(e) {
            const r = [new u.b2(0, e)];
            if (this._helper._renderWorldCopies) {
              const c = this.screenPointToMercatorCoordinate(new u.P(0, 0)), f = this.screenPointToMercatorCoordinate(new u.P(this._helper._width, 0)), _ = this.screenPointToMercatorCoordinate(new u.P(this._helper._width, this._helper._height)), w = this.screenPointToMercatorCoordinate(new u.P(0, this._helper._height)), C = Math.floor(Math.min(c.x, f.x, _.x, w.x)), P = Math.floor(Math.max(c.x, f.x, _.x, w.x)), R = 1;
              for (let L = C - R; L <= P + R; L++) L !== 0 && r.push(new u.b2(L, e));
            }
            return r;
          }
          getCameraFrustum() {
            return Dn.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            const r = this.screenPointToLocation(this.centerPoint, e), c = e ? e.getElevationForLngLatZoom(r, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(c);
          }
          setLocationAtPoint(e, r) {
            const c = u.aj(this.elevation, this.center.lat), f = this.screenPointToMercatorCoordinateAtZ(r, c), _ = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, c), w = u.a1.fromLngLat(e), C = new u.a1(w.x - (f.x - _.x), w.y - (f.y - _.y));
            this.setCenter(C?.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(e, r) {
            return r ? this.coordinatePoint(u.a1.fromLngLat(e), r.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(u.a1.fromLngLat(e));
          }
          screenPointToLocation(e, r) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, r)) === null || c === void 0 ? void 0 : c.toLngLat();
          }
          screenPointToMercatorCoordinate(e, r) {
            if (r) {
              const c = r.pointCoordinate(e);
              if (c != null) return c;
            }
            return this.screenPointToMercatorCoordinateAtZ(e);
          }
          screenPointToMercatorCoordinateAtZ(e, r) {
            const c = r || 0, f = [e.x, e.y, 0, 1], _ = [e.x, e.y, 1, 1];
            u.aw(f, f, this._pixelMatrixInverse), u.aw(_, _, this._pixelMatrixInverse);
            const w = f[3], C = _[3], P = f[1] / w, R = _[1] / C, L = f[2] / w, j = _[2] / C, B = L === j ? 0 : (c - L) / (j - L);
            return new u.a1(u.C.number(f[0] / w, _[0] / C, B) / this.worldSize, u.C.number(P, R, B) / this.worldSize, c);
          }
          coordinatePoint(e, r = 0, c = this._pixelMatrix) {
            const f = [e.x * this.worldSize, e.y * this.worldSize, r, 1];
            return u.aw(f, f, c), new u.P(f[0] / f[3], f[1] / f[3]);
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - me(this));
            return new an().extend(this.screenPointToLocation(new u.P(0, e))).extend(this.screenPointToLocation(new u.P(this._helper._width, e))).extend(this.screenPointToLocation(new u.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new u.P(0, this._helper._height)));
          }
          isPointOnMapSurface(e, r) {
            return r ? r.pointCoordinate(e) != null : e.y > this.height / 2 - me(this);
          }
          calculatePosMatrix(e, r = !1, c) {
            var f;
            const _ = (f = e.key) !== null && f !== void 0 ? f : u.b3(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), w = r ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (w.has(_)) {
              const R = w.get(_);
              return c ? R.f32 : R.f64;
            }
            const C = ve(e, this.worldSize);
            u.O(C, r ? this._alignedProjMatrix : this._viewProjMatrix, C);
            const P = { f64: C, f32: new Float32Array(C) };
            return w.set(_, P), c ? P.f32 : P.f64;
          }
          calculateFogMatrix(e) {
            const r = e.key, c = this._fogMatrixCacheF32;
            if (c.has(r)) return c.get(r);
            const f = ve(e, this.worldSize);
            return u.O(f, this._fogMatrix, f), c.set(r, new Float32Array(f)), c.get(r);
          }
          getConstrained(e, r) {
            r = u.ah(+r, this.minZoom, this.maxZoom);
            const c = { center: new u.S(e.lng, e.lat), zoom: r };
            let f = this._helper._lngRange;
            if (!this._helper._renderWorldCopies && f === null) {
              const ce = 179.9999999999;
              f = [-ce, ce];
            }
            const _ = this.tileSize * u.af(c.zoom);
            let w = 0, C = _, P = 0, R = _, L = 0, j = 0;
            const { x: B, y: V } = this.size;
            if (this._helper._latRange) {
              const ce = this._helper._latRange;
              w = u.U(ce[1]) * _, C = u.U(ce[0]) * _, C - w < V && (L = V / (C - w));
            }
            f && (P = u.aO(u.V(f[0]) * _, 0, _), R = u.aO(u.V(f[1]) * _, 0, _), R < P && (R += _), R - P < B && (j = B / (R - P)));
            const { x: $, y: ie } = Q(_, e);
            let te, ne;
            const re = Math.max(j || 0, L || 0);
            if (re) {
              const ce = new u.P(j ? (R + P) / 2 : $, L ? (C + w) / 2 : ie);
              return c.center = le(_, ce).wrap(), c.zoom += u.ak(re), c;
            }
            if (this._helper._latRange) {
              const ce = V / 2;
              ie - ce < w && (ne = w + ce), ie + ce > C && (ne = C - ce);
            }
            if (f) {
              const ce = (P + R) / 2;
              let oe = $;
              this._helper._renderWorldCopies && (oe = u.aO($, ce - _ / 2, ce + _ / 2));
              const pe = B / 2;
              oe - pe < P && (te = P + pe), oe + pe > R && (te = R - pe);
            }
            if (te !== void 0 || ne !== void 0) {
              const ce = new u.P(te ?? $, ne ?? ie);
              c.center = le(_, ce).wrap();
            }
            return c;
          }
          calculateCenterFromCameraLngLatAlt(e, r, c, f) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, r, c, f);
          }
          _calculateNearFarZIfNeeded(e, r, c) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const f = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), _ = e - f * this._helper._pixelPerMeter / Math.cos(r), w = f < 0 ? _ : e, C = Math.PI / 2 + this.pitchInRadians, P = u.ae(this.fov) * (Math.abs(Math.cos(u.ae(this.roll))) * this.height + Math.abs(Math.sin(u.ae(this.roll))) * this.width) / this.height * (0.5 + c.y / this.height), R = Math.sin(P) * w / Math.sin(u.ah(Math.PI - C - P, 0.01, Math.PI - 0.01)), L = me(this), j = Math.atan(L / this._helper.cameraToCenterDistance), B = u.ae(0.75), V = j > B ? 2 * j * (0.5 + c.y / (2 * L)) : B, $ = Math.sin(V) * w / Math.sin(u.ah(Math.PI - C - V, 0.01, Math.PI - 0.01)), ie = Math.min(R, $);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - r) * ie + w), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset, r = Q(this.worldSize, this.center), c = r.x, f = r.y;
            this._helper._pixelPerMeter = u.aj(1, this.center.lat) * this.worldSize;
            const _ = u.ae(Math.min(this.pitch, Y)), w = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(_));
            let C;
            this._calculateNearFarZIfNeeded(w, _, e), C = new Float64Array(16), u.b4(C, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), u.aq(this._invProjMatrix, C), C[8] = 2 * -e.x / this._helper._width, C[9] = 2 * e.y / this._helper._height, this._projectionMatrix = u.b5(C), u.N(C, C, [1, -1, 1]), u.M(C, C, [0, 0, -this._helper.cameraToCenterDistance]), u.b6(C, C, -this.rollInRadians), u.b7(C, C, this.pitchInRadians), u.b6(C, C, -this.bearingInRadians), u.M(C, C, [-c, -f, 0]), this._mercatorMatrix = u.N([], C, [this.worldSize, this.worldSize, this.worldSize]), u.N(C, C, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = u.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, C), u.M(C, C, [0, 0, -this.elevation]), this._viewProjMatrix = C, this._invViewProjMatrix = u.aq([], C);
            const P = [0, 0, -1, 1];
            u.aw(P, P, this._invViewProjMatrix), this._cameraPosition = [P[0] / P[3], P[1] / P[3], P[2] / P[3]], this._fogMatrix = new Float64Array(16), u.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, w, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, u.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]), u.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), u.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), u.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), u.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), u.M(this._fogMatrix, this._fogMatrix, [-c, -f, 0]), u.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), u.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = u.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, C);
            const R = this._helper._width % 2 / 2, L = this._helper._height % 2 / 2, j = Math.cos(this.bearingInRadians), B = Math.sin(-this.bearingInRadians), V = c - Math.round(c) + j * R + B * L, $ = f - Math.round(f) + j * L + B * R, ie = new Float64Array(C);
            if (u.M(ie, ie, [V > 0.5 ? V - 1 : V, $ > 0.5 ? $ - 1 : $, 0]), this._alignedProjMatrix = ie, C = u.aq(new Float64Array(16), this._pixelMatrix), !C) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = C, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new u.P(0, 0)), r = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return u.aw(r, r, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const e = u.aj(1, this.center.lat) * this.worldSize;
            return Ee(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat();
          }
          lngLatToCameraDepth(e, r) {
            const c = u.a1.fromLngLat(e), f = [c.x * this.worldSize, c.y * this.worldSize, r, 1];
            return u.aw(f, f, this._viewProjMatrix), f[2] / f[3];
          }
          getProjectionData(e) {
            const { overscaledTileID: r, aligned: c, applyTerrainMatrix: f } = e, _ = this._helper.getMercatorTileCoordinates(r), w = r ? this.calculatePosMatrix(r, c, !0) : null;
            let C;
            return C = r && r.terrainRttPosMatrix32f && f ? r.terrainRttPosMatrix32f : w || u.b8(), { mainMatrix: C, tileMercatorCoords: _, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: C };
          }
          isLocationOccluded(e) {
            return !1;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(e, r, c) {
            return 1;
          }
          transformLightDirection(e) {
            return u.aT(e);
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(e, r, c, f) {
            const _ = this.calculatePosMatrix(c);
            let w;
            f ? (w = [e, r, f(e, r), 1], u.aw(w, w, _)) : (w = [e, r, 0, 1], os(w, w, _));
            const C = w[3];
            return { point: new u.P(w[0] / C, w[1] / C), signedDistanceFromCamera: C, isOccluded: !1 };
          }
          populateCache(e) {
            for (const r of e) this.calculatePosMatrix(r);
          }
          getMatrixForModel(e, r) {
            const c = u.a1.fromLngLat(e, r), f = c.meterInMercatorCoordinateUnits(), _ = u.b9();
            return u.M(_, _, [c.x, c.y, c.z]), u.b6(_, _, Math.PI), u.b7(_, _, Math.PI / 2), u.N(_, _, [-f, f, f]), _;
          }
          getProjectionDataForCustomLayer(e = !0) {
            const r = new u.Z(0, 0, 0, 0, 0), c = this.getProjectionData({ overscaledTileID: r, applyGlobeMatrix: e }), f = ve(r, this.worldSize);
            u.O(f, this._viewProjMatrix, f), c.tileMercatorCoords = [0, 0, 1, 1];
            const _ = [u.$, u.$, this.worldSize / this._helper.pixelsPerMeter], w = u.ba();
            return u.N(w, f, _), c.fallbackMatrix = w, c.mainMatrix = w, c;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e);
          }
        }
        function zh() {
          u.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function Wn(y) {
          if (y.useSlerp) if (y.k < 1) {
            const e = u.bb(y.startEulerAngles.roll, y.startEulerAngles.pitch, y.startEulerAngles.bearing), r = u.bb(y.endEulerAngles.roll, y.endEulerAngles.pitch, y.endEulerAngles.bearing), c = new Float64Array(4);
            u.bc(c, e, r, y.k);
            const f = u.bd(c);
            y.tr.setRoll(f.roll), y.tr.setPitch(f.pitch), y.tr.setBearing(f.bearing);
          } else y.tr.setRoll(y.endEulerAngles.roll), y.tr.setPitch(y.endEulerAngles.pitch), y.tr.setBearing(y.endEulerAngles.bearing);
          else y.tr.setRoll(u.C.number(y.startEulerAngles.roll, y.endEulerAngles.roll, y.k)), y.tr.setPitch(u.C.number(y.startEulerAngles.pitch, y.endEulerAngles.pitch, y.k)), y.tr.setBearing(u.C.number(y.startEulerAngles.bearing, y.endEulerAngles.bearing, y.k));
        }
        function Ln(y, e, r, c, f) {
          const _ = f.padding, w = Q(f.worldSize, r.getNorthWest()), C = Q(f.worldSize, r.getNorthEast()), P = Q(f.worldSize, r.getSouthEast()), R = Q(f.worldSize, r.getSouthWest()), L = u.ae(-c), j = w.rotate(L), B = C.rotate(L), V = P.rotate(L), $ = R.rotate(L), ie = new u.P(Math.max(j.x, B.x, $.x, V.x), Math.max(j.y, B.y, $.y, V.y)), te = new u.P(Math.min(j.x, B.x, $.x, V.x), Math.min(j.y, B.y, $.y, V.y)), ne = ie.sub(te), re = (f.width - (_.left + _.right + e.left + e.right)) / ne.x, ce = (f.height - (_.top + _.bottom + e.top + e.bottom)) / ne.y;
          if (ce < 0 || re < 0) return void zh();
          const oe = Math.min(u.ak(f.scale * Math.min(re, ce)), y.maxZoom), pe = u.P.convert(y.offset), ye = new u.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(u.ae(c)), ue = pe.add(ye).mult(f.scale / u.af(oe));
          return { center: le(f.worldSize, w.add(P).div(2).sub(ue)), zoom: oe, bearing: c };
        }
        class ua {
          get useGlobeControls() {
            return !1;
          }
          handlePanInertia(e, r) {
            return { easingOffset: e, easingCenter: r.center };
          }
          handleMapControlsRollPitchBearingZoom(e, r) {
            e.bearingDelta && r.setBearing(r.bearing + e.bearingDelta), e.pitchDelta && r.setPitch(r.pitch + e.pitchDelta), e.rollDelta && r.setRoll(r.roll + e.rollDelta), e.zoomDelta && r.setZoom(r.zoom + e.zoomDelta);
          }
          handleMapControlsPan(e, r, c) {
            e.around.distSqr(r.centerPoint) < 0.01 || r.setLocationAtPoint(c, e.around);
          }
          cameraForBoxAndBearing(e, r, c, f, _) {
            return Ln(e, r, c, f, _);
          }
          handleJumpToCenterZoom(e, r) {
            e.zoom !== (r.zoom !== void 0 ? +r.zoom : e.zoom) && e.setZoom(+r.zoom), r.center !== void 0 && e.setCenter(u.S.convert(r.center));
          }
          handleEaseTo(e, r) {
            const c = e.zoom, f = e.padding, _ = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, w = { roll: r.roll === void 0 ? e.roll : r.roll, pitch: r.pitch === void 0 ? e.pitch : r.pitch, bearing: r.bearing === void 0 ? e.bearing : r.bearing }, C = r.zoom !== void 0, P = !e.isPaddingEqual(r.padding);
            let R = !1;
            const L = C ? +r.zoom : e.zoom;
            let j = e.centerPoint.add(r.offsetAsPoint);
            const B = e.screenPointToLocation(j), { center: V, zoom: $ } = e.getConstrained(u.S.convert(r.center || B), L ?? c);
            Rr(e, V);
            const ie = Q(e.worldSize, B), te = Q(e.worldSize, V).sub(ie), ne = u.af($ - c);
            return R = $ !== c, { easeFunc: (re) => {
              if (R && e.setZoom(u.C.number(c, $, re)), u.be(_, w) || Wn({ startEulerAngles: _, endEulerAngles: w, tr: e, k: re, useSlerp: _.roll != w.roll }), P && (e.interpolatePadding(f, r.padding, re), j = e.centerPoint.add(r.offsetAsPoint)), r.around) e.setLocationAtPoint(r.around, r.aroundPoint);
              else {
                const ce = u.af(e.zoom - c), oe = $ > c ? Math.min(2, ne) : Math.max(0.5, ne), pe = Math.pow(oe, 1 - re), ye = le(e.worldSize, ie.add(te.mult(re * pe)).mult(ce));
                e.setLocationAtPoint(e.renderWorldCopies ? ye.wrap() : ye, j);
              }
            }, isZooming: R, elevationCenter: V };
          }
          handleFlyTo(e, r) {
            const c = r.zoom !== void 0, f = e.zoom, _ = e.getConstrained(u.S.convert(r.center || r.locationAtOffset), c ? +r.zoom : f), w = _.center, C = _.zoom;
            Rr(e, w);
            const P = Q(e.worldSize, r.locationAtOffset), R = Q(e.worldSize, w).sub(P), L = R.mag(), j = u.af(C - f);
            let B;
            if (r.minZoom !== void 0) {
              const V = Math.min(+r.minZoom, f, C), $ = e.getConstrained(w, V).zoom;
              B = u.af($ - f);
            }
            return { easeFunc: (V, $, ie, te) => {
              e.setZoom(V === 1 ? C : f + u.ak($));
              const ne = V === 1 ? w : le(e.worldSize, P.add(R.mult(ie)).mult($));
              e.setLocationAtPoint(e.renderWorldCopies ? ne.wrap() : ne, te);
            }, scaleOfZoom: j, targetCenter: w, scaleOfMinZoom: B, pixelPathLength: L };
          }
        }
        class Fi {
          constructor(e, r, c) {
            this.blendFunction = e, this.blendColor = r, this.mask = c;
          }
        }
        Fi.Replace = [1, 0], Fi.disabled = new Fi(Fi.Replace, u.bf.transparent, [!1, !1, !1, !1]), Fi.unblended = new Fi(Fi.Replace, u.bf.transparent, [!0, !0, !0, !0]), Fi.alphaBlended = new Fi([1, 771], u.bf.transparent, [!0, !0, !0, !0]);
        const Ja = 2305;
        class Ut {
          constructor(e, r, c) {
            this.enable = e, this.mode = r, this.frontFace = c;
          }
        }
        Ut.disabled = new Ut(!1, 1029, Ja), Ut.backCCW = new Ut(!0, 1029, Ja), Ut.frontCCW = new Ut(!0, 1028, Ja);
        class Wt {
          constructor(e, r, c) {
            this.func = e, this.mask = r, this.range = c;
          }
        }
        Wt.ReadOnly = !1, Wt.ReadWrite = !0, Wt.disabled = new Wt(519, Wt.ReadOnly, [0, 1]);
        const cs = 7680;
        class fi {
          constructor(e, r, c, f, _, w) {
            this.test = e, this.ref = r, this.mask = c, this.fail = f, this.depthFail = _, this.pass = w;
          }
        }
        fi.disabled = new fi({ func: 519, mask: 0 }, 0, 0, cs, cs, cs);
        const Aa = /* @__PURE__ */ new WeakMap();
        function Wr(y) {
          var e;
          if (Aa.has(y)) return Aa.get(y);
          {
            const r = (e = y.getParameter(y.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return Aa.set(y, r), r;
          }
        }
        class wn {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const r = e.context, c = r.gl;
            this._texFormat = c.RGBA, this._texType = c.UNSIGNED_BYTE;
            const f = new u.aL();
            f.emplaceBack(-1, -1), f.emplaceBack(2, -1), f.emplaceBack(-1, 2);
            const _ = new u.aN();
            _.emplaceBack(0, 1, 2), this._fullscreenTriangle = new _o(r.createVertexBuffer(f, Zs.members), r.createIndexBuffer(_), u.aM.simpleSegment(0, 0, f.length, _.length)), this._resultBuffer = new Uint8Array(4), r.activeTexture.set(c.TEXTURE1);
            const w = c.createTexture();
            c.bindTexture(c.TEXTURE_2D, w), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST), c.texImage2D(c.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = r.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(w), Wr(c) && (this._pbo = c.createBuffer(), c.bindBuffer(c.PIXEL_PACK_BUFFER, this._pbo), c.bufferData(c.PIXEL_PACK_BUFFER, 4, c.STREAM_READ), c.bindBuffer(c.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(e, r) {
            const c = this._updateCount;
            return this._readbackQueue ? c >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : c >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, r), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context, r = e.gl;
            e.activeTexture.set(r.TEXTURE1), r.bindTexture(r.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(e, r) {
            const c = this._cachedRenderContext.context, f = c.gl;
            if (this._bindFramebuffer(), c.viewport.set([0, 0, this._texWidth, this._texHeight]), c.clear({ color: u.bf.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(c, f.TRIANGLES, Wt.disabled, fi.disabled, Fi.unblended, Ut.disabled, /* @__PURE__ */ ((_, w) => ({ u_input: _, u_output_expected: w }))(e, r), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Wr(f)) {
              f.bindBuffer(f.PIXEL_PACK_BUFFER, this._pbo), f.readBuffer(f.COLOR_ATTACHMENT0), f.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), f.bindBuffer(f.PIXEL_PACK_BUFFER, null);
              const _ = f.fenceSync(f.SYNC_GPU_COMMANDS_COMPLETE, 0);
              f.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: _ };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Wr(e)) {
              const r = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (r === e.WAIT_FAILED) return u.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (r === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = wn._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(e) {
            let r = 0;
            return r += e[0] / 256, r += e[1] / 65536, r += e[2] / 16777216, e[3] < 127 && (r = -r), r / 128;
          }
        }
        const hs = u.$ / 128;
        function Gl(y, e) {
          const r = y.granularity !== void 0 ? Math.max(y.granularity, 1) : 1, c = r + (y.generateBorders ? 2 : 0), f = r + (y.extendToNorthPole || y.generateBorders ? 1 : 0) + (y.extendToSouthPole || y.generateBorders ? 1 : 0), _ = c + 1, w = f + 1, C = y.generateBorders ? -1 : 0, P = y.generateBorders || y.extendToNorthPole ? -1 : 0, R = r + (y.generateBorders ? 1 : 0), L = r + (y.generateBorders || y.extendToSouthPole ? 1 : 0), j = _ * w, B = c * f * 6, V = _ * w > 65536;
          if (V && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const $ = V || e === "32bit", ie = new Int16Array(2 * j);
          let te = 0;
          for (let ce = P; ce <= L; ce++) for (let oe = C; oe <= R; oe++) {
            let pe = oe / r * u.$;
            oe === -1 && (pe = -hs), oe === r + 1 && (pe = u.$ + hs);
            let ye = ce / r * u.$;
            ce === -1 && (ye = y.extendToNorthPole ? u.bh : -hs), ce === r + 1 && (ye = y.extendToSouthPole ? u.bi : u.$ + hs), ie[te++] = pe, ie[te++] = ye;
          }
          const ne = $ ? new Uint32Array(B) : new Uint16Array(B);
          let re = 0;
          for (let ce = 0; ce < f; ce++) for (let oe = 0; oe < c; oe++) {
            const pe = oe + 1 + ce * _, ye = oe + (ce + 1) * _, ue = oe + 1 + (ce + 1) * _;
            ne[re++] = oe + ce * _, ne[re++] = ye, ne[re++] = pe, ne[re++] = pe, ne[re++] = ye, ne[re++] = ue;
          }
          return { vertices: ie.buffer.slice(0), indices: ne.buffer.slice(0), uses32bitIndices: $ };
        }
        const ds = new u.aK({ fill: new u.bj(128, 2), line: new u.bj(512, 0), tile: new u.bj(128, 32), stencil: new u.bj(128, 1), circle: 3 });
        class Lu {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return !0;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return Ma.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return Ma.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return ds;
          }
          get useGlobeControls() {
            return !0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new wn(e));
            const r = u.U(this._errorQueryLatitudeDegrees), c = 2 * Math.atan(Math.exp(Math.PI - r * Math.PI * 2)) - 0.5 * Math.PI, f = this._errorMeasurement.updateErrorLoop(r, c), _ = he.now();
            f !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = f, this._errorMeasurementLastChangeTime = _);
            const w = Math.min(Math.max((_ - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = u.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, u.bl(w));
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(e, r, c, f, _) {
            const w = (_ === "stencil" ? ds.stencil : ds.tile).getGranularityForZoomLevel(r.z);
            return this._getMesh(e, { granularity: w, generateBorders: c, extendToNorthPole: r.y === 0 && f, extendToSouthPole: r.y === (1 << r.z) - 1 && f });
          }
          _getMesh(e, r) {
            const c = this._getMeshKey(r);
            if (c in this._tileMeshCache) return this._tileMeshCache[c];
            const f = (function(_, w) {
              const C = Gl(w, "16bit"), P = u.aL.deserialize({ arrayBuffer: C.vertices, length: C.vertices.byteLength / 2 / 2 }), R = u.aN.deserialize({ arrayBuffer: C.indices, length: C.indices.byteLength / 2 / 3 });
              return new _o(_.createVertexBuffer(P, Zs.members), _.createIndexBuffer(R), u.aM.simpleSegment(0, 0, P.length, R.length));
            })(e, r);
            return this._tileMeshCache[c] = f, f;
          }
          recalculate(e) {
          }
          hasTransition() {
            const e = he.now();
            let r = !1;
            return r = r || (e - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, r = r || this._errorMeasurement && this._errorMeasurement.awaitingQuery, r;
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e;
          }
        }
        const Zl = new u.r({ type: new u.D(u.v.projection.type) });
        class $l extends u.E {
          constructor(e) {
            super(), this._transitionable = new u.t(Zl), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new u.F(0)), this._mercatorProjection = new di(), this._verticalPerspectiveProjection = new Lu();
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof u.bm) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e);
          }
          getMeshFromTileID(e, r, c, f, _) {
            return this.currentProjection.getMeshFromTileID(e, r, c, f, _);
          }
          setProjection(e) {
            this._transitionable.setValue("type", e?.type || "mercator");
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
          }
        }
        function vo(y) {
          const e = Hl(y.worldSize, y.center.lat);
          return 2 * Math.PI * e;
        }
        function Qa(y, e, r, c, f) {
          const _ = 1 / (1 << f), w = e / u.$ * _ + c * _, C = u.bo((y / u.$ * _ + r * _) * Math.PI * 2 + Math.PI, 2 * Math.PI), P = 2 * Math.atan(Math.exp(Math.PI - w * Math.PI * 2)) - 0.5 * Math.PI, R = Math.cos(P), L = new Float64Array(3);
          return L[0] = Math.sin(C) * R, L[1] = Math.sin(P), L[2] = Math.cos(C) * R, L;
        }
        function Jn(y) {
          return (function(e, r) {
            const c = Math.cos(r), f = new Float64Array(3);
            return f[0] = Math.sin(e) * c, f[1] = Math.sin(r), f[2] = Math.cos(e) * c, f;
          })(y.lng * Math.PI / 180, y.lat * Math.PI / 180);
        }
        function Hl(y, e) {
          return y / (2 * Math.PI) / Math.cos(e * Math.PI / 180);
        }
        function Ou(y) {
          const e = Math.asin(y[1]) / Math.PI * 180, r = Math.sqrt(y[0] * y[0] + y[2] * y[2]);
          if (r > 1e-6) {
            const c = y[0] / r, f = Math.acos(y[2] / r), _ = (c > 0 ? f : -f) / Math.PI * 180;
            return new u.S(u.aO(_, -180, 180), e);
          }
          return new u.S(0, e);
        }
        function ol(y) {
          return Math.cos(y * Math.PI / 180);
        }
        function pn(y, e) {
          const r = ol(y), c = ol(e);
          return u.ak(c / r);
        }
        function Gd(y, e) {
          const r = y.rotate(e.bearingInRadians), c = e.zoom + pn(e.center.lat, 0), f = u.bk(1 / ol(e.center.lat), 1 / ol(Math.min(Math.abs(e.center.lat), 60)), u.bn(c, 7, 3, 0, 1)), _ = 360 / vo({ worldSize: e.worldSize, center: { lat: e.center.lat } });
          return new u.S(e.center.lng - r.x * _ * f, u.ah(e.center.lat + r.y * _, -u.ai, u.ai));
        }
        function Bu(y) {
          const e = 0.5 * y, r = Math.sin(e), c = Math.cos(e);
          return Math.log(r + c) - Math.log(c - r);
        }
        function Ph(y, e, r, c) {
          const f = y.lat + r * c;
          if (Math.abs(r) > 1) {
            const _ = (Math.sign(y.lat + r) !== Math.sign(y.lat) ? -Math.abs(y.lat) : Math.abs(y.lat)) * Math.PI / 180, w = Math.abs(y.lat + r) * Math.PI / 180, C = Bu(_ + c * (w - _)), P = Bu(_), R = Bu(w);
            return new u.S(y.lng + e * ((C - P) / (R - P)), f);
          }
          return new u.S(y.lng + e * c, f);
        }
        class af {
          constructor(e) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._boundingVolumeFactory = e;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1;
          }
          getTileBoundingVolume(e, r, c, f) {
            const _ = `${e.z}_${e.x}_${e.y}_${f?.terrain ? "t" : ""}`, w = this._cache.get(_);
            if (w) return w;
            const C = this._cachePrevious.get(_);
            if (C) return this._cache.set(_, C), C;
            const P = this._boundingVolumeFactory(e, r, c, f);
            return this._cache.set(_, P), this._hadAnyChanges = !0, P;
          }
        }
        class Xl {
          constructor(e, r, c, f) {
            this.min = c, this.max = f, this.points = e, this.planes = r;
          }
          static fromAabb(e, r) {
            const c = [];
            for (let f = 0; f < 8; f++) c.push([1 & ~f ? e[0] : r[0], (f >> 1 & 1) == 1 ? r[1] : e[1], (f >> 2 & 1) == 1 ? r[2] : e[2]]);
            return new Xl(c, [[-1, 0, 0, r[0]], [1, 0, 0, -e[0]], [0, -1, 0, r[1]], [0, 1, 0, -e[1]], [0, 0, -1, r[2]], [0, 0, 1, -e[2]]], e, r);
          }
          static fromCenterSizeAngles(e, r, c) {
            const f = u.br([], c[0], c[1], c[2]), _ = u.bs([], [r[0], 0, 0], f), w = u.bs([], [0, r[1], 0], f), C = u.bs([], [0, 0, r[2]], f), P = [...e], R = [...e];
            for (let j = 0; j < 8; j++) for (let B = 0; B < 3; B++) {
              const V = e[B] + _[B] * (1 & ~j ? -1 : 1) + w[B] * ((j >> 1 & 1) == 1 ? 1 : -1) + C[B] * ((j >> 2 & 1) == 1 ? 1 : -1);
              P[B] = Math.min(P[B], V), R[B] = Math.max(R[B], V);
            }
            const L = [];
            for (let j = 0; j < 8; j++) {
              const B = [...e];
              u.aS(B, B, u.aR([], _, 1 & ~j ? -1 : 1)), u.aS(B, B, u.aR([], w, (j >> 1 & 1) == 1 ? 1 : -1)), u.aS(B, B, u.aR([], C, (j >> 2 & 1) == 1 ? 1 : -1)), L.push(B);
            }
            return new Xl(L, [[..._, -u.aX(_, L[0])], [...w, -u.aX(w, L[0])], [...C, -u.aX(C, L[0])], [-_[0], -_[1], -_[2], -u.aX(_, L[7])], [-w[0], -w[1], -w[2], -u.aX(w, L[7])], [-C[0], -C[1], -C[2], -u.aX(C, L[7])]], P, R);
          }
          intersectsFrustum(e) {
            let r = !0;
            const c = this.points.length, f = this.planes.length, _ = e.planes.length, w = e.points.length;
            for (let C = 0; C < _; C++) {
              const P = e.planes[C];
              let R = 0;
              for (let L = 0; L < c; L++) {
                const j = this.points[L];
                P[0] * j[0] + P[1] * j[1] + P[2] * j[2] + P[3] >= 0 && R++;
              }
              if (R === 0) return 0;
              R < c && (r = !1);
            }
            if (r) return 2;
            for (let C = 0; C < f; C++) {
              const P = this.planes[C];
              let R = 0;
              for (let L = 0; L < w; L++) {
                const j = e.points[L];
                P[0] * j[0] + P[1] * j[1] + P[2] * j[2] + P[3] >= 0 && R++;
              }
              if (R === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(e) {
            const r = this.points.length;
            let c = 0;
            for (let f = 0; f < r; f++) {
              const _ = this.points[f];
              e[0] * _[0] + e[1] * _[1] + e[2] * _[2] + e[3] >= 0 && c++;
            }
            return c === r ? 2 : c === 0 ? 0 : 1;
          }
        }
        function ca(y, e, r) {
          const c = y - e;
          return c < 0 ? -c : Math.max(0, c - r);
        }
        function Nu(y, e, r, c, f) {
          const _ = y - r;
          let w;
          return w = _ < 0 ? Math.min(-_, 1 + _ - f) : _ > 1 ? Math.min(Math.max(_ - f, 0), 1 - _) : 0, Math.max(w, ca(e, c, f));
        }
        class ps {
          constructor() {
            this._boundingVolumeCache = new af(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(e, r, c, f) {
            const _ = 1 << c.z, w = 1 / _, C = c.x / _, P = c.y / _;
            let R = 2;
            return R = Math.min(R, Nu(e, r, C, P, w)), R = Math.min(R, Nu(e, r, C + 0.5, -P - w, w)), R = Math.min(R, Nu(e, r, C + 0.5, 2 - P - w, w)), R;
          }
          getWrap(e, r, c) {
            const f = 1 << r.z, _ = 1 / f, w = r.x / f, C = ca(e.x, w, _), P = ca(e.x, w - 1, _), R = ca(e.x, w + 1, _), L = Math.min(C, P, R);
            return L === R ? 1 : L === P ? -1 : 0;
          }
          allowVariableZoom(e, r) {
            return Mt(e, r) > 4;
          }
          allowWorldCopies() {
            return !1;
          }
          getTileBoundingVolume(e, r, c, f) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, r, c, f);
          }
          _computeTileBoundingVolume(e, r, c, f) {
            var _, w;
            let C = 0, P = 0;
            if (f?.terrain) {
              const R = new u.Z(e.z, r, e.z, e.x, e.y), L = f.terrain.getMinMaxElevation(R);
              C = (_ = L.minElevation) !== null && _ !== void 0 ? _ : Math.min(0, c), P = (w = L.maxElevation) !== null && w !== void 0 ? w : Math.max(0, c);
            }
            if (C /= u.bu, P /= u.bu, C += 1, P += 1, e.z <= 0) return Xl.fromAabb([-P, -P, -P], [P, P, P]);
            if (e.z === 1) return Xl.fromAabb([e.x === 0 ? -P : 0, e.y === 0 ? 0 : -P, -P], [e.x === 0 ? 0 : P, e.y === 0 ? P : 0, P]);
            {
              const R = [Qa(0, 0, e.x, e.y, e.z), Qa(u.$, 0, e.x, e.y, e.z), Qa(u.$, u.$, e.x, e.y, e.z), Qa(0, u.$, e.x, e.y, e.z)], L = [];
              for (const Pe of R) L.push(u.aR([], Pe, P));
              if (P !== C) for (const Pe of R) L.push(u.aR([], Pe, C));
              e.y === 0 && L.push([0, 1, 0]), e.y === (1 << e.z) - 1 && L.push([0, -1, 0]);
              const j = [1, 1, 1], B = [-1, -1, -1];
              for (const Pe of L) for (let Le = 0; Le < 3; Le++) j[Le] = Math.min(j[Le], Pe[Le]), B[Le] = Math.max(B[Le], Pe[Le]);
              const V = Qa(u.$ / 2, u.$ / 2, e.x, e.y, e.z), $ = u.aW([], [0, 1, 0], V);
              u.aV($, $);
              const ie = u.aW([], V, $);
              u.aV(ie, ie);
              const te = u.aW([], R[2], R[1]);
              u.aV(te, te);
              const ne = u.aW([], R[0], R[3]);
              u.aV(ne, ne), L.push(u.aR([], V, P)), e.y >= (1 << e.z) / 2 && L.push(u.aR([], Qa(u.$ / 2, 0, e.x, e.y, e.z), P)), e.y < (1 << e.z) / 2 && L.push(u.aR([], Qa(u.$ / 2, u.$, e.x, e.y, e.z), P));
              const re = ju(V, L), ce = ju(ie, L), oe = [-V[0], -V[1], -V[2], re.max], pe = [V[0], V[1], V[2], -re.min], ye = [-ie[0], -ie[1], -ie[2], ce.max], ue = [ie[0], ie[1], ie[2], -ce.min], we = [...te, 0], Oe = [...ne, 0], ze = [];
              return e.y === 0 ? ze.push(u.bt(Oe, we, oe), u.bt(Oe, we, pe)) : ze.push(u.bt(ye, we, oe), u.bt(ye, we, pe), u.bt(ye, Oe, oe), u.bt(ye, Oe, pe)), e.y === (1 << e.z) - 1 ? ze.push(u.bt(Oe, we, oe), u.bt(Oe, we, pe)) : ze.push(u.bt(ue, we, oe), u.bt(ue, we, pe), u.bt(ue, Oe, oe), u.bt(ue, Oe, pe)), new Xl(ze, [oe, pe, ye, ue, we, Oe], j, B);
            }
          }
        }
        function ju(y, e) {
          let r = 1 / 0, c = -1 / 0;
          for (const f of e) {
            const _ = u.aX(y, f);
            r = Math.min(r, _), c = Math.max(c, _);
          }
          return { min: r, max: c };
        }
        class Uu {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, r, c) {
            return this._helper.interpolatePadding(e, r, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, r) {
            this._helper.resize(e, r);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, r) {
            this._helper.overrideNearFarZ(e, r);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e) {
          }
          constructor() {
            this._cachedClippingPlane = u.bv(), this._projectionMatrix = u.b9(), this._globeViewProjMatrix32f = u.b8(), this._globeViewProjMatrixNoCorrection = u.b9(), this._globeViewProjMatrixNoCorrectionInverted = u.b9(), this._globeProjMatrixInverted = u.b9(), this._cameraPosition = u.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new ga({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, r) => this.getConstrained(e, r) }), this._coveringTilesDetailsProvider = new ps();
          }
          clone() {
            const e = new Uu();
            return e.apply(this), e;
          }
          apply(e, r) {
            this._globeLatitudeErrorCorrectionRadians = r || 0, this._helper.apply(e);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const e = u.bp();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(e) {
            const { overscaledTileID: r, applyGlobeMatrix: c } = e, f = this._helper.getMercatorTileCoordinates(r);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: f, clippingPlane: this._cachedClippingPlane, projectionTransition: c ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(e) {
            const r = this.pitchInRadians, c = this.cameraToCenterDistance / e, f = Math.sin(r) * c, _ = Math.cos(r) * c + 1, w = 1 / Math.sqrt(f * f + _ * _) * 1;
            let C = -f, P = _;
            const R = Math.sqrt(C * C + P * P);
            C /= R, P /= R;
            const L = [0, C, P];
            u.bw(L, L, [0, 0, 0], -this.bearingInRadians), u.bx(L, L, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), u.by(L, L, [0, 0, 0], this.center.lng * Math.PI / 180);
            const j = 1 / u.aZ(L);
            return u.aR(L, L, j), [...L, -w * j];
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(Jn(e));
          }
          transformLightDirection(e) {
            const r = this._helper._center.lng * Math.PI / 180, c = this._helper._center.lat * Math.PI / 180, f = Math.cos(c), _ = [Math.sin(r) * f, Math.sin(c), Math.cos(r) * f], w = [_[2], 0, -_[0]], C = [0, 0, 0];
            u.aW(C, w, _), u.aV(w, w), u.aV(C, C);
            const P = [0, 0, 0];
            return u.aV(P, [w[0] * e[0] + C[0] * e[1] + _[0] * e[2], w[1] * e[0] + C[1] * e[1] + _[1] * e[2], w[2] * e[0] + C[2] * e[1] + _[2] * e[2]]), P;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(e, r, c) {
            const f = (function(C, P, R) {
              const L = 1 / (1 << R.z);
              return new u.a1(C / u.$ * L + R.x * L, P / u.$ * L + R.y * L);
            })(e, r, c.canonical), _ = (w = f.y, [u.bo(f.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - w * Math.PI * 2)) - 0.5 * Math.PI]);
            var w;
            return this.getCircleRadiusCorrection() / Math.cos(_[1]);
          }
          projectTileCoordinates(e, r, c, f) {
            const _ = c.canonical, w = Qa(e, r, _.x, _.y, _.z), C = 1 + (f ? f(e, r) : 0) / u.bu, P = [w[0] * C, w[1] * C, w[2] * C, 1];
            u.aw(P, P, this._globeViewProjMatrixNoCorrection);
            const R = this._cachedClippingPlane, L = R[0] * w[0] + R[1] * w[1] + R[2] * w[2] + R[3] < 0;
            return { point: new u.P(P[0] / P[3], P[1] / P[3]), signedDistanceFromCamera: P[3], isOccluded: L };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = Hl(this.worldSize, this.center.lat), r = u.ba(), c = u.ba();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), u.b4(r, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const f = this.centerOffset;
            r[8] = 2 * -f.x / this._helper._width, r[9] = 2 * f.y / this._helper._height, this._projectionMatrix = u.b5(r), this._globeProjMatrixInverted = u.ba(), u.aq(this._globeProjMatrixInverted, r), u.M(r, r, [0, 0, -this.cameraToCenterDistance]), u.b6(r, r, this.rollInRadians), u.b7(r, r, -this.pitchInRadians), u.b6(r, r, this.bearingInRadians), u.M(r, r, [0, 0, -e]);
            const _ = u.bp();
            _[0] = e, _[1] = e, _[2] = e, u.b7(c, r, this.center.lat * Math.PI / 180), u.bz(c, c, -this.center.lng * Math.PI / 180), u.N(c, c, _), this._globeViewProjMatrixNoCorrection = c, u.b7(r, r, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), u.bz(r, r, -this.center.lng * Math.PI / 180), u.N(r, r, _), this._globeViewProjMatrix32f = new Float32Array(r), this._globeViewProjMatrixNoCorrectionInverted = u.ba(), u.aq(this._globeViewProjMatrixNoCorrectionInverted, c);
            const w = u.bp();
            this._cameraPosition = u.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / e, u.bw(this._cameraPosition, this._cameraPosition, w, -this.rollInRadians), u.bx(this._cameraPosition, this._cameraPosition, w, this.pitchInRadians), u.bw(this._cameraPosition, this._cameraPosition, w, -this.bearingInRadians), u.aS(this._cameraPosition, this._cameraPosition, [0, 0, 1]), u.bx(this._cameraPosition, this._cameraPosition, w, -this.center.lat * Math.PI / 180), u.by(this._cameraPosition, this._cameraPosition, w, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const C = u.b5(this._globeViewProjMatrixNoCorrectionInverted);
            u.N(C, C, [1, 1, -1]), this._cachedFrustum = Dn.fromInvProjectionMatrix(C, 1, 0, this._cachedClippingPlane, !0);
          }
          calculateFogMatrix(e) {
            u.w("calculateFogMatrix is not supported on globe projection.");
            const r = u.ba();
            return u.ag(r), r;
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new u.b2(0, e)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            e && u.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, r) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const c = Jn(e);
            u.aR(c, c, 1 + r / u.bu);
            const f = u.bv();
            return u.aw(f, [c[0], c[1], c[2], 1], this._globeViewProjMatrixNoCorrection), f[2] / f[3];
          }
          populateCache(e) {
          }
          getBounds() {
            const e = 0.5 * this.width, r = 0.5 * this.height, c = [new u.P(0, 0), new u.P(e, 0), new u.P(this.width, 0), new u.P(this.width, r), new u.P(this.width, this.height), new u.P(e, this.height), new u.P(0, this.height), new u.P(0, r)], f = [];
            for (const j of c) f.push(this.unprojectScreenPoint(j));
            let _ = 0, w = 0, C = 0, P = 0;
            const R = this.center;
            for (const j of f) {
              const B = u.bA(R.lng, j.lng), V = u.bA(R.lat, j.lat);
              B < w && (w = B), B > _ && (_ = B), V < P && (P = V), V > C && (C = V);
            }
            const L = [R.lng + w, R.lat + P, R.lng + _, R.lat + C];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (L[3] = 90, L[0] = -180, L[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (L[1] = -90, L[0] = -180, L[2] = 180), new an(L);
          }
          getConstrained(e, r) {
            const c = u.ah(e.lat, -u.ai, u.ai), f = u.ah(+r, this.minZoom + pn(0, c), this.maxZoom);
            return { center: new u.S(e.lng, c), zoom: f };
          }
          calculateCenterFromCameraLngLatAlt(e, r, c, f) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, r, c, f);
          }
          setLocationAtPoint(e, r) {
            const c = Jn(this.unprojectScreenPoint(r)), f = Jn(e), _ = u.bp();
            u.bB(_);
            const w = u.bp();
            u.by(w, c, _, -this.center.lng * Math.PI / 180), u.bx(w, w, _, this.center.lat * Math.PI / 180);
            const C = f[0] * f[0] + f[2] * f[2], P = w[0] * w[0];
            if (C < P) return;
            const R = Math.sqrt(C - P), L = -R, j = u.bC(f[0], f[2], w[0], R), B = u.bC(f[0], f[2], w[0], L), V = u.bp();
            u.by(V, f, _, -j);
            const $ = u.bC(V[1], V[2], w[1], w[2]), ie = u.bp();
            u.by(ie, f, _, -B);
            const te = u.bC(ie[1], ie[2], w[1], w[2]), ne = 0.5 * Math.PI, re = $ >= -ne && $ <= ne, ce = te >= -ne && te <= ne;
            let oe, pe;
            if (re && ce) {
              const Oe = this.center.lng * Math.PI / 180, ze = this.center.lat * Math.PI / 180;
              u.bD(j, Oe) + u.bD($, ze) < u.bD(B, Oe) + u.bD(te, ze) ? (oe = j, pe = $) : (oe = B, pe = te);
            } else if (re) oe = j, pe = $;
            else {
              if (!ce) return;
              oe = B, pe = te;
            }
            const ye = oe / Math.PI * 180, ue = pe / Math.PI * 180, we = this.center.lat;
            this.setCenter(new u.S(ye, u.ah(ue, -90, 90))), this.setZoom(this.zoom + pn(we, this.center.lat));
          }
          locationToScreenPoint(e, r) {
            const c = Jn(e);
            if (r) {
              const f = r.getElevationForLngLatZoom(e, this._helper._tileZoom);
              u.aR(c, c, 1 + f / u.bu);
            }
            return this._projectSurfacePointToScreen(c);
          }
          _projectSurfacePointToScreen(e) {
            const r = u.bv();
            return u.aw(r, [...e, 1], this._globeViewProjMatrixNoCorrection), r[0] /= r[3], r[1] /= r[3], new u.P((0.5 * r[0] + 0.5) * this.width, (0.5 * -r[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(e, r) {
            if (r) {
              const c = r.pointCoordinate(e);
              if (c) return c;
            }
            return u.a1.fromLngLat(this.unprojectScreenPoint(e));
          }
          screenPointToLocation(e, r) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, r)) === null || c === void 0 ? void 0 : c.toLngLat();
          }
          isPointOnMapSurface(e, r) {
            const c = this._cameraPosition, f = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(c, f);
          }
          getRayDirectionFromPixel(e) {
            const r = u.bv();
            r[0] = e.x / this.width * 2 - 1, r[1] = -1 * (e.y / this.height * 2 - 1), r[2] = 1, r[3] = 1, u.aw(r, r, this._globeViewProjMatrixNoCorrectionInverted), r[0] /= r[3], r[1] /= r[3], r[2] /= r[3];
            const c = u.bp();
            c[0] = r[0] - this._cameraPosition[0], c[1] = r[1] - this._cameraPosition[1], c[2] = r[2] - this._cameraPosition[2];
            const f = u.bp();
            return u.aV(f, c), f;
          }
          isSurfacePointVisible(e) {
            const r = this._cachedClippingPlane;
            return r[0] * e[0] + r[1] * e[1] + r[2] * e[2] + r[3] >= 0;
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const r = u.bv();
            return u.aw(r, [...e, 1], this._globeViewProjMatrixNoCorrection), r[0] /= r[3], r[1] /= r[3], r[2] /= r[3], r[0] > -1 && r[0] < 1 && r[1] > -1 && r[1] < 1 && r[2] > -1 && r[2] < 1;
          }
          rayPlanetIntersection(e, r) {
            const c = u.aX(e, r), f = u.bp(), _ = u.bp();
            u.aR(_, r, c), u.aU(f, e, _);
            const w = 1 - u.aX(f, f);
            if (w < 0) return null;
            const C = u.aX(e, e) - 1, P = -c + (c < 0 ? 1 : -1) * Math.sqrt(w), R = C / P, L = P;
            return { tMin: Math.min(R, L), tMax: Math.max(R, L) };
          }
          unprojectScreenPoint(e) {
            const r = this._cameraPosition, c = this.getRayDirectionFromPixel(e), f = this.rayPlanetIntersection(r, c);
            if (f) {
              const L = u.bp();
              u.aS(L, r, [c[0] * f.tMin, c[1] * f.tMin, c[2] * f.tMin]);
              const j = u.bp();
              return u.aV(j, L), Ou(j);
            }
            const _ = this._cachedClippingPlane, w = _[0] * c[0] + _[1] * c[1] + _[2] * c[2], C = -u.b1(_, r) / w, P = u.bp();
            if (C > 0) u.aS(P, r, [c[0] * C, c[1] * C, c[2] * C]);
            else {
              const L = u.bp();
              u.aS(L, r, [2 * c[0], 2 * c[1], 2 * c[2]]);
              const j = u.b1(this._cachedClippingPlane, L);
              u.aU(P, L, [this._cachedClippingPlane[0] * j, this._cachedClippingPlane[1] * j, this._cachedClippingPlane[2] * j]);
            }
            const R = (function(L) {
              const j = u.bp();
              return j[0] = L[0] * -L[3], j[1] = L[1] * -L[3], j[2] = L[2] * -L[3], { center: j, radius: Math.sqrt(1 - L[3] * L[3]) };
            })(_);
            return Ou((function(L, j, B) {
              const V = u.bp();
              u.aU(V, B, L);
              const $ = u.bp();
              return u.bq($, L, V, j / u.a$(V)), $;
            })(R.center, R.radius, P));
          }
          getMatrixForModel(e, r) {
            const c = u.S.convert(e), f = 1 / u.bu, _ = u.b9();
            return u.bz(_, _, c.lng / 180 * Math.PI), u.b7(_, _, -c.lat / 180 * Math.PI), u.M(_, _, [0, 0, 1 + r / u.bu]), u.b7(_, _, 0.5 * Math.PI), u.N(_, _, [f, f, f]), _;
          }
          getProjectionDataForCustomLayer(e = !0) {
            const r = this.getProjectionData({ overscaledTileID: new u.Z(0, 0, 0, 0, 0), applyGlobeMatrix: e });
            return r.tileMercatorCoords = [0, 0, 1, 1], r;
          }
          getFastPathSimpleProjectionMatrix(e) {
          }
        }
        class ll {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, r, c) {
            return this._helper.interpolatePadding(e, r, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, r, c = !0) {
            this._helper.resize(e, r, c);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, r) {
            this._helper.overrideNearFarZ(e, r);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(e, r) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = r, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new ga({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, r) => this.getConstrained(e, r) }), this._globeness = 1, this._mercatorTransform = new Ui(), this._verticalPerspectiveTransform = new Uu();
          }
          clone() {
            const e = new ll();
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e;
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(e) {
            const r = this._mercatorTransform.getProjectionData(e), c = this._verticalPerspectiveTransform.getProjectionData(e);
            return { mainMatrix: this.isGlobeRendering ? c.mainMatrix : r.mainMatrix, clippingPlane: c.clippingPlane, tileMercatorCoords: c.tileMercatorCoords, projectionTransition: e.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: r.fallbackMatrix };
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e);
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e);
          }
          getPixelScale() {
            return u.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return u.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(e, r, c) {
            const f = this._mercatorTransform.getPitchedTextCorrection(e, r, c), _ = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, r, c);
            return u.bk(f, _, this._globeness);
          }
          projectTileCoordinates(e, r, c, f) {
            return this.currentTransform.projectTileCoordinates(e, r, c, f);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e);
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, r) {
            return this.currentTransform.lngLatToCameraDepth(e, r);
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          getConstrained(e, r) {
            return this.currentTransform.getConstrained(e, r);
          }
          calculateCenterFromCameraLngLatAlt(e, r, c, f) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, r, c, f);
          }
          setLocationAtPoint(e, r) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, r), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, r), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(e, r) {
            return this.currentTransform.locationToScreenPoint(e, r);
          }
          screenPointToMercatorCoordinate(e, r) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, r);
          }
          screenPointToLocation(e, r) {
            return this.currentTransform.screenPointToLocation(e, r);
          }
          isPointOnMapSurface(e, r) {
            return this.currentTransform.isPointOnMapSurface(e, r);
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e);
          }
          getMatrixForModel(e, r) {
            return this.currentTransform.getMatrixForModel(e, r);
          }
          getProjectionDataForCustomLayer(e = !0) {
            const r = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return r;
            const c = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return c.fallbackMatrix = r.mainMatrix, c;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e);
          }
        }
        class Ea {
          get useGlobeControls() {
            return !0;
          }
          handlePanInertia(e, r) {
            const c = Gd(e, r);
            return Math.abs(c.lng - r.center.lng) > 180 && (c.lng = r.center.lng + 179.5 * Math.sign(c.lng - r.center.lng)), { easingCenter: c, easingOffset: new u.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(e, r) {
            const c = e.around, f = r.screenPointToLocation(c);
            e.bearingDelta && r.setBearing(r.bearing + e.bearingDelta), e.pitchDelta && r.setPitch(r.pitch + e.pitchDelta), e.rollDelta && r.setRoll(r.roll + e.rollDelta);
            const _ = r.zoom;
            e.zoomDelta && r.setZoom(r.zoom + e.zoomDelta);
            const w = r.zoom - _;
            if (w === 0) return;
            const C = u.bA(r.center.lng, f.lng), P = C / (Math.abs(C / 180) + 1), R = u.bA(r.center.lat, f.lat), L = r.getRayDirectionFromPixel(c), j = r.cameraPosition, B = -1 * u.aX(j, L), V = u.bp();
            u.aS(V, j, [L[0] * B, L[1] * B, L[2] * B]);
            const $ = u.aZ(V) - 1, ie = Math.exp(0.5 * -Math.max($ - 0.3, 0)), te = Hl(r.worldSize, r.center.lat) / Math.min(r.width, r.height), ne = u.bn(te, 0.9, 0.5, 1, 0.25), re = (1 - u.af(-w)) * Math.min(ie, ne), ce = r.center.lat, oe = r.zoom, pe = new u.S(r.center.lng + P * re, u.ah(r.center.lat + R * re, -u.ai, u.ai));
            r.setLocationAtPoint(f, c);
            const ye = r.center, ue = u.bn(Math.abs(C), 45, 85, 0, 1), we = u.bn(te, 0.75, 0.35, 0, 1), Oe = Math.pow(Math.max(ue, we), 0.25), ze = u.bA(ye.lng, pe.lng), Pe = u.bA(ye.lat, pe.lat);
            r.setCenter(new u.S(ye.lng + ze * Oe, ye.lat + Pe * Oe).wrap()), r.setZoom(oe + pn(ce, r.center.lat));
          }
          handleMapControlsPan(e, r, c) {
            if (!e.panDelta) return;
            const f = r.center.lat, _ = r.zoom;
            r.setCenter(Gd(e.panDelta, r).wrap()), r.setZoom(_ + pn(f, r.center.lat));
          }
          cameraForBoxAndBearing(e, r, c, f, _) {
            const w = Ln(e, r, c, f, _), C = r.left / _.width * 2 - 1, P = (_.width - r.right) / _.width * 2 - 1, R = r.top / _.height * -2 + 1, L = (_.height - r.bottom) / _.height * -2 + 1, j = u.bA(c.getWest(), c.getEast()) < 0, B = j ? c.getEast() : c.getWest(), V = j ? c.getWest() : c.getEast(), $ = Math.max(c.getNorth(), c.getSouth()), ie = Math.min(c.getNorth(), c.getSouth()), te = B + 0.5 * u.bA(B, V), ne = $ + 0.5 * u.bA($, ie), re = _.clone();
            re.setCenter(w.center), re.setBearing(w.bearing), re.setPitch(0), re.setRoll(0), re.setZoom(w.zoom);
            const ce = re.modelViewProjectionMatrix, oe = [Jn(c.getNorthWest()), Jn(c.getNorthEast()), Jn(c.getSouthWest()), Jn(c.getSouthEast()), Jn(new u.S(V, ne)), Jn(new u.S(B, ne)), Jn(new u.S(te, $)), Jn(new u.S(te, ie))], pe = Jn(w.center);
            let ye = Number.POSITIVE_INFINITY;
            for (const ue of oe) C < 0 && (ye = Ea.getLesserNonNegativeNonNull(ye, Ea.solveVectorScale(ue, pe, ce, "x", C))), P > 0 && (ye = Ea.getLesserNonNegativeNonNull(ye, Ea.solveVectorScale(ue, pe, ce, "x", P))), R > 0 && (ye = Ea.getLesserNonNegativeNonNull(ye, Ea.solveVectorScale(ue, pe, ce, "y", R))), L < 0 && (ye = Ea.getLesserNonNegativeNonNull(ye, Ea.solveVectorScale(ue, pe, ce, "y", L)));
            if (Number.isFinite(ye) && ye !== 0) return w.zoom = re.zoom + u.ak(ye), w;
            zh();
          }
          handleJumpToCenterZoom(e, r) {
            const c = e.center.lat, f = e.getConstrained(r.center ? u.S.convert(r.center) : e.center, e.zoom).center;
            e.setCenter(f.wrap());
            const _ = r.zoom !== void 0 ? +r.zoom : e.zoom + pn(c, f.lat);
            e.zoom !== _ && e.setZoom(_);
          }
          handleEaseTo(e, r) {
            const c = e.zoom, f = e.center, _ = e.padding, w = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, C = { roll: r.roll === void 0 ? e.roll : r.roll, pitch: r.pitch === void 0 ? e.pitch : r.pitch, bearing: r.bearing === void 0 ? e.bearing : r.bearing }, P = r.zoom !== void 0, R = !e.isPaddingEqual(r.padding);
            let L = !1;
            const j = r.center ? u.S.convert(r.center) : f, B = e.getConstrained(j, c).center;
            Rr(e, B);
            const V = e.clone();
            V.setCenter(B), V.setZoom(P ? +r.zoom : c + pn(f.lat, j.lat)), V.setBearing(r.bearing);
            const $ = new u.P(u.ah(e.centerPoint.x + r.offsetAsPoint.x, 0, e.width), u.ah(e.centerPoint.y + r.offsetAsPoint.y, 0, e.height));
            V.setLocationAtPoint(B, $);
            const ie = (r.offset && r.offsetAsPoint.mag()) > 0 ? V.center : B, te = P ? +r.zoom : c + pn(f.lat, ie.lat), ne = c + pn(f.lat, 0), re = te + pn(ie.lat, 0), ce = u.bA(f.lng, ie.lng), oe = u.bA(f.lat, ie.lat), pe = u.af(re - ne);
            return L = te !== c, { easeFunc: (ye) => {
              if (u.be(w, C) || Wn({ startEulerAngles: w, endEulerAngles: C, tr: e, k: ye, useSlerp: w.roll != C.roll }), R && e.interpolatePadding(_, r.padding, ye), r.around) u.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(r.around, r.aroundPoint);
              else {
                const ue = re > ne ? Math.min(2, pe) : Math.max(0.5, pe), we = Math.pow(ue, 1 - ye), Oe = Ph(f, ce, oe, ye * we);
                e.setCenter(Oe.wrap());
              }
              if (L) {
                const ue = u.C.number(ne, re, ye) + pn(0, e.center.lat);
                e.setZoom(ue);
              }
            }, isZooming: L, elevationCenter: ie };
          }
          handleFlyTo(e, r) {
            const c = r.zoom !== void 0, f = e.center, _ = e.zoom, w = e.padding, C = !e.isPaddingEqual(r.padding), P = e.getConstrained(u.S.convert(r.center || r.locationAtOffset), _).center, R = c ? +r.zoom : e.zoom + pn(e.center.lat, P.lat), L = e.clone();
            L.setCenter(P), L.setZoom(R), L.setBearing(r.bearing);
            const j = new u.P(u.ah(e.centerPoint.x + r.offsetAsPoint.x, 0, e.width), u.ah(e.centerPoint.y + r.offsetAsPoint.y, 0, e.height));
            L.setLocationAtPoint(P, j);
            const B = L.center;
            Rr(e, B);
            const V = (function(oe, pe, ye) {
              const ue = Jn(pe), we = Jn(ye), Oe = u.aX(ue, we), ze = Math.acos(Oe), Pe = vo(oe);
              return ze / (2 * Math.PI) * Pe;
            })(e, f, B), $ = _ + pn(f.lat, 0), ie = R + pn(B.lat, 0), te = u.af(ie - $);
            let ne;
            if (typeof r.minZoom == "number") {
              const oe = +r.minZoom + pn(B.lat, 0), pe = Math.min(oe, $, ie) + pn(0, B.lat), ye = e.getConstrained(B, pe).zoom + pn(B.lat, 0);
              ne = u.af(ye - $);
            }
            const re = u.bA(f.lng, B.lng), ce = u.bA(f.lat, B.lat);
            return { easeFunc: (oe, pe, ye, ue) => {
              const we = Ph(f, re, ce, ye);
              C && e.interpolatePadding(w, r.padding, oe);
              const Oe = oe === 1 ? B : we;
              e.setCenter(Oe.wrap());
              const ze = $ + u.ak(pe);
              e.setZoom(oe === 1 ? R : ze + pn(0, Oe.lat));
            }, scaleOfZoom: te, targetCenter: B, scaleOfMinZoom: ne, pixelPathLength: V };
          }
          static solveVectorScale(e, r, c, f, _) {
            const w = f === "x" ? [c[0], c[4], c[8], c[12]] : [c[1], c[5], c[9], c[13]], C = [c[3], c[7], c[11], c[15]], P = e[0] * w[0] + e[1] * w[1] + e[2] * w[2], R = e[0] * C[0] + e[1] * C[1] + e[2] * C[2], L = r[0] * w[0] + r[1] * w[1] + r[2] * w[2], j = r[0] * C[0] + r[1] * C[1] + r[2] * C[2];
            return L + _ * R === P + _ * j || C[3] * (P - L) + w[3] * (j - R) + P * j == L * R ? null : (L + w[3] - _ * j - _ * C[3]) / (L - P - _ * j + _ * R);
          }
          static getLesserNonNegativeNonNull(e, r) {
            return r !== null && r >= 0 && r < e ? r : e;
          }
        }
        class Zd {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new ua(), this._verticalPerspectiveCameraHelper = new Ea();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(e, r) {
            return this.currentHelper.handlePanInertia(e, r);
          }
          handleMapControlsRollPitchBearingZoom(e, r) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, r);
          }
          handleMapControlsPan(e, r, c) {
            this.currentHelper.handleMapControlsPan(e, r, c);
          }
          cameraForBoxAndBearing(e, r, c, f, _) {
            return this.currentHelper.cameraForBoxAndBearing(e, r, c, f, _);
          }
          handleJumpToCenterZoom(e, r) {
            this.currentHelper.handleJumpToCenterZoom(e, r);
          }
          handleEaseTo(e, r) {
            return this.currentHelper.handleEaseTo(e, r);
          }
          handleFlyTo(e, r) {
            return this.currentHelper.handleFlyTo(e, r);
          }
        }
        const Lc = (y, e) => u.y(y, e && e.filter(((r) => r.identifier !== "source.canvas"))), $d = u.bE();
        class Ih extends u.E {
          constructor(e, r = {}) {
            super(), this._rtlPluginLoaded = () => {
              for (const c in this.sourceCaches) {
                const f = this.sourceCaches[c].getSource().type;
                f !== "vector" && f !== "geojson" || this.sourceCaches[c].reload();
              }
            }, this.map = e, this.dispatcher = new Vt(Pt(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((c, f) => this.getGlyphs(c, f))), this.dispatcher.registerMessageHandler("GI", ((c, f) => this.getImages(c, f))), this.imageManager = new Ht(), this.imageManager.setEventedParent(this), this.glyphManager = new vn(e._requestManager, r.localIdeographFontFamily), this.lineAtlas = new at(256, 512), this.crossTileSymbolIndex = new rl(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new u.bF(), this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", u.bG()), Ns().on(Yn, this._rtlPluginLoaded), this.on("data", ((c) => {
              if (c.dataType !== "source" || c.sourceDataType !== "metadata") return;
              const f = this.sourceCaches[c.sourceId];
              if (!f) return;
              const _ = f.getSource();
              if (_ && _.vectorLayerIds) for (const w in this._layers) {
                const C = this._layers[w];
                C.source === _.id && this._validateLayer(C);
              }
            }));
          }
          setGlobalStateProperty(e, r) {
            var c, f, _;
            this._checkLoaded();
            const w = r === null ? (_ = (f = (c = this.stylesheet.state) === null || c === void 0 ? void 0 : c[e]) === null || f === void 0 ? void 0 : f.default) !== null && _ !== void 0 ? _ : null : r;
            if (u.bH(w, this._globalState[e])) return this;
            this._globalState[e] = w;
            const C = this._findGlobalStateAffectedSources([e]);
            for (const P in this.sourceCaches) C.has(P) && (this._reloadSource(P), this._changed = !0);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(e) {
            this._checkLoaded();
            const r = [];
            for (const f in e) !u.bH(this._globalState[f], e[f].default) && (r.push(f), this._globalState[f] = e[f].default);
            const c = this._findGlobalStateAffectedSources(r);
            for (const f in this.sourceCaches) c.has(f) && (this._reloadSource(f), this._changed = !0);
          }
          _findGlobalStateAffectedSources(e) {
            if (e.length === 0) return /* @__PURE__ */ new Set();
            const r = /* @__PURE__ */ new Set();
            for (const c in this._layers) {
              const f = this._layers[c], _ = f.getLayoutAffectingGlobalStateRefs();
              for (const w of e) _.has(w) && r.add(f.source);
            }
            return r;
          }
          loadURL(e, r = {}, c) {
            this.fire(new u.l("dataloading", { dataType: "style" })), r.validate = typeof r.validate != "boolean" || r.validate;
            const f = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController();
            const _ = this._loadStyleRequest;
            u.j(f, this._loadStyleRequest).then(((w) => {
              this._loadStyleRequest = null, this._load(w.data, r, c);
            })).catch(((w) => {
              this._loadStyleRequest = null, w && !_.signal.aborted && this.fire(new u.k(w));
            }));
          }
          loadJSON(e, r = {}, c) {
            this.fire(new u.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), he.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, r.validate = r.validate !== !1, this._load(e, r, c);
            })).catch((() => {
            }));
          }
          loadEmpty() {
            this.fire(new u.l("dataloading", { dataType: "style" })), this._load($d, { validate: !1 });
          }
          _load(e, r, c) {
            var f, _, w;
            const C = r.transformStyle ? r.transformStyle(c, e) : e;
            if (!r.validate || !Lc(this, u.z(C))) {
              this._loaded = !0, this.stylesheet = C;
              for (const P in C.sources) this.addSource(P, C.sources[P], { validate: !1 });
              C.sprite ? this._loadSprite(C.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(C.glyphs), this._createLayers(), this.light = new He(this.stylesheet.light), this._setProjectionInternal(((f = this.stylesheet.projection) === null || f === void 0 ? void 0 : f.type) || "mercator"), this.sky = new Gt(this.stylesheet.sky), this.map.setTerrain((_ = this.stylesheet.terrain) !== null && _ !== void 0 ? _ : null), this.setGlobalState((w = this.stylesheet.state) !== null && w !== void 0 ? w : null), this.fire(new u.l("data", { dataType: "style" })), this.fire(new u.l("style.load"));
            }
          }
          _createLayers() {
            const e = u.bI(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", e), this._order = e.map(((r) => r.id)), this._layers = {}, this._serializedLayers = null;
            for (const r of e) {
              const c = u.bJ(r);
              c.setEventedParent(this, { layer: { id: r.id } }), this._layers[r.id] = c;
            }
          }
          _loadSprite(e, r = !1, c = void 0) {
            let f;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), (function(_, w, C, P) {
              return u._(this, void 0, void 0, (function* () {
                const R = $e(_), L = C > 1 ? "@2x" : "", j = {}, B = {};
                for (const { id: V, url: $ } of R) {
                  const ie = w.transformRequest(rt($, L, ".json"), "SpriteJSON");
                  j[V] = u.j(ie, P);
                  const te = w.transformRequest(rt($, L, ".png"), "SpriteImage");
                  B[V] = De.getImage(te, P);
                }
                return yield Promise.all([...Object.values(j), ...Object.values(B)]), (function(V, $) {
                  return u._(this, void 0, void 0, (function* () {
                    const ie = {};
                    for (const te in V) {
                      ie[te] = {};
                      const ne = he.getImageCanvasContext((yield $[te]).data), re = (yield V[te]).data;
                      for (const ce in re) {
                        const { width: oe, height: pe, x: ye, y: ue, sdf: we, pixelRatio: Oe, stretchX: ze, stretchY: Pe, content: Le, textFitWidth: lt, textFitHeight: ct } = re[ce];
                        ie[te][ce] = { data: null, pixelRatio: Oe, sdf: we, stretchX: ze, stretchY: Pe, content: Le, textFitWidth: lt, textFitHeight: ct, spriteData: { width: oe, height: pe, x: ye, y: ue, context: ne } };
                      }
                    }
                    return ie;
                  }));
                })(j, B);
              }));
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((_) => {
              if (this._spriteRequest = null, _) for (const w in _) {
                this._spritesImagesIds[w] = [];
                const C = this._spritesImagesIds[w] ? this._spritesImagesIds[w].filter(((P) => !(P in _))) : [];
                for (const P of C) this.imageManager.removeImage(P), this._changedImages[P] = !0;
                for (const P in _[w]) {
                  const R = w === "default" ? P : `${w}:${P}`;
                  this._spritesImagesIds[w].push(R), R in this.imageManager.images ? this.imageManager.updateImage(R, _[w][P], !1) : this.imageManager.addImage(R, _[w][P]), r && (this._changedImages[R] = !0);
                }
              }
            })).catch(((_) => {
              this._spriteRequest = null, f = _, this.fire(new u.k(f));
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), r && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" })), c && c(f);
            }));
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" }));
          }
          _validateLayer(e) {
            const r = this.sourceCaches[e.source];
            if (!r) return;
            const c = e.sourceLayer;
            if (!c) return;
            const f = r.getSource();
            (f.type === "geojson" || f.vectorLayerIds && f.vectorLayerIds.indexOf(c) === -1) && this.fire(new u.k(new Error(`Source layer "${c}" does not exist on source "${f.id}" as specified by style layer "${e.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(e, r = !1) {
            const c = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(r ? u.bK(c) : c);
            const f = [];
            for (const _ of e) if (c[_]) {
              const w = r ? u.bK(c[_]) : c[_];
              f.push(w);
            }
            return f;
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const r = Object.keys(this._layers);
            for (const c of r) {
              const f = this._layers[c];
              f.type !== "custom" && (e[c] = f.serialize());
            }
            return e;
          }
          hasTransitions() {
            var e, r, c;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((r = this.sky) === null || r === void 0) && r.hasTransition() || !((c = this.projection) === null || c === void 0) && c.hasTransition()) return !0;
            for (const f in this.sourceCaches) if (this.sourceCaches[f].hasTransition()) return !0;
            for (const f in this._layers) if (this._layers[f].hasTransition()) return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e) {
            if (!this._loaded) return;
            const r = this._changed;
            if (r) {
              const f = Object.keys(this._updatedLayers), _ = Object.keys(this._removedLayers);
              (f.length || _.length) && this._updateWorkerLayers(f, _);
              for (const w in this._updatedSources) {
                const C = this._updatedSources[w];
                if (C === "reload") this._reloadSource(w);
                else {
                  if (C !== "clear") throw new Error(`Invalid action ${C}`);
                  this._clearSource(w);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const w in this._updatedPaintProps) this._layers[w].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
            }
            const c = {};
            for (const f in this.sourceCaches) {
              const _ = this.sourceCaches[f];
              c[f] = _.used, _.used = !1;
            }
            for (const f of this._order) {
              const _ = this._layers[f];
              _.recalculate(e, this._availableImages), !_.isHidden(e.zoom) && _.source && (this.sourceCaches[_.source].used = !0);
            }
            for (const f in c) {
              const _ = this.sourceCaches[f];
              !!c[f] != !!_.used && _.fire(new u.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: f }));
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, r && this.fire(new u.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const r in this.sourceCaches) this.sourceCaches[r].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1;
            }
          }
          _updateWorkerLayers(e, r) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, !1), removedIds: r });
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
          }
          setState(e, r = {}) {
            var c;
            this._checkLoaded();
            const f = this.serialize();
            if (e = r.transformStyle ? r.transformStyle(f, e) : e, ((c = r.validate) === null || c === void 0 || c) && Lc(this, u.z(e))) return !1;
            (e = u.bK(e)).layers = u.bI(e.layers);
            const _ = u.bL(f, e), w = this._getOperationsToPerform(_);
            if (w.unimplemented.length > 0) throw new Error(`Unimplemented: ${w.unimplemented.join(", ")}.`);
            if (w.operations.length === 0) return !1;
            for (const C of w.operations) C();
            return this.stylesheet = e, this._serializedLayers = null, !0;
          }
          _getOperationsToPerform(e) {
            const r = [], c = [];
            for (const f of e) switch (f.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                r.push((() => this.addLayer.apply(this, f.args)));
                break;
              case "removeLayer":
                r.push((() => this.removeLayer.apply(this, f.args)));
                break;
              case "setPaintProperty":
                r.push((() => this.setPaintProperty.apply(this, f.args)));
                break;
              case "setLayoutProperty":
                r.push((() => this.setLayoutProperty.apply(this, f.args)));
                break;
              case "setFilter":
                r.push((() => this.setFilter.apply(this, f.args)));
                break;
              case "addSource":
                r.push((() => this.addSource.apply(this, f.args)));
                break;
              case "removeSource":
                r.push((() => this.removeSource.apply(this, f.args)));
                break;
              case "setLayerZoomRange":
                r.push((() => this.setLayerZoomRange.apply(this, f.args)));
                break;
              case "setLight":
                r.push((() => this.setLight.apply(this, f.args)));
                break;
              case "setGeoJSONSourceData":
                r.push((() => this.setGeoJSONSourceData.apply(this, f.args)));
                break;
              case "setGlyphs":
                r.push((() => this.setGlyphs.apply(this, f.args)));
                break;
              case "setSprite":
                r.push((() => this.setSprite.apply(this, f.args)));
                break;
              case "setTerrain":
                r.push((() => this.map.setTerrain.apply(this, f.args)));
                break;
              case "setSky":
                r.push((() => this.setSky.apply(this, f.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, f.args);
                break;
              case "setGlobalState":
                r.push((() => this.setGlobalState.apply(this, f.args)));
                break;
              case "setTransition":
                r.push((() => {
                }));
                break;
              default:
                c.push(f.command);
            }
            return { operations: r, unimplemented: c };
          }
          addImage(e, r) {
            if (this.getImage(e)) return this.fire(new u.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, r), this._afterImageUpdated(e);
          }
          updateImage(e, r) {
            this.imageManager.updateImage(e, r);
          }
          getImage(e) {
            return this.imageManager.getImage(e);
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new u.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e);
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e, r, c = {}) {
            if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!r.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(r).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(r.type) >= 0 && this._validate(u.z.source, `sources.${e}`, r, null, c)) return;
            this.map && this.map._collectResourceTiming && (r.collectResourceTiming = !0);
            const f = this.sourceCaches[e] = new ri(e, r, this.dispatcher);
            f.style = this, f.setEventedParent(this, (() => ({ isSourceLoaded: f.loaded(), source: f.serialize(), sourceId: e }))), f.onAdd(this.map), this._changed = !0;
          }
          removeSource(e) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
            for (const c in this._layers) if (this._layers[c].source === e) return this.fire(new u.k(new Error(`Source "${e}" cannot be removed while layer "${c}" is using it.`)));
            const r = this.sourceCaches[e];
            delete this.sourceCaches[e], delete this._updatedSources[e], r.fire(new u.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), r.setEventedParent(null), r.onRemove(this.map), this._changed = !0;
          }
          setGeoJSONSourceData(e, r) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const c = this.sourceCaches[e].getSource();
            if (c.type !== "geojson") throw new Error(`geojsonSource.type is ${c.type}, which is !== 'geojson`);
            c.setData(r), this._changed = !0;
          }
          getSource(e) {
            return this.sourceCaches[e] && this.sourceCaches[e].getSource();
          }
          addLayer(e, r, c = {}) {
            this._checkLoaded();
            const f = e.id;
            if (this.getLayer(f)) return void this.fire(new u.k(new Error(`Layer "${f}" already exists on this map.`)));
            let _;
            if (e.type === "custom") {
              if (Lc(this, u.bM(e))) return;
              _ = u.bJ(e);
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(f, e.source), e = u.bK(e), e = u.e(e, { source: f })), this._validate(u.z.layer, `layers.${f}`, e, { arrayIndex: -1 }, c)) return;
              _ = u.bJ(e), this._validateLayer(_), _.setEventedParent(this, { layer: { id: f } });
            }
            const w = r ? this._order.indexOf(r) : this._order.length;
            if (r && w === -1) this.fire(new u.k(new Error(`Cannot add layer "${f}" before non-existing layer "${r}".`)));
            else {
              if (this._order.splice(w, 0, f), this._layerOrderChanged = !0, this._layers[f] = _, this._removedLayers[f] && _.source && _.type !== "custom") {
                const C = this._removedLayers[f];
                delete this._removedLayers[f], C.type !== _.type ? this._updatedSources[_.source] = "clear" : (this._updatedSources[_.source] = "reload", this.sourceCaches[_.source].pause());
              }
              this._updateLayer(_), _.onAdd && _.onAdd(this.map);
            }
          }
          moveLayer(e, r) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new u.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === r) return;
            const c = this._order.indexOf(e);
            this._order.splice(c, 1);
            const f = r ? this._order.indexOf(r) : this._order.length;
            r && f === -1 ? this.fire(new u.k(new Error(`Cannot move layer "${e}" before non-existing layer "${r}".`))) : (this._order.splice(f, 0, e), this._layerOrderChanged = !0);
          }
          removeLayer(e) {
            this._checkLoaded();
            const r = this._layers[e];
            if (!r) return void this.fire(new u.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            r.setEventedParent(null);
            const c = this._order.indexOf(e);
            this._order.splice(c, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = r, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], r.onRemove && r.onRemove(this.map);
          }
          getLayer(e) {
            return this._layers[e];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(e) {
            return e in this._layers;
          }
          setLayerZoomRange(e, r, c) {
            this._checkLoaded();
            const f = this.getLayer(e);
            f ? f.minzoom === r && f.maxzoom === c || (r != null && (f.minzoom = r), c != null && (f.maxzoom = c), this._updateLayer(f)) : this.fire(new u.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
          }
          setFilter(e, r, c = {}) {
            this._checkLoaded();
            const f = this.getLayer(e);
            if (f) {
              if (!u.bH(f.filter, r)) return r == null ? (f.setFilter(void 0), void this._updateLayer(f)) : void (this._validate(u.z.filter, `layers.${f.id}.filter`, r, null, c) || (f.setFilter(u.bK(r)), this._updateLayer(f)));
            } else this.fire(new u.k(new Error(`Cannot filter non-existing layer "${e}".`)));
          }
          getFilter(e) {
            return u.bK(this.getLayer(e).filter);
          }
          setLayoutProperty(e, r, c, f = {}) {
            this._checkLoaded();
            const _ = this.getLayer(e);
            _ ? u.bH(_.getLayoutProperty(r), c) || (_.setLayoutProperty(r, c, f), this._updateLayer(_)) : this.fire(new u.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          getLayoutProperty(e, r) {
            const c = this.getLayer(e);
            if (c) return c.getLayoutProperty(r);
            this.fire(new u.k(new Error(`Cannot get style of non-existing layer "${e}".`)));
          }
          setPaintProperty(e, r, c, f = {}) {
            this._checkLoaded();
            const _ = this.getLayer(e);
            _ ? u.bH(_.getPaintProperty(r), c) || (_.setPaintProperty(r, c, f) && this._updateLayer(_), this._changed = !0, this._updatedPaintProps[e] = !0, this._serializedLayers = null) : this.fire(new u.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          getPaintProperty(e, r) {
            return this.getLayer(e).getPaintProperty(r);
          }
          setFeatureState(e, r) {
            this._checkLoaded();
            const c = e.source, f = e.sourceLayer, _ = this.sourceCaches[c];
            if (_ === void 0) return void this.fire(new u.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const w = _.getSource().type;
            w === "geojson" && f ? this.fire(new u.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : w !== "vector" || f ? (e.id === void 0 && this.fire(new u.k(new Error("The feature id parameter must be provided."))), _.setFeatureState(f, e.id, r)) : this.fire(new u.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e, r) {
            this._checkLoaded();
            const c = e.source, f = this.sourceCaches[c];
            if (f === void 0) return void this.fire(new u.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const _ = f.getSource().type, w = _ === "vector" ? e.sourceLayer : void 0;
            _ !== "vector" || w ? r && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new u.k(new Error("A feature id is required to remove its specific state property."))) : f.removeFeatureState(w, e.id, r) : this.fire(new u.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e) {
            this._checkLoaded();
            const r = e.source, c = e.sourceLayer, f = this.sourceCaches[r];
            if (f !== void 0) return f.getSource().type !== "vector" || c ? (e.id === void 0 && this.fire(new u.k(new Error("The feature id parameter must be provided."))), f.getFeatureState(c, e.id)) : void this.fire(new u.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new u.k(new Error(`The source '${r}' does not exist in the map's style.`)));
          }
          getTransition() {
            return u.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const e = u.bN(this.sourceCaches, ((_) => _.serialize())), r = this._serializeByIds(this._order, !0), c = this.map.getTerrain() || void 0, f = this.stylesheet;
            return u.bO({ version: f.version, name: f.name, metadata: f.metadata, light: f.light, sky: f.sky, center: f.center, zoom: f.zoom, bearing: f.bearing, pitch: f.pitch, sprite: f.sprite, glyphs: f.glyphs, transition: f.transition, projection: f.projection, sources: e, layers: r, terrain: c }, ((_) => _ !== void 0));
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0;
          }
          _flattenAndSortRenderedFeatures(e) {
            const r = (w) => this._layers[w].type === "fill-extrusion", c = {}, f = [];
            for (let w = this._order.length - 1; w >= 0; w--) {
              const C = this._order[w];
              if (r(C)) {
                c[C] = w;
                for (const P of e) {
                  const R = P[C];
                  if (R) for (const L of R) f.push(L);
                }
              }
            }
            f.sort(((w, C) => C.intersectionZ - w.intersectionZ));
            const _ = [];
            for (let w = this._order.length - 1; w >= 0; w--) {
              const C = this._order[w];
              if (r(C)) for (let P = f.length - 1; P >= 0; P--) {
                const R = f[P].feature;
                if (c[R.layer.id] < w) break;
                _.push(R), f.pop();
              }
              else for (const P of e) {
                const R = P[C];
                if (R) for (const L of R) _.push(L.feature);
              }
            }
            return _;
          }
          queryRenderedFeatures(e, r, c) {
            r && r.filter && this._validate(u.z.filter, "queryRenderedFeatures.filter", r.filter, null, r);
            const f = {};
            if (r && r.layers) {
              if (!(Array.isArray(r.layers) || r.layers instanceof Set)) return this.fire(new u.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const R of r.layers) {
                const L = this._layers[R];
                if (!L) return this.fire(new u.k(new Error(`The layer '${R}' does not exist in the map's style and cannot be queried for features.`))), [];
                f[L.source] = !0;
              }
            }
            const _ = [];
            r.availableImages = this._availableImages;
            const w = this._serializedAllLayers(), C = r.layers instanceof Set ? r.layers : Array.isArray(r.layers) ? new Set(r.layers) : null, P = Object.assign(Object.assign({}, r), { layers: C });
            for (const R in this.sourceCaches) r.layers && !f[R] || _.push(xi(this.sourceCaches[R], this._layers, w, e, P, c, this.map.terrain ? (L, j, B) => this.map.terrain.getElevation(L, j, B) : void 0));
            return this.placement && _.push((function(R, L, j, B, V, $, ie) {
              const te = {}, ne = $.queryRenderedSymbols(B), re = [];
              for (const ce of Object.keys(ne).map(Number)) re.push(ie[ce]);
              re.sort(Ta);
              for (const ce of re) {
                const oe = ce.featureIndex.lookupSymbolFeatures(ne[ce.bucketInstanceId], L, ce.bucketIndex, ce.sourceLayerIndex, V.filter, V.layers, V.availableImages, R);
                for (const pe in oe) {
                  const ye = te[pe] = te[pe] || [], ue = oe[pe];
                  ue.sort(((we, Oe) => {
                    const ze = ce.featureSortOrder;
                    if (ze) {
                      const Pe = ze.indexOf(we.featureIndex);
                      return ze.indexOf(Oe.featureIndex) - Pe;
                    }
                    return Oe.featureIndex - we.featureIndex;
                  }));
                  for (const we of ue) ye.push(we);
                }
              }
              return (function(ce, oe, pe) {
                for (const ye in ce) for (const ue of ce[ye]) bi(ue, pe[oe[ye].source]);
                return ce;
              })(te, R, j);
            })(this._layers, w, this.sourceCaches, e, P, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(_);
          }
          querySourceFeatures(e, r) {
            r && r.filter && this._validate(u.z.filter, "querySourceFeatures.filter", r.filter, null, r);
            const c = this.sourceCaches[e];
            return c ? (function(f, _) {
              const w = f.getRenderableIds().map(((R) => f.getTileByID(R))), C = [], P = {};
              for (let R = 0; R < w.length; R++) {
                const L = w[R], j = L.tileID.canonical.key;
                P[j] || (P[j] = !0, L.querySourceFeatures(C, _));
              }
              return C;
            })(c, r) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e, r = {}) {
            this._checkLoaded();
            const c = this.light.getLight();
            let f = !1;
            for (const w in e) if (!u.bH(e[w], c[w])) {
              f = !0;
              break;
            }
            if (!f) return;
            const _ = { now: he.now(), transition: u.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e, r), this.light.updateTransitions(_);
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection;
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type);
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky;
          }
          setSky(e, r = {}) {
            this._checkLoaded();
            const c = this.getSky();
            let f = !1;
            if (!e && !c) return;
            if (e && !c) f = !0;
            else if (!e && c) f = !0;
            else for (const w in e) if (!u.bH(e[w], c[w])) {
              f = !0;
              break;
            }
            if (!f) return;
            const _ = { now: he.now(), transition: u.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = e, this.sky.setSky(e, r), this.sky.updateTransitions(_);
          }
          _setProjectionInternal(e) {
            const r = (function(c) {
              if (Array.isArray(c)) {
                const f = new $l({ type: c });
                return { projection: f, transform: new ll(), cameraHelper: new Zd(f) };
              }
              switch (c) {
                case "mercator":
                  return { projection: new di(), transform: new Ui(), cameraHelper: new ua() };
                case "globe": {
                  const f = new $l({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: f, transform: new ll(), cameraHelper: new Zd(f) };
                }
                case "vertical-perspective":
                  return { projection: new Lu(), transform: new Uu(), cameraHelper: new Ea() };
                default:
                  return u.w(`Unknown projection name: ${c}. Falling back to mercator projection.`), { projection: new di(), transform: new Ui(), cameraHelper: new ua() };
              }
            })(e);
            this.projection = r.projection, this.map.migrateProjection(r.transform, r.cameraHelper);
            for (const c in this.sourceCaches) this.sourceCaches[c].reload();
          }
          _validate(e, r, c, f, _ = {}) {
            return (!_ || _.validate !== !1) && Lc(this, e.call(u.z, u.e({ key: r, style: this.serialize(), value: c, styleSpec: u.v }, f)));
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Ns().off(Yn, this._rtlPluginLoaded);
            for (const r in this._layers) this._layers[r].setEventedParent(null);
            for (const r in this.sourceCaches) {
              const c = this.sourceCaches[r];
              c.setEventedParent(null), c.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
          }
          _clearSource(e) {
            this.sourceCaches[e].clearTiles();
          }
          _reloadSource(e) {
            this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
          }
          _updateSources(e) {
            for (const r in this.sourceCaches) this.sourceCaches[r].update(e, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const e in this.sourceCaches) this._reloadSource(e);
          }
          _updatePlacement(e, r, c, f, _ = !1) {
            let w = !1, C = !1;
            const P = {};
            for (const R of this._order) {
              const L = this._layers[R];
              if (L.type !== "symbol") continue;
              if (!P[L.source]) {
                const B = this.sourceCaches[L.source];
                P[L.source] = B.getRenderableIds(!0).map(((V) => B.getTileByID(V))).sort(((V, $) => $.tileID.overscaledZ - V.tileID.overscaledZ || (V.tileID.isLessThan($.tileID) ? -1 : 1)));
              }
              const j = this.crossTileSymbolIndex.addLayer(L, P[L.source], e.center.lng);
              w = w || j;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((_ = _ || this._layerOrderChanged || c === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(he.now(), e.zoom)) && (this.pauseablePlacement = new Wa(e, this.map.terrain, this._order, _, r, c, f, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, P), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(he.now()), C = !0), w && this.pauseablePlacement.placement.setStale()), C || w) for (const R of this._order) {
              const L = this._layers[R];
              L.type === "symbol" && this.placement.updateLayerOpacities(L, P[L.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(he.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles();
          }
          getImages(e, r) {
            return u._(this, void 0, void 0, (function* () {
              const c = yield this.imageManager.getImages(r.icons);
              this._updateTilesForChangedImages();
              const f = this.sourceCaches[r.source];
              return f && f.setDependencies(r.tileID.key, r.type, r.icons), c;
            }));
          }
          getGlyphs(e, r) {
            return u._(this, void 0, void 0, (function* () {
              const c = yield this.glyphManager.getGlyphs(r.stacks), f = this.sourceCaches[r.source];
              return f && f.setDependencies(r.tileID.key, r.type, [""]), c;
            }));
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e, r = {}) {
            this._checkLoaded(), e && this._validate(u.z.glyphs, "glyphs", e, null, r) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
          }
          addSprite(e, r, c = {}, f) {
            this._checkLoaded();
            const _ = [{ id: e, url: r }], w = [...$e(this.stylesheet.sprite), ..._];
            this._validate(u.z.sprite, "sprite", w, null, c) || (this.stylesheet.sprite = w, this._loadSprite(_, !0, f));
          }
          removeSprite(e) {
            this._checkLoaded();
            const r = $e(this.stylesheet.sprite);
            if (r.find(((c) => c.id === e))) {
              if (this._spritesImagesIds[e]) for (const c of this._spritesImagesIds[e]) this.imageManager.removeImage(c), this._changedImages[c] = !0;
              r.splice(r.findIndex(((c) => c.id === e)), 1), this.stylesheet.sprite = r.length > 0 ? r : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" }));
            } else this.fire(new u.k(new Error(`Sprite "${e}" doesn't exists on this map.`)));
          }
          getSprite() {
            return $e(this.stylesheet.sprite);
          }
          setSprite(e, r = {}, c) {
            this._checkLoaded(), e && this._validate(u.z.sprite, "sprite", e, null, r) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, c) : (this._unloadSprite(), c && c(null)));
          }
        }
        var rf = u.aJ([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class sf {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(e, r, c, f, _, w, C, P, R) {
            this.context = e;
            let L = this.boundPaintVertexBuffers.length !== f.length;
            for (let j = 0; !L && j < f.length; j++) this.boundPaintVertexBuffers[j] !== f[j] && (L = !0);
            !this.vao || this.boundProgram !== r || this.boundLayoutVertexBuffer !== c || L || this.boundIndexBuffer !== _ || this.boundVertexOffset !== w || this.boundDynamicVertexBuffer !== C || this.boundDynamicVertexBuffer2 !== P || this.boundDynamicVertexBuffer3 !== R ? this.freshBind(r, c, f, _, w, C, P, R) : (e.bindVertexArray.set(this.vao), C && C.bind(), _ && _.dynamicDraw && _.bind(), P && P.bind(), R && R.bind());
          }
          freshBind(e, r, c, f, _, w, C, P) {
            const R = e.numAttributes, L = this.context, j = L.gl;
            this.vao && this.destroy(), this.vao = L.createVertexArray(), L.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = r, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = f, this.boundVertexOffset = _, this.boundDynamicVertexBuffer = w, this.boundDynamicVertexBuffer2 = C, this.boundDynamicVertexBuffer3 = P, r.enableAttributes(j, e);
            for (const B of c) B.enableAttributes(j, e);
            w && w.enableAttributes(j, e), C && C.enableAttributes(j, e), P && P.enableAttributes(j, e), r.bind(), r.setVertexAttribPointers(j, e, _);
            for (const B of c) B.bind(), B.setVertexAttribPointers(j, e, _);
            w && (w.bind(), w.setVertexAttribPointers(j, e, _)), f && f.bind(), C && (C.bind(), C.setVertexAttribPointers(j, e, _)), P && (P.bind(), P.setVertexAttribPointers(j, e, _)), L.currentNumAttributes = R;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const Oc = (y, e, r, c, f) => ({ u_texture: 0, u_ele_delta: y, u_fog_matrix: e, u_fog_color: r ? r.properties.get("fog-color") : u.bf.white, u_fog_ground_blend: r ? r.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: f ? 0 : r ? r.calculateFogBlendOpacity(c) : 0, u_horizon_color: r ? r.properties.get("horizon-color") : u.bf.white, u_horizon_fog_blend: r ? r.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: f ? 1 : 0 }), kh = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function ul(y) {
          const e = [];
          for (let r = 0; r < y.length; r++) {
            if (y[r] === null) continue;
            const c = y[r].split(" ");
            e.push(c.pop());
          }
          return e;
        }
        class Rh {
          constructor(e, r, c, f, _, w, C, P, R = []) {
            const L = e.gl;
            this.program = L.createProgram();
            const j = ul(r.staticAttributes), B = c ? c.getBinderAttributes() : [], V = j.concat(B), $ = Ma.prelude.staticUniforms ? ul(Ma.prelude.staticUniforms) : [], ie = C.staticUniforms ? ul(C.staticUniforms) : [], te = r.staticUniforms ? ul(r.staticUniforms) : [], ne = c ? c.getBinderUniforms() : [], re = $.concat(ie).concat(te).concat(ne), ce = [];
            for (const ze of re) ce.indexOf(ze) < 0 && ce.push(ze);
            const oe = c ? c.defines() : [];
            Wr(L) && oe.unshift("#version 300 es"), _ && oe.push("#define OVERDRAW_INSPECTOR;"), w && oe.push("#define TERRAIN3D;"), P && oe.push(P), R && oe.push(...R);
            let pe = oe.concat(Ma.prelude.fragmentSource, C.fragmentSource, r.fragmentSource).join(`
`), ye = oe.concat(Ma.prelude.vertexSource, C.vertexSource, r.vertexSource).join(`
`);
            Wr(L) || (pe = (function(ze) {
              return ze.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            })(pe), ye = (function(ze) {
              return ze.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            })(ye));
            const ue = L.createShader(L.FRAGMENT_SHADER);
            if (L.isContextLost()) return void (this.failedToCreate = !0);
            if (L.shaderSource(ue, pe), L.compileShader(ue), !L.getShaderParameter(ue, L.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${L.getShaderInfoLog(ue)}`);
            L.attachShader(this.program, ue);
            const we = L.createShader(L.VERTEX_SHADER);
            if (L.isContextLost()) return void (this.failedToCreate = !0);
            if (L.shaderSource(we, ye), L.compileShader(we), !L.getShaderParameter(we, L.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${L.getShaderInfoLog(we)}`);
            L.attachShader(this.program, we), this.attributes = {};
            const Oe = {};
            this.numAttributes = V.length;
            for (let ze = 0; ze < this.numAttributes; ze++) V[ze] && (L.bindAttribLocation(this.program, ze, V[ze]), this.attributes[V[ze]] = ze);
            if (L.linkProgram(this.program), !L.getProgramParameter(this.program, L.LINK_STATUS)) throw new Error(`Program failed to link: ${L.getProgramInfoLog(this.program)}`);
            L.deleteShader(we), L.deleteShader(ue);
            for (let ze = 0; ze < ce.length; ze++) {
              const Pe = ce[ze];
              if (Pe && !Oe[Pe]) {
                const Le = L.getUniformLocation(this.program, Pe);
                Le && (Oe[Pe] = Le);
              }
            }
            this.fixedUniforms = f(e, Oe), this.terrainUniforms = ((ze, Pe) => ({ u_depth: new u.bP(ze, Pe.u_depth), u_terrain: new u.bP(ze, Pe.u_terrain), u_terrain_dim: new u.bg(ze, Pe.u_terrain_dim), u_terrain_matrix: new u.bR(ze, Pe.u_terrain_matrix), u_terrain_unpack: new u.bS(ze, Pe.u_terrain_unpack), u_terrain_exaggeration: new u.bg(ze, Pe.u_terrain_exaggeration) }))(e, Oe), this.projectionUniforms = ((ze, Pe) => ({ u_projection_matrix: new u.bR(ze, Pe.u_projection_matrix), u_projection_tile_mercator_coords: new u.bS(ze, Pe.u_projection_tile_mercator_coords), u_projection_clipping_plane: new u.bS(ze, Pe.u_projection_clipping_plane), u_projection_transition: new u.bg(ze, Pe.u_projection_transition), u_projection_fallback_matrix: new u.bR(ze, Pe.u_projection_fallback_matrix) }))(e, Oe), this.binderUniforms = c ? c.getUniforms(e, Oe) : [];
          }
          draw(e, r, c, f, _, w, C, P, R, L, j, B, V, $, ie, te, ne, re, ce) {
            const oe = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(c), e.setStencilMode(f), e.setColorMode(_), e.setCullFace(w), P) {
              e.activeTexture.set(oe.TEXTURE2), oe.bindTexture(oe.TEXTURE_2D, P.depthTexture), e.activeTexture.set(oe.TEXTURE3), oe.bindTexture(oe.TEXTURE_2D, P.texture);
              for (const ye in this.terrainUniforms) this.terrainUniforms[ye].set(P[ye]);
            }
            if (R) for (const ye in R) this.projectionUniforms[kh[ye]].set(R[ye]);
            if (C) for (const ye in this.fixedUniforms) this.fixedUniforms[ye].set(C[ye]);
            te && te.setUniforms(e, this.binderUniforms, $, { zoom: ie });
            let pe = 0;
            switch (r) {
              case oe.LINES:
                pe = 2;
                break;
              case oe.TRIANGLES:
                pe = 3;
                break;
              case oe.LINE_STRIP:
                pe = 1;
            }
            for (const ye of V.get()) {
              const ue = ye.vaos || (ye.vaos = {});
              (ue[L] || (ue[L] = new sf())).bind(e, this, j, te ? te.getPaintVertexBuffers() : [], B, ye.vertexOffset, ne, re, ce), oe.drawElements(r, ye.primitiveLength * pe, oe.UNSIGNED_SHORT, ye.primitiveOffset * pe * 2);
            }
          }
        }
        function Bc(y, e, r) {
          const c = 1 / u.aC(r, 1, e.transform.tileZoom), f = Math.pow(2, r.tileID.overscaledZ), _ = r.tileSize * Math.pow(2, e.transform.tileZoom) / f, w = _ * (r.tileID.canonical.x + r.tileID.wrap * f), C = _ * r.tileID.canonical.y;
          return { u_image: 0, u_texsize: r.imageAtlasTexture.size, u_scale: [c, y.fromScale, y.toScale], u_fade: y.t, u_pixel_coord_upper: [w >> 16, C >> 16], u_pixel_coord_lower: [65535 & w, 65535 & C] };
        }
        const Jr = (y, e, r, c) => {
          const f = y.style.light, _ = f.properties.get("position"), w = [_.x, _.y, _.z], C = u.bV();
          f.properties.get("anchor") === "viewport" && u.bW(C, y.transform.bearingInRadians), u.bX(w, w, C);
          const P = y.transform.transformLightDirection(w), R = f.properties.get("color");
          return { u_lightpos: w, u_lightpos_globe: P, u_lightintensity: f.properties.get("intensity"), u_lightcolor: [R.r, R.g, R.b], u_vertical_gradient: +e, u_opacity: r, u_fill_translate: c };
        }, Dh = (y, e, r, c, f, _, w) => u.e(Jr(y, e, r, c), Bc(_, y, w), { u_height_factor: -Math.pow(2, f.overscaledZ) / w.tileSize / 8 }), xo = (y, e, r, c) => u.e(Bc(e, y, r), { u_fill_translate: c }), Fu = (y, e) => ({ u_world: y, u_fill_translate: e }), Yl = (y, e, r, c, f) => u.e(xo(y, e, r, f), { u_world: c }), Hd = (y, e, r, c, f) => {
          const _ = y.transform;
          let w, C, P = 0;
          if (r.paint.get("circle-pitch-alignment") === "map") {
            const R = u.aC(e, 1, _.zoom);
            w = !0, C = [R, R], P = R / (u.$ * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * f;
          } else w = !1, C = _.pixelsToGLUnits;
          return { u_camera_to_center_distance: _.cameraToCenterDistance, u_scale_with_map: +(r.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +w, u_device_pixel_ratio: y.pixelRatio, u_extrude_scale: C, u_globe_extrude_scale: P, u_translate: c };
        }, Vu = (y) => ({ u_pixel_extrude_scale: [1 / y.width, 1 / y.height] }), Xd = (y) => ({ u_viewport_size: [y.width, y.height] }), bo = (y, e = 1) => ({ u_color: y, u_overlay: 0, u_overlay_scale: e }), cl = (y, e, r, c) => {
          const f = u.aC(y, 1, e) / (u.$ * Math.pow(2, y.tileID.overscaledZ)) * 2 * Math.PI * c;
          return { u_extrude_scale: u.aC(y, 1, e), u_intensity: r, u_globe_extrude_scale: f };
        }, Lh = (y, e, r, c) => {
          const f = u.L();
          u.bY(f, 0, y.width, y.height, 0, 0, 1);
          const _ = y.context.gl;
          return { u_matrix: f, u_world: [_.drawingBufferWidth, _.drawingBufferHeight], u_image: r, u_color_ramp: c, u_opacity: e.paint.get("heatmap-opacity") };
        }, of = (y, e, r) => {
          const c = r.paint.get("hillshade-accent-color");
          let f;
          switch (r.paint.get("hillshade-method")) {
            case "basic":
              f = 4;
              break;
            case "combined":
              f = 1;
              break;
            case "igor":
              f = 2;
              break;
            case "multidirectional":
              f = 3;
              break;
            default:
              f = 0;
          }
          const _ = r.getIlluminationProperties();
          for (let w = 0; w < _.directionRadians.length; w++) r.paint.get("hillshade-illumination-anchor") === "viewport" && (_.directionRadians[w] += y.transform.bearingInRadians);
          return { u_image: 0, u_latrange: Nc(0, e.tileID), u_exaggeration: r.paint.get("hillshade-exaggeration"), u_altitudes: _.altitudeRadians, u_azimuths: _.directionRadians, u_accent: c, u_method: f, u_highlights: _.highlightColor, u_shadows: _.shadowColor };
        }, Yd = (y, e) => {
          const r = e.stride, c = u.L();
          return u.bY(c, 0, u.$, -u.$, 0, 0, 1), u.M(c, c, [0, -u.$, 0]), { u_matrix: c, u_image: 1, u_dimension: [r, r], u_zoom: y.overscaledZ, u_unpack: e.getUnpackVector() };
        };
        function Nc(y, e) {
          const r = Math.pow(2, e.canonical.z), c = e.canonical.y;
          return [new u.a1(0, c / r).toLngLat().lat, new u.a1(0, (c + 1) / r).toLngLat().lat];
        }
        const Oh = (y, e, r = 0) => ({ u_image: 0, u_unpack: e.getUnpackVector(), u_dimension: [e.stride, e.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: r, u_opacity: y.paint.get("color-relief-opacity") }), wo = (y, e, r, c) => {
          const f = y.transform;
          return { u_translation: Uc(y, e, r), u_ratio: c / u.aC(e, 1, f.zoom), u_device_pixel_ratio: y.pixelRatio, u_units_to_pixels: [1 / f.pixelsToGLUnits[0], 1 / f.pixelsToGLUnits[1]] };
        }, Kl = (y, e, r, c, f) => u.e(wo(y, e, r, c), { u_image: 0, u_image_height: f }), Kd = (y, e, r, c, f) => {
          const _ = y.transform, w = jc(e, _);
          return { u_translation: Uc(y, e, r), u_texsize: e.imageAtlasTexture.size, u_ratio: c / u.aC(e, 1, _.zoom), u_device_pixel_ratio: y.pixelRatio, u_image: 0, u_scale: [w, f.fromScale, f.toScale], u_fade: f.t, u_units_to_pixels: [1 / _.pixelsToGLUnits[0], 1 / _.pixelsToGLUnits[1]] };
        }, fs = (y, e, r, c, f, _) => {
          const w = y.lineAtlas, C = jc(e, y.transform), P = r.layout.get("line-cap") === "round", R = w.getDash(f.from, P), L = w.getDash(f.to, P), j = R.width * _.fromScale, B = L.width * _.toScale;
          return u.e(wo(y, e, r, c), { u_patternscale_a: [C / j, -R.height / 2], u_patternscale_b: [C / B, -L.height / 2], u_sdfgamma: w.width / (256 * Math.min(j, B) * y.pixelRatio) / 2, u_image: 0, u_tex_y_a: R.y, u_tex_y_b: L.y, u_mix: _.t });
        };
        function jc(y, e) {
          return 1 / u.aC(y, 1, e.tileZoom);
        }
        function Uc(y, e, r) {
          return u.aD(y.transform, e, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"));
        }
        const hl = (y, e, r, c, f) => {
          return { u_tl_parent: y, u_scale_parent: e, u_buffer_scale: 1, u_fade_t: r.mix, u_opacity: r.opacity * c.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: c.paint.get("raster-brightness-min"), u_brightness_high: c.paint.get("raster-brightness-max"), u_saturation_factor: (w = c.paint.get("raster-saturation"), w > 0 ? 1 - 1 / (1.001 - w) : -w), u_contrast_factor: (_ = c.paint.get("raster-contrast"), _ > 0 ? 1 / (1 - _) : 1 + _), u_spin_weights: Bh(c.paint.get("raster-hue-rotate")), u_coords_top: [f[0].x, f[0].y, f[1].x, f[1].y], u_coords_bottom: [f[3].x, f[3].y, f[2].x, f[2].y] };
          var _, w;
        };
        function Bh(y) {
          y *= Math.PI / 180;
          const e = Math.sin(y), r = Math.cos(y);
          return [(2 * r + 1) / 3, (-Math.sqrt(3) * e - r + 1) / 3, (Math.sqrt(3) * e - r + 1) / 3];
        }
        const Wl = (y, e, r, c, f, _, w, C, P, R, L, j, B) => {
          const V = w.transform;
          return { u_is_size_zoom_constant: +(y === "constant" || y === "source"), u_is_size_feature_constant: +(y === "constant" || y === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: V.cameraToCenterDistance, u_pitch: V.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +r, u_aspect_ratio: V.width / V.height, u_fade_change: w.options.fadeDuration ? w.symbolFadeChange : 1, u_label_plane_matrix: C, u_coord_matrix: P, u_is_text: +L, u_pitch_with_map: +c, u_is_along_line: f, u_is_variable_anchor: _, u_texsize: j, u_texture: 0, u_translation: R, u_pitched_scale: B };
        }, Nh = (y, e, r, c, f, _, w, C, P, R, L, j, B, V) => {
          const $ = w.transform;
          return u.e(Wl(y, e, r, c, f, _, w, C, P, R, L, j, V), { u_gamma_scale: c ? Math.cos($.pitch * Math.PI / 180) * $.cameraToCenterDistance : 1, u_device_pixel_ratio: w.pixelRatio, u_is_halo: 1 });
        }, Wd = (y, e, r, c, f, _, w, C, P, R, L, j, B) => u.e(Nh(y, e, r, c, f, _, w, C, P, R, !0, L, 0, B), { u_texsize_icon: j, u_texture_icon: 1 }), Jd = (y, e) => ({ u_opacity: y, u_color: e }), Qd = (y, e, r, c, f) => u.e((function(_, w, C, P) {
          const R = C.imageManager.getPattern(_.from.toString()), L = C.imageManager.getPattern(_.to.toString()), { width: j, height: B } = C.imageManager.getPixelSize(), V = Math.pow(2, P.tileID.overscaledZ), $ = P.tileSize * Math.pow(2, C.transform.tileZoom) / V, ie = $ * (P.tileID.canonical.x + P.tileID.wrap * V), te = $ * P.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: R.tl, u_pattern_br_a: R.br, u_pattern_tl_b: L.tl, u_pattern_br_b: L.br, u_texsize: [j, B], u_mix: w.t, u_pattern_size_a: R.displaySize, u_pattern_size_b: L.displaySize, u_scale_a: w.fromScale, u_scale_b: w.toScale, u_tile_units_to_pixels: 1 / u.aC(P, 1, C.transform.tileZoom), u_pixel_coord_upper: [ie >> 16, te >> 16], u_pixel_coord_lower: [65535 & ie, 65535 & te] };
        })(r, f, e, c), { u_opacity: y }), jh = (y, e) => {
        }, Uh = { fillExtrusion: (y, e) => ({ u_lightpos: new u.bT(y, e.u_lightpos), u_lightpos_globe: new u.bT(y, e.u_lightpos_globe), u_lightintensity: new u.bg(y, e.u_lightintensity), u_lightcolor: new u.bT(y, e.u_lightcolor), u_vertical_gradient: new u.bg(y, e.u_vertical_gradient), u_opacity: new u.bg(y, e.u_opacity), u_fill_translate: new u.bU(y, e.u_fill_translate) }), fillExtrusionPattern: (y, e) => ({ u_lightpos: new u.bT(y, e.u_lightpos), u_lightpos_globe: new u.bT(y, e.u_lightpos_globe), u_lightintensity: new u.bg(y, e.u_lightintensity), u_lightcolor: new u.bT(y, e.u_lightcolor), u_vertical_gradient: new u.bg(y, e.u_vertical_gradient), u_height_factor: new u.bg(y, e.u_height_factor), u_opacity: new u.bg(y, e.u_opacity), u_fill_translate: new u.bU(y, e.u_fill_translate), u_image: new u.bP(y, e.u_image), u_texsize: new u.bU(y, e.u_texsize), u_pixel_coord_upper: new u.bU(y, e.u_pixel_coord_upper), u_pixel_coord_lower: new u.bU(y, e.u_pixel_coord_lower), u_scale: new u.bT(y, e.u_scale), u_fade: new u.bg(y, e.u_fade) }), fill: (y, e) => ({ u_fill_translate: new u.bU(y, e.u_fill_translate) }), fillPattern: (y, e) => ({ u_image: new u.bP(y, e.u_image), u_texsize: new u.bU(y, e.u_texsize), u_pixel_coord_upper: new u.bU(y, e.u_pixel_coord_upper), u_pixel_coord_lower: new u.bU(y, e.u_pixel_coord_lower), u_scale: new u.bT(y, e.u_scale), u_fade: new u.bg(y, e.u_fade), u_fill_translate: new u.bU(y, e.u_fill_translate) }), fillOutline: (y, e) => ({ u_world: new u.bU(y, e.u_world), u_fill_translate: new u.bU(y, e.u_fill_translate) }), fillOutlinePattern: (y, e) => ({ u_world: new u.bU(y, e.u_world), u_image: new u.bP(y, e.u_image), u_texsize: new u.bU(y, e.u_texsize), u_pixel_coord_upper: new u.bU(y, e.u_pixel_coord_upper), u_pixel_coord_lower: new u.bU(y, e.u_pixel_coord_lower), u_scale: new u.bT(y, e.u_scale), u_fade: new u.bg(y, e.u_fade), u_fill_translate: new u.bU(y, e.u_fill_translate) }), circle: (y, e) => ({ u_camera_to_center_distance: new u.bg(y, e.u_camera_to_center_distance), u_scale_with_map: new u.bP(y, e.u_scale_with_map), u_pitch_with_map: new u.bP(y, e.u_pitch_with_map), u_extrude_scale: new u.bU(y, e.u_extrude_scale), u_device_pixel_ratio: new u.bg(y, e.u_device_pixel_ratio), u_globe_extrude_scale: new u.bg(y, e.u_globe_extrude_scale), u_translate: new u.bU(y, e.u_translate) }), collisionBox: (y, e) => ({ u_pixel_extrude_scale: new u.bU(y, e.u_pixel_extrude_scale) }), collisionCircle: (y, e) => ({ u_viewport_size: new u.bU(y, e.u_viewport_size) }), debug: (y, e) => ({ u_color: new u.bQ(y, e.u_color), u_overlay: new u.bP(y, e.u_overlay), u_overlay_scale: new u.bg(y, e.u_overlay_scale) }), depth: jh, clippingMask: jh, heatmap: (y, e) => ({ u_extrude_scale: new u.bg(y, e.u_extrude_scale), u_intensity: new u.bg(y, e.u_intensity), u_globe_extrude_scale: new u.bg(y, e.u_globe_extrude_scale) }), heatmapTexture: (y, e) => ({ u_matrix: new u.bR(y, e.u_matrix), u_world: new u.bU(y, e.u_world), u_image: new u.bP(y, e.u_image), u_color_ramp: new u.bP(y, e.u_color_ramp), u_opacity: new u.bg(y, e.u_opacity) }), hillshade: (y, e) => ({ u_image: new u.bP(y, e.u_image), u_latrange: new u.bU(y, e.u_latrange), u_exaggeration: new u.bg(y, e.u_exaggeration), u_altitudes: new u.b_(y, e.u_altitudes), u_azimuths: new u.b_(y, e.u_azimuths), u_accent: new u.bQ(y, e.u_accent), u_method: new u.bP(y, e.u_method), u_shadows: new u.bZ(y, e.u_shadows), u_highlights: new u.bZ(y, e.u_highlights) }), hillshadePrepare: (y, e) => ({ u_matrix: new u.bR(y, e.u_matrix), u_image: new u.bP(y, e.u_image), u_dimension: new u.bU(y, e.u_dimension), u_zoom: new u.bg(y, e.u_zoom), u_unpack: new u.bS(y, e.u_unpack) }), colorRelief: (y, e) => ({ u_image: new u.bP(y, e.u_image), u_unpack: new u.bS(y, e.u_unpack), u_dimension: new u.bU(y, e.u_dimension), u_elevation_stops: new u.bP(y, e.u_elevation_stops), u_color_stops: new u.bP(y, e.u_color_stops), u_color_ramp_size: new u.bP(y, e.u_color_ramp_size), u_opacity: new u.bg(y, e.u_opacity) }), line: (y, e) => ({ u_translation: new u.bU(y, e.u_translation), u_ratio: new u.bg(y, e.u_ratio), u_device_pixel_ratio: new u.bg(y, e.u_device_pixel_ratio), u_units_to_pixels: new u.bU(y, e.u_units_to_pixels) }), lineGradient: (y, e) => ({ u_translation: new u.bU(y, e.u_translation), u_ratio: new u.bg(y, e.u_ratio), u_device_pixel_ratio: new u.bg(y, e.u_device_pixel_ratio), u_units_to_pixels: new u.bU(y, e.u_units_to_pixels), u_image: new u.bP(y, e.u_image), u_image_height: new u.bg(y, e.u_image_height) }), linePattern: (y, e) => ({ u_translation: new u.bU(y, e.u_translation), u_texsize: new u.bU(y, e.u_texsize), u_ratio: new u.bg(y, e.u_ratio), u_device_pixel_ratio: new u.bg(y, e.u_device_pixel_ratio), u_image: new u.bP(y, e.u_image), u_units_to_pixels: new u.bU(y, e.u_units_to_pixels), u_scale: new u.bT(y, e.u_scale), u_fade: new u.bg(y, e.u_fade) }), lineSDF: (y, e) => ({ u_translation: new u.bU(y, e.u_translation), u_ratio: new u.bg(y, e.u_ratio), u_device_pixel_ratio: new u.bg(y, e.u_device_pixel_ratio), u_units_to_pixels: new u.bU(y, e.u_units_to_pixels), u_patternscale_a: new u.bU(y, e.u_patternscale_a), u_patternscale_b: new u.bU(y, e.u_patternscale_b), u_sdfgamma: new u.bg(y, e.u_sdfgamma), u_image: new u.bP(y, e.u_image), u_tex_y_a: new u.bg(y, e.u_tex_y_a), u_tex_y_b: new u.bg(y, e.u_tex_y_b), u_mix: new u.bg(y, e.u_mix) }), raster: (y, e) => ({ u_tl_parent: new u.bU(y, e.u_tl_parent), u_scale_parent: new u.bg(y, e.u_scale_parent), u_buffer_scale: new u.bg(y, e.u_buffer_scale), u_fade_t: new u.bg(y, e.u_fade_t), u_opacity: new u.bg(y, e.u_opacity), u_image0: new u.bP(y, e.u_image0), u_image1: new u.bP(y, e.u_image1), u_brightness_low: new u.bg(y, e.u_brightness_low), u_brightness_high: new u.bg(y, e.u_brightness_high), u_saturation_factor: new u.bg(y, e.u_saturation_factor), u_contrast_factor: new u.bg(y, e.u_contrast_factor), u_spin_weights: new u.bT(y, e.u_spin_weights), u_coords_top: new u.bS(y, e.u_coords_top), u_coords_bottom: new u.bS(y, e.u_coords_bottom) }), symbolIcon: (y, e) => ({ u_is_size_zoom_constant: new u.bP(y, e.u_is_size_zoom_constant), u_is_size_feature_constant: new u.bP(y, e.u_is_size_feature_constant), u_size_t: new u.bg(y, e.u_size_t), u_size: new u.bg(y, e.u_size), u_camera_to_center_distance: new u.bg(y, e.u_camera_to_center_distance), u_pitch: new u.bg(y, e.u_pitch), u_rotate_symbol: new u.bP(y, e.u_rotate_symbol), u_aspect_ratio: new u.bg(y, e.u_aspect_ratio), u_fade_change: new u.bg(y, e.u_fade_change), u_label_plane_matrix: new u.bR(y, e.u_label_plane_matrix), u_coord_matrix: new u.bR(y, e.u_coord_matrix), u_is_text: new u.bP(y, e.u_is_text), u_pitch_with_map: new u.bP(y, e.u_pitch_with_map), u_is_along_line: new u.bP(y, e.u_is_along_line), u_is_variable_anchor: new u.bP(y, e.u_is_variable_anchor), u_texsize: new u.bU(y, e.u_texsize), u_texture: new u.bP(y, e.u_texture), u_translation: new u.bU(y, e.u_translation), u_pitched_scale: new u.bg(y, e.u_pitched_scale) }), symbolSDF: (y, e) => ({ u_is_size_zoom_constant: new u.bP(y, e.u_is_size_zoom_constant), u_is_size_feature_constant: new u.bP(y, e.u_is_size_feature_constant), u_size_t: new u.bg(y, e.u_size_t), u_size: new u.bg(y, e.u_size), u_camera_to_center_distance: new u.bg(y, e.u_camera_to_center_distance), u_pitch: new u.bg(y, e.u_pitch), u_rotate_symbol: new u.bP(y, e.u_rotate_symbol), u_aspect_ratio: new u.bg(y, e.u_aspect_ratio), u_fade_change: new u.bg(y, e.u_fade_change), u_label_plane_matrix: new u.bR(y, e.u_label_plane_matrix), u_coord_matrix: new u.bR(y, e.u_coord_matrix), u_is_text: new u.bP(y, e.u_is_text), u_pitch_with_map: new u.bP(y, e.u_pitch_with_map), u_is_along_line: new u.bP(y, e.u_is_along_line), u_is_variable_anchor: new u.bP(y, e.u_is_variable_anchor), u_texsize: new u.bU(y, e.u_texsize), u_texture: new u.bP(y, e.u_texture), u_gamma_scale: new u.bg(y, e.u_gamma_scale), u_device_pixel_ratio: new u.bg(y, e.u_device_pixel_ratio), u_is_halo: new u.bP(y, e.u_is_halo), u_translation: new u.bU(y, e.u_translation), u_pitched_scale: new u.bg(y, e.u_pitched_scale) }), symbolTextAndIcon: (y, e) => ({ u_is_size_zoom_constant: new u.bP(y, e.u_is_size_zoom_constant), u_is_size_feature_constant: new u.bP(y, e.u_is_size_feature_constant), u_size_t: new u.bg(y, e.u_size_t), u_size: new u.bg(y, e.u_size), u_camera_to_center_distance: new u.bg(y, e.u_camera_to_center_distance), u_pitch: new u.bg(y, e.u_pitch), u_rotate_symbol: new u.bP(y, e.u_rotate_symbol), u_aspect_ratio: new u.bg(y, e.u_aspect_ratio), u_fade_change: new u.bg(y, e.u_fade_change), u_label_plane_matrix: new u.bR(y, e.u_label_plane_matrix), u_coord_matrix: new u.bR(y, e.u_coord_matrix), u_is_text: new u.bP(y, e.u_is_text), u_pitch_with_map: new u.bP(y, e.u_pitch_with_map), u_is_along_line: new u.bP(y, e.u_is_along_line), u_is_variable_anchor: new u.bP(y, e.u_is_variable_anchor), u_texsize: new u.bU(y, e.u_texsize), u_texsize_icon: new u.bU(y, e.u_texsize_icon), u_texture: new u.bP(y, e.u_texture), u_texture_icon: new u.bP(y, e.u_texture_icon), u_gamma_scale: new u.bg(y, e.u_gamma_scale), u_device_pixel_ratio: new u.bg(y, e.u_device_pixel_ratio), u_is_halo: new u.bP(y, e.u_is_halo), u_translation: new u.bU(y, e.u_translation), u_pitched_scale: new u.bg(y, e.u_pitched_scale) }), background: (y, e) => ({ u_opacity: new u.bg(y, e.u_opacity), u_color: new u.bQ(y, e.u_color) }), backgroundPattern: (y, e) => ({ u_opacity: new u.bg(y, e.u_opacity), u_image: new u.bP(y, e.u_image), u_pattern_tl_a: new u.bU(y, e.u_pattern_tl_a), u_pattern_br_a: new u.bU(y, e.u_pattern_br_a), u_pattern_tl_b: new u.bU(y, e.u_pattern_tl_b), u_pattern_br_b: new u.bU(y, e.u_pattern_br_b), u_texsize: new u.bU(y, e.u_texsize), u_mix: new u.bg(y, e.u_mix), u_pattern_size_a: new u.bU(y, e.u_pattern_size_a), u_pattern_size_b: new u.bU(y, e.u_pattern_size_b), u_scale_a: new u.bg(y, e.u_scale_a), u_scale_b: new u.bg(y, e.u_scale_b), u_pixel_coord_upper: new u.bU(y, e.u_pixel_coord_upper), u_pixel_coord_lower: new u.bU(y, e.u_pixel_coord_lower), u_tile_units_to_pixels: new u.bg(y, e.u_tile_units_to_pixels) }), terrain: (y, e) => ({ u_texture: new u.bP(y, e.u_texture), u_ele_delta: new u.bg(y, e.u_ele_delta), u_fog_matrix: new u.bR(y, e.u_fog_matrix), u_fog_color: new u.bQ(y, e.u_fog_color), u_fog_ground_blend: new u.bg(y, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new u.bg(y, e.u_fog_ground_blend_opacity), u_horizon_color: new u.bQ(y, e.u_horizon_color), u_horizon_fog_blend: new u.bg(y, e.u_horizon_fog_blend), u_is_globe_mode: new u.bg(y, e.u_is_globe_mode) }), terrainDepth: (y, e) => ({ u_ele_delta: new u.bg(y, e.u_ele_delta) }), terrainCoords: (y, e) => ({ u_texture: new u.bP(y, e.u_texture), u_terrain_coords_id: new u.bg(y, e.u_terrain_coords_id), u_ele_delta: new u.bg(y, e.u_ele_delta) }), projectionErrorMeasurement: (y, e) => ({ u_input: new u.bg(y, e.u_input), u_output_expected: new u.bg(y, e.u_output_expected) }), atmosphere: (y, e) => ({ u_sun_pos: new u.bT(y, e.u_sun_pos), u_atmosphere_blend: new u.bg(y, e.u_atmosphere_blend), u_globe_position: new u.bT(y, e.u_globe_position), u_globe_radius: new u.bg(y, e.u_globe_radius), u_inv_proj_matrix: new u.bR(y, e.u_inv_proj_matrix) }), sky: (y, e) => ({ u_sky_color: new u.bQ(y, e.u_sky_color), u_horizon_color: new u.bQ(y, e.u_horizon_color), u_horizon: new u.bU(y, e.u_horizon), u_horizon_normal: new u.bU(y, e.u_horizon_normal), u_sky_horizon_blend: new u.bg(y, e.u_sky_horizon_blend), u_sky_blend: new u.bg(y, e.u_sky_blend) }) };
        class ep {
          constructor(e, r, c) {
            this.context = e;
            const f = e.gl;
            this.buffer = f.createBuffer(), this.dynamicDraw = !!c, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), f.bufferData(f.ELEMENT_ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? f.DYNAMIC_DRAW : f.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e) {
            const r = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), r.bufferSubData(r.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Ca = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class gr {
          constructor(e, r, c, f) {
            this.length = r.length, this.attributes = c, this.itemSize = r.bytesPerElement, this.dynamicDraw = f, this.context = e;
            const _ = e.gl;
            this.buffer = _.createBuffer(), e.bindVertexBuffer.set(this.buffer), _.bufferData(_.ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? _.DYNAMIC_DRAW : _.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const r = this.context.gl;
            this.bind(), r.bufferSubData(r.ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          enableAttributes(e, r) {
            for (let c = 0; c < this.attributes.length; c++) {
              const f = r.attributes[this.attributes[c].name];
              f !== void 0 && e.enableVertexAttribArray(f);
            }
          }
          setVertexAttribPointers(e, r, c) {
            for (let f = 0; f < this.attributes.length; f++) {
              const _ = this.attributes[f], w = r.attributes[_.name];
              w !== void 0 && e.vertexAttribPointer(w, _.components, e[Ca[_.type]], !1, this.itemSize, _.offset + this.itemSize * (c || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Ci {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(e) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Fc extends Ci {
          getDefault() {
            return u.bf.transparent;
          }
          set(e) {
            const r = this.current;
            (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
          }
        }
        class Vc extends Ci {
          getDefault() {
            return 1;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
          }
        }
        class Fh extends Ci {
          getDefault() {
            return 0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
          }
        }
        class qu extends Ci {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
          }
        }
        class dl extends Ci {
          getDefault() {
            return !0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
          }
        }
        class So extends Ci {
          getDefault() {
            return 255;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
          }
        }
        class Vh extends Ci {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e) {
            const r = this.current;
            (e.func !== r.func || e.ref !== r.ref || e.mask !== r.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
          }
        }
        class Gu extends Ci {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP];
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
          }
        }
        class qh extends Ci {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            e ? r.enable(r.STENCIL_TEST) : r.disable(r.STENCIL_TEST), this.current = e, this.dirty = !1;
          }
        }
        class tp extends Ci {
          getDefault() {
            return [0, 1];
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
          }
        }
        class To extends Ci {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            e ? r.enable(r.DEPTH_TEST) : r.disable(r.DEPTH_TEST), this.current = e, this.dirty = !1;
          }
        }
        class Jl extends Ci {
          getDefault() {
            return this.gl.LESS;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
          }
        }
        class qc extends Ci {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            e ? r.enable(r.BLEND) : r.disable(r.BLEND), this.current = e, this.dirty = !1;
          }
        }
        class Zu extends Ci {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO];
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
          }
        }
        class ms extends Ci {
          getDefault() {
            return u.bf.transparent;
          }
          set(e) {
            const r = this.current;
            (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
          }
        }
        class $u extends Ci {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
          }
        }
        class Gc extends Ci {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            e ? r.enable(r.CULL_FACE) : r.disable(r.CULL_FACE), this.current = e, this.dirty = !1;
          }
        }
        class Mo extends Ci {
          getDefault() {
            return this.gl.BACK;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
          }
        }
        class Hu extends Ci {
          getDefault() {
            return this.gl.CCW;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
          }
        }
        class Ql extends Ci {
          getDefault() {
            return null;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
          }
        }
        class Dr extends Ci {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
          }
        }
        class Gh extends Ci {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
          }
        }
        class Zh extends Ci {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.bindFramebuffer(r.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class Xu extends Ci {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.bindRenderbuffer(r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class ya extends Ci {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.bindTexture(r.TEXTURE_2D, e), this.current = e, this.dirty = !1;
          }
        }
        class pl extends Ci {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.bindBuffer(r.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class ja extends Ci {
          getDefault() {
            return null;
          }
          set(e) {
            const r = this.gl;
            r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class gs extends Ci {
          getDefault() {
            return null;
          }
          set(e) {
            var r;
            if (e === this.current && !this.dirty) return;
            const c = this.gl;
            Wr(c) ? c.bindVertexArray(e) : (r = c.getExtension("OES_vertex_array_object")) === null || r === void 0 || r.bindVertexArrayOES(e), this.current = e, this.dirty = !1;
          }
        }
        class eu extends Ci {
          getDefault() {
            return 4;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.pixelStorei(r.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
          }
        }
        class Yu extends Ci {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
          }
        }
        class $s extends Ci {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
          }
        }
        class ys extends Ci {
          constructor(e, r) {
            super(e), this.context = e, this.parent = r;
          }
          getDefault() {
            return null;
          }
        }
        class Ao extends ys {
          setDirty() {
            this.dirty = !0;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const r = this.gl;
            r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
          }
        }
        class Zc extends ys {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const r = this.gl;
            r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class oi extends ys {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const r = this.gl;
            r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        const _s = "Framebuffer is not complete";
        class lf {
          constructor(e, r, c, f, _) {
            this.context = e, this.width = r, this.height = c;
            const w = e.gl, C = this.framebuffer = w.createFramebuffer();
            if (this.colorAttachment = new Ao(e, C), f) this.depthAttachment = _ ? new oi(e, C) : new Zc(e, C);
            else if (_) throw new Error("Stencil cannot be set without depth");
            if (w.checkFramebufferStatus(w.FRAMEBUFFER) !== w.FRAMEBUFFER_COMPLETE) throw new Error(_s);
          }
          destroy() {
            const e = this.context.gl, r = this.colorAttachment.get();
            if (r && e.deleteTexture(r), this.depthAttachment) {
              const c = this.depthAttachment.get();
              c && e.deleteRenderbuffer(c);
            }
            e.deleteFramebuffer(this.framebuffer);
          }
        }
        class er {
          constructor(e) {
            var r, c;
            if (this.gl = e, this.clearColor = new Fc(this), this.clearDepth = new Vc(this), this.clearStencil = new Fh(this), this.colorMask = new qu(this), this.depthMask = new dl(this), this.stencilMask = new So(this), this.stencilFunc = new Vh(this), this.stencilOp = new Gu(this), this.stencilTest = new qh(this), this.depthRange = new tp(this), this.depthTest = new To(this), this.depthFunc = new Jl(this), this.blend = new qc(this), this.blendFunc = new Zu(this), this.blendColor = new ms(this), this.blendEquation = new $u(this), this.cullFace = new Gc(this), this.cullFaceSide = new Mo(this), this.frontFace = new Hu(this), this.program = new Ql(this), this.activeTexture = new Dr(this), this.viewport = new Gh(this), this.bindFramebuffer = new Zh(this), this.bindRenderbuffer = new Xu(this), this.bindTexture = new ya(this), this.bindVertexBuffer = new pl(this), this.bindElementBuffer = new ja(this), this.bindVertexArray = new gs(this), this.pixelStoreUnpack = new eu(this), this.pixelStoreUnpackPremultiplyAlpha = new Yu(this), this.pixelStoreUnpackFlipY = new $s(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Wr(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const f = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (r = e.RGBA16F) !== null && r !== void 0 ? r : f?.RGBA16F_EXT, this.RGB16F = (c = e.RGB16F) !== null && c !== void 0 ? c : f?.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const f = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = f?.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(e, r) {
            return new ep(this, e, r);
          }
          createVertexBuffer(e, r, c) {
            return new gr(this, e, r, c);
          }
          createRenderbuffer(e, r, c) {
            const f = this.gl, _ = f.createRenderbuffer();
            return this.bindRenderbuffer.set(_), f.renderbufferStorage(f.RENDERBUFFER, e, r, c), this.bindRenderbuffer.set(null), _;
          }
          createFramebuffer(e, r, c, f) {
            return new lf(this, e, r, c, f);
          }
          clear({ color: e, depth: r, stencil: c }) {
            const f = this.gl;
            let _ = 0;
            e && (_ |= f.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), r !== void 0 && (_ |= f.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(r), this.depthMask.set(!0)), c !== void 0 && (_ |= f.STENCIL_BUFFER_BIT, this.clearStencil.set(c), this.stencilMask.set(255)), f.clear(_);
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(!1);
          }
          setColorMode(e) {
            u.bH(e.blendFunction, Fi.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
          }
          createVertexArray() {
            var e;
            return Wr(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES();
          }
          deleteVertexArray(e) {
            var r;
            return Wr(this.gl) ? this.gl.deleteVertexArray(e) : (r = this.gl.getExtension("OES_vertex_array_object")) === null || r === void 0 ? void 0 : r.deleteVertexArrayOES(e);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let vs;
        function xs(y, e, r, c, f) {
          const _ = y.context, w = y.transform, C = _.gl, P = y.useProgram("collisionBox"), R = [];
          let L = 0, j = 0;
          for (let ne = 0; ne < c.length; ne++) {
            const re = c[ne], ce = e.getTile(re).getBucket(r);
            if (!ce) continue;
            const oe = f ? ce.textCollisionBox : ce.iconCollisionBox, pe = ce.collisionCircleArray;
            pe.length > 0 && (R.push({ circleArray: pe, circleOffset: j, coord: re }), L += pe.length / 4, j = L), oe && P.draw(_, C.LINES, Wt.disabled, fi.disabled, y.colorModeForRenderPass(), Ut.disabled, Vu(y.transform), y.style.map.terrain && y.style.map.terrain.getTerrainData(re), w.getProjectionData({ overscaledTileID: re, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), r.id, oe.layoutVertexBuffer, oe.indexBuffer, oe.segments, null, y.transform.zoom, null, null, oe.collisionVertexBuffer);
          }
          if (!f || !R.length) return;
          const B = y.useProgram("collisionCircle"), V = new u.b$();
          V.resize(4 * L), V._trim();
          let $ = 0;
          for (const ne of R) for (let re = 0; re < ne.circleArray.length / 4; re++) {
            const ce = 4 * re, oe = ne.circleArray[ce + 0], pe = ne.circleArray[ce + 1], ye = ne.circleArray[ce + 2], ue = ne.circleArray[ce + 3];
            V.emplace($++, oe, pe, ye, ue, 0), V.emplace($++, oe, pe, ye, ue, 1), V.emplace($++, oe, pe, ye, ue, 2), V.emplace($++, oe, pe, ye, ue, 3);
          }
          (!vs || vs.length < 2 * L) && (vs = (function(ne) {
            const re = 2 * ne, ce = new u.c1();
            ce.resize(re), ce._trim();
            for (let oe = 0; oe < re; oe++) {
              const pe = 6 * oe;
              ce.uint16[pe + 0] = 4 * oe + 0, ce.uint16[pe + 1] = 4 * oe + 1, ce.uint16[pe + 2] = 4 * oe + 2, ce.uint16[pe + 3] = 4 * oe + 2, ce.uint16[pe + 4] = 4 * oe + 3, ce.uint16[pe + 5] = 4 * oe + 0;
            }
            return ce;
          })(L));
          const ie = _.createIndexBuffer(vs, !0), te = _.createVertexBuffer(V, u.c0.members, !0);
          for (const ne of R) {
            const re = Xd(y.transform);
            B.draw(_, C.TRIANGLES, Wt.disabled, fi.disabled, y.colorModeForRenderPass(), Ut.disabled, re, y.style.map.terrain && y.style.map.terrain.getTerrainData(ne.coord), null, r.id, te, ie, u.aM.simpleSegment(0, 2 * ne.circleOffset, ne.circleArray.length, ne.circleArray.length / 2), null, y.transform.zoom, null, null, null);
          }
          te.destroy(), ie.destroy();
        }
        const ip = u.ag(new Float32Array(16));
        function Ku(y, e, r, c, f, _) {
          const { horizontalAlign: w, verticalAlign: C } = u.aH(y);
          return new u.P((-(w - 0.5) * e / f + c[0]) * _, (-(C - 0.5) * r / f + c[1]) * _);
        }
        function fl(y, e, r, c, f, _) {
          const w = e.tileAnchorPoint.add(new u.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let C = c.mult(_);
            r || (C = C.rotate(-f));
            const P = w.add(C);
            return kn(P.x, P.y, e.pitchedLabelPlaneMatrix, e.getElevation).point;
          }
          if (r) {
            const C = Kn(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(y), P = Math.atan(C.y / C.x) + (C.x < 0 ? Math.PI : 0);
            return y.add(c.rotate(P));
          }
          return y.add(c);
        }
        function Wu(y, e, r, c, f, _, w, C, P, R, L, j) {
          const B = y.text.placedSymbolArray, V = y.text.dynamicLayoutVertexArray, $ = y.icon.dynamicLayoutVertexArray, ie = {};
          V.clear();
          for (let te = 0; te < B.length; te++) {
            const ne = B.get(te), re = ne.hidden || !ne.crossTileID || y.allowVerticalPlacement && !ne.placedOrientation ? null : c[ne.crossTileID];
            if (re) {
              const ce = new u.P(ne.anchorX, ne.anchorY), oe = { getElevation: j, width: f.width, height: f.height, pitchedLabelPlaneMatrix: _, pitchWithMap: r, transform: f, tileAnchorPoint: ce, translation: R, unwrappedTileID: L }, pe = r ? fo(ce.x, ce.y, oe) : Kn(ce.x, ce.y, oe), ye = ot(f.cameraToCenterDistance, pe.signedDistanceFromCamera);
              let ue = u.ap(y.textSizeData, C, ne) * ye / u.aB;
              r && (ue *= y.tilePixelRatio / w);
              const { width: we, height: Oe, anchor: ze, textOffset: Pe, textBoxScale: Le } = re, lt = Ku(ze, we, Oe, Pe, Le, ue), ct = f.getPitchedTextCorrection(ce.x + R[0], ce.y + R[1], L), We = fl(pe.point, oe, e, lt, -f.bearingInRadians, ct), At = y.allowVerticalPlacement && ne.placedOrientation === u.ao.vertical ? Math.PI / 2 : 0;
              for (let ai = 0; ai < ne.numGlyphs; ai++) u.av(V, We, At);
              P && ne.associatedIconIndex >= 0 && (ie[ne.associatedIconIndex] = { shiftedAnchor: We, angle: At });
            } else Ba(ne.numGlyphs, V);
          }
          if (P) {
            $.clear();
            const te = y.icon.placedSymbolArray;
            for (let ne = 0; ne < te.length; ne++) {
              const re = te.get(ne);
              if (re.hidden) Ba(re.numGlyphs, $);
              else {
                const ce = ie[ne];
                if (ce) for (let oe = 0; oe < re.numGlyphs; oe++) u.av($, ce.shiftedAnchor, ce.angle);
                else Ba(re.numGlyphs, $);
              }
            }
            y.icon.dynamicLayoutVertexBuffer.updateData($);
          }
          y.text.dynamicLayoutVertexBuffer.updateData(V);
        }
        function Ju(y, e, r) {
          return r.iconsInText && e ? "symbolTextAndIcon" : y ? "symbolSDF" : "symbolIcon";
        }
        function ml(y, e, r, c, f, _, w, C, P, R, L, j, B) {
          const V = y.context, $ = V.gl, ie = y.transform, te = C === "map", ne = P === "map", re = C !== "viewport" && r.layout.get("symbol-placement") !== "point", ce = te && !ne && !re, oe = !r.layout.get("symbol-sort-key").isConstant();
          let pe = !1;
          const ye = y.getDepthModeForSublayer(0, Wt.ReadOnly), ue = r._unevaluatedLayout.hasValue("text-variable-anchor") || r._unevaluatedLayout.hasValue("text-variable-anchor-offset"), we = [], Oe = ie.getCircleRadiusCorrection();
          for (const ze of c) {
            const Pe = e.getTile(ze), Le = Pe.getBucket(r);
            if (!Le) continue;
            const lt = f ? Le.text : Le.icon;
            if (!lt || !lt.segments.get().length || !lt.hasVisibleVertices) continue;
            const ct = lt.programConfigurations.get(r.id), We = f || Le.sdfIcons, At = f ? Le.textSizeData : Le.iconSizeData, ai = ne || ie.pitch !== 0, zi = y.useProgram(Ju(We, f, Le), ct), qi = u.an(At, ie.zoom), Ni = y.style.map.terrain && y.style.map.terrain.getTerrainData(ze);
            let un, mn, Qt, Xi, Bn = [0, 0], gn = null;
            if (f) mn = Pe.glyphAtlasTexture, Qt = $.LINEAR, un = Pe.glyphAtlasTexture.size, Le.iconsInText && (Bn = Pe.imageAtlasTexture.size, gn = Pe.imageAtlasTexture, Xi = ai || y.options.rotating || y.options.zooming || At.kind === "composite" || At.kind === "camera" ? $.LINEAR : $.NEAREST);
            else {
              const Nn = r.layout.get("icon-size").constantOr(0) !== 1 || Le.iconsNeedLinear;
              mn = Pe.imageAtlasTexture, Qt = We || y.options.rotating || y.options.zooming || Nn || ai ? $.LINEAR : $.NEAREST, un = Pe.imageAtlasTexture.size;
            }
            const ta = u.aC(Pe, 1, y.transform.zoom), pa = In(te, y.transform, ta), sr = u.L();
            u.aq(sr, pa);
            const Qs = ci(ne, te, y.transform, ta), Is = u.aD(ie, Pe, _, w), hu = ie.getProjectionData({ overscaledTileID: ze, applyGlobeMatrix: !B, applyTerrainMatrix: !0 }), Tl = ue && Le.hasTextData(), No = r.layout.get("icon-text-fit") !== "none" && Tl && Le.hasIconData();
            if (re) {
              const Nn = y.style.map.terrain ? (Sr, Un) => y.style.map.terrain.getElevation(ze, Sr, Un) : null, jn = r.layout.get("text-rotation-alignment") === "map";
              dn(Le, y, f, pa, sr, ne, R, jn, ze.toUnwrapped(), ie.width, ie.height, Is, Nn);
            }
            const jo = f && ue || No, Ga = re || jo ? ip : ne ? pa : y.transform.clipSpaceToPixelsMatrix, jr = We && r.paint.get(f ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let va;
            va = We ? Le.iconsInText ? Wd(At.kind, qi, ce, ne, re, jo, y, Ga, Qs, Is, un, Bn, Oe) : Nh(At.kind, qi, ce, ne, re, jo, y, Ga, Qs, Is, f, un, 0, Oe) : Wl(At.kind, qi, ce, ne, re, jo, y, Ga, Qs, Is, f, un, Oe);
            const eo = { program: zi, buffers: lt, uniformValues: va, projectionData: hu, atlasTexture: mn, atlasTextureIcon: gn, atlasInterpolation: Qt, atlasInterpolationIcon: Xi, isSDF: We, hasHalo: jr };
            if (oe && Le.canOverlap) {
              pe = !0;
              const Nn = lt.segments.get();
              for (const jn of Nn) we.push({ segments: new u.aM([jn]), sortKey: jn.sortKey, state: eo, terrainData: Ni });
            } else we.push({ segments: lt.segments, sortKey: 0, state: eo, terrainData: Ni });
          }
          pe && we.sort(((ze, Pe) => ze.sortKey - Pe.sortKey));
          for (const ze of we) {
            const Pe = ze.state;
            if (V.activeTexture.set($.TEXTURE0), Pe.atlasTexture.bind(Pe.atlasInterpolation, $.CLAMP_TO_EDGE), Pe.atlasTextureIcon && (V.activeTexture.set($.TEXTURE1), Pe.atlasTextureIcon && Pe.atlasTextureIcon.bind(Pe.atlasInterpolationIcon, $.CLAMP_TO_EDGE)), Pe.isSDF) {
              const Le = Pe.uniformValues;
              Pe.hasHalo && (Le.u_is_halo = 1, tu(Pe.buffers, ze.segments, r, y, Pe.program, ye, L, j, Le, Pe.projectionData, ze.terrainData)), Le.u_is_halo = 0;
            }
            tu(Pe.buffers, ze.segments, r, y, Pe.program, ye, L, j, Pe.uniformValues, Pe.projectionData, ze.terrainData);
          }
        }
        function tu(y, e, r, c, f, _, w, C, P, R, L) {
          const j = c.context;
          f.draw(j, j.gl.TRIANGLES, _, w, C, Ut.backCCW, P, L, R, r.id, y.layoutVertexBuffer, y.indexBuffer, e, r.paint, c.transform.zoom, y.programConfigurations.get(r.id), y.dynamicLayoutVertexBuffer, y.opacityVertexBuffer);
        }
        function tr(y, e, r, c, f) {
          const _ = y.context, w = _.gl, C = fi.disabled, P = new Fi([w.ONE, w.ONE], u.bf.transparent, [!0, !0, !0, !0]), R = e.getBucket(r);
          if (!R) return;
          const L = c.key;
          let j = r.heatmapFbos.get(L);
          j || (j = bs(_, e.tileSize, e.tileSize), r.heatmapFbos.set(L, j)), _.bindFramebuffer.set(j.framebuffer), _.viewport.set([0, 0, e.tileSize, e.tileSize]), _.clear({ color: u.bf.transparent });
          const B = R.programConfigurations.get(r.id), V = y.useProgram("heatmap", B, !f), $ = y.transform.getProjectionData({ overscaledTileID: e.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), ie = y.style.map.terrain.getTerrainData(c);
          V.draw(_, w.TRIANGLES, Wt.disabled, C, P, Ut.disabled, cl(e, y.transform.zoom, r.paint.get("heatmap-intensity"), 1), ie, $, r.id, R.layoutVertexBuffer, R.indexBuffer, R.segments, r.paint, y.transform.zoom, B);
        }
        function gl(y, e, r, c, f) {
          const _ = y.context, w = _.gl, C = y.transform;
          _.setColorMode(y.colorModeForRenderPass());
          const P = Eo(_, e), R = r.key, L = e.heatmapFbos.get(R);
          if (!L) return;
          _.activeTexture.set(w.TEXTURE0), w.bindTexture(w.TEXTURE_2D, L.colorAttachment.get()), _.activeTexture.set(w.TEXTURE1), P.bind(w.LINEAR, w.CLAMP_TO_EDGE);
          const j = C.getProjectionData({ overscaledTileID: r, applyTerrainMatrix: f, applyGlobeMatrix: !c });
          y.useProgram("heatmapTexture").draw(_, w.TRIANGLES, Wt.disabled, fi.disabled, y.colorModeForRenderPass(), Ut.disabled, Lh(y, e, 0, 1), null, j, e.id, y.rasterBoundsBuffer, y.quadTriangleIndexBuffer, y.rasterBoundsSegments, e.paint, C.zoom), L.destroy(), e.heatmapFbos.delete(R);
        }
        function bs(y, e, r) {
          var c, f;
          const _ = y.gl, w = _.createTexture();
          _.bindTexture(_.TEXTURE_2D, w), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, _.CLAMP_TO_EDGE), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, _.CLAMP_TO_EDGE), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MIN_FILTER, _.LINEAR), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MAG_FILTER, _.LINEAR);
          const C = (c = y.HALF_FLOAT) !== null && c !== void 0 ? c : _.UNSIGNED_BYTE, P = (f = y.RGBA16F) !== null && f !== void 0 ? f : _.RGBA;
          _.texImage2D(_.TEXTURE_2D, 0, P, e, r, 0, _.RGBA, C, null);
          const R = y.createFramebuffer(e, r, !1, !1);
          return R.colorAttachment.set(w), R;
        }
        function Eo(y, e) {
          return e.colorRampTexture || (e.colorRampTexture = new u.T(y, e.colorRamp, y.gl.RGBA)), e.colorRampTexture;
        }
        function Hs(y, e, r, c, f) {
          if (!r || !c || !c.imageAtlas) return;
          const _ = c.imageAtlas.patternPositions;
          let w = _[r.to.toString()], C = _[r.from.toString()];
          if (!w && C && (w = C), !C && w && (C = w), !w || !C) {
            const P = f.getPaintProperty(e);
            w = _[P], C = _[P];
          }
          w && C && y.setConstantPatternPositions(w, C);
        }
        function Ua(y, e, r, c, f, _, w, C) {
          const P = y.context.gl, R = "fill-pattern", L = r.paint.get(R), j = L && L.constantOr(1), B = r.getCrossfadeParameters();
          let V, $, ie, te, ne;
          const re = y.transform, ce = r.paint.get("fill-translate"), oe = r.paint.get("fill-translate-anchor");
          w ? ($ = j && !r.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", V = P.LINES) : ($ = j ? "fillPattern" : "fill", V = P.TRIANGLES);
          const pe = L.constantOr(null);
          for (const ye of c) {
            const ue = e.getTile(ye);
            if (j && !ue.patternsLoaded()) continue;
            const we = ue.getBucket(r);
            if (!we) continue;
            const Oe = we.programConfigurations.get(r.id), ze = y.useProgram($, Oe), Pe = y.style.map.terrain && y.style.map.terrain.getTerrainData(ye);
            j && (y.context.activeTexture.set(P.TEXTURE0), ue.imageAtlasTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE), Oe.updatePaintBuffers(B)), Hs(Oe, R, pe, ue, r);
            const Le = re.getProjectionData({ overscaledTileID: ye, applyGlobeMatrix: !C, applyTerrainMatrix: !0 }), lt = u.aD(re, ue, ce, oe);
            if (w) {
              te = we.indexBuffer2, ne = we.segments2;
              const We = [P.drawingBufferWidth, P.drawingBufferHeight];
              ie = $ === "fillOutlinePattern" && j ? Yl(y, B, ue, We, lt) : Fu(We, lt);
            } else te = we.indexBuffer, ne = we.segments, ie = j ? xo(y, B, ue, lt) : { u_fill_translate: lt };
            const ct = y.stencilModeForClipping(ye);
            ze.draw(y.context, V, f, ct, _, Ut.backCCW, ie, Pe, Le, r.id, we.layoutVertexBuffer, te, ne, r.paint, y.transform.zoom, Oe);
          }
        }
        function ir(y, e, r, c, f, _, w, C) {
          const P = y.context, R = P.gl, L = "fill-extrusion-pattern", j = r.paint.get(L), B = j.constantOr(1), V = r.getCrossfadeParameters(), $ = r.paint.get("fill-extrusion-opacity"), ie = j.constantOr(null), te = y.transform;
          for (const ne of c) {
            const re = e.getTile(ne), ce = re.getBucket(r);
            if (!ce) continue;
            const oe = y.style.map.terrain && y.style.map.terrain.getTerrainData(ne), pe = ce.programConfigurations.get(r.id), ye = y.useProgram(B ? "fillExtrusionPattern" : "fillExtrusion", pe);
            B && (y.context.activeTexture.set(R.TEXTURE0), re.imageAtlasTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE), pe.updatePaintBuffers(V));
            const ue = te.getProjectionData({ overscaledTileID: ne, applyGlobeMatrix: !C, applyTerrainMatrix: !0 });
            Hs(pe, L, ie, re, r);
            const we = u.aD(te, re, r.paint.get("fill-extrusion-translate"), r.paint.get("fill-extrusion-translate-anchor")), Oe = r.paint.get("fill-extrusion-vertical-gradient"), ze = B ? Dh(y, Oe, $, we, ne, V, re) : Jr(y, Oe, $, we);
            ye.draw(P, P.gl.TRIANGLES, f, _, w, Ut.backCCW, ze, oe, ue, r.id, ce.layoutVertexBuffer, ce.indexBuffer, ce.segments, r.paint, y.transform.zoom, pe, y.style.map.terrain && ce.centroidVertexBuffer);
          }
        }
        function nr(y, e, r, c, f, _, w, C, P) {
          var R;
          const L = y.style.projection, j = y.context, B = y.transform, V = j.gl, $ = [`#define NUM_ILLUMINATION_SOURCES ${r.paint.get("hillshade-highlight-color").values.length}`], ie = y.useProgram("hillshade", null, !1, $), te = !y.options.moving;
          for (const ne of c) {
            const re = e.getTile(ne), ce = re.fbo;
            if (!ce) continue;
            const oe = L.getMeshFromTileID(j, ne.canonical, C, !0, "raster"), pe = (R = y.style.map.terrain) === null || R === void 0 ? void 0 : R.getTerrainData(ne);
            j.activeTexture.set(V.TEXTURE0), V.bindTexture(V.TEXTURE_2D, ce.colorAttachment.get());
            const ye = B.getProjectionData({ overscaledTileID: ne, aligned: te, applyGlobeMatrix: !P, applyTerrainMatrix: !0 });
            ie.draw(j, V.TRIANGLES, _, f[ne.overscaledZ], w, Ut.backCCW, of(y, re, r), pe, ye, r.id, oe.vertexBuffer, oe.indexBuffer, oe.segments);
          }
        }
        function Lr(y, e, r, c, f, _, w, C, P) {
          var R;
          const L = y.style.projection, j = y.context, B = y.transform, V = j.gl, $ = y.useProgram("colorRelief"), ie = !y.options.moving;
          let te = !0, ne = 0;
          for (const re of c) {
            const ce = e.getTile(re), oe = ce.dem;
            if (te) {
              const ze = V.getParameter(V.MAX_TEXTURE_SIZE), { elevationTexture: Pe, colorTexture: Le } = r.getColorRampTextures(j, ze, oe.getUnpackVector());
              j.activeTexture.set(V.TEXTURE1), Pe.bind(V.NEAREST, V.CLAMP_TO_EDGE), j.activeTexture.set(V.TEXTURE4), Le.bind(V.LINEAR, V.CLAMP_TO_EDGE), te = !1, ne = Pe.size[0];
            }
            if (!oe || !oe.data) continue;
            const pe = oe.stride, ye = oe.getPixels();
            if (j.activeTexture.set(V.TEXTURE0), j.pixelStoreUnpackPremultiplyAlpha.set(!1), ce.demTexture = ce.demTexture || y.getTileTexture(pe), ce.demTexture) {
              const ze = ce.demTexture;
              ze.update(ye, { premultiply: !1 }), ze.bind(V.LINEAR, V.CLAMP_TO_EDGE);
            } else ce.demTexture = new u.T(j, ye, V.RGBA, { premultiply: !1 }), ce.demTexture.bind(V.LINEAR, V.CLAMP_TO_EDGE);
            const ue = L.getMeshFromTileID(j, re.canonical, C, !0, "raster"), we = (R = y.style.map.terrain) === null || R === void 0 ? void 0 : R.getTerrainData(re), Oe = B.getProjectionData({ overscaledTileID: re, aligned: ie, applyGlobeMatrix: !P, applyTerrainMatrix: !0 });
            $.draw(j, V.TRIANGLES, _, f[re.overscaledZ], w, Ut.backCCW, Oh(r, ce.dem, ne), we, Oe, r.id, ue.vertexBuffer, ue.indexBuffer, ue.segments);
          }
        }
        const yr = [new u.P(0, 0), new u.P(u.$, 0), new u.P(u.$, u.$), new u.P(0, u.$)];
        function Fa(y, e, r, c, f, _, w, C, P = !1, R = !1) {
          const L = c[c.length - 1].overscaledZ, j = y.context, B = j.gl, V = y.useProgram("raster"), $ = y.transform, ie = y.style.projection, te = y.colorModeForRenderPass(), ne = !y.options.moving;
          for (const re of c) {
            const ce = y.getDepthModeForSublayer(re.overscaledZ - L, r.paint.get("raster-opacity") === 1 ? Wt.ReadWrite : Wt.ReadOnly, B.LESS), oe = e.getTile(re);
            oe.registerFadeDuration(r.paint.get("raster-fade-duration"));
            const pe = e.findLoadedParent(re, 0), ye = e.findLoadedSibling(re), ue = $c(oe, pe || ye || null, e, r, y.transform, y.style.map.terrain);
            let we, Oe;
            const ze = r.paint.get("raster-resampling") === "nearest" ? B.NEAREST : B.LINEAR;
            j.activeTexture.set(B.TEXTURE0), oe.texture.bind(ze, B.CLAMP_TO_EDGE, B.LINEAR_MIPMAP_NEAREST), j.activeTexture.set(B.TEXTURE1), pe ? (pe.texture.bind(ze, B.CLAMP_TO_EDGE, B.LINEAR_MIPMAP_NEAREST), we = Math.pow(2, pe.tileID.overscaledZ - oe.tileID.overscaledZ), Oe = [oe.tileID.canonical.x * we % 1, oe.tileID.canonical.y * we % 1]) : oe.texture.bind(ze, B.CLAMP_TO_EDGE, B.LINEAR_MIPMAP_NEAREST), oe.texture.useMipmap && j.extTextureFilterAnisotropic && y.transform.pitch > 20 && B.texParameterf(B.TEXTURE_2D, j.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, j.extTextureFilterAnisotropicMax);
            const Pe = y.style.map.terrain && y.style.map.terrain.getTerrainData(re), Le = $.getProjectionData({ overscaledTileID: re, aligned: ne, applyGlobeMatrix: !R, applyTerrainMatrix: !0 }), lt = hl(Oe || [0, 0], we || 1, ue, r, C), ct = ie.getMeshFromTileID(j, re.canonical, _, w, "raster");
            V.draw(j, B.TRIANGLES, ce, f ? f[re.overscaledZ] : fi.disabled, te, P ? Ut.frontCCW : Ut.backCCW, lt, Pe, Le, r.id, ct.vertexBuffer, ct.indexBuffer, ct.segments);
          }
        }
        function $c(y, e, r, c, f, _) {
          const w = c.paint.get("raster-fade-duration");
          if (!_ && w > 0) {
            const C = he.now(), P = (C - y.timeAdded) / w, R = e ? (C - e.timeAdded) / w : -1, L = r.getSource(), j = Mt(f, { tileSize: L.tileSize, roundZoom: L.roundZoom }), B = !e || Math.abs(e.tileID.overscaledZ - j) > Math.abs(y.tileID.overscaledZ - j), V = B && y.refreshedUponExpiration ? 1 : u.ah(B ? P : 1 - R, 0, 1);
            return y.refreshedUponExpiration && P >= 1 && (y.refreshedUponExpiration = !1), e ? { opacity: 1, mix: 1 - V } : { opacity: V, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const Hc = new u.bf(1, 0, 0, 1), Xc = new u.bf(0, 1, 0, 1), Qu = new u.bf(0, 0, 1, 1), Qn = new u.bf(1, 0, 1, 1), ln = new u.bf(0, 1, 1, 1);
        function wi(y, e, r, c) {
          On(y, 0, e + r / 2, y.transform.width, r, c);
        }
        function Vi(y, e, r, c) {
          On(y, e - r / 2, 0, r, y.transform.height, c);
        }
        function On(y, e, r, c, f, _) {
          const w = y.context, C = w.gl;
          C.enable(C.SCISSOR_TEST), C.scissor(e * y.pixelRatio, r * y.pixelRatio, c * y.pixelRatio, f * y.pixelRatio), w.clear({ color: _ }), C.disable(C.SCISSOR_TEST);
        }
        function ar(y, e, r) {
          const c = y.context, f = c.gl, _ = y.useProgram("debug"), w = Wt.disabled, C = fi.disabled, P = y.colorModeForRenderPass(), R = "$debug", L = y.style.map.terrain && y.style.map.terrain.getTerrainData(r);
          c.activeTexture.set(f.TEXTURE0);
          const j = e.getTileByID(r.key).latestRawTileData, B = Math.floor((j && j.byteLength || 0) / 1024), V = e.getTile(r).tileSize, $ = 512 / Math.min(V, 512) * (r.overscaledZ / y.transform.zoom) * 0.5;
          let ie = r.canonical.toString();
          r.overscaledZ !== r.canonical.z && (ie += ` => ${r.overscaledZ}`), (function(ne, re) {
            ne.initDebugOverlayCanvas();
            const ce = ne.debugOverlayCanvas, oe = ne.context.gl, pe = ne.debugOverlayCanvas.getContext("2d");
            pe.clearRect(0, 0, ce.width, ce.height), pe.shadowColor = "white", pe.shadowBlur = 2, pe.lineWidth = 1.5, pe.strokeStyle = "white", pe.textBaseline = "top", pe.font = "bold 36px Open Sans, sans-serif", pe.fillText(re, 5, 5), pe.strokeText(re, 5, 5), ne.debugOverlayTexture.update(ce), ne.debugOverlayTexture.bind(oe.LINEAR, oe.CLAMP_TO_EDGE);
          })(y, `${ie} ${B}kB`);
          const te = y.transform.getProjectionData({ overscaledTileID: r, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
          _.draw(c, f.TRIANGLES, w, C, Fi.alphaBlended, Ut.disabled, bo(u.bf.transparent, $), null, te, R, y.debugBuffer, y.quadTriangleIndexBuffer, y.debugSegments), _.draw(c, f.LINE_STRIP, w, C, P, Ut.disabled, bo(u.bf.red), L, te, R, y.debugBuffer, y.tileBorderIndexBuffer, y.debugSegments);
        }
        function Qr(y, e, r, c) {
          const { isRenderingGlobe: f } = c, _ = y.context, w = _.gl, C = y.transform, P = y.colorModeForRenderPass(), R = y.getDepthModeFor3D(), L = y.useProgram("terrain");
          _.bindFramebuffer.set(null), _.viewport.set([0, 0, y.width, y.height]);
          for (const j of r) {
            const B = e.getTerrainMesh(j.tileID), V = y.renderToTexture.getTexture(j), $ = e.getTerrainData(j.tileID);
            _.activeTexture.set(w.TEXTURE0), w.bindTexture(w.TEXTURE_2D, V.texture);
            const ie = e.getMeshFrameDelta(C.zoom), te = C.calculateFogMatrix(j.tileID.toUnwrapped()), ne = Oc(ie, te, y.style.sky, C.pitch, f), re = C.getProjectionData({ overscaledTileID: j.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
            L.draw(_, w.TRIANGLES, R, fi.disabled, P, Ut.backCCW, ne, $, re, "terrain", B.vertexBuffer, B.indexBuffer, B.segments);
          }
        }
        function iu(y, e) {
          if (!e.mesh) {
            const r = new u.aL();
            r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(1, 1), r.emplaceBack(-1, 1);
            const c = new u.aN();
            c.emplaceBack(0, 1, 2), c.emplaceBack(0, 2, 3), e.mesh = new _o(y.createVertexBuffer(r, Zs.members), y.createIndexBuffer(c), u.aM.simpleSegment(0, 0, r.length, c.length));
          }
          return e.mesh;
        }
        class $h {
          constructor(e, r) {
            this.context = new er(e), this.transform = r, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: u.ag(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = ri.maxUnderzooming + ri.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new rl();
          }
          resize(e, r, c) {
            if (this.width = Math.floor(e * c), this.height = Math.floor(r * c), this.pixelRatio = c, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const f of this.style._order) this.style._layers[f].resize();
          }
          setup() {
            const e = this.context, r = new u.aL();
            r.emplaceBack(0, 0), r.emplaceBack(u.$, 0), r.emplaceBack(0, u.$), r.emplaceBack(u.$, u.$), this.tileExtentBuffer = e.createVertexBuffer(r, Zs.members), this.tileExtentSegments = u.aM.simpleSegment(0, 0, 4, 2);
            const c = new u.aL();
            c.emplaceBack(0, 0), c.emplaceBack(u.$, 0), c.emplaceBack(0, u.$), c.emplaceBack(u.$, u.$), this.debugBuffer = e.createVertexBuffer(c, Zs.members), this.debugSegments = u.aM.simpleSegment(0, 0, 4, 5);
            const f = new u.c6();
            f.emplaceBack(0, 0, 0, 0), f.emplaceBack(u.$, 0, u.$, 0), f.emplaceBack(0, u.$, 0, u.$), f.emplaceBack(u.$, u.$, u.$, u.$), this.rasterBoundsBuffer = e.createVertexBuffer(f, rf.members), this.rasterBoundsSegments = u.aM.simpleSegment(0, 0, 4, 2);
            const _ = new u.aL();
            _.emplaceBack(0, 0), _.emplaceBack(u.$, 0), _.emplaceBack(0, u.$), _.emplaceBack(u.$, u.$), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(_, Zs.members), this.rasterBoundsSegmentsPosOnly = u.aM.simpleSegment(0, 0, 4, 5);
            const w = new u.aL();
            w.emplaceBack(0, 0), w.emplaceBack(1, 0), w.emplaceBack(0, 1), w.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(w, Zs.members), this.viewportSegments = u.aM.simpleSegment(0, 0, 4, 2);
            const C = new u.c7();
            C.emplaceBack(0), C.emplaceBack(1), C.emplaceBack(3), C.emplaceBack(2), C.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(C);
            const P = new u.aN();
            P.emplaceBack(1, 0, 2), P.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(P);
            const R = this.context.gl;
            this.stencilClearMode = new fi({ func: R.ALWAYS, mask: 0 }, 0, 255, R.ZERO, R.ZERO, R.ZERO), this.tileExtentMesh = new _o(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const e = this.context, r = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const c = u.L();
            u.bY(c, 0, this.width, this.height, 0, 0, 1), u.N(c, c, [r.drawingBufferWidth, r.drawingBufferHeight, 0]);
            const f = { mainMatrix: c, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: c };
            this.useProgram("clippingMask", null, !0).draw(e, r.TRIANGLES, Wt.disabled, this.stencilClearMode, Fi.disabled, Ut.disabled, null, null, f, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(e, r, c) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !r || !r.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + r.length > 256 && this.clearStencil();
            const f = this.context;
            f.setColorMode(Fi.disabled), f.setDepthMode(Wt.disabled);
            const _ = {};
            for (const w of r) _[w.key] = this.nextStencilID++;
            this._renderTileMasks(_, r, c, !0), this._renderTileMasks(_, r, c, !1), this._tileClippingMaskIDs = _;
          }
          _renderTileMasks(e, r, c, f) {
            const _ = this.context, w = _.gl, C = this.style.projection, P = this.transform, R = this.useProgram("clippingMask");
            for (const L of r) {
              const j = e[L.key], B = this.style.map.terrain && this.style.map.terrain.getTerrainData(L), V = C.getMeshFromTileID(this.context, L.canonical, f, !0, "stencil"), $ = P.getProjectionData({ overscaledTileID: L, applyGlobeMatrix: !c, applyTerrainMatrix: !0 });
              R.draw(_, w.TRIANGLES, Wt.disabled, new fi({ func: w.ALWAYS, mask: 0 }, j, 255, w.KEEP, w.KEEP, w.REPLACE), Fi.disabled, c ? Ut.disabled : Ut.backCCW, null, B, $, "$clipping", V.vertexBuffer, V.indexBuffer, V.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context, r = e.gl, c = this.style.projection, f = this.transform, _ = this.useProgram("depth"), w = this.getDepthModeFor3D(), C = Ae(f, { tileSize: f.tileSize });
            for (const P of C) {
              const R = this.style.map.terrain && this.style.map.terrain.getTerrainData(P), L = c.getMeshFromTileID(this.context, P.canonical, !0, !0, "raster"), j = f.getProjectionData({ overscaledTileID: P, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
              _.draw(e, r.TRIANGLES, w, fi.disabled, Fi.disabled, Ut.backCCW, null, R, j, "$clipping", L.vertexBuffer, L.indexBuffer, L.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++, r = this.context.gl;
            return new fi({ func: r.NOTEQUAL, mask: 255 }, e, 255, r.KEEP, r.KEEP, r.REPLACE);
          }
          stencilModeForClipping(e) {
            const r = this.context.gl;
            return new fi({ func: r.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, r.KEEP, r.KEEP, r.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const r = this.context.gl, c = e.sort(((w, C) => C.overscaledZ - w.overscaledZ)), f = c[c.length - 1].overscaledZ, _ = c[0].overscaledZ - f + 1;
            if (_ > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + _ > 256 && this.clearStencil();
              const w = {};
              for (let C = 0; C < _; C++) w[C + f] = new fi({ func: r.GEQUAL, mask: 255 }, C + this.nextStencilID, 255, r.KEEP, r.KEEP, r.REPLACE);
              return this.nextStencilID += _, [w, c];
            }
            return [{ [f]: fi.disabled }, c];
          }
          stencilConfigForOverlapTwoPass(e) {
            const r = this.context.gl, c = e.sort(((w, C) => C.overscaledZ - w.overscaledZ)), f = c[c.length - 1].overscaledZ, _ = c[0].overscaledZ - f + 1;
            if (this.clearStencil(), _ > 1) {
              const w = {}, C = {};
              for (let P = 0; P < _; P++) w[P + f] = new fi({ func: r.GREATER, mask: 255 }, _ + 1 + P, 255, r.KEEP, r.KEEP, r.REPLACE), C[P + f] = new fi({ func: r.GREATER, mask: 255 }, 1 + P, 255, r.KEEP, r.KEEP, r.REPLACE);
              return this.nextStencilID = 2 * _ + 1, [w, C, c];
            }
            return this.nextStencilID = 3, [{ [f]: new fi({ func: r.GREATER, mask: 255 }, 2, 255, r.KEEP, r.KEEP, r.REPLACE) }, { [f]: new fi({ func: r.GREATER, mask: 255 }, 1, 255, r.KEEP, r.KEEP, r.REPLACE) }, c];
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new Fi([e.CONSTANT_COLOR, e.ONE], new u.bf(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Fi.unblended : Fi.alphaBlended;
          }
          getDepthModeForSublayer(e, r, c) {
            if (!this.opaquePassEnabledForLayer()) return Wt.disabled;
            const f = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new Wt(c || this.context.gl.LEQUAL, r, [f, f]);
          }
          getDepthModeFor3D() {
            return new Wt(this.context.gl.LEQUAL, Wt.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e, r) {
            var c, f;
            this.style = e, this.options = r, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(he.now()), this.imageManager.beginFrame();
            const _ = this.style._order, w = this.style.sourceCaches, C = {}, P = {}, R = {}, L = { isRenderingToTexture: !1, isRenderingGlobe: ((c = e.projection) === null || c === void 0 ? void 0 : c.transitionState) > 0 };
            for (const B in w) {
              const V = w[B];
              V.used && V.prepare(this.context), C[B] = V.getVisibleCoordinates(!1), P[B] = C[B].slice().reverse(), R[B] = V.getVisibleCoordinates(!0).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let B = 0; B < _.length; B++) if (this.style._layers[_[B]].is3D()) {
              this.opaquePassCutoff = B;
              break;
            }
            this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const B of _) {
              const V = this.style._layers[B];
              if (!V.hasOffscreenPass() || V.isHidden(this.transform.zoom)) continue;
              const $ = P[V.source];
              (V.type === "custom" || $.length) && this.renderLayer(this, w[V.source], V, $, L);
            }
            if ((f = this.style.projection) === null || f === void 0 || f.updateGPUdependent({ context: this.context, useProgram: (B) => this.useProgram(B) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: r.showOverdrawInspector ? u.bf.black : u.bf.transparent, depth: 1 }), this.clearStencil(), this.style.sky && (function(B, V) {
              const $ = B.context, ie = $.gl, te = ((ye, ue, we) => {
                const Oe = Math.cos(ue.rollInRadians), ze = Math.sin(ue.rollInRadians), Pe = me(ue), Le = ue.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition;
                return { u_sky_color: ye.properties.get("sky-color"), u_horizon_color: ye.properties.get("horizon-color"), u_horizon: [(ue.width / 2 - Pe * ze) * we, (ue.height / 2 + Pe * Oe) * we], u_horizon_normal: [-ze, Oe], u_sky_horizon_blend: ye.properties.get("sky-horizon-blend") * ue.height / 2 * we, u_sky_blend: Le };
              })(V, B.style.map.transform, B.pixelRatio), ne = new Wt(ie.LEQUAL, Wt.ReadWrite, [0, 1]), re = fi.disabled, ce = B.colorModeForRenderPass(), oe = B.useProgram("sky"), pe = iu($, V);
              oe.draw($, ie.TRIANGLES, ne, re, ce, Ut.disabled, te, null, void 0, "sky", pe.vertexBuffer, pe.indexBuffer, pe.segments);
            })(this, this.style.sky), this._showOverdrawInspector = r.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = _.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const B = this.style._layers[_[this.currentLayer]], V = w[B.source], $ = C[B.source];
              this._renderTileClippingMasks(B, $, !1), this.renderLayer(this, V, B, $, L);
            }
            this.renderPass = "translucent";
            let j = !1;
            for (this.currentLayer = 0; this.currentLayer < _.length; this.currentLayer++) {
              const B = this.style._layers[_[this.currentLayer]], V = w[B.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(B, L)) continue;
              this.opaquePassEnabledForLayer() || j || (j = !0, L.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const $ = (B.type === "symbol" ? R : P)[B.source];
              this._renderTileClippingMasks(B, C[B.source], !!this.renderToTexture), this.renderLayer(this, V, B, $, L);
            }
            if (L.isRenderingGlobe && (function(B, V, $) {
              const ie = B.context, te = ie.gl, ne = B.useProgram("atmosphere"), re = new Wt(te.LEQUAL, Wt.ReadOnly, [0, 1]), ce = B.transform, oe = (function(Le, lt) {
                const ct = Le.properties.get("position"), We = [-ct.x, -ct.y, -ct.z], At = u.ag(new Float64Array(16));
                return Le.properties.get("anchor") === "map" && (u.b6(At, At, lt.rollInRadians), u.b7(At, At, -lt.pitchInRadians), u.b6(At, At, lt.bearingInRadians), u.b7(At, At, lt.center.lat * Math.PI / 180), u.bz(At, At, -lt.center.lng * Math.PI / 180)), u.c5(We, We, At), We;
              })($, B.transform), pe = ce.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), ye = V.properties.get("atmosphere-blend") * pe.projectionTransition;
              if (ye === 0) return;
              const ue = Hl(ce.worldSize, ce.center.lat), we = ce.inverseProjectionMatrix, Oe = new Float64Array(4);
              Oe[3] = 1, u.aw(Oe, Oe, ce.modelViewProjectionMatrix), Oe[0] /= Oe[3], Oe[1] /= Oe[3], Oe[2] /= Oe[3], Oe[3] = 1, u.aw(Oe, Oe, we), Oe[0] /= Oe[3], Oe[1] /= Oe[3], Oe[2] /= Oe[3], Oe[3] = 1;
              const ze = /* @__PURE__ */ ((Le, lt, ct, We, At) => ({ u_sun_pos: Le, u_atmosphere_blend: lt, u_globe_position: ct, u_globe_radius: We, u_inv_proj_matrix: At }))(oe, ye, [Oe[0], Oe[1], Oe[2]], ue, we), Pe = iu(ie, V);
              ne.draw(ie, te.TRIANGLES, re, fi.disabled, Fi.alphaBlended, Ut.disabled, ze, null, null, "atmosphere", Pe.vertexBuffer, Pe.indexBuffer, Pe.segments);
            })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const B = (function(V, $) {
                let ie = null;
                const te = Object.values(V._layers).flatMap(((oe) => oe.source && !oe.isHidden($) ? [V.sourceCaches[oe.source]] : [])), ne = te.filter(((oe) => oe.getSource().type === "vector")), re = te.filter(((oe) => oe.getSource().type !== "vector")), ce = (oe) => {
                  (!ie || ie.getSource().maxzoom < oe.getSource().maxzoom) && (ie = oe);
                };
                return ne.forEach(((oe) => ce(oe))), ie || re.forEach(((oe) => ce(oe))), ie;
              })(this.style, this.transform.zoom);
              B && (function(V, $, ie) {
                for (let te = 0; te < ie.length; te++) ar(V, $, ie[te]);
              })(this, B, B.getVisibleCoordinates());
            }
            this.options.showPadding && (function(B) {
              const V = B.transform.padding;
              wi(B, B.transform.height - (V.top || 0), 3, Hc), wi(B, V.bottom || 0, 3, Xc), Vi(B, V.left || 0, 3, Qu), Vi(B, B.transform.width - (V.right || 0), 3, Qn);
              const $ = B.transform.centerPoint;
              (function(ie, te, ne, re) {
                On(ie, te - 1, ne - 10, 2, 20, re), On(ie, te - 10, ne - 1, 20, 2, re);
              })(B, $.x, B.transform.height - $.y, ln);
            })(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const r = this.terrainFacilitator.matrix, c = this.transform.modelViewProjectionMatrix;
            let f = this.terrainFacilitator.dirty;
            f || (f = e ? !u.c8(r, c) : !u.c9(r, c)), f || (f = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), f && (u.ca(r, c), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(_, w) {
              const C = _.context, P = C.gl, R = _.transform, L = Fi.unblended, j = new Wt(P.LEQUAL, Wt.ReadWrite, [0, 1]), B = w.sourceCache.getRenderableTiles(), V = _.useProgram("terrainDepth");
              C.bindFramebuffer.set(w.getFramebuffer("depth").framebuffer), C.viewport.set([0, 0, _.width / devicePixelRatio, _.height / devicePixelRatio]), C.clear({ color: u.bf.transparent, depth: 1 });
              for (const $ of B) {
                const ie = w.getTerrainMesh($.tileID), te = w.getTerrainData($.tileID), ne = R.getProjectionData({ overscaledTileID: $.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), re = { u_ele_delta: w.getMeshFrameDelta(R.zoom) };
                V.draw(C, P.TRIANGLES, j, fi.disabled, L, Ut.backCCW, re, te, ne, "terrain", ie.vertexBuffer, ie.indexBuffer, ie.segments);
              }
              C.bindFramebuffer.set(null), C.viewport.set([0, 0, _.width, _.height]);
            })(this, this.style.map.terrain), (function(_, w) {
              const C = _.context, P = C.gl, R = _.transform, L = Fi.unblended, j = new Wt(P.LEQUAL, Wt.ReadWrite, [0, 1]), B = w.getCoordsTexture(), V = w.sourceCache.getRenderableTiles(), $ = _.useProgram("terrainCoords");
              C.bindFramebuffer.set(w.getFramebuffer("coords").framebuffer), C.viewport.set([0, 0, _.width / devicePixelRatio, _.height / devicePixelRatio]), C.clear({ color: u.bf.transparent, depth: 1 }), w.coordsIndex = [];
              for (const ie of V) {
                const te = w.getTerrainMesh(ie.tileID), ne = w.getTerrainData(ie.tileID);
                C.activeTexture.set(P.TEXTURE0), P.bindTexture(P.TEXTURE_2D, B.texture);
                const re = { u_terrain_coords_id: (255 - w.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: w.getMeshFrameDelta(R.zoom) }, ce = R.getProjectionData({ overscaledTileID: ie.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
                $.draw(C, P.TRIANGLES, j, fi.disabled, L, Ut.backCCW, re, ne, ce, "terrain", te.vertexBuffer, te.indexBuffer, te.segments), w.coordsIndex.push(ie.tileID.key);
              }
              C.bindFramebuffer.set(null), C.viewport.set([0, 0, _.width, _.height]);
            })(this, this.style.map.terrain));
          }
          renderLayer(e, r, c, f, _) {
            c.isHidden(this.transform.zoom) || (c.type === "background" || c.type === "custom" || (f || []).length) && (this.id = c.id, u.cb(c) ? (function(w, C, P, R, L, j) {
              if (w.renderPass !== "translucent") return;
              const { isRenderingToTexture: B } = j, V = fi.disabled, $ = w.colorModeForRenderPass();
              (P._unevaluatedLayout.hasValue("text-variable-anchor") || P._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(ie, te, ne, re, ce, oe, pe, ye, ue) {
                const we = te.transform, Oe = te.style.map.terrain, ze = ce === "map", Pe = oe === "map";
                for (const Le of ie) {
                  const lt = re.getTile(Le), ct = lt.getBucket(ne);
                  if (!ct || !ct.text || !ct.text.segments.get().length) continue;
                  const We = u.an(ct.textSizeData, we.zoom), At = u.aC(lt, 1, te.transform.zoom), ai = In(ze, te.transform, At), zi = ne.layout.get("icon-text-fit") !== "none" && ct.hasIconData();
                  if (We) {
                    const qi = Math.pow(2, we.zoom - lt.tileID.overscaledZ), Ni = Oe ? (un, mn) => Oe.getElevation(Le, un, mn) : null;
                    Wu(ct, ze, Pe, ue, we, ai, qi, We, zi, u.aD(we, lt, pe, ye), Le.toUnwrapped(), Ni);
                  }
                }
              })(R, w, P, C, P.layout.get("text-rotation-alignment"), P.layout.get("text-pitch-alignment"), P.paint.get("text-translate"), P.paint.get("text-translate-anchor"), L), P.paint.get("icon-opacity").constantOr(1) !== 0 && ml(w, C, P, R, !1, P.paint.get("icon-translate"), P.paint.get("icon-translate-anchor"), P.layout.get("icon-rotation-alignment"), P.layout.get("icon-pitch-alignment"), P.layout.get("icon-keep-upright"), V, $, B), P.paint.get("text-opacity").constantOr(1) !== 0 && ml(w, C, P, R, !0, P.paint.get("text-translate"), P.paint.get("text-translate-anchor"), P.layout.get("text-rotation-alignment"), P.layout.get("text-pitch-alignment"), P.layout.get("text-keep-upright"), V, $, B), C.map.showCollisionBoxes && (xs(w, C, P, R, !0), xs(w, C, P, R, !1));
            })(e, r, c, f, this.style.placement.variableOffsets, _) : u.cc(c) ? (function(w, C, P, R, L) {
              if (w.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = L, B = P.paint.get("circle-opacity"), V = P.paint.get("circle-stroke-width"), $ = P.paint.get("circle-stroke-opacity"), ie = !P.layout.get("circle-sort-key").isConstant();
              if (B.constantOr(1) === 0 && (V.constantOr(1) === 0 || $.constantOr(1) === 0)) return;
              const te = w.context, ne = te.gl, re = w.transform, ce = w.getDepthModeForSublayer(0, Wt.ReadOnly), oe = fi.disabled, pe = w.colorModeForRenderPass(), ye = [], ue = re.getCircleRadiusCorrection();
              for (let we = 0; we < R.length; we++) {
                const Oe = R[we], ze = C.getTile(Oe), Pe = ze.getBucket(P);
                if (!Pe) continue;
                const Le = P.paint.get("circle-translate"), lt = P.paint.get("circle-translate-anchor"), ct = u.aD(re, ze, Le, lt), We = Pe.programConfigurations.get(P.id), At = w.useProgram("circle", We), ai = Pe.layoutVertexBuffer, zi = Pe.indexBuffer, qi = w.style.map.terrain && w.style.map.terrain.getTerrainData(Oe), Ni = { programConfiguration: We, program: At, layoutVertexBuffer: ai, indexBuffer: zi, uniformValues: Hd(w, ze, P, ct, ue), terrainData: qi, projectionData: re.getProjectionData({ overscaledTileID: Oe, applyGlobeMatrix: !j, applyTerrainMatrix: !0 }) };
                if (ie) {
                  const un = Pe.segments.get();
                  for (const mn of un) ye.push({ segments: new u.aM([mn]), sortKey: mn.sortKey, state: Ni });
                } else ye.push({ segments: Pe.segments, sortKey: 0, state: Ni });
              }
              ie && ye.sort(((we, Oe) => we.sortKey - Oe.sortKey));
              for (const we of ye) {
                const { programConfiguration: Oe, program: ze, layoutVertexBuffer: Pe, indexBuffer: Le, uniformValues: lt, terrainData: ct, projectionData: We } = we.state;
                ze.draw(te, ne.TRIANGLES, ce, oe, pe, Ut.backCCW, lt, ct, We, P.id, Pe, Le, we.segments, P.paint, w.transform.zoom, Oe);
              }
            })(e, r, c, f, _) : u.cd(c) ? (function(w, C, P, R, L) {
              if (P.paint.get("heatmap-opacity") === 0) return;
              const j = w.context, { isRenderingToTexture: B, isRenderingGlobe: V } = L;
              if (w.style.map.terrain) {
                for (const $ of R) {
                  const ie = C.getTile($);
                  C.hasRenderableParent($) || (w.renderPass === "offscreen" ? tr(w, ie, P, $, V) : w.renderPass === "translucent" && gl(w, P, $, B, V));
                }
                j.viewport.set([0, 0, w.width, w.height]);
              } else w.renderPass === "offscreen" ? (function($, ie, te, ne) {
                const re = $.context, ce = re.gl, oe = $.transform, pe = fi.disabled, ye = new Fi([ce.ONE, ce.ONE], u.bf.transparent, [!0, !0, !0, !0]);
                (function(ue, we, Oe) {
                  const ze = ue.gl;
                  ue.activeTexture.set(ze.TEXTURE1), ue.viewport.set([0, 0, we.width / 4, we.height / 4]);
                  let Pe = Oe.heatmapFbos.get(u.c2);
                  Pe ? (ze.bindTexture(ze.TEXTURE_2D, Pe.colorAttachment.get()), ue.bindFramebuffer.set(Pe.framebuffer)) : (Pe = bs(ue, we.width / 4, we.height / 4), Oe.heatmapFbos.set(u.c2, Pe));
                })(re, $, te), re.clear({ color: u.bf.transparent });
                for (let ue = 0; ue < ne.length; ue++) {
                  const we = ne[ue];
                  if (ie.hasRenderableParent(we)) continue;
                  const Oe = ie.getTile(we), ze = Oe.getBucket(te);
                  if (!ze) continue;
                  const Pe = ze.programConfigurations.get(te.id), Le = $.useProgram("heatmap", Pe), lt = oe.getProjectionData({ overscaledTileID: we, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), ct = oe.getCircleRadiusCorrection();
                  Le.draw(re, ce.TRIANGLES, Wt.disabled, pe, ye, Ut.backCCW, cl(Oe, oe.zoom, te.paint.get("heatmap-intensity"), ct), null, lt, te.id, ze.layoutVertexBuffer, ze.indexBuffer, ze.segments, te.paint, oe.zoom, Pe);
                }
                re.viewport.set([0, 0, $.width, $.height]);
              })(w, C, P, R) : w.renderPass === "translucent" && (function($, ie) {
                const te = $.context, ne = te.gl;
                te.setColorMode($.colorModeForRenderPass());
                const re = ie.heatmapFbos.get(u.c2);
                re && (te.activeTexture.set(ne.TEXTURE0), ne.bindTexture(ne.TEXTURE_2D, re.colorAttachment.get()), te.activeTexture.set(ne.TEXTURE1), Eo(te, ie).bind(ne.LINEAR, ne.CLAMP_TO_EDGE), $.useProgram("heatmapTexture").draw(te, ne.TRIANGLES, Wt.disabled, fi.disabled, $.colorModeForRenderPass(), Ut.disabled, Lh($, ie, 0, 1), null, null, ie.id, $.viewportBuffer, $.quadTriangleIndexBuffer, $.viewportSegments, ie.paint, $.transform.zoom));
              })(w, P);
            })(e, r, c, f, _) : u.ce(c) ? (function(w, C, P, R, L) {
              if (w.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = L, B = P.paint.get("line-opacity"), V = P.paint.get("line-width");
              if (B.constantOr(1) === 0 || V.constantOr(1) === 0) return;
              const $ = w.getDepthModeForSublayer(0, Wt.ReadOnly), ie = w.colorModeForRenderPass(), te = P.paint.get("line-dasharray"), ne = P.paint.get("line-pattern"), re = ne.constantOr(1), ce = P.paint.get("line-gradient"), oe = P.getCrossfadeParameters(), pe = re ? "linePattern" : te ? "lineSDF" : ce ? "lineGradient" : "line", ye = w.context, ue = ye.gl, we = w.transform;
              let Oe = !0;
              for (const ze of R) {
                const Pe = C.getTile(ze);
                if (re && !Pe.patternsLoaded()) continue;
                const Le = Pe.getBucket(P);
                if (!Le) continue;
                const lt = Le.programConfigurations.get(P.id), ct = w.context.program.get(), We = w.useProgram(pe, lt), At = Oe || We.program !== ct, ai = w.style.map.terrain && w.style.map.terrain.getTerrainData(ze), zi = ne.constantOr(null);
                if (zi && Pe.imageAtlas) {
                  const Qt = Pe.imageAtlas, Xi = Qt.patternPositions[zi.to.toString()], Bn = Qt.patternPositions[zi.from.toString()];
                  Xi && Bn && lt.setConstantPatternPositions(Xi, Bn);
                }
                const qi = we.getProjectionData({ overscaledTileID: ze, applyGlobeMatrix: !j, applyTerrainMatrix: !0 }), Ni = we.getPixelScale(), un = re ? Kd(w, Pe, P, Ni, oe) : te ? fs(w, Pe, P, Ni, te, oe) : ce ? Kl(w, Pe, P, Ni, Le.lineClipsArray.length) : wo(w, Pe, P, Ni);
                if (re) ye.activeTexture.set(ue.TEXTURE0), Pe.imageAtlasTexture.bind(ue.LINEAR, ue.CLAMP_TO_EDGE), lt.updatePaintBuffers(oe);
                else if (te && (At || w.lineAtlas.dirty)) ye.activeTexture.set(ue.TEXTURE0), w.lineAtlas.bind(ye);
                else if (ce) {
                  const Qt = Le.gradients[P.id];
                  let Xi = Qt.texture;
                  if (P.gradientVersion !== Qt.version) {
                    let Bn = 256;
                    if (P.stepInterpolant) {
                      const gn = C.getSource().maxzoom, ta = ze.canonical.z === gn ? Math.ceil(1 << w.transform.maxZoom - ze.canonical.z) : 1;
                      Bn = u.ah(u.c3(Le.maxLineLength / u.$ * 1024 * ta), 256, ye.maxTextureSize);
                    }
                    Qt.gradient = u.c4({ expression: P.gradientExpression(), evaluationKey: "lineProgress", resolution: Bn, image: Qt.gradient || void 0, clips: Le.lineClipsArray }), Qt.texture ? Qt.texture.update(Qt.gradient) : Qt.texture = new u.T(ye, Qt.gradient, ue.RGBA), Qt.version = P.gradientVersion, Xi = Qt.texture;
                  }
                  ye.activeTexture.set(ue.TEXTURE0), Xi.bind(P.stepInterpolant ? ue.NEAREST : ue.LINEAR, ue.CLAMP_TO_EDGE);
                }
                const mn = w.stencilModeForClipping(ze);
                We.draw(ye, ue.TRIANGLES, $, mn, ie, Ut.disabled, un, ai, qi, P.id, Le.layoutVertexBuffer, Le.indexBuffer, Le.segments, P.paint, w.transform.zoom, lt, Le.layoutVertexBuffer2), Oe = !1;
              }
            })(e, r, c, f, _) : u.cf(c) ? (function(w, C, P, R, L) {
              const j = P.paint.get("fill-color"), B = P.paint.get("fill-opacity");
              if (B.constantOr(1) === 0) return;
              const { isRenderingToTexture: V } = L, $ = w.colorModeForRenderPass(), ie = P.paint.get("fill-pattern"), te = w.opaquePassEnabledForLayer() && !ie.constantOr(1) && j.constantOr(u.bf.transparent).a === 1 && B.constantOr(0) === 1 ? "opaque" : "translucent";
              if (w.renderPass === te) {
                const ne = w.getDepthModeForSublayer(1, w.renderPass === "opaque" ? Wt.ReadWrite : Wt.ReadOnly);
                Ua(w, C, P, R, ne, $, !1, V);
              }
              if (w.renderPass === "translucent" && P.paint.get("fill-antialias")) {
                const ne = w.getDepthModeForSublayer(P.getPaintProperty("fill-outline-color") ? 2 : 0, Wt.ReadOnly);
                Ua(w, C, P, R, ne, $, !0, V);
              }
            })(e, r, c, f, _) : u.cg(c) ? (function(w, C, P, R, L) {
              const j = P.paint.get("fill-extrusion-opacity");
              if (j === 0) return;
              const { isRenderingToTexture: B } = L;
              if (w.renderPass === "translucent") {
                const V = new Wt(w.context.gl.LEQUAL, Wt.ReadWrite, w.depthRangeFor3D);
                if (j !== 1 || P.paint.get("fill-extrusion-pattern").constantOr(1)) ir(w, C, P, R, V, fi.disabled, Fi.disabled, B), ir(w, C, P, R, V, w.stencilModeFor3D(), w.colorModeForRenderPass(), B);
                else {
                  const $ = w.colorModeForRenderPass();
                  ir(w, C, P, R, V, fi.disabled, $, B);
                }
              }
            })(e, r, c, f, _) : u.ch(c) ? (function(w, C, P, R, L) {
              if (w.renderPass !== "offscreen" && w.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = L, B = w.context, V = w.style.projection.useSubdivision, $ = w.getDepthModeForSublayer(0, Wt.ReadOnly), ie = w.colorModeForRenderPass();
              if (w.renderPass === "offscreen") (function(te, ne, re, ce, oe, pe, ye) {
                const ue = te.context, we = ue.gl;
                for (const Oe of re) {
                  const ze = ne.getTile(Oe), Pe = ze.dem;
                  if (!Pe || !Pe.data || !ze.needsHillshadePrepare) continue;
                  const Le = Pe.dim, lt = Pe.stride, ct = Pe.getPixels();
                  if (ue.activeTexture.set(we.TEXTURE1), ue.pixelStoreUnpackPremultiplyAlpha.set(!1), ze.demTexture = ze.demTexture || te.getTileTexture(lt), ze.demTexture) {
                    const At = ze.demTexture;
                    At.update(ct, { premultiply: !1 }), At.bind(we.NEAREST, we.CLAMP_TO_EDGE);
                  } else ze.demTexture = new u.T(ue, ct, we.RGBA, { premultiply: !1 }), ze.demTexture.bind(we.NEAREST, we.CLAMP_TO_EDGE);
                  ue.activeTexture.set(we.TEXTURE0);
                  let We = ze.fbo;
                  if (!We) {
                    const At = new u.T(ue, { width: Le, height: Le, data: null }, we.RGBA);
                    At.bind(we.LINEAR, we.CLAMP_TO_EDGE), We = ze.fbo = ue.createFramebuffer(Le, Le, !0, !1), We.colorAttachment.set(At.texture);
                  }
                  ue.bindFramebuffer.set(We.framebuffer), ue.viewport.set([0, 0, Le, Le]), te.useProgram("hillshadePrepare").draw(ue, we.TRIANGLES, oe, pe, ye, Ut.disabled, Yd(ze.tileID, Pe), null, null, ce.id, te.rasterBoundsBuffer, te.quadTriangleIndexBuffer, te.rasterBoundsSegments), ze.needsHillshadePrepare = !1;
                }
              })(w, C, R, P, $, fi.disabled, ie), B.viewport.set([0, 0, w.width, w.height]);
              else if (w.renderPass === "translucent") if (V) {
                const [te, ne, re] = w.stencilConfigForOverlapTwoPass(R);
                nr(w, C, P, re, te, $, ie, !1, j), nr(w, C, P, re, ne, $, ie, !0, j);
              } else {
                const [te, ne] = w.getStencilConfigForOverlapAndUpdateStencilID(R);
                nr(w, C, P, ne, te, $, ie, !1, j);
              }
            })(e, r, c, f, _) : u.ci(c) ? (function(w, C, P, R, L) {
              if (w.renderPass !== "translucent" || !R.length) return;
              const { isRenderingToTexture: j } = L, B = w.style.projection.useSubdivision, V = w.getDepthModeForSublayer(0, Wt.ReadOnly), $ = w.colorModeForRenderPass();
              if (B) {
                const [ie, te, ne] = w.stencilConfigForOverlapTwoPass(R);
                Lr(w, C, P, ne, ie, V, $, !1, j), Lr(w, C, P, ne, te, V, $, !0, j);
              } else {
                const [ie, te] = w.getStencilConfigForOverlapAndUpdateStencilID(R);
                Lr(w, C, P, te, ie, V, $, !1, j);
              }
            })(e, r, c, f, _) : u.cj(c) ? (function(w, C, P, R, L) {
              if (w.renderPass !== "translucent" || P.paint.get("raster-opacity") === 0 || !R.length) return;
              const { isRenderingToTexture: j } = L, B = C.getSource(), V = w.style.projection.useSubdivision;
              if (B instanceof pr) Fa(w, C, P, R, null, !1, !1, B.tileCoords, B.flippedWindingOrder, j);
              else if (V) {
                const [$, ie, te] = w.stencilConfigForOverlapTwoPass(R);
                Fa(w, C, P, te, $, !1, !0, yr, !1, j), Fa(w, C, P, te, ie, !0, !0, yr, !1, j);
              } else {
                const [$, ie] = w.getStencilConfigForOverlapAndUpdateStencilID(R);
                Fa(w, C, P, ie, $, !1, !0, yr, !1, j);
              }
            })(e, r, c, f, _) : u.ck(c) ? (function(w, C, P, R, L) {
              const j = P.paint.get("background-color"), B = P.paint.get("background-opacity");
              if (B === 0) return;
              const { isRenderingToTexture: V } = L, $ = w.context, ie = $.gl, te = w.style.projection, ne = w.transform, re = ne.tileSize, ce = P.paint.get("background-pattern");
              if (w.isPatternMissing(ce)) return;
              const oe = !ce && j.a === 1 && B === 1 && w.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (w.renderPass !== oe) return;
              const pe = fi.disabled, ye = w.getDepthModeForSublayer(0, oe === "opaque" ? Wt.ReadWrite : Wt.ReadOnly), ue = w.colorModeForRenderPass(), we = w.useProgram(ce ? "backgroundPattern" : "background"), Oe = R || Ae(ne, { tileSize: re, terrain: w.style.map.terrain });
              ce && ($.activeTexture.set(ie.TEXTURE0), w.imageManager.bind(w.context));
              const ze = P.getCrossfadeParameters();
              for (const Pe of Oe) {
                const Le = ne.getProjectionData({ overscaledTileID: Pe, applyGlobeMatrix: !V, applyTerrainMatrix: !0 }), lt = ce ? Qd(B, w, ce, { tileID: Pe, tileSize: re }, ze) : Jd(B, j), ct = w.style.map.terrain && w.style.map.terrain.getTerrainData(Pe), We = te.getMeshFromTileID($, Pe.canonical, !1, !0, "raster");
                we.draw($, ie.TRIANGLES, ye, pe, ue, Ut.backCCW, lt, ct, Le, P.id, We.vertexBuffer, We.indexBuffer, We.segments);
              }
            })(e, 0, c, f, _) : u.cl(c) && (function(w, C, P, R) {
              const { isRenderingGlobe: L } = R, j = w.context, B = P.implementation, V = w.style.projection, $ = w.transform, ie = $.getProjectionDataForCustomLayer(L), te = { farZ: $.farZ, nearZ: $.nearZ, fov: $.fov * Math.PI / 180, modelViewProjectionMatrix: $.modelViewProjectionMatrix, projectionMatrix: $.projectionMatrix, shaderData: { variantName: V.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${V.shaderPreludeCode.vertexSource}`, define: V.shaderDefine }, defaultProjectionData: ie }, ne = B.renderingMode ? B.renderingMode : "2d";
              if (w.renderPass === "offscreen") {
                const re = B.prerender;
                re && (w.setCustomLayerDefaults(), j.setColorMode(w.colorModeForRenderPass()), re.call(B, j.gl, te), j.setDirty(), w.setBaseState());
              } else if (w.renderPass === "translucent") {
                w.setCustomLayerDefaults(), j.setColorMode(w.colorModeForRenderPass()), j.setStencilMode(fi.disabled);
                const re = ne === "3d" ? w.getDepthModeFor3D() : w.getDepthModeForSublayer(0, Wt.ReadOnly);
                j.setDepthMode(re), B.render(j.gl, te), j.setDirty(), w.setBaseState(), j.bindFramebuffer.set(null);
              }
            })(e, 0, c, _));
          }
          saveTileTexture(e) {
            const r = this._tileTextures[e.size[0]];
            r ? r.push(e) : this._tileTextures[e.size[0]] = [e];
          }
          getTileTexture(e) {
            const r = this._tileTextures[e];
            return r && r.length > 0 ? r.pop() : null;
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const r = this.imageManager.getPattern(e.from.toString()), c = this.imageManager.getPattern(e.to.toString());
            return !r || !c;
          }
          useProgram(e, r, c = !1, f = []) {
            this.cache = this.cache || {};
            const _ = !!this.style.map.terrain, w = this.style.projection, C = c ? Ma.projectionMercator : w.shaderPreludeCode, P = c ? Kr : w.shaderDefine, R = e + (r ? r.cacheKey : "") + `/${c ? sl : w.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (_ ? "/terrain" : "") + (f ? `/${f.join("/")}` : "");
            return this.cache[R] || (this.cache[R] = new Rh(this.context, Ma[e], r, Uh[e], this._showOverdrawInspector, _, C, P, f)), this.cache[R];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new u.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: e, drawingBufferHeight: r } = this.context.gl;
            return this.width !== e || this.height !== r;
          }
        }
        function Or(y, e) {
          let r, c = !1, f = null, _ = null;
          const w = () => {
            f = null, c && (y.apply(_, r), f = setTimeout(w, e), c = !1);
          };
          return (...C) => (c = !0, _ = this, r = C, f || w(), f);
        }
        class ws {
          constructor(e) {
            this._getCurrentHash = () => {
              const r = window.location.hash.replace("#", "");
              if (this._hashName) {
                let c;
                return r.split("&").map(((f) => f.split("="))).forEach(((f) => {
                  f[0] === this._hashName && (c = f);
                })), (c && c[1] || "").split("/");
              }
              return r.split("/");
            }, this._onHashChange = () => {
              const r = this._getCurrentHash();
              if (!this._isValidHash(r)) return !1;
              const c = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(r[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+r[2], +r[1]], zoom: +r[0], bearing: c, pitch: +(r[4] || 0) }), !0;
            }, this._updateHashUnthrottled = () => {
              const r = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, r);
            }, this._removeHash = () => {
              const r = this._getCurrentHash();
              if (r.length === 0) return;
              const c = r.join("/");
              let f = c;
              f.split("&").length > 0 && (f = f.split("&")[0]), this._hashName && (f = `${this._hashName}=${c}`);
              let _ = window.location.hash.replace(f, "");
              _.startsWith("#&") ? _ = _.slice(0, 1) + _.slice(2) : _ === "#" && (_ = "");
              let w = window.location.href.replace(/(#.+)?$/, _);
              w = w.replace("&&", "&"), window.history.replaceState(window.history.state, null, w);
            }, this._updateHash = Or(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(e) {
            const r = this._map.getCenter(), c = Math.round(100 * this._map.getZoom()) / 100, f = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), _ = Math.pow(10, f), w = Math.round(r.lng * _) / _, C = Math.round(r.lat * _) / _, P = this._map.getBearing(), R = this._map.getPitch();
            let L = "";
            if (L += e ? `/${w}/${C}/${c}` : `${c}/${C}/${w}`, (P || R) && (L += "/" + Math.round(10 * P) / 10), R && (L += `/${Math.round(R)}`), this._hashName) {
              const j = this._hashName;
              let B = !1;
              const V = window.location.hash.slice(1).split("&").map((($) => {
                const ie = $.split("=")[0];
                return ie === j ? (B = !0, `${ie}=${L}`) : $;
              })).filter((($) => $));
              return B || V.push(`${j}=${L}`), `#${V.join("&")}`;
            }
            return `#${L}`;
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new u.S(+e[2], +e[1]);
            } catch {
              return !1;
            }
            const r = +e[0], c = +(e[3] || 0), f = +(e[4] || 0);
            return r >= this._map.getMinZoom() && r <= this._map.getMaxZoom() && c >= -180 && c <= 180 && f >= this._map.getMinPitch() && f <= this._map.getMaxPitch();
          }
        }
        const es = { linearity: 0.3, easing: u.cm(0, 0, 0.3, 1) }, yl = u.e({ deceleration: 2500, maxSpeed: 1400 }, es), Yc = u.e({ deceleration: 20, maxSpeed: 1400 }, es), Co = u.e({ deceleration: 1e3, maxSpeed: 360 }, es), Ss = u.e({ deceleration: 1e3, maxSpeed: 90 }, es), Xs = u.e({ deceleration: 1e3, maxSpeed: 360 }, es);
        class Ts {
          constructor(e) {
            this._map = e, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: he.now(), settings: e });
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer, r = he.now();
            for (; e.length > 0 && r - e[0].time > 160; ) e.shift();
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const r = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new u.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: _ } of this._inertiaBuffer) r.zoom += _.zoomDelta || 0, r.bearing += _.bearingDelta || 0, r.pitch += _.pitchDelta || 0, r.roll += _.rollDelta || 0, _.panDelta && r.pan._add(_.panDelta), _.around && (r.around = _.around), _.pinchAround && (r.pinchAround = _.pinchAround);
            const c = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, f = {};
            if (r.pan.mag()) {
              const _ = zo(r.pan.mag(), c, u.e({}, yl, e || {})), w = r.pan.mult(_.amount / r.pan.mag()), C = this._map.cameraHelper.handlePanInertia(w, this._map.transform);
              f.center = C.easingCenter, f.offset = C.easingOffset, _r(f, _);
            }
            if (r.zoom) {
              const _ = zo(r.zoom, c, Yc);
              f.zoom = this._map.transform.zoom + _.amount, _r(f, _);
            }
            if (r.bearing) {
              const _ = zo(r.bearing, c, Co);
              f.bearing = this._map.transform.bearing + u.ah(_.amount, -179, 179), _r(f, _);
            }
            if (r.pitch) {
              const _ = zo(r.pitch, c, Ss);
              f.pitch = this._map.transform.pitch + _.amount, _r(f, _);
            }
            if (r.roll) {
              const _ = zo(r.roll, c, Xs);
              f.roll = this._map.transform.roll + u.ah(_.amount, -179, 179), _r(f, _);
            }
            if (f.zoom || f.bearing) {
              const _ = r.pinchAround === void 0 ? r.around : r.pinchAround;
              f.around = _ ? this._map.unproject(_) : this._map.getCenter();
            }
            return this.clear(), u.e(f, { noMoveStart: !0 });
          }
        }
        function _r(y, e) {
          (!y.duration || y.duration < e.duration) && (y.duration = e.duration, y.easing = e.easing);
        }
        function zo(y, e, r) {
          const { maxSpeed: c, linearity: f, deceleration: _ } = r, w = u.ah(y * f / (e / 1e3), -c, c), C = Math.abs(w) / (_ * f);
          return { easing: r.easing, duration: 1e3 * C, amount: w * (C / 2) };
        }
        class ea extends u.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, r, c, f = {}) {
            c = c instanceof MouseEvent ? c : new MouseEvent(e, c);
            const _ = J.mousePos(r.getCanvas(), c), w = r.unproject(_);
            super(e, u.e({ point: _, lngLat: w, originalEvent: c }, f)), this._defaultPrevented = !1, this.target = r;
          }
        }
        class Ys extends u.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, r, c) {
            const f = e === "touchend" ? c.changedTouches : c.touches, _ = J.touchPos(r.getCanvasContainer(), f), w = _.map(((P) => r.unproject(P))), C = _.reduce(((P, R, L, j) => P.add(R.div(j.length))), new u.P(0, 0));
            super(e, { points: _, point: C, lngLats: w, lngLat: r.unproject(C), originalEvent: c }), this._defaultPrevented = !1;
          }
        }
        class Ks extends u.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, r, c) {
            super(e, { originalEvent: c }), this._defaultPrevented = !1;
          }
        }
        class ha {
          constructor(e, r) {
            this._map = e, this._clickTolerance = r.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e) {
            return this._firePreventable(new Ks(e.type, this._map, e));
          }
          mousedown(e, r) {
            return this._mousedownPos = r, this._firePreventable(new ea(e.type, this._map, e));
          }
          mouseup(e) {
            this._map.fire(new ea(e.type, this._map, e));
          }
          click(e, r) {
            this._mousedownPos && this._mousedownPos.dist(r) >= this._clickTolerance || this._map.fire(new ea(e.type, this._map, e));
          }
          dblclick(e) {
            return this._firePreventable(new ea(e.type, this._map, e));
          }
          mouseover(e) {
            this._map.fire(new ea(e.type, this._map, e));
          }
          mouseout(e) {
            this._map.fire(new ea(e.type, this._map, e));
          }
          touchstart(e) {
            return this._firePreventable(new Ys(e.type, this._map, e));
          }
          touchmove(e) {
            this._map.fire(new Ys(e.type, this._map, e));
          }
          touchend(e) {
            this._map.fire(new Ys(e.type, this._map, e));
          }
          touchcancel(e) {
            this._map.fire(new Ys(e.type, this._map, e));
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class ec {
          constructor(e) {
            this._map = e;
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
          }
          mousemove(e) {
            this._map.fire(new ea(e.type, this._map, e));
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new ea("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new ea(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class _l {
          constructor(e) {
            this._map = e;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e) {
            return this.transform.screenPointToLocation(u.P.convert(e), this._map.terrain);
          }
        }
        class Hh {
          constructor(e, r) {
            this._map = e, this._tr = new _l(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = r.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(e, r) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (J.disableDrag(), this._startPos = this._lastPos = r, this._active = !0);
          }
          mousemoveWindow(e, r) {
            if (!this._active) return;
            const c = r;
            if (this._lastPos.equals(c) || !this._box && c.dist(this._startPos) < this._clickTolerance) return;
            const f = this._startPos;
            this._lastPos = c, this._box || (this._box = J.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const _ = Math.min(f.x, c.x), w = Math.max(f.x, c.x), C = Math.min(f.y, c.y), P = Math.max(f.y, c.y);
            J.setTransform(this._box, `translate(${_}px,${C}px)`), this._box.style.width = w - _ + "px", this._box.style.height = P - C + "px";
          }
          mouseupWindow(e, r) {
            if (!this._active || e.button !== 0) return;
            const c = this._startPos, f = r;
            if (this.reset(), J.suppressClick(), c.x !== f.x || c.y !== f.y) return this._map.fire(new u.l("boxzoomend", { originalEvent: e })), { cameraAnimation: (_) => _.fitScreenCoordinates(c, f, this._tr.bearing, { linear: !0 }) };
            this._fireEvent("boxzoomcancel", e);
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (J.remove(this._box), this._box = null), J.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e, r) {
            return this._map.fire(new u.l(e, { originalEvent: r }));
          }
        }
        function nu(y, e) {
          if (y.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${y.length}, points ${e.length}`);
          const r = {};
          for (let c = 0; c < y.length; c++) r[y[c].identifier] = e[c];
          return r;
        }
        class np {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
          }
          touchstart(e, r, c) {
            (this.centroid || c.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), c.length === this.numTouches && (this.centroid = (function(f) {
              const _ = new u.P(0, 0);
              for (const w of f) _._add(w);
              return _.div(f.length);
            })(r), this.touches = nu(c, r)));
          }
          touchmove(e, r, c) {
            if (this.aborted || !this.centroid) return;
            const f = nu(c, r);
            for (const _ in this.touches) {
              const w = f[_];
              (!w || w.dist(this.touches[_]) > 30) && (this.aborted = !0);
            }
          }
          touchend(e, r, c) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), c.length === 0) {
              const f = !this.aborted && this.centroid;
              if (this.reset(), f) return f;
            }
          }
        }
        class ki {
          constructor(e) {
            this.singleTap = new np(e), this.numTaps = e.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(e, r, c) {
            this.singleTap.touchstart(e, r, c);
          }
          touchmove(e, r, c) {
            this.singleTap.touchmove(e, r, c);
          }
          touchend(e, r, c) {
            const f = this.singleTap.touchend(e, r, c);
            if (f) {
              const _ = e.timeStamp - this.lastTime < 500, w = !this.lastTap || this.lastTap.dist(f) < 30;
              if (_ && w || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = f, this.count === this.numTaps) return this.reset(), f;
            }
          }
        }
        class vr {
          constructor(e) {
            this._tr = new _l(e), this._zoomIn = new ki({ numTouches: 1, numTaps: 2 }), this._zoomOut = new ki({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e, r, c) {
            this._zoomIn.touchstart(e, r, c), this._zoomOut.touchstart(e, r, c);
          }
          touchmove(e, r, c) {
            this._zoomIn.touchmove(e, r, c), this._zoomOut.touchmove(e, r, c);
          }
          touchend(e, r, c) {
            const f = this._zoomIn.touchend(e, r, c), _ = this._zoomOut.touchend(e, r, c), w = this._tr;
            return f ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (C) => C.easeTo({ duration: 300, zoom: w.zoom + 1, around: w.unproject(f) }, { originalEvent: e }) }) : _ ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (C) => C.easeTo({ duration: 300, zoom: w.zoom - 1, around: w.unproject(_) }, { originalEvent: e }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ms {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e);
          }
          _move(...e) {
            const r = this._moveFunction(...e);
            if (r.bearingDelta || r.pitchDelta || r.rollDelta || r.around || r.panDelta) return this._active = !0, r;
          }
          dragStart(e, r) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(r) ? r[0] : r, this._activateOnStart && this._lastPoint && (this._active = !0));
          }
          dragMove(e, r) {
            if (!this.isEnabled()) return;
            const c = this._lastPoint;
            if (!c) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const f = Array.isArray(r) ? r[0] : r;
            return !this._moved && f.dist(c) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = f, this._move(c, f));
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && J.suppressClick(), this.reset(e));
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Va = 0, Po = 2, au = { [Va]: 1, [Po]: 2 };
        class As {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent;
          }
          startMove(e) {
            const r = J.mouseButton(e);
            this._eventButton = r;
          }
          endMove(e) {
            delete this._eventButton;
          }
          isValidStartEvent(e) {
            return this._correctEvent(e);
          }
          isValidMoveEvent(e) {
            return !(function(r, c) {
              const f = au[c];
              return r.buttons === void 0 || (r.buttons & f) !== f;
            })(e, this._eventButton);
          }
          isValidEndEvent(e) {
            return J.mouseButton(e) === this._eventButton;
          }
        }
        class uf {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1;
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier;
          }
          endMove(e) {
            delete this._firstTouch;
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e);
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
        }
        class ap {
          constructor(e = new As({ checkCorrectEvent: () => !0 }), r = new uf()) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = r;
          }
          _executeRelevantHandler(e, r, c) {
            return e instanceof MouseEvent ? r(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? c(e) : void 0;
          }
          startMove(e) {
            this._executeRelevantHandler(e, ((r) => this.mouseMoveStateManager.startMove(r)), ((r) => this.oneFingerTouchMoveStateManager.startMove(r)));
          }
          endMove(e) {
            this._executeRelevantHandler(e, ((r) => this.mouseMoveStateManager.endMove(r)), ((r) => this.oneFingerTouchMoveStateManager.endMove(r)));
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, ((r) => this.mouseMoveStateManager.isValidStartEvent(r)), ((r) => this.oneFingerTouchMoveStateManager.isValidStartEvent(r)));
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, ((r) => this.mouseMoveStateManager.isValidMoveEvent(r)), ((r) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(r)));
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, ((r) => this.mouseMoveStateManager.isValidEndEvent(r)), ((r) => this.oneFingerTouchMoveStateManager.isValidEndEvent(r)));
          }
        }
        const tc = (y) => {
          y.mousedown = y.dragStart, y.mousemoveWindow = y.dragMove, y.mouseup = y.dragEnd, y.contextmenu = (e) => {
            e.preventDefault();
          };
        };
        class ru {
          constructor(e, r) {
            this._clickTolerance = e.clickTolerance || 1, this._map = r, this.reset();
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new u.P(0, 0);
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(e, r, c) {
            return this._calculateTransform(e, r, c);
          }
          touchmove(e, r, c) {
            if (this._active) {
              if (!this._shouldBePrevented(c.length)) return e.preventDefault(), this._calculateTransform(e, r, c);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
            }
          }
          touchend(e, r, c) {
            this._calculateTransform(e, r, c), this._active && this._shouldBePrevented(c.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e, r, c) {
            c.length > 0 && (this._active = !0);
            const f = nu(c, r), _ = new u.P(0, 0), w = new u.P(0, 0);
            let C = 0;
            for (const R in f) {
              const L = f[R], j = this._touches[R];
              j && (_._add(L), w._add(L.sub(j)), C++, f[R] = L);
            }
            if (this._touches = f, this._shouldBePrevented(C) || !w.mag()) return;
            const P = w.div(C);
            return this._sum._add(P), this._sum.mag() < this._clickTolerance ? void 0 : { around: _.div(C), panDelta: P };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class _a {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches;
          }
          touchstart(e, r, c) {
            this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([r[0], r[1]]));
          }
          touchmove(e, r, c) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [f, _] = this._firstTwoTouches, w = xt(c, r, f), C = xt(c, r, _);
            if (!w || !C) return;
            const P = this._aroundCenter ? null : w.add(C).div(2);
            return this._move([w, C], P, e);
          }
          touchend(e, r, c) {
            if (!this._firstTwoTouches) return;
            const [f, _] = this._firstTwoTouches, w = xt(c, r, f), C = xt(c, r, _);
            w && C || (this._active && J.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center";
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function xt(y, e, r) {
          for (let c = 0; c < y.length; c++) if (y[c].identifier === r) return e[c];
        }
        function su(y, e) {
          return Math.log(y / e) / Math.LN2;
        }
        class ic extends _a {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1]);
          }
          _move(e, r) {
            const c = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(su(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: su(this._distance, c), pinchAround: r };
          }
        }
        function Io(y, e) {
          return 180 * y.angleWith(e) / Math.PI;
        }
        class ko extends _a {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
          }
          _move(e, r, c) {
            const f = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: Io(this._vector, f), pinchAround: r };
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const r = 25 / (Math.PI * this._minDiameter) * 360, c = Io(e, this._startVector);
            return Math.abs(c) < r;
          }
        }
        function Es(y) {
          return Math.abs(y.y) > Math.abs(y.x);
        }
        class vl extends _a {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(e, r, c) {
            super.touchstart(e, r, c), this._currentTouchCount = c.length;
          }
          _start(e) {
            this._lastPoints = e, Es(e[0].sub(e[1])) && (this._valid = !1);
          }
          _move(e, r, c) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const f = e[0].sub(this._lastPoints[0]), _ = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(f, _, c.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, { pitchDelta: (f.y + _.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(e, r, c) {
            if (this._valid !== void 0) return this._valid;
            const f = e.mag() >= 2, _ = r.mag() >= 2;
            if (!f && !_) return;
            if (!f || !_) return this._firstMove === void 0 && (this._firstMove = c), c - this._firstMove < 100 && void 0;
            const w = e.y > 0 == r.y > 0;
            return Es(e) && Es(r) && w;
          }
        }
        const mi = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class nc {
          constructor(e) {
            this._tr = new _l(e);
            const r = mi;
            this._panStep = r.panStep, this._bearingStep = r.bearingStep, this._pitchStep = r.pitchStep, this._rotationDisabled = !1;
          }
          reset() {
            this._active = !1;
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let r = 0, c = 0, f = 0, _ = 0, w = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                r = 1;
                break;
              case 189:
              case 109:
              case 173:
                r = -1;
                break;
              case 37:
                e.shiftKey ? c = -1 : (e.preventDefault(), _ = -1);
                break;
              case 39:
                e.shiftKey ? c = 1 : (e.preventDefault(), _ = 1);
                break;
              case 38:
                e.shiftKey ? f = 1 : (e.preventDefault(), w = -1);
                break;
              case 40:
                e.shiftKey ? f = -1 : (e.preventDefault(), w = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (c = 0, f = 0), { cameraAnimation: (C) => {
              const P = this._tr;
              C.easeTo({ duration: 300, easeId: "keyboardHandler", easing: xl, zoom: r ? Math.round(P.zoom) + r * (e.shiftKey ? 2 : 1) : P.zoom, bearing: P.bearing + c * this._bearingStep, pitch: P.pitch + f * this._pitchStep, offset: [-_ * this._panStep, -w * this._panStep], center: P.center }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function xl(y) {
          return y * (2 - y);
        }
        const Cs = 4.000244140625, rp = 1 / 450;
        class Xh {
          constructor(e, r) {
            this._onTimeout = (c) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(c);
            }, this._map = e, this._tr = new _l(e), this._triggerRenderFrame = r, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = rp;
          }
          setZoomRate(e) {
            this._defaultZoomRate = e;
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let r = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const c = he.now(), f = c - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = c, r !== 0 && r % Cs == 0 ? this._type = "wheel" : r !== 0 && Math.abs(r) < 4 ? this._type = "trackpad" : f > 400 ? (this._type = null, this._lastValue = r, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(f * r) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, r += this._lastValue)), e.shiftKey && r && (r /= 4), this._type && (this._lastWheelEvent = e, this._delta -= r, this._active || this._start(e)), e.preventDefault();
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const r = J.mousePos(this._map.getCanvas(), e), c = this._tr;
            this._aroundPoint = this._aroundCenter ? c.transform.locationToScreenPoint(u.S.convert(c.center)) : r, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const C = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += C), typeof this._targetZoom == "number" && (this._targetZoom += C);
            }
            if (this._delta !== 0) {
              const C = this._type === "wheel" && Math.abs(this._delta) > Cs ? this._wheelZoomRate : this._defaultZoomRate;
              let P = 2 / (1 + Math.exp(-Math.abs(this._delta * C)));
              this._delta < 0 && P !== 0 && (P = 1 / P);
              const R = typeof this._targetZoom != "number" ? e.scale : u.af(this._targetZoom);
              this._targetZoom = e.getConstrained(e.getCameraLngLat(), u.ak(R * P)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const r = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom, c = this._startZoom, f = this._easing;
            let _, w = !1;
            if (this._type === "wheel" && c && f) {
              const C = he.now() - this._lastWheelEventTime, P = Math.min((C + 5) / 200, 1), R = f(P);
              _ = u.C.number(c, r, R), P < 1 ? this._frameId || (this._frameId = !0) : w = !0;
            } else _ = r, w = !0;
            return this._active = !0, w && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }), 200)), this._lastExpectedZoom = _, { noInertia: !0, needsRenderFrame: !w, zoomDelta: _ - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e) {
            let r = u.co;
            if (this._prevEase) {
              const c = this._prevEase, f = (he.now() - c.start) / c.duration, _ = c.easing(f + 0.01) - c.easing(f), w = 0.27 / Math.sqrt(_ * _ + 1e-4) * 0.01, C = Math.sqrt(0.0729 - w * w);
              r = u.cm(w, C, 0.25, 1);
            }
            return this._prevEase = { start: he.now(), duration: e, easing: r }, r;
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class Ro {
          constructor(e, r) {
            this._clickZoom = e, this._tapZoom = r;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class bl {
          constructor(e) {
            this._tr = new _l(e), this.reset();
          }
          reset() {
            this._active = !1;
          }
          dblclick(e, r) {
            return e.preventDefault(), { cameraAnimation: (c) => {
              c.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(r) }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ac {
          constructor() {
            this._tap = new ki({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(e, r, c) {
            if (!this._swipePoint) if (this._tapTime) {
              const f = r[0], _ = e.timeStamp - this._tapTime < 500, w = this._tapPoint.dist(f) < 30;
              _ && w ? c.length > 0 && (this._swipePoint = f, this._swipeTouch = c[0].identifier) : this.reset();
            } else this._tap.touchstart(e, r, c);
          }
          touchmove(e, r, c) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (c[0].identifier !== this._swipeTouch) return;
                const f = r[0], _ = f.y - this._swipePoint.y;
                return this._swipePoint = f, e.preventDefault(), this._active = !0, { zoomDelta: _ / 128 };
              }
            } else this._tap.touchmove(e, r, c);
          }
          touchend(e, r, c) {
            if (this._tapTime) this._swipePoint && c.length === 0 && this.reset();
            else {
              const f = this._tap.touchend(e, r, c);
              f && (this._tapTime = e.timeStamp, this._tapPoint = f);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ou {
          constructor(e, r, c) {
            this._el = e, this._mousePan = r, this._touchPan = c;
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class lu {
          constructor(e, r, c, f) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = r, this._mousePitch = c, this._mouseRoll = f;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Yh {
          constructor(e, r, c, f) {
            this._el = e, this._touchZoom = r, this._touchRotate = c, this._tapDragZoom = f, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class Do {
          constructor(e, r) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = r, this._enabled = !1;
          }
          isActive() {
            return !1;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = J.create("div", "maplibregl-cooperative-gesture-screen", e);
            let r = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (r = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const c = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), f = document.createElement("div");
            f.className = "maplibregl-desktop-message", f.textContent = r, this._container.appendChild(f);
            const _ = document.createElement("div");
            _.className = "maplibregl-mobile-message", _.textContent = c, this._container.appendChild(_), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (J.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(e) {
            return e[this._bypassKey];
          }
          notifyGestureBlocked(e, r) {
            this._enabled && (this._map.fire(new u.l("cooperativegestureprevented", { gestureType: e, originalEvent: r })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show");
            }), 100));
          }
        }
        const Br = (y) => y.zoom || y.drag || y.roll || y.pitch || y.rotate;
        class Li extends u.l {
        }
        function Lo(y) {
          return y.panDelta && y.panDelta.mag() || y.zoomDelta || y.bearingDelta || y.pitchDelta || y.rollDelta;
        }
        class rc {
          constructor(e, r) {
            this.handleWindowEvent = (f) => {
              this.handleEvent(f, `${f.type}Window`);
            }, this.handleEvent = (f, _) => {
              if (f.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const w = f.type === "renderFrame" ? void 0 : f, C = { needsRenderFrame: !1 }, P = {}, R = {};
              for (const { handlerName: B, handler: V, allowed: $ } of this._handlers) {
                if (!V.isEnabled()) continue;
                let ie;
                if (this._blockedByActive(R, $, B)) V.reset();
                else if (V[_ || f.type]) {
                  if (u.cp(f, _ || f.type)) {
                    const te = J.mousePos(this._map.getCanvas(), f);
                    ie = V[_ || f.type](f, te);
                  } else if (u.cq(f, _ || f.type)) {
                    const te = this._getMapTouches(f.touches), ne = J.touchPos(this._map.getCanvas(), te);
                    ie = V[_ || f.type](f, ne, te);
                  } else u.cr(_ || f.type) || (ie = V[_ || f.type](f));
                  this.mergeHandlerResult(C, P, ie, B, w), ie && ie.needsRenderFrame && this._triggerRenderFrame();
                }
                (ie || V.isActive()) && (R[B] = V);
              }
              const L = {};
              for (const B in this._previousActiveHandlers) R[B] || (L[B] = w);
              this._previousActiveHandlers = R, (Object.keys(L).length || Lo(C)) && (this._changes.push([C, P, L]), this._triggerRenderFrame()), (Object.keys(R).length || Lo(C)) && this._map._stop(!0), this._updatingCamera = !1;
              const { cameraAnimation: j } = C;
              j && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], j(this._map));
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ts(e), this._bearingSnap = r.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(r);
            const c = this._el;
            this._listeners = [[c, "touchstart", { passive: !0 }], [c, "touchmove", { passive: !1 }], [c, "touchend", void 0], [c, "touchcancel", void 0], [c, "mousedown", void 0], [c, "mousemove", void 0], [c, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [c, "mouseover", void 0], [c, "mouseout", void 0], [c, "dblclick", void 0], [c, "click", void 0], [c, "keydown", { capture: !1 }], [c, "keyup", void 0], [c, "wheel", { passive: !1 }], [c, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [f, _, w] of this._listeners) J.addEventListener(f, _, f === document ? this.handleWindowEvent : this.handleEvent, w);
          }
          destroy() {
            for (const [e, r, c] of this._listeners) J.removeEventListener(e, r, e === document ? this.handleWindowEvent : this.handleEvent, c);
          }
          _addDefaultHandlers(e) {
            const r = this._map, c = r.getCanvasContainer();
            this._add("mapEvent", new ha(r, e));
            const f = r.boxZoom = new Hh(r, e);
            this._add("boxZoom", f), e.interactive && e.boxZoom && f.enable();
            const _ = r.cooperativeGestures = new Do(r, e.cooperativeGestures);
            this._add("cooperativeGestures", _), e.cooperativeGestures && _.enable();
            const w = new vr(r), C = new bl(r);
            r.doubleClickZoom = new Ro(C, w), this._add("tapZoom", w), this._add("clickZoom", C), e.interactive && e.doubleClickZoom && r.doubleClickZoom.enable();
            const P = new ac();
            this._add("tapDragZoom", P);
            const R = r.touchPitch = new vl(r);
            this._add("touchPitch", R), e.interactive && e.touchPitch && r.touchPitch.enable(e.touchPitch);
            const L = () => r.project(r.getCenter()), j = (function({ enable: oe, clickTolerance: pe, aroundCenter: ye = !0, minPixelCenterThreshold: ue = 100, rotateDegreesPerPixelMoved: we = 0.8 }, Oe) {
              const ze = new As({ checkCorrectEvent: (Pe) => J.mouseButton(Pe) === 0 && Pe.ctrlKey || J.mouseButton(Pe) === 2 && !Pe.ctrlKey });
              return new Ms({ clickTolerance: pe, move: (Pe, Le) => {
                const lt = Oe();
                if (ye && Math.abs(lt.y - Pe.y) > ue) return { bearingDelta: u.cn(new u.P(Pe.x, Le.y), Le, lt) };
                let ct = (Le.x - Pe.x) * we;
                return ye && Le.y < lt.y && (ct = -ct), { bearingDelta: ct };
              }, moveStateManager: ze, enable: oe, assignEvents: tc });
            })(e, L), B = (function({ enable: oe, clickTolerance: pe, pitchDegreesPerPixelMoved: ye = -0.5 }) {
              const ue = new As({ checkCorrectEvent: (we) => J.mouseButton(we) === 0 && we.ctrlKey || J.mouseButton(we) === 2 });
              return new Ms({ clickTolerance: pe, move: (we, Oe) => ({ pitchDelta: (Oe.y - we.y) * ye }), moveStateManager: ue, enable: oe, assignEvents: tc });
            })(e), V = (function({ enable: oe, clickTolerance: pe, rollDegreesPerPixelMoved: ye = 0.3 }, ue) {
              const we = new As({ checkCorrectEvent: (Oe) => J.mouseButton(Oe) === 2 && Oe.ctrlKey });
              return new Ms({ clickTolerance: pe, move: (Oe, ze) => {
                const Pe = ue();
                let Le = (ze.x - Oe.x) * ye;
                return ze.y < Pe.y && (Le = -Le), { rollDelta: Le };
              }, moveStateManager: we, enable: oe, assignEvents: tc });
            })(e, L);
            r.dragRotate = new lu(e, j, B, V), this._add("mouseRotate", j, ["mousePitch"]), this._add("mousePitch", B, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", V, ["mousePitch"]), e.interactive && e.dragRotate && r.dragRotate.enable();
            const $ = (function({ enable: oe, clickTolerance: pe }) {
              const ye = new As({ checkCorrectEvent: (ue) => J.mouseButton(ue) === 0 && !ue.ctrlKey });
              return new Ms({ clickTolerance: pe, move: (ue, we) => ({ around: we, panDelta: we.sub(ue) }), activateOnStart: !0, moveStateManager: ye, enable: oe, assignEvents: tc });
            })(e), ie = new ru(e, r);
            r.dragPan = new ou(c, $, ie), this._add("mousePan", $), this._add("touchPan", ie, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && r.dragPan.enable(e.dragPan);
            const te = new ko(), ne = new ic();
            r.touchZoomRotate = new Yh(c, ne, te, P), this._add("touchRotate", te, ["touchPan", "touchZoom"]), this._add("touchZoom", ne, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && r.touchZoomRotate.enable(e.touchZoomRotate);
            const re = r.scrollZoom = new Xh(r, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", re, ["mousePan"]), e.interactive && e.scrollZoom && r.scrollZoom.enable(e.scrollZoom);
            const ce = r.keyboard = new nc(r);
            this._add("keyboard", ce), e.interactive && e.keyboard && r.keyboard.enable(), this._add("blockableMapEvent", new ec(r));
          }
          _add(e, r, c) {
            this._handlers.push({ handlerName: e, handler: r, allowed: c }), this._handlersById[e] = r;
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const { handler: r } of this._handlers) r.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e } of this._handlers) if (e.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!Br(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(e, r, c) {
            for (const f in e) if (f !== c && (!r || r.indexOf(f) < 0)) return !0;
            return !1;
          }
          _getMapTouches(e) {
            const r = [];
            for (const c of e) this._el.contains(c.target) && r.push(c);
            return r;
          }
          mergeHandlerResult(e, r, c, f, _) {
            if (!c) return;
            u.e(e, c);
            const w = { handlerName: f, originalEvent: c.originalEvent || _ };
            c.zoomDelta !== void 0 && (r.zoom = w), c.panDelta !== void 0 && (r.drag = w), c.rollDelta !== void 0 && (r.roll = w), c.pitchDelta !== void 0 && (r.pitch = w), c.bearingDelta !== void 0 && (r.rotate = w);
          }
          _applyChanges() {
            const e = {}, r = {}, c = {};
            for (const [f, _, w] of this._changes) f.panDelta && (e.panDelta = (e.panDelta || new u.P(0, 0))._add(f.panDelta)), f.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + f.zoomDelta), f.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + f.bearingDelta), f.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + f.pitchDelta), f.rollDelta && (e.rollDelta = (e.rollDelta || 0) + f.rollDelta), f.around !== void 0 && (e.around = f.around), f.pinchAround !== void 0 && (e.pinchAround = f.pinchAround), f.noInertia && (e.noInertia = f.noInertia), u.e(r, _), u.e(c, w);
            this._updateMapTransform(e, r, c), this._changes = [];
          }
          _updateMapTransform(e, r, c) {
            const f = this._map, _ = f._getTransformForUpdate(), w = f.terrain;
            if (!(Lo(e) || w && this._terrainMovement)) return this._fireEvents(r, c, !0);
            f._stop(!0);
            let { panDelta: C, zoomDelta: P, bearingDelta: R, pitchDelta: L, rollDelta: j, around: B, pinchAround: V } = e;
            V !== void 0 && (B = V), B = B || f.transform.centerPoint, w && !_.isPointOnMapSurface(B) && (B = _.centerPoint);
            const $ = { panDelta: C, zoomDelta: P, rollDelta: j, pitchDelta: L, bearingDelta: R, around: B };
            this._map.cameraHelper.useGlobeControls && !_.isPointOnMapSurface(B) && (B = _.centerPoint);
            const ie = B.distSqr(_.centerPoint) < 0.01 ? _.center : _.screenPointToLocation(C ? B.sub(C) : B);
            w ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom($, _), this._terrainMovement || !r.drag && !r.zoom ? r.drag && this._terrainMovement ? _.setCenter(_.screenPointToLocation(_.centerPoint.sub(C))) : this._map.cameraHelper.handleMapControlsPan($, _, ie) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan($, _, ie))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom($, _), this._map.cameraHelper.handleMapControlsPan($, _, ie)), f._applyUpdatedTransform(_), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(r, c, !0);
          }
          _fireEvents(e, r, c) {
            const f = Br(this._eventsInProgress), _ = Br(e), w = {};
            for (const j in e) {
              const { originalEvent: B } = e[j];
              this._eventsInProgress[j] || (w[`${j}start`] = B), this._eventsInProgress[j] = e[j];
            }
            !f && _ && this._fireEvent("movestart", _.originalEvent);
            for (const j in w) this._fireEvent(j, w[j]);
            _ && this._fireEvent("move", _.originalEvent);
            for (const j in e) {
              const { originalEvent: B } = e[j];
              this._fireEvent(j, B);
            }
            const C = {};
            let P;
            for (const j in this._eventsInProgress) {
              const { handlerName: B, originalEvent: V } = this._eventsInProgress[j];
              this._handlersById[B].isActive() || (delete this._eventsInProgress[j], P = r[B] || V, C[`${j}end`] = P);
            }
            for (const j in C) this._fireEvent(j, C[j]);
            const R = Br(this._eventsInProgress), L = (f || _) && !R;
            if (L && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const j = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && j.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(j);
            }
            if (c && L) {
              this._updatingCamera = !0;
              const j = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), B = (V) => V !== 0 && -this._bearingSnap < V && V < this._bearingSnap;
              !j || !j.essential && he.prefersReducedMotion ? (this._map.fire(new u.l("moveend", { originalEvent: P })), B(this._map.getBearing()) && this._map.resetNorth()) : (B(j.bearing || this._map.getBearing()) && (j.bearing = 0), j.freezeElevation = !0, this._map.easeTo(j, { originalEvent: P })), this._updatingCamera = !1;
            }
          }
          _fireEvent(e, r) {
            this._map.fire(new u.l(e, r ? { originalEvent: r } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e) => {
              delete this._frameId, this.handleEvent(new Li("renderFrame", { timeStamp: e })), this._applyChanges();
            }));
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class Ws extends u.E {
          constructor(e, r, c) {
            super(), this._renderFrameCallback = () => {
              const f = Math.min((he.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(f)), f < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = c.bearingSnap, this.cameraHelper = r, this.on("moveend", (() => {
              delete this._requestedCameraState;
            }));
          }
          migrateProjection(e, r) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = r;
          }
          getCenter() {
            return new u.S(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e, r) {
            return this.jumpTo({ center: e }, r);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(e, r) {
            return this.jumpTo({ elevation: e }, r), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e;
          }
          panBy(e, r, c) {
            return e = u.P.convert(e).mult(-1), this.panTo(this.transform.center, u.e({ offset: e }, r), c);
          }
          panTo(e, r, c) {
            return this.easeTo(u.e({ center: e }, r), c);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e, r) {
            return this.jumpTo({ zoom: e }, r), this;
          }
          zoomTo(e, r, c) {
            return this.easeTo(u.e({ zoom: e }, r), c);
          }
          zoomIn(e, r) {
            return this.zoomTo(this.getZoom() + 1, e, r), this;
          }
          zoomOut(e, r) {
            return this.zoomTo(this.getZoom() - 1, e, r), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(e, r) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new u.l("movestart", r)).fire(new u.l("move", r)).fire(new u.l("moveend", r))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e, r) {
            return this.jumpTo({ bearing: e }, r), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e, r) {
            return this.jumpTo({ padding: e }, r), this;
          }
          rotateTo(e, r, c) {
            return this.easeTo(u.e({ bearing: e }, r), c);
          }
          resetNorth(e, r) {
            return this.rotateTo(0, u.e({ duration: 1e3 }, e), r), this;
          }
          resetNorthPitch(e, r) {
            return this.easeTo(u.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e), r), this;
          }
          snapToNorth(e, r) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, r) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e, r) {
            return this.jumpTo({ pitch: e }, r), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(e, r) {
            return this.jumpTo({ roll: e }, r), this;
          }
          cameraForBounds(e, r) {
            e = an.convert(e).adjustAntiMeridian();
            const c = r && r.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), c, r);
          }
          _cameraForBoxAndBearing(e, r, c, f) {
            const _ = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (f = u.e({ padding: _, offset: [0, 0], maxZoom: this.transform.maxZoom }, f)).padding == "number") {
              const R = f.padding;
              f.padding = { top: R, bottom: R, right: R, left: R };
            }
            const w = u.e(_, f.padding);
            f.padding = w;
            const C = this.transform, P = new an(e, r);
            return this.cameraHelper.cameraForBoxAndBearing(f, w, P, c, C);
          }
          fitBounds(e, r, c) {
            return this._fitInternal(this.cameraForBounds(e, r), r, c);
          }
          fitScreenCoordinates(e, r, c, f, _) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(u.P.convert(e)), this.transform.screenPointToLocation(u.P.convert(r)), c, f), f, _);
          }
          _fitInternal(e, r, c) {
            return e ? (delete (r = u.e(e, r)).padding, r.linear ? this.easeTo(r, c) : this.flyTo(r, c)) : this;
          }
          jumpTo(e, r) {
            this.stop();
            const c = this._getTransformForUpdate();
            let f = !1, _ = !1, w = !1;
            const C = c.zoom;
            this.cameraHelper.handleJumpToCenterZoom(c, e);
            const P = c.zoom !== C;
            return "elevation" in e && c.elevation !== +e.elevation && c.setElevation(+e.elevation), "bearing" in e && c.bearing !== +e.bearing && (f = !0, c.setBearing(+e.bearing)), "pitch" in e && c.pitch !== +e.pitch && (_ = !0, c.setPitch(+e.pitch)), "roll" in e && c.roll !== +e.roll && (w = !0, c.setRoll(+e.roll)), e.padding == null || c.isPaddingEqual(e.padding) || c.setPadding(e.padding), this._applyUpdatedTransform(c), this.fire(new u.l("movestart", r)).fire(new u.l("move", r)), P && this.fire(new u.l("zoomstart", r)).fire(new u.l("zoom", r)).fire(new u.l("zoomend", r)), f && this.fire(new u.l("rotatestart", r)).fire(new u.l("rotate", r)).fire(new u.l("rotateend", r)), _ && this.fire(new u.l("pitchstart", r)).fire(new u.l("pitch", r)).fire(new u.l("pitchend", r)), w && this.fire(new u.l("rollstart", r)).fire(new u.l("roll", r)).fire(new u.l("rollend", r)), this.fire(new u.l("moveend", r));
          }
          calculateCameraOptionsFromTo(e, r, c, f = 0) {
            const _ = u.a1.fromLngLat(e, r), w = u.a1.fromLngLat(c, f), C = w.x - _.x, P = w.y - _.y, R = w.z - _.z, L = Math.hypot(C, P, R);
            if (L === 0) throw new Error("Can't calculate camera options with same From and To");
            const j = Math.hypot(C, P), B = u.ak(this.transform.cameraToCenterDistance / L / this.transform.tileSize), V = 180 * Math.atan2(C, -P) / Math.PI;
            let $ = 180 * Math.acos(j / L) / Math.PI;
            return $ = R < 0 ? 90 - $ : 90 + $, { center: w.toLngLat(), elevation: f, zoom: B, pitch: $, bearing: V };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, r, c, f, _) {
            const w = this.transform.calculateCenterFromCameraLngLatAlt(e, r, c, f);
            return { center: w.center, elevation: w.elevation, zoom: w.zoom, bearing: c, pitch: f, roll: _ };
          }
          easeTo(e, r) {
            this._stop(!1, e.easeId), ((e = u.e({ offset: [0, 0], duration: 500, easing: u.co }, e)).animate === !1 || !e.essential && he.prefersReducedMotion) && (e.duration = 0);
            const c = this._getTransformForUpdate(), f = this.getBearing(), _ = c.pitch, w = c.roll, C = "bearing" in e ? this._normalizeBearing(e.bearing, f) : f, P = "pitch" in e ? +e.pitch : _, R = "roll" in e ? this._normalizeBearing(e.roll, w) : w, L = "padding" in e ? e.padding : c.padding, j = u.P.convert(e.offset);
            let B, V;
            e.around && (B = u.S.convert(e.around), V = c.locationToScreenPoint(B));
            const $ = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, ie = this.cameraHelper.handleEaseTo(c, { bearing: C, pitch: P, roll: R, padding: L, around: B, aroundPoint: V, offsetAsPoint: j, offset: e.offset, zoom: e.zoom, center: e.center });
            return this._rotating = this._rotating || f !== C, this._pitching = this._pitching || P !== _, this._rolling = this._rolling || R !== w, this._padding = !c.isPaddingEqual(L), this._zooming = this._zooming || ie.isZooming, this._easeId = e.easeId, this._prepareEase(r, e.noMoveStart, $), this.terrain && this._prepareElevation(ie.elevationCenter), this._ease(((te) => {
              ie.easeFunc(te), this.terrain && !e.freezeElevation && this._updateElevation(te), this._applyUpdatedTransform(c), this._fireMoveEvents(r);
            }), ((te) => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(r, te);
            }), e), this;
          }
          _prepareEase(e, r, c = {}) {
            this._moving = !0, r || c.moving || this.fire(new u.l("movestart", e)), this._zooming && !c.zooming && this.fire(new u.l("zoomstart", e)), this._rotating && !c.rotating && this.fire(new u.l("rotatestart", e)), this._pitching && !c.pitching && this.fire(new u.l("pitchstart", e)), this._rolling && !c.rolling && this.fire(new u.l("rollstart", e));
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0;
          }
          _updateElevation(e) {
            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const r = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && r !== this._elevationTarget) {
              const c = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (c - (r - (c * e + this._elevationStart)) / (1 - e)), this._elevationTarget = r;
            }
            this.transform.setElevation(u.C.number(this._elevationStart, this._elevationTarget, e));
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const r = e.getCameraLngLat(), c = e.getCameraAltitude(), f = this.terrain ? this.terrain.getElevationForLngLatZoom(r, e.zoom) : 0;
            if (c < f) {
              const _ = this.calculateCameraOptionsFromTo(r, f, e.center, e.elevation);
              return { pitch: _.pitch, zoom: _.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(e) {
            const r = [];
            if (r.push(((f) => this._elevateCameraIfInsideTerrain(f))), this.transformCameraUpdate && r.push(((f) => this.transformCameraUpdate(f))), !r.length) return;
            const c = e.clone();
            for (const f of r) {
              const _ = c.clone(), { center: w, zoom: C, roll: P, pitch: R, bearing: L, elevation: j } = f(_);
              w && _.setCenter(w), j !== void 0 && _.setElevation(j), C !== void 0 && _.setZoom(C), P !== void 0 && _.setRoll(P), R !== void 0 && _.setPitch(R), L !== void 0 && _.setBearing(L), c.apply(_);
            }
            this.transform.apply(c);
          }
          _fireMoveEvents(e) {
            this.fire(new u.l("move", e)), this._zooming && this.fire(new u.l("zoom", e)), this._rotating && this.fire(new u.l("rotate", e)), this._pitching && this.fire(new u.l("pitch", e)), this._rolling && this.fire(new u.l("roll", e));
          }
          _afterEase(e, r) {
            if (this._easeId && r && this._easeId === r) return;
            delete this._easeId;
            const c = this._zooming, f = this._rotating, _ = this._pitching, w = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, c && this.fire(new u.l("zoomend", e)), f && this.fire(new u.l("rotateend", e)), _ && this.fire(new u.l("pitchend", e)), w && this.fire(new u.l("rollend", e)), this.fire(new u.l("moveend", e));
          }
          flyTo(e, r) {
            if (!e.essential && he.prefersReducedMotion) {
              const Le = u.Q(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(Le, r);
            }
            this.stop(), e = u.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: u.co }, e);
            const c = this._getTransformForUpdate(), f = c.bearing, _ = c.pitch, w = c.roll, C = c.padding, P = "bearing" in e ? this._normalizeBearing(e.bearing, f) : f, R = "pitch" in e ? +e.pitch : _, L = "roll" in e ? this._normalizeBearing(e.roll, w) : w, j = "padding" in e ? e.padding : c.padding, B = u.P.convert(e.offset);
            let V = c.centerPoint.add(B);
            const $ = c.screenPointToLocation(V), ie = this.cameraHelper.handleFlyTo(c, { bearing: P, pitch: R, roll: L, padding: j, locationAtOffset: $, offsetAsPoint: B, center: e.center, minZoom: e.minZoom, zoom: e.zoom });
            let te = e.curve;
            const ne = Math.max(c.width, c.height), re = ne / ie.scaleOfZoom, ce = ie.pixelPathLength;
            typeof ie.scaleOfMinZoom == "number" && (te = Math.sqrt(ne / ie.scaleOfMinZoom / ce * 2));
            const oe = te * te;
            function pe(Le) {
              const lt = (re * re - ne * ne + (Le ? -1 : 1) * oe * oe * ce * ce) / (2 * (Le ? re : ne) * oe * ce);
              return Math.log(Math.sqrt(lt * lt + 1) - lt);
            }
            function ye(Le) {
              return (Math.exp(Le) - Math.exp(-Le)) / 2;
            }
            function ue(Le) {
              return (Math.exp(Le) + Math.exp(-Le)) / 2;
            }
            const we = pe(!1);
            let Oe = function(Le) {
              return ue(we) / ue(we + te * Le);
            }, ze = function(Le) {
              return ne * ((ue(we) * (ye(lt = we + te * Le) / ue(lt)) - ye(we)) / oe) / ce;
              var lt;
            }, Pe = (pe(!0) - we) / te;
            if (Math.abs(ce) < 2e-6 || !isFinite(Pe)) {
              if (Math.abs(ne - re) < 1e-6) return this.easeTo(e, r);
              const Le = re < ne ? -1 : 1;
              Pe = Math.abs(Math.log(re / ne)) / te, ze = () => 0, Oe = (lt) => Math.exp(Le * te * lt);
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * Pe / ("screenSpeed" in e ? +e.screenSpeed / te : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = f !== P, this._pitching = R !== _, this._rolling = L !== w, this._padding = !c.isPaddingEqual(j), this._prepareEase(r, !1), this.terrain && this._prepareElevation(ie.targetCenter), this._ease(((Le) => {
              const lt = Le * Pe, ct = 1 / Oe(lt), We = ze(lt);
              this._rotating && c.setBearing(u.C.number(f, P, Le)), this._pitching && c.setPitch(u.C.number(_, R, Le)), this._rolling && c.setRoll(u.C.number(w, L, Le)), this._padding && (c.interpolatePadding(C, j, Le), V = c.centerPoint.add(B)), ie.easeFunc(Le, ct, We, V), this.terrain && !e.freezeElevation && this._updateElevation(Le), this._applyUpdatedTransform(c), this._fireMoveEvents(r);
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(r);
            }), e), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e, r) {
            var c;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const f = this._onEaseEnd;
              delete this._onEaseEnd, f.call(this, r);
            }
            return e || (c = this.handlers) === null || c === void 0 || c.stop(!1), this;
          }
          _ease(e, r, c) {
            c.animate === !1 || c.duration === 0 ? (e(1), r()) : (this._easeStart = he.now(), this._easeOptions = c, this._onEaseFrame = e, this._onEaseEnd = r, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e, r) {
            e = u.aO(e, -180, 180);
            const c = Math.abs(e - r);
            return Math.abs(e - 360 - r) < c && (e -= 360), Math.abs(e + 360 - r) < c && (e += 360), e;
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(u.S.convert(e), this.transform.tileZoom) : null;
          }
        }
        const zs = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class wl {
          constructor(e = zs) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (r) => {
              !r || r.sourceDataType !== "metadata" && r.sourceDataType !== "visibility" && r.dataType !== "style" && r.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = J.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = J.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = J.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            J.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e, r) {
            const c = this._map._getUIString(`AttributionControl.${r}`);
            e.title = c, e.setAttribute("aria-label", c);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map(((f) => typeof f != "string" ? "" : f))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const f = this._map.style.stylesheet;
              this.styleOwner = f.owner, this.styleId = f.id;
            }
            const r = this._map.style.sourceCaches;
            for (const f in r) {
              const _ = r[f];
              if (_.used || _.usedForTerrain) {
                const w = _.getSource();
                w.attribution && e.indexOf(w.attribution) < 0 && e.push(w.attribution);
              }
            }
            e = e.filter(((f) => String(f).trim())), e.sort(((f, _) => f.length - _.length)), e = e.filter(((f, _) => {
              for (let w = _ + 1; w < e.length; w++) if (e[w].indexOf(f) >= 0) return !1;
              return !0;
            }));
            const c = e.join(" | ");
            c !== this._attribHTML && (this._attribHTML = c, e.length ? (this._innerContainer.innerHTML = J.sanitize(c), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class Kc {
          constructor(e = {}) {
            this._updateCompact = () => {
              const r = this._container.children;
              if (r.length) {
                const c = r[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && c.classList.add("maplibregl-compact") : c.classList.remove("maplibregl-compact");
              }
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = J.create("div", "maplibregl-ctrl");
            const r = J.create("a", "maplibregl-ctrl-logo");
            return r.target = "_blank", r.rel = "noopener nofollow", r.href = "https://maplibre.org/", r.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), r.setAttribute("rel", "noopener nofollow"), this._container.appendChild(r), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            J.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class Nr {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(e) {
            const r = ++this._id;
            return this._queue.push({ callback: e, id: r, cancelled: !1 }), r;
          }
          remove(e) {
            const r = this._currentlyRunning, c = r ? this._queue.concat(r) : this._queue;
            for (const f of c) if (f.id === e) return void (f.cancelled = !0);
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const r = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const c of r) if (!c.cancelled && (c.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        var Oo = u.aJ([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class Tt extends u.E {
          constructor(e) {
            super(), this._lastTilesetChange = he.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize;
          }
          destruct() {
            this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
          }
          update(e, r) {
            this.sourceCache.update(e, r), this._renderableTilesKeys = [];
            const c = {};
            for (const f of Ae(e, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: r, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) c[f.key] = !0, this._renderableTilesKeys.push(f.key), this._tiles[f.key] || (f.terrainRttPosMatrix32f = new Float64Array(16), u.bY(f.terrainRttPosMatrix32f, 0, u.$, u.$, 0, 0, 1), this._tiles[f.key] = new js(f, this.tileSize), this._lastTilesetChange = he.now());
            for (const f in this._tiles) c[f] || delete this._tiles[f];
          }
          freeRtt(e) {
            for (const r in this._tiles) {
              const c = this._tiles[r];
              (!e || c.tileID.equals(e) || c.tileID.isChildOf(e) || e.isChildOf(c.tileID)) && (c.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map(((e) => this.getTileByID(e)));
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          getTerrainCoords(e, r) {
            return r ? this._getTerrainCoordsForTileRanges(e, r) : this._getTerrainCoordsForRegularTile(e);
          }
          _getTerrainCoordsForRegularTile(e) {
            const r = {};
            for (const c of this._renderableTilesKeys) {
              const f = this._tiles[c].tileID, _ = e.clone(), w = u.ba();
              if (f.canonical.equals(e.canonical)) u.bY(w, 0, u.$, u.$, 0, 0, 1);
              else if (f.canonical.isChildOf(e.canonical)) {
                const C = f.canonical.z - e.canonical.z, P = f.canonical.x - (f.canonical.x >> C << C), R = f.canonical.y - (f.canonical.y >> C << C), L = u.$ >> C;
                u.bY(w, 0, L, L, 0, 0, 1), u.M(w, w, [-P * L, -R * L, 0]);
              } else {
                if (!e.canonical.isChildOf(f.canonical)) continue;
                {
                  const C = e.canonical.z - f.canonical.z, P = e.canonical.x - (e.canonical.x >> C << C), R = e.canonical.y - (e.canonical.y >> C << C), L = u.$ >> C;
                  u.bY(w, 0, u.$, u.$, 0, 0, 1), u.M(w, w, [P * L, R * L, 0]), u.N(w, w, [1 / 2 ** C, 1 / 2 ** C, 0]);
                }
              }
              _.terrainRttPosMatrix32f = new Float32Array(w), r[c] = _;
            }
            return r;
          }
          _getTerrainCoordsForTileRanges(e, r) {
            const c = {};
            for (const f of this._renderableTilesKeys) {
              const _ = this._tiles[f].tileID;
              if (!this._isWithinTileRanges(_, r)) continue;
              const w = e.clone(), C = u.ba();
              if (_.canonical.z === e.canonical.z) {
                const P = e.canonical.x - _.canonical.x, R = e.canonical.y - _.canonical.y;
                u.bY(C, 0, u.$, u.$, 0, 0, 1), u.M(C, C, [P * u.$, R * u.$, 0]);
              } else if (_.canonical.z > e.canonical.z) {
                const P = _.canonical.z - e.canonical.z, R = _.canonical.x - (_.canonical.x >> P << P), L = _.canonical.y - (_.canonical.y >> P << P), j = e.canonical.x - (_.canonical.x >> P), B = e.canonical.y - (_.canonical.y >> P), V = u.$ >> P;
                u.bY(C, 0, V, V, 0, 0, 1), u.M(C, C, [-R * V + j * u.$, -L * V + B * u.$, 0]);
              } else {
                const P = e.canonical.z - _.canonical.z, R = e.canonical.x - (e.canonical.x >> P << P), L = e.canonical.y - (e.canonical.y >> P << P), j = (e.canonical.x >> P) - _.canonical.x, B = (e.canonical.y >> P) - _.canonical.y, V = u.$ << P;
                u.bY(C, 0, V, V, 0, 0, 1), u.M(C, C, [R * u.$ + j * V, L * u.$ + B * V, 0]);
              }
              w.terrainRttPosMatrix32f = new Float32Array(C), c[f] = w;
            }
            return c;
          }
          getSourceTile(e, r) {
            const c = this.sourceCache._source;
            let f = e.overscaledZ - this.deltaZoom;
            if (f > c.maxzoom && (f = c.maxzoom), f < c.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(f).key);
            let _ = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
            if ((!_ || !_.dem) && r) for (; f >= c.minzoom && (!_ || !_.dem); ) _ = this.sourceCache.getTileByID(e.scaledTo(f--).key);
            return _;
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e;
          }
          _isWithinTileRanges(e, r) {
            return r[e.canonical.z] && e.canonical.x >= r[e.canonical.z].minTileX && e.canonical.x <= r[e.canonical.z].maxTileX && e.canonical.y >= r[e.canonical.z].minTileY && e.canonical.y <= r[e.canonical.z].maxTileY;
          }
        }
        class Ot {
          constructor(e, r, c) {
            this._meshCache = {}, this.painter = e, this.sourceCache = new Tt(r), this.options = c, this.exaggeration = typeof c.exaggeration == "number" ? c.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e, r, c, f = u.$) {
            var _;
            if (!(r >= 0 && r < f && c >= 0 && c < f)) return 0;
            const w = this.getTerrainData(e), C = (_ = w.tile) === null || _ === void 0 ? void 0 : _.dem;
            if (!C) return 0;
            const P = u.cs([], [r / f * u.$, c / f * u.$], w.u_terrain_matrix), R = [P[0] * C.dim, P[1] * C.dim], L = Math.floor(R[0]), j = Math.floor(R[1]), B = R[0] - L, V = R[1] - j;
            return C.get(L, j) * (1 - B) * (1 - V) + C.get(L + 1, j) * B * (1 - V) + C.get(L, j + 1) * (1 - B) * V + C.get(L + 1, j + 1) * B * V;
          }
          getElevationForLngLatZoom(e, r) {
            if (!u.ct(r, e.wrap())) return 0;
            const { tileID: c, mercatorX: f, mercatorY: _ } = this._getOverscaledTileIDFromLngLatZoom(e, r);
            return this.getElevation(c, f % u.$, _ % u.$, u.$);
          }
          getElevation(e, r, c, f = u.$) {
            return this.getDEMElevation(e, r, c, f) * this.exaggeration;
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const f = this.painter.context, _ = new u.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new u.T(f, _, f.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new u.T(f, new u.R({ width: 1, height: 1 }), f.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(f.gl.NEAREST, f.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = u.ag([]);
            }
            const r = this.sourceCache.getSourceTile(e, !0);
            if (r && r.dem && (!r.demTexture || r.needsTerrainPrepare)) {
              const f = this.painter.context;
              r.demTexture = this.painter.getTileTexture(r.dem.stride), r.demTexture ? r.demTexture.update(r.dem.getPixels(), { premultiply: !1 }) : r.demTexture = new u.T(f, r.dem.getPixels(), f.gl.RGBA, { premultiply: !1 }), r.demTexture.bind(f.gl.NEAREST, f.gl.CLAMP_TO_EDGE), r.needsTerrainPrepare = !1;
            }
            const c = r && r + r.tileID.key + e.key;
            if (c && !this._demMatrixCache[c]) {
              const f = this.sourceCache.sourceCache._source.maxzoom;
              let _ = e.canonical.z - r.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= f ? _ = e.canonical.z - f : u.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const w = e.canonical.x - (e.canonical.x >> _ << _), C = e.canonical.y - (e.canonical.y >> _ << _), P = u.cu(new Float64Array(16), [1 / (u.$ << _), 1 / (u.$ << _), 0]);
              u.M(P, P, [w * u.$, C * u.$, 0]), this._demMatrixCache[e.key] = { matrix: P, coord: e };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: r && r.dem && r.dem.dim || 1, u_terrain_matrix: c ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: r && r.dem && r.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (r && r.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: r };
          }
          getFramebuffer(e) {
            const r = this.painter, c = r.width / devicePixelRatio, f = r.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === c && this._fbo.height === f || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new u.T(r.context, { width: c, height: f, data: null }, r.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new u.T(r.context, { width: c, height: f, data: null }, r.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = r.context.createFramebuffer(c, f, !0, !1), this._fbo.depthAttachment.set(r.context.createRenderbuffer(r.context.gl.DEPTH_COMPONENT16, c, f))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const r = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let _ = 0, w = 0; _ < this._coordsTextureSize; _++) for (let C = 0; C < this._coordsTextureSize; C++, w += 4) r[w + 0] = 255 & C, r[w + 1] = 255 & _, r[w + 2] = C >> 8 << 4 | _ >> 8, r[w + 3] = 0;
            const c = new u.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(r.buffer)), f = new u.T(e, c, e.gl.RGBA, { premultiply: !1 });
            return f.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = f, f;
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const r = new Uint8Array(4), c = this.painter.context, f = c.gl, _ = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), w = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), C = Math.round(this.painter.height / devicePixelRatio);
            c.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), f.readPixels(_, C - w - 1, 1, 1, f.RGBA, f.UNSIGNED_BYTE, r), c.bindFramebuffer.set(null);
            const P = r[0] + (r[2] >> 4 << 8), R = r[1] + ((15 & r[2]) << 8), L = this.coordsIndex[255 - r[3]], j = L && this.sourceCache.getTileByID(L);
            if (!j) return null;
            const B = this._coordsTextureSize, V = (1 << j.tileID.canonical.z) * B;
            return new u.a1((j.tileID.canonical.x * B + P) / V + j.tileID.wrap, (j.tileID.canonical.y * B + R) / V, this.getElevation(j.tileID, P, R, B));
          }
          depthAtPoint(e) {
            const r = new Uint8Array(4), c = this.painter.context, f = c.gl;
            return c.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), f.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, f.RGBA, f.UNSIGNED_BYTE, r), c.bindFramebuffer.set(null), (r[0] / 16777216 + r[1] / 65536 + r[2] / 256 + r[3]) / 256;
          }
          getTerrainMesh(e) {
            var r;
            const c = ((r = this.painter.style.projection) === null || r === void 0 ? void 0 : r.transitionState) > 0, f = c && e.canonical.y === 0, _ = c && e.canonical.y === (1 << e.canonical.z) - 1, w = `m_${f ? "n" : ""}_${_ ? "s" : ""}`;
            if (this._meshCache[w]) return this._meshCache[w];
            const C = this.painter.context, P = new u.cv(), R = new u.aN(), L = this.meshSize, j = u.$ / L, B = L * L;
            for (let ue = 0; ue <= L; ue++) for (let we = 0; we <= L; we++) P.emplaceBack(we * j, ue * j, 0);
            for (let ue = 0; ue < B; ue += L + 1) for (let we = 0; we < L; we++) R.emplaceBack(we + ue, L + we + ue + 1, L + we + ue + 2), R.emplaceBack(we + ue, L + we + ue + 2, we + ue + 1);
            const V = P.length, $ = V + (L + 1), ie = (L + 1) * L, te = f ? u.bh : 0, ne = f ? 0 : 1, re = _ ? u.bi : u.$, ce = _ ? 0 : 1;
            for (let ue = 0; ue <= L; ue++) P.emplaceBack(ue * j, te, ne);
            for (let ue = 0; ue <= L; ue++) P.emplaceBack(ue * j, re, ce);
            for (let ue = 0; ue < L; ue++) R.emplaceBack(ie + ue, $ + ue, $ + ue + 1), R.emplaceBack(ie + ue, $ + ue + 1, ie + ue + 1), R.emplaceBack(0 + ue, V + ue + 1, V + ue), R.emplaceBack(0 + ue, 0 + ue + 1, V + ue + 1);
            const oe = P.length, pe = oe + 2 * (L + 1);
            for (const ue of [0, 1]) for (let we = 0; we <= L; we++) for (const Oe of [0, 1]) P.emplaceBack(ue * u.$, we * j, Oe);
            for (let ue = 0; ue < 2 * L; ue += 2) R.emplaceBack(oe + ue, oe + ue + 1, oe + ue + 3), R.emplaceBack(oe + ue, oe + ue + 3, oe + ue + 2), R.emplaceBack(pe + ue, pe + ue + 3, pe + ue + 1), R.emplaceBack(pe + ue, pe + ue + 2, pe + ue + 3);
            const ye = new _o(C.createVertexBuffer(P, Oo.members), C.createIndexBuffer(R), u.aM.simpleSegment(0, 0, P.length, R.length));
            return this._meshCache[w] = ye, ye;
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * u.bu / Math.pow(2, Math.max(e, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(e, r) {
            var c;
            const { tileID: f } = this._getOverscaledTileIDFromLngLatZoom(e, r);
            return (c = this.getMinMaxElevation(f).minElevation) !== null && c !== void 0 ? c : 0;
          }
          getMinMaxElevation(e) {
            const r = this.getTerrainData(e).tile, c = { minElevation: null, maxElevation: null };
            return r && r.dem && (c.minElevation = r.dem.min * this.exaggeration, c.maxElevation = r.dem.max * this.exaggeration), c;
          }
          _getOverscaledTileIDFromLngLatZoom(e, r) {
            const c = u.a1.fromLngLat(e.wrap()), f = (1 << r) * u.$, _ = c.x * f, w = c.y * f, C = Math.floor(_ / u.$), P = Math.floor(w / u.$);
            return { tileID: new u.Z(r, 0, r, C, P), mercatorX: _, mercatorY: w };
          }
        }
        class sc {
          constructor(e, r, c) {
            this._context = e, this._size = r, this._tileSize = c, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
          }
          _createObject(e) {
            const r = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), c = new u.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return c.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), r.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), r.colorAttachment.set(c.texture), { id: e, fbo: r, texture: c, stamp: -1, inUse: !1 };
          }
          getObjectForId(e) {
            return this._objects[e];
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(((r) => e.id !== r)), this._recentlyUsed.push(e.id);
          }
          stampObject(e) {
            e.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const r of this._recentlyUsed) if (!this._objects[r].inUse) return this._objects[r];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e;
          }
          freeObject(e) {
            e.inUse = !1;
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some(((e) => !e.inUse)) === !1;
          }
        }
        const xr = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0, "color-relief": !0 };
        class Sl {
          constructor(e, r) {
            this.painter = e, this.terrain = r, this.pool = new sc(e.context, 30, r.sourceCache.tileSize * r.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(e, r) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter(((c) => !e._layers[c].isHidden(r))), this._coordsAscending = {};
            for (const c in e.sourceCaches) {
              this._coordsAscending[c] = {};
              const f = e.sourceCaches[c].getVisibleCoordinates(), _ = e.sourceCaches[c].getSource(), w = _ instanceof pr ? _.terrainTileRanges : null;
              for (const C of f) {
                const P = this.terrain.sourceCache.getTerrainCoords(C, w);
                for (const R in P) this._coordsAscending[c][R] || (this._coordsAscending[c][R] = []), this._coordsAscending[c][R].push(P[R]);
              }
            }
            this._coordsAscendingStr = {};
            for (const c of e._order) {
              const f = e._layers[c], _ = f.source;
              if (xr[f.type] && !this._coordsAscendingStr[_]) {
                this._coordsAscendingStr[_] = {};
                for (const w in this._coordsAscending[_]) this._coordsAscendingStr[_][w] = this._coordsAscending[_][w].map(((C) => C.key)).sort().join();
              }
            }
            for (const c of this._renderableTiles) for (const f in this._coordsAscendingStr) {
              const _ = this._coordsAscendingStr[f][c.tileID.key];
              _ && _ !== c.rttCoords[f] && (c.rtt = []);
            }
          }
          renderLayer(e, r) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const c = Object.assign(Object.assign({}, r), { isRenderingToTexture: !0 }), f = e.type, _ = this.painter, w = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (xr[f] && (this._prevType && xr[this._prevType] || this._stacks.push([]), this._prevType = f, this._stacks[this._stacks.length - 1].push(e.id), !w)) return !0;
            if (xr[this._prevType] || xr[f] && w) {
              this._prevType = f;
              const C = this._stacks.length - 1, P = this._stacks[C] || [];
              for (const R of this._renderableTiles) {
                if (this.pool.isFull() && (Qr(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(R), R.rtt[C]) {
                  const j = this.pool.getObjectForId(R.rtt[C].id);
                  if (j.stamp === R.rtt[C].stamp) {
                    this.pool.useObject(j);
                    continue;
                  }
                }
                const L = this.pool.getOrCreateFreeObject();
                this.pool.useObject(L), this.pool.stampObject(L), R.rtt[C] = { id: L.id, stamp: L.stamp }, _.context.bindFramebuffer.set(L.fbo.framebuffer), _.context.clear({ color: u.bf.transparent, stencil: 0 }), _.currentStencilSource = void 0;
                for (let j = 0; j < P.length; j++) {
                  const B = _.style._layers[P[j]], V = B.source ? this._coordsAscending[B.source][R.tileID.key] : [R.tileID];
                  _.context.viewport.set([0, 0, L.fbo.width, L.fbo.height]), _._renderTileClippingMasks(B, V, !0), _.renderLayer(_, _.style.sourceCaches[B.source], B, V, c), B.source && (R.rttCoords[B.source] = this._coordsAscendingStr[B.source][R.tileID.key]);
                }
              }
              return Qr(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects(), xr[f];
            }
            return !1;
          }
        }
        const za = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Wc = O, rr = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: zs, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: u.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0 }, br = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 };
        class Pa {
          constructor(e, r, c = !1) {
            this.mousedown = (_) => {
              this.startMove(_, J.mousePos(this.element, _)), J.addEventListener(window, "mousemove", this.mousemove), J.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (_) => {
              this.move(_, J.mousePos(this.element, _));
            }, this.mouseup = (_) => {
              this._rotatePitchHandler.dragEnd(_), this.offTemp();
            }, this.touchstart = (_) => {
              _.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = J.touchPos(this.element, _.targetTouches)[0], this.startMove(_, this._startPos), J.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), J.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (_) => {
              _.targetTouches.length !== 1 ? this.reset() : (this._lastPos = J.touchPos(this.element, _.targetTouches)[0], this.move(_, this._lastPos));
            }, this.touchend = (_) => {
              _.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = r;
            const f = new ap();
            this._rotatePitchHandler = new Ms({ clickTolerance: 3, move: (_, w) => {
              const C = r.getBoundingClientRect(), P = new u.P((C.bottom - C.top) / 2, (C.right - C.left) / 2);
              return { bearingDelta: u.cn(new u.P(_.x, w.y), w, P), pitchDelta: c ? -0.5 * (w.y - _.y) : void 0 };
            }, moveStateManager: f, enable: !0, assignEvents: () => {
            } }), this.map = e, J.addEventListener(r, "mousedown", this.mousedown), J.addEventListener(r, "touchstart", this.touchstart, { passive: !1 }), J.addEventListener(r, "touchcancel", this.reset);
          }
          startMove(e, r) {
            this._rotatePitchHandler.dragStart(e, r), J.disableDrag();
          }
          move(e, r) {
            const c = this.map, { bearingDelta: f, pitchDelta: _ } = this._rotatePitchHandler.dragMove(e, r) || {};
            f && c.setBearing(c.getBearing() + f), _ && c.setPitch(c.getPitch() + _);
          }
          off() {
            const e = this.element;
            J.removeEventListener(e, "mousedown", this.mousedown), J.removeEventListener(e, "touchstart", this.touchstart, { passive: !1 }), J.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), J.removeEventListener(window, "touchend", this.touchend), J.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            J.enableDrag(), J.removeEventListener(window, "mousemove", this.mousemove), J.removeEventListener(window, "mouseup", this.mouseup), J.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), J.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let Ti;
        function fn(y, e, r, c = !1) {
          if (c || !r.getCoveringTilesDetailsProvider().allowWorldCopies()) return y?.wrap();
          const f = new u.S(y.lng, y.lat);
          if (y = new u.S(y.lng, y.lat), e) {
            const _ = new u.S(y.lng - 360, y.lat), w = new u.S(y.lng + 360, y.lat), C = r.locationToScreenPoint(y).distSqr(e);
            r.locationToScreenPoint(_).distSqr(e) < C ? y = _ : r.locationToScreenPoint(w).distSqr(e) < C && (y = w);
          }
          for (; Math.abs(y.lng - r.center.lng) > 180; ) {
            const _ = r.locationToScreenPoint(y);
            if (_.x >= 0 && _.y >= 0 && _.x <= r.width && _.y <= r.height) break;
            y.lng > r.center.lng ? y.lng -= 360 : y.lng += 360;
          }
          return y.lng !== f.lng && r.isPointOnMapSurface(r.locationToScreenPoint(y)) ? y : f;
        }
        const oc = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function wr(y, e, r) {
          const c = y.classList;
          for (const f in oc) c.remove(`maplibregl-${r}-anchor-${f}`);
          c.add(`maplibregl-${r}-anchor-${e}`);
        }
        class da extends u.E {
          constructor(e) {
            if (super(), this._onKeyPress = (r) => {
              const c = r.code, f = r.charCode || r.keyCode;
              c !== "Space" && c !== "Enter" && f !== 32 && f !== 13 || this.togglePopup();
            }, this._onMapClick = (r) => {
              const c = r.originalEvent.target, f = this._element;
              this._popup && (c === f || f.contains(c)) && this.togglePopup();
            }, this._update = (r) => {
              if (!this._map) return;
              const c = this._map.loaded() && !this._map.isMoving();
              (r?.type === "terrain" || r?.type === "render" && !c) && this._map.once("render", this._update), this._lngLat = fn(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let f = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? f = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (f = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let _ = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? _ = "rotateX(0deg)" : this._pitchAlignment === "map" && (_ = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || r && r.type !== "moveend" || (this._pos = this._pos.round()), J.setTransform(this._element, `${oc[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${_} ${f}`), he.frameAsync(new AbortController()).then((() => {
                this._updateOpacity(r && r.type === "moveend");
              })).catch((() => {
              }));
            }, this._onMove = (r) => {
              if (!this._isDragging) {
                const c = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = r.point.dist(this._pointerdownPos) >= c;
              }
              this._isDragging && (this._pos = r.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new u.l("dragstart"))), this.fire(new u.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new u.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (r) => {
              this._element.contains(r.originalEvent.target) && (r.preventDefault(), this._positionDelta = r.point.sub(this._pos).add(this._offset), this._pointerdownPos = r.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e?.opacity, e?.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = u.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = J.create("div");
              const r = J.createNS("http://www.w3.org/2000/svg", "svg"), c = 41, f = 27;
              r.setAttributeNS(null, "display", "block"), r.setAttributeNS(null, "height", `${c}px`), r.setAttributeNS(null, "width", `${f}px`), r.setAttributeNS(null, "viewBox", `0 0 ${f} ${c}`);
              const _ = J.createNS("http://www.w3.org/2000/svg", "g");
              _.setAttributeNS(null, "stroke", "none"), _.setAttributeNS(null, "stroke-width", "1"), _.setAttributeNS(null, "fill", "none"), _.setAttributeNS(null, "fill-rule", "evenodd");
              const w = J.createNS("http://www.w3.org/2000/svg", "g");
              w.setAttributeNS(null, "fill-rule", "nonzero");
              const C = J.createNS("http://www.w3.org/2000/svg", "g");
              C.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), C.setAttributeNS(null, "fill", "#000000");
              const P = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const ne of P) {
                const re = J.createNS("http://www.w3.org/2000/svg", "ellipse");
                re.setAttributeNS(null, "opacity", "0.04"), re.setAttributeNS(null, "cx", "10.5"), re.setAttributeNS(null, "cy", "5.80029008"), re.setAttributeNS(null, "rx", ne.rx), re.setAttributeNS(null, "ry", ne.ry), C.appendChild(re);
              }
              const R = J.createNS("http://www.w3.org/2000/svg", "g");
              R.setAttributeNS(null, "fill", this._color);
              const L = J.createNS("http://www.w3.org/2000/svg", "path");
              L.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), R.appendChild(L);
              const j = J.createNS("http://www.w3.org/2000/svg", "g");
              j.setAttributeNS(null, "opacity", "0.25"), j.setAttributeNS(null, "fill", "#000000");
              const B = J.createNS("http://www.w3.org/2000/svg", "path");
              B.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), j.appendChild(B);
              const V = J.createNS("http://www.w3.org/2000/svg", "g");
              V.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), V.setAttributeNS(null, "fill", "#FFFFFF");
              const $ = J.createNS("http://www.w3.org/2000/svg", "g");
              $.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const ie = J.createNS("http://www.w3.org/2000/svg", "circle");
              ie.setAttributeNS(null, "fill", "#000000"), ie.setAttributeNS(null, "opacity", "0.25"), ie.setAttributeNS(null, "cx", "5.5"), ie.setAttributeNS(null, "cy", "5.5"), ie.setAttributeNS(null, "r", "5.4999962");
              const te = J.createNS("http://www.w3.org/2000/svg", "circle");
              te.setAttributeNS(null, "fill", "#FFFFFF"), te.setAttributeNS(null, "cx", "5.5"), te.setAttributeNS(null, "cy", "5.5"), te.setAttributeNS(null, "r", "5.4999962"), $.appendChild(ie), $.appendChild(te), w.appendChild(C), w.appendChild(R), w.appendChild(j), w.appendChild(V), w.appendChild($), r.appendChild(w), r.setAttributeNS(null, "height", c * this._scale + "px"), r.setAttributeNS(null, "width", f * this._scale + "px"), this._element.appendChild(r), this._offset = u.P.convert(e && e.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((r) => {
              r.preventDefault();
            })), this._element.addEventListener("mousedown", ((r) => {
              r.preventDefault();
            })), wr(this._element, this._anchor, "marker"), e && e.className) for (const r of e.className.split(" ")) this._element.classList.add(r);
            this._popup = null;
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), J.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e) {
            return this._lngLat = u.S.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const f = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [f, -1 * (38.1 - 13.5 + f)], "bottom-right": [-f, -1 * (38.1 - 13.5 + f)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this;
          }
          _updateOpacity(e = !1) {
            var r, c;
            const f = (r = this._map) === null || r === void 0 ? void 0 : r.terrain, _ = this._map.transform.isLocationOccluded(this._lngLat);
            if (!f || _) {
              const V = _ ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== V && (this._element.style.opacity = V));
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null;
              }), 100);
            }
            const w = this._map, C = w.terrain.depthAtPoint(this._pos), P = w.terrain.getElevationForLngLatZoom(this._lngLat, w.transform.tileZoom);
            if (w.transform.lngLatToCameraDepth(this._lngLat, P) - C < 6e-3) return void (this._element.style.opacity = this._opacity);
            const R = -this._offset.y / w.transform.pixelsPerMeter, L = Math.sin(w.getPitch() * Math.PI / 180) * R, j = w.terrain.depthAtPoint(new u.P(this._pos.x, this._pos.y - this._offset.y)), B = w.transform.lngLatToCameraDepth(this._lngLat, P + L) - j > 6e-3;
            !((c = this._popup) === null || c === void 0) && c.isOpen() && B && this._popup.remove(), this._element.style.opacity = B ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e) {
            return this._offset = u.P.convert(e), this._update(), this;
          }
          addClassName(e) {
            this._element.classList.add(e);
          }
          removeClassName(e) {
            this._element.classList.remove(e);
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e);
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(e, r) {
            return (this._opacity === void 0 || e === void 0 && r === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), r !== void 0 && (this._opacityWhenCovered = r), this._map && this._updateOpacity(!0), this;
          }
        }
        const Sn = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
        let Js = 0, qa = !1;
        const ni = { maxWidth: 100, unit: "metric" };
        function Bi(y, e, r) {
          const c = r && r.maxWidth || 100, f = y._container.clientHeight / 2, _ = y._container.clientWidth / 2, w = y.unproject([_ - c / 2, f]), C = y.unproject([_ + c / 2, f]), P = Math.round(y.project(C).x - y.project(w).x), R = Math.min(c, P, y._container.clientWidth), L = w.distanceTo(C);
          if (r && r.unit === "imperial") {
            const j = 3.2808 * L;
            j > 5280 ? rn(e, R, j / 5280, y._getUIString("ScaleControl.Miles")) : rn(e, R, j, y._getUIString("ScaleControl.Feet"));
          } else r && r.unit === "nautical" ? rn(e, R, L / 1852, y._getUIString("ScaleControl.NauticalMiles")) : L >= 1e3 ? rn(e, R, L / 1e3, y._getUIString("ScaleControl.Kilometers")) : rn(e, R, L, y._getUIString("ScaleControl.Meters"));
        }
        function rn(y, e, r, c) {
          const f = (function(_) {
            const w = Math.pow(10, `${Math.floor(_)}`.length - 1);
            let C = _ / w;
            return C = C >= 10 ? 10 : C >= 5 ? 5 : C >= 3 ? 3 : C >= 2 ? 2 : C >= 1 ? 1 : (function(P) {
              const R = Math.pow(10, Math.ceil(-Math.log(P) / Math.LN10));
              return Math.round(P * R) / R;
            })(C), w * C;
          })(r);
          y.style.width = e * (f / r) + "px", y.innerHTML = `${f}&nbsp;${c}`;
        }
        const uu = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1, locationOccludedOpacity: void 0 }, Bo = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function Ps(y) {
          if (y) {
            if (typeof y == "number") {
              const e = Math.round(Math.abs(y) / Math.SQRT2);
              return { center: new u.P(0, 0), top: new u.P(0, y), "top-left": new u.P(e, e), "top-right": new u.P(-e, e), bottom: new u.P(0, -y), "bottom-left": new u.P(e, -e), "bottom-right": new u.P(-e, -e), left: new u.P(y, 0), right: new u.P(-y, 0) };
            }
            if (y instanceof u.P || Array.isArray(y)) {
              const e = u.P.convert(y);
              return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
            }
            return { center: u.P.convert(y.center || [0, 0]), top: u.P.convert(y.top || [0, 0]), "top-left": u.P.convert(y["top-left"] || [0, 0]), "top-right": u.P.convert(y["top-right"] || [0, 0]), bottom: u.P.convert(y.bottom || [0, 0]), "bottom-left": u.P.convert(y["bottom-left"] || [0, 0]), "bottom-right": u.P.convert(y["bottom-right"] || [0, 0]), left: u.P.convert(y.left || [0, 0]), right: u.P.convert(y.right || [0, 0]) };
          }
          return Ps(new u.P(0, 0));
        }
        const cu = O;
        S.AJAXError = u.cz, S.Event = u.l, S.Evented = u.E, S.LngLat = u.S, S.MercatorCoordinate = u.a1, S.Point = u.P, S.addProtocol = u.cA, S.config = u.a, S.removeProtocol = u.cB, S.AttributionControl = wl, S.BoxZoomHandler = Hh, S.CanvasSource = Xr, S.CooperativeGesturesHandler = Do, S.DoubleClickZoomHandler = Ro, S.DragPanHandler = ou, S.DragRotateHandler = lu, S.EdgeInsets = us, S.FullscreenControl = class extends u.E {
          constructor(y = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let r = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = r?.shadowRoot) === null || e === void 0) && e.fullscreenElement; ) r = r.shadowRoot.fullscreenElement;
              r === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = !1, y && y.container && (y.container instanceof HTMLElement ? this._container = y.container : u.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(y) {
            return this._map = y, this._container || (this._container = this._map.getContainer()), this._controlContainer = J.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            J.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const y = this._fullscreenButton = J.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            J.create("span", "maplibregl-ctrl-icon", y).setAttribute("aria-hidden", "true"), y.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const y = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", y), this._fullscreenButton.title = y;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new u.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new u.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, S.GeoJSONSource = Ya, S.GeolocateControl = class extends u.E {
          constructor(y) {
            super(), this._onSuccess = (e) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new u.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new u.l("geolocate", e)), this._finish();
              }
            }, this._updateCamera = (e) => {
              const r = new u.S(e.coords.longitude, e.coords.latitude), c = e.coords.accuracy, f = this._map.getBearing(), _ = u.e({ bearing: f }, this.options.fitBoundsOptions), w = an.fromLngLat(r, c);
              this._map.fitBounds(w, _, { geolocateSource: !0 });
            }, this._updateMarker = (e) => {
              if (e) {
                const r = new u.S(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(r).addTo(this._map), this._userLocationDotMarker.setLngLat(r).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, this._onError = (e) => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (e.code === 3 && qa) return;
                  this.options.trackUserLocation && this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new u.l("error", e)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this._geolocateButton = J.create("button", "maplibregl-ctrl-geolocate", this._container), J.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
            }, this._finishSetupUI = (e) => {
              if (this._map) {
                if (e === !1) {
                  u.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);
                } else {
                  const r = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = J.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new da({ element: this._dotElement }), this._circleElement = J.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new da({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", ((r) => {
                  const c = r?.[0] instanceof ResizeObserverEntry;
                  r.geolocateSource || this._watchState !== "ACTIVE_LOCK" || c || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new u.l("trackuserlocationend")), this.fire(new u.l("userlocationlostfocus")));
                }));
              }
            }, this.options = u.e({}, Sn, y);
          }
          onAdd(y) {
            return this._map = y, this._container = J.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return u._(this, arguments, void 0, (function* (e = !1) {
                if (Ti !== void 0 && !e) return Ti;
                if (window.navigator.permissions === void 0) return Ti = !!window.navigator.geolocation, Ti;
                try {
                  Ti = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  Ti = !!window.navigator.geolocation;
                }
                return Ti;
              }));
            })().then(((e) => this._finishSetupUI(e))), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), J.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Js = 0, qa = !1;
          }
          _isOutOfMapMaxBounds(y) {
            const e = this._map.getMaxBounds(), r = y.coords;
            return e && (r.longitude < e.getWest() || r.longitude > e.getEast() || r.latitude < e.getSouth() || r.latitude > e.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadius() {
            const y = this._map.getBounds(), e = y.getSouthEast(), r = y.getNorthEast(), c = e.distanceTo(r), f = Math.ceil(this._accuracy / (c / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${f}px`, this._circleElement.style.height = `${f}px`;
          }
          trigger() {
            if (!this._setup) return u.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new u.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Js--, qa = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new u.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new u.l("trackuserlocationstart")), this.fire(new u.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let y;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Js++, Js > 1 ? (y = { maximumAge: 6e5, timeout: 0 }, qa = !0) : (y = this.options.positionOptions, qa = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, y);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, S.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var y;
              const e = (y = this._map.getProjection()) === null || y === void 0 ? void 0 : y.type;
              this._map.setProjection(e !== "mercator" && e ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var y;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((y = this._map.getProjection()) === null || y === void 0 ? void 0 : y.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(y) {
            return this._map = y, this._container = J.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = J.create("button", "maplibregl-ctrl-globe", this._container), J.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            J.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, S.Hash = ws, S.ImageSource = pr, S.KeyboardHandler = nc, S.LngLatBounds = an, S.LogoControl = Kc, S.Map = class extends Ws {
          constructor(y) {
            var e, r;
            u.cw.mark(u.cx.create);
            const c = Object.assign(Object.assign(Object.assign({}, rr), y), { canvasContextAttributes: Object.assign(Object.assign({}, rr.canvasContextAttributes), y.canvasContextAttributes) });
            if (c.minZoom != null && c.maxZoom != null && c.minZoom > c.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (c.minPitch != null && c.maxPitch != null && c.minPitch > c.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (c.minPitch != null && c.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (c.maxPitch != null && c.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const f = new Ui(), _ = new ua();
            if (c.minZoom !== void 0 && f.setMinZoom(c.minZoom), c.maxZoom !== void 0 && f.setMaxZoom(c.maxZoom), c.minPitch !== void 0 && f.setMinPitch(c.minPitch), c.maxPitch !== void 0 && f.setMaxPitch(c.maxPitch), c.renderWorldCopies !== void 0 && f.setRenderWorldCopies(c.renderWorldCopies), super(f, _, { bearingSnap: c.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Nr(), this._controls = [], this._mapId = u.a7(), this._contextLost = (C) => {
              C.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new u.l("webglcontextlost", { originalEvent: C }));
            }, this._contextRestored = (C) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new u.l("webglcontextrestored", { originalEvent: C }));
            }, this._onMapScroll = (C) => {
              if (C.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = c.interactive, this._maxTileCacheSize = c.maxTileCacheSize, this._maxTileCacheZoomLevels = c.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, c.canvasContextAttributes), this._trackResize = c.trackResize === !0, this._bearingSnap = c.bearingSnap, this._centerClampedToGround = c.centerClampedToGround, this._refreshExpiredTiles = c.refreshExpiredTiles === !0, this._fadeDuration = c.fadeDuration, this._crossSourceCollisions = c.crossSourceCollisions === !0, this._collectResourceTiming = c.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, za), c.locale), this._clickTolerance = c.clickTolerance, this._overridePixelRatio = c.pixelRatio, this._maxCanvasSize = c.maxCanvasSize, this.transformCameraUpdate = c.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = c.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = De.addThrottleControl((() => this.isMoving())), this._requestManager = new Re(c.transformRequest), typeof c.container == "string") {
              if (this._container = document.getElementById(c.container), !this._container) throw new Error(`Container '${c.container}' not found.`);
            } else {
              if (!(c.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = c.container;
            }
            if (c.maxBounds && this.setMaxBounds(c.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
              this.painter.terrainFacilitator.dirty = !0, this._update(!0);
            })), this.once("idle", (() => {
              this._idleTriggered = !0;
            })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let C = !1;
              const P = Or(((R) => {
                this._trackResize && !this._removed && (this.resize(R), this.redraw());
              }), 50);
              this._resizeObserver = new ResizeObserver(((R) => {
                C ? P(R) : C = !0;
              })), this._resizeObserver.observe(this._container);
            }
            this.handlers = new rc(this, c), this._hash = c.hash && new ws(typeof c.hash == "string" && c.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: c.center, elevation: c.elevation, zoom: c.zoom, bearing: c.bearing, pitch: c.pitch, roll: c.roll }), c.bounds && (this.resize(), this.fitBounds(c.bounds, u.e({}, c.fitBoundsOptions, { duration: 0 }))));
            const w = typeof c.style == "string" || ((r = (e = c.style) === null || e === void 0 ? void 0 : e.projection) === null || r === void 0 ? void 0 : r.type) !== "globe";
            this.resize(null, w), this._localIdeographFontFamily = c.localIdeographFontFamily, this._validateStyle = c.validateStyle, c.style && this.setStyle(c.style, { localIdeographFontFamily: c.localIdeographFontFamily }), c.attributionControl && this.addControl(new wl(typeof c.attributionControl == "boolean" ? void 0 : c.attributionControl)), c.maplibreLogo && this.addControl(new Kc(), c.logoPosition), this.on("style.load", (() => {
              if (w || this._resizeTransform(), this.transform.unmodified) {
                const C = u.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(C);
              }
            })), this.on("data", ((C) => {
              this._update(C.dataType === "style"), this.fire(new u.l(`${C.dataType}data`, C));
            })), this.on("dataloading", ((C) => {
              this.fire(new u.l(`${C.dataType}dataloading`, C));
            })), this.on("dataabort", ((C) => {
              this.fire(new u.l("sourcedataabort", C));
            }));
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(y, e) {
            return this.style.setGlobalStateProperty(y, e), this._update(!0);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(y, e) {
            if (e === void 0 && (e = y.getDefaultPosition ? y.getDefaultPosition() : "top-right"), !y || !y.onAdd) return this.fire(new u.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const r = y.onAdd(this);
            this._controls.push(y);
            const c = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? c.insertBefore(r, c.firstChild) : c.appendChild(r), this;
          }
          removeControl(y) {
            if (!y || !y.onRemove) return this.fire(new u.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(y);
            return e > -1 && this._controls.splice(e, 1), y.onRemove(this), this;
          }
          hasControl(y) {
            return this._controls.indexOf(y) > -1;
          }
          calculateCameraOptionsFromTo(y, e, r, c) {
            return c == null && this.terrain && (c = this.terrain.getElevationForLngLatZoom(r, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(y, e, r, c);
          }
          resize(y, e = !0) {
            const [r, c] = this._containerDimensions(), f = this._getClampedPixelRatio(r, c);
            if (this._resizeCanvas(r, c, f), this.painter.resize(r, c, f), this.painter.overLimit()) {
              const w = this.painter.context.gl;
              this._maxCanvasSize = [w.drawingBufferWidth, w.drawingBufferHeight];
              const C = this._getClampedPixelRatio(r, c);
              this._resizeCanvas(r, c, C), this.painter.resize(r, c, C);
            }
            this._resizeTransform(e);
            const _ = !this._moving;
            return _ && (this.stop(), this.fire(new u.l("movestart", y)).fire(new u.l("move", y))), this.fire(new u.l("resize", y)), _ && this.fire(new u.l("moveend", y)), this;
          }
          _resizeTransform(y = !0) {
            var e;
            const [r, c] = this._containerDimensions();
            this.transform.resize(r, c, y), (e = this._requestedCameraState) === null || e === void 0 || e.resize(r, c, y);
          }
          _getClampedPixelRatio(y, e) {
            const { 0: r, 1: c } = this._maxCanvasSize, f = this.getPixelRatio(), _ = y * f, w = e * f;
            return Math.min(_ > r ? r / _ : 1, w > c ? c / w : 1) * f;
          }
          getPixelRatio() {
            var y;
            return (y = this._overridePixelRatio) !== null && y !== void 0 ? y : devicePixelRatio;
          }
          setPixelRatio(y) {
            this._overridePixelRatio = y, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(y) {
            return this.transform.setMaxBounds(an.convert(y)), this._update();
          }
          setMinZoom(y) {
            if ((y = y ?? -2) >= -2 && y <= this.transform.maxZoom) return this.transform.setMinZoom(y), this._update(), this.getZoom() < y && this.setZoom(y), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(y) {
            if ((y = y ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(y), this._update(), this.getZoom() > y && this.setZoom(y), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(y) {
            if ((y = y ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (y >= 0 && y <= this.transform.maxPitch) return this.transform.setMinPitch(y), this._update(), this.getPitch() < y && this.setPitch(y), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(y) {
            if ((y = y ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (y >= this.transform.minPitch) return this.transform.setMaxPitch(y), this._update(), this.getPitch() > y && this.setPitch(y), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(y) {
            return this.transform.setRenderWorldCopies(y), this._update();
          }
          project(y) {
            return this.transform.locationToScreenPoint(u.S.convert(y), this.style && this.terrain);
          }
          unproject(y) {
            return this.transform.screenPointToLocation(u.P.convert(y), this.terrain);
          }
          isMoving() {
            var y;
            return this._moving || ((y = this.handlers) === null || y === void 0 ? void 0 : y.isMoving());
          }
          isZooming() {
            var y;
            return this._zooming || ((y = this.handlers) === null || y === void 0 ? void 0 : y.isZooming());
          }
          isRotating() {
            var y;
            return this._rotating || ((y = this.handlers) === null || y === void 0 ? void 0 : y.isRotating());
          }
          _createDelegatedListener(y, e, r) {
            if (y === "mouseenter" || y === "mouseover") {
              let c = !1;
              return { layers: e, listener: r, delegates: { mousemove: (_) => {
                const w = e.filter(((P) => this.getLayer(P))), C = w.length !== 0 ? this.queryRenderedFeatures(_.point, { layers: w }) : [];
                C.length ? c || (c = !0, r.call(this, new ea(y, this, _.originalEvent, { features: C }))) : c = !1;
              }, mouseout: () => {
                c = !1;
              } } };
            }
            if (y === "mouseleave" || y === "mouseout") {
              let c = !1;
              return { layers: e, listener: r, delegates: { mousemove: (w) => {
                const C = e.filter(((P) => this.getLayer(P)));
                (C.length !== 0 ? this.queryRenderedFeatures(w.point, { layers: C }) : []).length ? c = !0 : c && (c = !1, r.call(this, new ea(y, this, w.originalEvent)));
              }, mouseout: (w) => {
                c && (c = !1, r.call(this, new ea(y, this, w.originalEvent)));
              } } };
            }
            {
              const c = (f) => {
                const _ = e.filter(((C) => this.getLayer(C))), w = _.length !== 0 ? this.queryRenderedFeatures(f.point, { layers: _ }) : [];
                w.length && (f.features = w, r.call(this, f), delete f.features);
              };
              return { layers: e, listener: r, delegates: { [y]: c } };
            }
          }
          _saveDelegatedListener(y, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[y] = this._delegatedListeners[y] || [], this._delegatedListeners[y].push(e);
          }
          _removeDelegatedListener(y, e, r) {
            if (!this._delegatedListeners || !this._delegatedListeners[y]) return;
            const c = this._delegatedListeners[y];
            for (let f = 0; f < c.length; f++) {
              const _ = c[f];
              if (_.listener === r && _.layers.length === e.length && _.layers.every(((w) => e.includes(w)))) {
                for (const w in _.delegates) this.off(w, _.delegates[w]);
                return void c.splice(f, 1);
              }
            }
          }
          on(y, e, r) {
            if (r === void 0) return super.on(y, e);
            const c = typeof e == "string" ? [e] : e, f = this._createDelegatedListener(y, c, r);
            this._saveDelegatedListener(y, f);
            for (const _ in f.delegates) this.on(_, f.delegates[_]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(y, c, r);
            } };
          }
          once(y, e, r) {
            if (r === void 0) return super.once(y, e);
            const c = typeof e == "string" ? [e] : e, f = this._createDelegatedListener(y, c, r);
            for (const _ in f.delegates) {
              const w = f.delegates[_];
              f.delegates[_] = (...C) => {
                this._removeDelegatedListener(y, c, r), w(...C);
              };
            }
            this._saveDelegatedListener(y, f);
            for (const _ in f.delegates) this.once(_, f.delegates[_]);
            return this;
          }
          off(y, e, r) {
            return r === void 0 ? super.off(y, e) : (this._removeDelegatedListener(y, typeof e == "string" ? [e] : e, r), this);
          }
          queryRenderedFeatures(y, e) {
            if (!this.style) return [];
            let r;
            const c = y instanceof u.P || Array.isArray(y), f = c ? y : [[0, 0], [this.transform.width, this.transform.height]];
            if (e = e || (c ? {} : y) || {}, f instanceof u.P || typeof f[0] == "number") r = [u.P.convert(f)];
            else {
              const _ = u.P.convert(f[0]), w = u.P.convert(f[1]);
              r = [_, new u.P(w.x, _.y), w, new u.P(_.x, w.y), _];
            }
            return this.style.queryRenderedFeatures(r, e, this.transform);
          }
          querySourceFeatures(y, e) {
            return this.style.querySourceFeatures(y, e);
          }
          setStyle(y, e) {
            return (e = u.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && y ? (this._diffStyle(y, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(y, e));
          }
          setTransformRequest(y) {
            return this._requestManager.setTransformRequest(y), this;
          }
          _getUIString(y) {
            const e = this._locale[y];
            if (e == null) throw new Error(`Missing UI string '${y}'`);
            return e;
          }
          _updateStyle(y, e) {
            var r, c;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(y, e)));
            const f = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!y)), y ? (this.style = new Ih(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof y == "string" ? this.style.loadURL(y, e, f) : this.style.loadJSON(y, e, f), this) : ((c = (r = this.style) === null || r === void 0 ? void 0 : r.projection) === null || c === void 0 || c.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Ih(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(y, e) {
            if (typeof y == "string") {
              const r = this._requestManager.transformRequest(y, "Style");
              u.j(r, new AbortController()).then(((c) => {
                this._updateDiff(c.data, e);
              })).catch(((c) => {
                c && this.fire(new u.k(c));
              }));
            } else typeof y == "object" && this._updateDiff(y, e);
          }
          _updateDiff(y, e) {
            try {
              this.style.setState(y, e) && this._update(!0);
            } catch (r) {
              u.w(`Unable to perform style diff: ${r.message || r.error || r}.  Rebuilding the style from scratch.`), this._updateStyle(y, e);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : u.w("There is no style added to the map.");
          }
          addSource(y, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(y, e), this._update(!0);
          }
          isSourceLoaded(y) {
            const e = this.style && this.style.sourceCaches[y];
            if (e !== void 0) return e.loaded();
            this.fire(new u.k(new Error(`There is no source with ID '${y}'`)));
          }
          setTerrain(y) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), y) {
              const e = this.style.sourceCaches[y.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${y.source}`);
              this.terrain === null && e.reload();
              for (const r in this.style._layers) {
                const c = this.style._layers[r];
                c.type === "hillshade" && c.source === y.source && u.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), c.type === "color-relief" && c.source === y.source && u.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new Ot(this.painter, e, y), this.painter.renderToTexture = new Sl(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (r) => {
                var c;
                r.dataType === "style" ? this.terrain.sourceCache.freeRtt() : r.dataType === "source" && r.tile && (r.sourceId !== y.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((c = r.source) === null || c === void 0 ? void 0 : c.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(r.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new u.l("terrain", { terrain: y })), this;
          }
          getTerrain() {
            var y, e;
            return (e = (y = this.terrain) === null || y === void 0 ? void 0 : y.options) !== null && e !== void 0 ? e : null;
          }
          areTilesLoaded() {
            const y = this.style && this.style.sourceCaches;
            for (const e in y) {
              const r = y[e]._tiles;
              for (const c in r) {
                const f = r[c];
                if (f.state !== "loaded" && f.state !== "errored") return !1;
              }
            }
            return !0;
          }
          removeSource(y) {
            return this.style.removeSource(y), this._update(!0);
          }
          getSource(y) {
            return this.style.getSource(y);
          }
          setSourceTileLodParams(y, e, r) {
            if (r) {
              const c = this.getSource(r);
              if (!c) throw new Error(`There is no source with ID "${r}", cannot set LOD parameters`);
              c.calculateTileZoom = tt(Math.max(1, y), Math.max(1, e));
            } else for (const c in this.style.sourceCaches) this.style.sourceCaches[c].getSource().calculateTileZoom = tt(Math.max(1, y), Math.max(1, e));
            return this._update(!0), this;
          }
          refreshTiles(y, e) {
            const r = this.style.sourceCaches[y];
            if (!r) throw new Error(`There is no source cache with ID "${y}", cannot refresh tile`);
            e === void 0 ? r.reload(!0) : r.refreshTiles(e.map(((c) => new u.a4(c.z, c.x, c.y))));
          }
          addImage(y, e, r = {}) {
            const { pixelRatio: c = 1, sdf: f = !1, stretchX: _, stretchY: w, content: C, textFitWidth: P, textFitHeight: R } = r;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || u.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new u.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: L, height: j, data: B } = e, V = e;
                return this.style.addImage(y, { data: new u.R({ width: L, height: j }, new Uint8Array(B)), pixelRatio: c, stretchX: _, stretchY: w, content: C, textFitWidth: P, textFitHeight: R, sdf: f, version: 0, userImage: V }), V.onAdd && V.onAdd(this, y), this;
              }
            }
            {
              const { width: L, height: j, data: B } = he.getImageData(e);
              this.style.addImage(y, { data: new u.R({ width: L, height: j }, B), pixelRatio: c, stretchX: _, stretchY: w, content: C, textFitWidth: P, textFitHeight: R, sdf: f, version: 0 });
            }
          }
          updateImage(y, e) {
            const r = this.style.getImage(y);
            if (!r) return this.fire(new u.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const c = e instanceof HTMLImageElement || u.b(e) ? he.getImageData(e) : e, { width: f, height: _, data: w } = c;
            if (f === void 0 || _ === void 0) return this.fire(new u.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (f !== r.data.width || _ !== r.data.height) return this.fire(new u.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const C = !(e instanceof HTMLImageElement || u.b(e));
            return r.data.replace(w, C), this.style.updateImage(y, r), this;
          }
          getImage(y) {
            return this.style.getImage(y);
          }
          hasImage(y) {
            return y ? !!this.style.getImage(y) : (this.fire(new u.k(new Error("Missing required image id"))), !1);
          }
          removeImage(y) {
            this.style.removeImage(y);
          }
          loadImage(y) {
            return De.getImage(this._requestManager.transformRequest(y, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(y, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(y, e), this._update(!0);
          }
          moveLayer(y, e) {
            return this.style.moveLayer(y, e), this._update(!0);
          }
          removeLayer(y) {
            return this.style.removeLayer(y), this._update(!0);
          }
          getLayer(y) {
            return this.style.getLayer(y);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(y, e, r) {
            return this.style.setLayerZoomRange(y, e, r), this._update(!0);
          }
          setFilter(y, e, r = {}) {
            return this.style.setFilter(y, e, r), this._update(!0);
          }
          getFilter(y) {
            return this.style.getFilter(y);
          }
          setPaintProperty(y, e, r, c = {}) {
            return this.style.setPaintProperty(y, e, r, c), this._update(!0);
          }
          getPaintProperty(y, e) {
            return this.style.getPaintProperty(y, e);
          }
          setLayoutProperty(y, e, r, c = {}) {
            return this.style.setLayoutProperty(y, e, r, c), this._update(!0);
          }
          getLayoutProperty(y, e) {
            return this.style.getLayoutProperty(y, e);
          }
          setGlyphs(y, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(y, e), this._update(!0);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(y, e, r = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(y, e, r, ((c) => {
              c || this._update(!0);
            })), this;
          }
          removeSprite(y) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(y), this._update(!0);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(y, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(y, e, ((r) => {
              r || this._update(!0);
            })), this;
          }
          setLight(y, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(y, e), this._update(!0);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(y, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(y, e), this._update(!0);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(y, e) {
            return this.style.setFeatureState(y, e), this._update();
          }
          removeFeatureState(y, e) {
            return this.style.removeFeatureState(y, e), this._update();
          }
          getFeatureState(y) {
            return this.style.getFeatureState(y);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let y = 0, e = 0;
            return this._container && (y = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [y, e];
          }
          _setupContainer() {
            const y = this._container;
            y.classList.add("maplibregl-map");
            const e = this._canvasContainer = J.create("div", "maplibregl-canvas-container", y);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = J.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const r = this._containerDimensions(), c = this._getClampedPixelRatio(r[0], r[1]);
            this._resizeCanvas(r[0], r[1], c);
            const f = this._controlContainer = J.create("div", "maplibregl-control-container", y), _ = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(((w) => {
              _[w] = J.create("div", `maplibregl-ctrl-${w} `, f);
            })), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _resizeCanvas(y, e, r) {
            this._canvas.width = Math.floor(r * y), this._canvas.height = Math.floor(r * e), this._canvas.style.width = `${y}px`, this._canvas.style.height = `${e}px`;
          }
          _setupPainter() {
            const y = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", ((c) => {
              e = { requestedAttributes: y }, c && (e.statusMessage = c.statusMessage, e.type = c.type);
            }), { once: !0 });
            let r = null;
            if (r = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, y) : this._canvas.getContext("webgl2", y) || this._canvas.getContext("webgl", y), !r) {
              const c = "Failed to initialize WebGL";
              throw e ? (e.message = c, new Error(JSON.stringify(e))) : new Error(c);
            }
            this.painter = new $h(r, this.transform), ke.testSupport(r);
          }
          migrateProjection(y, e) {
            super.migrateProjection(y, e), this.painter.transform = y, this.fire(new u.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(y) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || y, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(y) {
            return this._update(), this._renderTaskQueue.add(y);
          }
          _cancelRenderFrame(y) {
            this._renderTaskQueue.remove(y);
          }
          _render(y) {
            var e, r, c, f, _;
            const w = this._idleTriggered ? this._fadeDuration : 0, C = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(y), this._removed) return;
            let P = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const j = this.transform.zoom, B = he.now();
              this.style.zoomHistory.update(j, B);
              const V = new u.F(j, { now: B, fadeDuration: w, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition(), globalState: this.style.getGlobalState() }), $ = V.crossFadingFactor();
              $ === 1 && $ === this._crossFadingFactor || (P = !0, this._crossFadingFactor = $), this.style.update(V);
            }
            const R = ((r = this.style.projection) === null || r === void 0 ? void 0 : r.transitionState) > 0 !== C;
            (c = this.style.projection) === null || c === void 0 || c.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((f = this.style.projection) === null || f === void 0 ? void 0 : f.transitionState, (_ = this.style.projection) === null || _ === void 0 ? void 0 : _.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || R) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, w, this._crossSourceCollisions, R), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: w, showPadding: this.showPadding }), this.fire(new u.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, u.cw.mark(u.cx.load), this.fire(new u.l("load"))), this.style && (this.style.hasTransitions() || P) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const L = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return L || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new u.l("idle")), !this._loaded || this._fullyLoaded || L || (this._fullyLoaded = !0, u.cw.mark(u.cx.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var y;
            this._hash && this._hash.remove();
            for (const r of this._controls) r.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), De.removeThrottleControl(this._imageQueueHandle), (y = this._resizeObserver) === null || y === void 0 || y.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e?.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), J.remove(this._canvasContainer), J.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), u.cw.clearMetrics(), this._removed = !0, this.fire(new u.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), he.frame(this._frameRequest, ((y) => {
              u.cw.frame(y), this._frameRequest = null;
              try {
                this._render(y);
              } catch (e) {
                if (!u.cy(e) && !(function(r) {
                  return r.message === _s;
                })(e)) throw e;
              }
            }), (() => {
            })));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(y) {
            this._showTileBoundaries !== y && (this._showTileBoundaries = y, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(y) {
            this._showPadding !== y && (this._showPadding = y, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(y) {
            this._showCollisionBoxes !== y && (this._showCollisionBoxes = y, y ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(y) {
            this._showOverdrawInspector !== y && (this._showOverdrawInspector = y, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(y) {
            this._repaint !== y && (this._repaint = y, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(y) {
            this._vertices = y, this._update();
          }
          get version() {
            return Wc;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(y) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(y), this._update(!0);
          }
        }, S.MapMouseEvent = ea, S.MapTouchEvent = Ys, S.MapWheelEvent = Ks, S.Marker = da, S.NavigationControl = class {
          constructor(y) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(), r = e === this._map.getMaxZoom(), c = e === this._map.getMinZoom();
              this._zoomInButton.disabled = r, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", r.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (e, r) => {
              const c = this._map._getUIString(`NavigationControl.${r}`);
              e.title = c, e.setAttribute("aria-label", c);
            }, this.options = u.e({}, br, y), this._container = J.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((e) => this._map.zoomIn({}, { originalEvent: e }))), J.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((e) => this._map.zoomOut({}, { originalEvent: e }))), J.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((e) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
            })), this._compassIcon = J.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(y) {
            return this._map = y, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Pa(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            J.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(y, e) {
            const r = J.create("button", y, this._container);
            return r.type = "button", r.addEventListener("click", e), r;
          }
        }, S.Popup = class extends u.E {
          constructor(y) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && J.remove(this._content), this._container && (J.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new u.l("close"))), this), this._onMouseUp = (e) => {
              this._update(e.point);
            }, this._onMouseMove = (e) => {
              this._update(e.point);
            }, this._onDrag = (e) => {
              this._update(e.point);
            }, this._update = (e) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = J.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = J.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const w of this.options.className.split(" ")) this._container.classList.add(w);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = fn(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const r = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let c = this.options.anchor;
              const f = Ps(this.options.offset);
              if (!c) {
                const w = this._container.offsetWidth, C = this._container.offsetHeight;
                let P;
                P = r.y + f.bottom.y < C ? ["top"] : r.y > this._map.transform.height - C ? ["bottom"] : [], r.x < w / 2 ? P.push("left") : r.x > this._map.transform.width - w / 2 && P.push("right"), c = P.length === 0 ? "bottom" : P.join("-");
              }
              let _ = r.add(f[c]);
              this.options.subpixelPositioning || (_ = _.round()), J.setTransform(this._container, `${oc[c]} translate(${_.x}px,${_.y}px)`), wr(this._container, c, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = u.e(Object.create(uu), y);
          }
          addTo(y) {
            return this._map && this.remove(), this._map = y, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new u.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(y) {
            return this._lngLat = u.S.convert(y), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(y) {
            return this.setDOMContent(document.createTextNode(y));
          }
          setHTML(y) {
            const e = document.createDocumentFragment(), r = document.createElement("body");
            let c;
            for (r.innerHTML = y; c = r.firstChild, c; ) e.appendChild(c);
            return this.setDOMContent(e);
          }
          getMaxWidth() {
            var y;
            return (y = this._container) === null || y === void 0 ? void 0 : y.style.maxWidth;
          }
          setMaxWidth(y) {
            return this.options.maxWidth = y, this._update(), this;
          }
          setDOMContent(y) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = J.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(y), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(y) {
            return this._container && this._container.classList.add(y), this;
          }
          removeClassName(y) {
            return this._container && this._container.classList.remove(y), this;
          }
          setOffset(y) {
            return this.options.offset = y, this._update(), this;
          }
          toggleClassName(y) {
            if (this._container) return this._container.classList.toggle(y);
          }
          setSubpixelPositioning(y) {
            this.options.subpixelPositioning = y;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = J.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const y = this._container.querySelector(Bo);
            y && y.focus();
          }
        }, S.RasterDEMTileSource = Xa, S.RasterTileSource = dr, S.ScaleControl = class {
          constructor(y) {
            this._onMove = () => {
              Bi(this._map, this._container, this.options);
            }, this.setUnit = (e) => {
              this.options.unit = e, Bi(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, ni), y);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(y) {
            return this._map = y, this._container = J.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", y.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            J.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, S.ScrollZoomHandler = Xh, S.Style = Ih, S.TerrainControl = class {
          constructor(y) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = y;
          }
          onAdd(y) {
            return this._map = y, this._container = J.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = J.create("button", "maplibregl-ctrl-terrain", this._container), J.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            J.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, S.TwoFingersTouchPitchHandler = vl, S.TwoFingersTouchRotateHandler = ko, S.TwoFingersTouchZoomHandler = ic, S.TwoFingersTouchZoomRotateHandler = Yh, S.VectorTileSource = ma, S.VideoSource = Os, S.addSourceType = (y, e) => u._(void 0, void 0, void 0, (function* () {
          if (ho(y)) throw new Error(`A source type called "${y}" already exists.`);
          ((r, c) => {
            Yr[r] = c;
          })(y, e);
        })), S.clearPrewarmedResources = function() {
          const y = et;
          y && (y.isPreloaded() && y.numActive() === 1 ? (y.release(Et), et = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, S.createTileMesh = Gl, S.getMaxParallelImageRequests = function() {
          return u.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, S.getRTLTextPluginStatus = function() {
          return Ns().getRTLTextPluginStatus();
        }, S.getVersion = function() {
          return cu;
        }, S.getWorkerCount = function() {
          return fe.workerCount;
        }, S.getWorkerUrl = function() {
          return u.a.WORKER_URL;
        }, S.importScriptInWorkers = function(y) {
          return si().broadcast("IS", y);
        }, S.prewarm = function() {
          Pt().acquire(Et);
        }, S.setMaxParallelImageRequests = function(y) {
          u.a.MAX_PARALLEL_IMAGE_REQUESTS = y;
        }, S.setRTLTextPlugin = function(y, e) {
          return Ns().setRTLTextPlugin(y, e);
        }, S.setWorkerCount = function(y) {
          fe.workerCount = y;
        }, S.setWorkerUrl = function(y) {
          u.a.WORKER_URL = y;
        };
      }));
      var z = m;
      return z;
    }));
  })(Og)), Og.exports;
}
var A1 = M1();
const Lt = /* @__PURE__ */ iy(A1);
function E1() {
  return typeof self < "u" ? fetch.bind(self) : typeof global < "u" && global.fetch ? global.fetch : null;
}
class C1 {
  constructor() {
    this._apiKey = "", this._fetch = E1(), this.tileCacheSize = 200;
  }
  /**
   * Set the MapTiler Cloud API key
   */
  set apiKey(o) {
    this._apiKey = o;
  }
  /**
   * Get the MapTiler Cloud API key
   */
  get apiKey() {
    return this._apiKey;
  }
  /**
   * Set a the custom fetch function to replace the default one
   */
  set fetch(o) {
    this._fetch = o;
  }
  /**
   * Get the fetch fucntion
   */
  get fetch() {
    return this._fetch;
  }
}
const Xp = new C1(), z1 = {
  /**
   * Language mode to display the labels in the end user's device language.
   */
  AUTO: {
    code: null,
    flag: "auto",
    name: "Auto",
    latin: !1,
    isMode: !0,
    geocoding: !0
  },
  /**
   * The OSM language using latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,
   * though it can be an handy fallback. This is not to be confused with the "Classical Latin" language, which is available under the tag `.CLASSICAL_LATIN`.
   */
  LATIN: {
    code: "latin",
    flag: "name:latin",
    name: "Latin",
    latin: !0,
    isMode: !1,
    geocoding: !1
  },
  /**
   * The OSM language using non-latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,
   * though it can be an handy fallback.
   */
  NON_LATIN: {
    code: "nonlatin",
    flag: "name:nonlatin",
    name: "Non Latin",
    latin: !1,
    isMode: !1,
    geocoding: !1
  },
  /**
   * Using the local language generaly (but not always) means that every labels of a given region will use the dominant local language.
   */
  LOCAL: {
    code: null,
    flag: "name",
    name: "Local",
    latin: !0,
    isMode: !1,
    geocoding: !1
  }
}, P1 = {
  /**
   * Albanian language
   */
  ALBANIAN: {
    code: "sq",
    flag: "name:sq",
    name: "Albanian",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Amharic language
   */
  AMHARIC: {
    code: "am",
    flag: "name:am",
    name: "Amharic",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Arabic language (right-to-left script)
   */
  ARABIC: {
    code: "ar",
    flag: "name:ar",
    name: "Arabic",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Armenian language
   */
  ARMENIAN: {
    code: "hy",
    flag: "name:hy",
    name: "Armenian",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Azerbaijani language
   */
  AZERBAIJANI: {
    code: "az",
    flag: "name:az",
    name: "Azerbaijani",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Basque language
   */
  BASQUE: {
    code: "eu",
    flag: "name:eu",
    name: "Basque",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Belarusian langauge
   */
  BELARUSIAN: {
    code: "be",
    flag: "name:be",
    name: "Belarusian",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Bengali language
   */
  BENGALI: {
    code: "bn",
    flag: "name:bn",
    name: "Bengali",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Bosnian language
   */
  BOSNIAN: {
    code: "bs",
    flag: "name:bs",
    name: "Bosnian",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Breton language
   */
  BRETON: {
    code: "br",
    flag: "name:br",
    name: "Breton",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Bulgarian language
   */
  BULGARIAN: {
    code: "bg",
    flag: "bg",
    name: "Bulgarian",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Catalan language
   */
  CATALAN: {
    code: "ca",
    flag: "name:ca",
    name: "Catalan",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Chinese language
   */
  CHINESE: {
    code: "zh",
    flag: "name:zh",
    name: "Chinese",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Traditional Chinese language
   */
  TRADITIONAL_CHINESE: {
    code: "zh-Hant",
    flag: "name:zh-Hant",
    name: "Chinese (traditional)",
    latin: !1,
    isMode: !1,
    geocoding: !1
  },
  /**
   * Simplified Chinese language
   */
  SIMPLIFIED_CHINESE: {
    code: "zh-Hans",
    flag: "name:zh-Hans",
    name: "Chinese (simplified)",
    latin: !1,
    isMode: !1,
    geocoding: !1
  },
  /**
   * Corsican language
   */
  CORSICAN: {
    code: "co",
    flag: "name:co",
    name: "Corsican",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Croatian language
   */
  CROATIAN: {
    code: "hr",
    flag: "name:hr",
    name: "Croatian",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Czech language
   */
  CZECH: {
    code: "cs",
    flag: "name:cs",
    name: "Czech",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Danish language
   */
  DANISH: {
    code: "da",
    flag: "name:da",
    name: "Danish",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Dutch language
   */
  DUTCH: {
    code: "nl",
    flag: "name:nl",
    name: "Dutch",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * German language
   */
  GERMAN: {
    code: "de",
    flag: "name:de",
    name: "German",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Greek language
   */
  GREEK: {
    code: "el",
    flag: "name:el",
    name: "Greek",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * English language
   */
  ENGLISH: {
    code: "en",
    flag: "name:en",
    name: "English",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Esperanto language
   */
  ESPERANTO: {
    code: "eo",
    flag: "name:eo",
    name: "Esperanto",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Estonian language
   */
  ESTONIAN: {
    code: "et",
    flag: "name:et",
    name: "Estonian",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Finnish language
   */
  FINNISH: {
    code: "fi",
    flag: "name:fi",
    name: "Finnish",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * French language
   */
  FRENCH: {
    code: "fr",
    flag: "name:fr",
    name: "French",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Frisian language
   */
  FRISIAN: {
    code: "fy",
    flag: "name:fy",
    name: "Frisian (West)",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Georgian language
   */
  GEORGIAN: {
    code: "ka",
    flag: "name:ka",
    name: "Georgian",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Hebrew language (right-to-left non-latin script)
   */
  HEBREW: {
    code: "he",
    flag: "name:he",
    name: "Hebrew",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Hindi language
   */
  HINDI: {
    code: "hi",
    flag: "name:hi",
    name: "Hindi",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Hungarian language
   */
  HUNGARIAN: {
    code: "hu",
    flag: "name:hu",
    name: "Hungarian",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Icelandic language
   */
  ICELANDIC: {
    code: "is",
    flag: "name:is",
    name: "Icelandic",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Indonesian language
   */
  INDONESIAN: {
    code: "id",
    flag: "name:id",
    name: "Indonesian",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Irish language
   */
  IRISH: {
    code: "ga",
    flag: "name:ga",
    name: "Irish",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Italian language
   */
  ITALIAN: {
    code: "it",
    flag: "name:it",
    name: "Italian",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Japanese language
   */
  JAPANESE: {
    code: "ja",
    flag: "name:ja",
    name: "Japanese",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Japanese language in Hiragana form
   */
  JAPANESE_HIRAGANA: {
    code: "ja-Hira",
    flag: "name:ja-Hira",
    name: "Japanese Hiragana form",
    latin: !1,
    isMode: !1,
    geocoding: !1
  },
  /**
   * Japanese language (latin script)
   */
  JAPANESE_2018: {
    code: "ja-Latn",
    flag: "name:ja-Latn",
    name: "Japanese (Latin 2018)",
    latin: !0,
    isMode: !1,
    geocoding: !1
  },
  /**
   * Japanese language in Kana form (non-latin script)
   */
  JAPANESE_KANA: {
    code: "ja_kana",
    flag: "name:ja_kana",
    name: "Japanese (Kana)",
    latin: !1,
    isMode: !1,
    geocoding: !1
  },
  /**
   * Japanse language, romanized (latin script)
   */
  JAPANESE_LATIN: {
    code: "ja_rm",
    flag: "name:ja_rm",
    name: "Japanese (Latin script)",
    latin: !0,
    isMode: !1,
    geocoding: !1
  },
  /**
   * Kannada language
   */
  KANNADA: {
    code: "kn",
    flag: "name:kn",
    name: "Kannada",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Kazakh language
   */
  KAZAKH: {
    code: "kk",
    flag: "name:kk",
    name: "Kazakh",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Korean language
   */
  KOREAN: {
    code: "ko",
    flag: "name:ko",
    name: "Korean",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Korean language (latin script)
   */
  KOREAN_LATIN: {
    code: "ko-Latn",
    flag: "name:ko-Latn",
    name: "Korean (Latin script)",
    latin: !0,
    isMode: !1,
    geocoding: !1
  },
  /**
   * Kurdish language
   */
  KURDISH: {
    code: "ku",
    flag: "name:ku",
    name: "Kurdish",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Classical Latin language
   */
  CLASSICAL_LATIN: {
    code: "la",
    flag: "name:la",
    name: "Latin",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Latvian language
   */
  LATVIAN: {
    code: "lv",
    flag: "name:lv",
    name: "Latvian",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Lithuanian language
   */
  LITHUANIAN: {
    code: "lt",
    flag: "name:lt",
    name: "Lithuanian",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Luxembourgish language
   */
  LUXEMBOURGISH: {
    code: "lb",
    flag: "name:lb",
    name: "Luxembourgish",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Macedonian language
   */
  MACEDONIAN: {
    code: "mk",
    flag: "name:mk",
    name: "Macedonian",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Malayalm language
   */
  MALAYALAM: {
    code: "ml",
    flag: "name:ml",
    name: "Malayalam",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Maltese language
   */
  MALTESE: {
    code: "mt",
    flag: "name:mt",
    name: "Maltese",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Norwegian language
   */
  NORWEGIAN: {
    code: "no",
    flag: "name:no",
    name: "Norwegian",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Occitan language
   */
  OCCITAN: {
    code: "oc",
    flag: "name:oc",
    name: "Occitan",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Persian language
   */
  PERSIAN: {
    code: "fa",
    flag: "name:fa",
    name: "Persian",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Polish language
   */
  POLISH: {
    code: "pl",
    flag: "name:pl",
    name: "Polish",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Portuguese language
   */
  PORTUGUESE: {
    code: "pt",
    flag: "name:pt",
    name: "Portuguese",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Punjabi language
   */
  PUNJABI: {
    code: "pa",
    flag: "name:pa",
    name: "Punjabi",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Western Punjabi language
   */
  WESTERN_PUNJABI: {
    code: "pnb",
    flag: "name:pnb",
    name: "Western Punjabi",
    latin: !1,
    isMode: !1,
    geocoding: !1
  },
  /**
   * Romanian language
   */
  ROMANIAN: {
    code: "ro",
    flag: "name:ro",
    name: "Romanian",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Romansh language
   */
  ROMANSH: {
    code: "rm",
    flag: "name:rm",
    name: "Romansh",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Russian language
   */
  RUSSIAN: {
    code: "ru",
    flag: "name:ru",
    name: "Russian",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Serbian language (cyrillic script)
   */
  SERBIAN_CYRILLIC: {
    code: "sr",
    flag: "name:sr",
    name: "Serbian (Cyrillic script)",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Serbian language (latin script)
   */
  SERBIAN_LATIN: {
    code: "sr-Latn",
    flag: "name:sr-Latn",
    name: "Serbian (Latin script)",
    latin: !0,
    isMode: !1,
    geocoding: !1
  },
  /**
   * Scottish Gaelic language
   */
  SCOTTISH_GAELIC: {
    code: "gd",
    flag: "name:gd",
    name: "Scottish Gaelic",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Slovak language
   */
  SLOVAK: {
    code: "sk",
    flag: "name:sk",
    name: "Slovak",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Slovene language
   */
  SLOVENE: {
    code: "sl",
    flag: "name:sl",
    name: "Slovene",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Spanish language
   */
  SPANISH: {
    code: "es",
    flag: "name:es",
    name: "Spanish",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Swedish language
   */
  SWEDISH: {
    code: "sv",
    flag: "name:sv",
    name: "Swedish",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Tamil language
   */
  TAMIL: {
    code: "ta",
    flag: "name:ta",
    name: "Tamil",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Telugu language
   */
  TELUGU: {
    code: "te",
    flag: "name:te",
    name: "Telugu",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Thai language
   */
  THAI: {
    code: "th",
    flag: "name:th",
    name: "Thai",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Turkish language
   */
  TURKISH: {
    code: "tr",
    flag: "name:tr",
    name: "Turkish",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Ukrainian language
   */
  UKRAINIAN: {
    code: "uk",
    flag: "name:uk",
    name: "Ukrainian",
    latin: !1,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Vietnamese language (latin script)
   */
  VIETNAMESE: {
    code: "vi",
    flag: "name:vi",
    name: "Vietnamese (Latin script)",
    latin: !0,
    isMode: !1,
    geocoding: !0
  },
  /**
   * Welsh language
   */
  WELSH: {
    code: "cy",
    flag: "name:cy",
    name: "Welsh",
    latin: !0,
    isMode: !1,
    geocoding: !0
  }
}, Rm = {
  ...z1,
  ...P1
};
function I1(d, o = Rm) {
  return d in o ? d[d] : null;
}
function m_(d, o = Rm) {
  for (const m of Object.values(o))
    if (m.code === d)
      return m;
  return null;
}
function g_(d, o = Rm) {
  for (const m of Object.values(o))
    if (m.flag === d)
      return m;
  return null;
}
function k1(d) {
  return d !== null && typeof d == "object" && "code" in d && "flag" in d && "name" in d && "latin" in d && "isMode" in d && "geocoding" in d && (typeof d.code == "string" || d.code === null) && typeof d.flag == "string" && typeof d.name == "string" && typeof d.latin == "boolean" && typeof d.isMode == "boolean" && typeof d.geocoding == "boolean";
}
function E0(d, o = Rm) {
  return k1(d) ? g_(d.flag, o) : typeof d != "string" ? null : I1(d, o) || m_(d, o) || g_(d, o) || null;
}
async function R1(d, o = {}) {
  if (Xp.fetch === null)
    throw new Error(
      "The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch"
    );
  if (new URL(d).searchParams.get("key").trim() === "")
    throw new Error(
      "The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com"
    );
  return Xp.fetch(d, o);
}
const Lv = {
  maptilerApiURL: "https://api.maptiler.com/",
  mapStyle: "streets-v2"
};
Object.freeze(Lv);
class D1 extends Error {
  constructor(o, m = "") {
    super(
      `Call to enpoint ${o.url} failed with the status code ${o.status}. ${m}`
    ), this.res = o;
  }
}
const C0 = {
  403: "Key is missing, invalid or restricted"
};
async function L1(d = {}) {
  const o = new URL("geolocation/ip.json", Lv.maptilerApiURL);
  o.searchParams.set("key", d.apiKey ?? Xp.apiKey), "elevation" in d && o.searchParams.set(
    "elevation",
    d.elevation ? "true" : "false"
  );
  const m = o.toString(), b = await R1(m);
  if (!b.ok)
    throw new D1(
      b,
      b.status in C0 ? C0[b.status] : ""
    );
  return await b.json();
}
const z0 = {
  info: L1
};
function Ov(d) {
  const o = /^maptiler:\/\/(.*)/;
  let m;
  const b = d.trim();
  let M;
  return b.startsWith("http://") || b.startsWith("https://") ? M = b : (m = o.exec(b)) !== null ? M = `https://api.maptiler.com/maps/${m[1]}/style.json` : M = `https://api.maptiler.com/maps/${b}/style.json`, M;
}
class Bv {
  constructor(o, m, b, M, z, S, u = !1) {
    this.name = o, this.variantType = m, this.id = b, this.referenceStyle = M, this.description = z, this.imageURL = S, this.deprecated = u;
  }
  /**
   * Get the human-friendly name
   * @returns
   */
  getName() {
    return this.name;
  }
  getFullName() {
    return `${this.referenceStyle.getName()} ${this.name}`;
  }
  /**
   * Get the variant type (eg. "DEFAULT", "DARK", "PASTEL", etc.)
   * @returns
   */
  getType() {
    return this.variantType;
  }
  /**
   * Get the MapTiler Cloud id
   * @returns
   */
  getId() {
    return this.id;
  }
  /**
   * Get the human-friendly description
   */
  getDescription() {
    return this.description;
  }
  /**
   * Get the reference style this variant belongs to
   * @returns
   */
  getReferenceStyle() {
    return this.referenceStyle;
  }
  /**
   * Check if a variant of a given type exists for _this_ variants
   * (eg. if this is a "DARK", then we can check if there is a "LIGHT" variant of it)
   * @param variantType
   * @returns
   */
  hasVariant(o) {
    return this.referenceStyle.hasVariant(o);
  }
  /**
   * Retrieve the variant of a given type. If not found, will return the "DEFAULT" variant.
   * (eg. _this_ "DARK" variant does not have any "PASTEL" variant, then the "DEFAULT" is returned)
   * @param variantType
   * @returns
   */
  getVariant(o) {
    const m = this.referenceStyle.getVariant(o);
    return this.warnIfDeprecated(m), m;
  }
  /**
   * Get all the variants for _this_ variants, except _this_ current one
   * @returns
   */
  getVariants() {
    return this.referenceStyle.getVariants().filter((o) => o !== this).map((o) => (this.warnIfDeprecated(o), o));
  }
  /**
   * Get the image URL that represent _this_ variant
   * @returns
   */
  getImageURL() {
    return this.imageURL;
  }
  /**
   * Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)
   * @returns
   */
  getExpandedStyleURL() {
    return Ov(this.getId());
  }
  warnIfDeprecated(o = this) {
    if (!o.deprecated)
      return o;
    const m = o.getFullName();
    return console.warn(
      `Style "${m}" is deprecated and will be removed in a future version.`
    ), o;
  }
}
class Nv {
  constructor(o, m) {
    this.name = o, this.id = m, this.variants = {}, this.orderedVariants = [];
  }
  /**
   * Get the human-friendly name of this reference style
   * @returns
   */
  getName() {
    return this.name;
  }
  /**
   * Get the id of _this_ reference style
   * @returns
   */
  getId() {
    return this.id;
  }
  /**
   * Add a variant to _this_ reference style
   * @param v
   */
  addVariant(o) {
    this.variants[o.getType()] = o, this.orderedVariants.push(o);
  }
  /**
   * Check if a given variant type exists for this reference style
   * @param variantType
   * @returns
   */
  hasVariant(o) {
    return o in this.variants;
  }
  /**
   * Get a given variant. If the given type of variant does not exist for this reference style,
   * then the most relevant default variant is returned instead
   * @param variantType
   * @returns
   */
  getVariant(o) {
    return o in this.variants ? this.variants[o] : this.orderedVariants[0];
  }
  /**
   * Get the list of variants for this reference style
   * @returns
   */
  getVariants() {
    return Object.values(this.variants);
  }
  /**
   * Get the defualt variant for this reference style
   * @returns
   */
  getDefaultVariant() {
    return this.orderedVariants[0].warnIfDeprecated();
  }
}
const ym = [
  {
    referenceStyleID: "STREETS",
    name: "Streets",
    description: "",
    variants: [
      {
        id: "streets-v2",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "streets-v2-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "streets-v2-light",
        name: "Light",
        variantType: "LIGHT",
        description: "",
        imageURL: ""
      },
      {
        id: "streets-v2-night",
        name: "Night",
        variantType: "NIGHT",
        description: "",
        imageURL: ""
      },
      {
        id: "streets-v2-pastel",
        name: "Pastel",
        variantType: "PASTEL",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "OUTDOOR",
    name: "Outdoor",
    description: "",
    variants: [
      {
        id: "outdoor-v2",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "outdoor-v2-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "WINTER",
    name: "Winter",
    description: "",
    variants: [
      {
        id: "winter-v2",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "winter-v2-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "SATELLITE",
    name: "Satellite",
    description: "",
    variants: [
      {
        id: "satellite",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "HYBRID",
    name: "Hybrid",
    description: "",
    variants: [
      {
        id: "hybrid",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "BASIC",
    name: "Basic",
    description: "",
    variants: [
      {
        id: "basic-v2",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "basic-v2-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "basic-v2-light",
        name: "Light",
        variantType: "LIGHT",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "BRIGHT",
    name: "Bright",
    description: "",
    variants: [
      {
        id: "bright-v2",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "bright-v2-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "bright-v2-light",
        name: "Light",
        variantType: "LIGHT",
        description: "",
        imageURL: ""
      },
      {
        id: "bright-v2-pastel",
        name: "Pastel",
        variantType: "PASTEL",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "OPENSTREETMAP",
    name: "OpenStreetMap",
    description: "",
    variants: [
      {
        id: "openstreetmap",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "TOPO",
    name: "Topo",
    description: "",
    variants: [
      {
        id: "topo-v2",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "topo-v2-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "topo-v2-shiny",
        name: "Shiny",
        deprecated: !0,
        variantType: "SHINY",
        description: "",
        imageURL: ""
      },
      {
        id: "topo-v2-pastel",
        name: "Pastel",
        variantType: "PASTEL",
        description: "",
        imageURL: ""
      },
      {
        id: "topo-v2-topographique",
        name: "Topographique",
        variantType: "TOPOGRAPHIQUE",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "VOYAGER",
    name: "Voyager",
    description: "",
    variants: [
      {
        id: "voyager-v2",
        name: "Default",
        deprecated: !0,
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "voyager-v2-darkmatter",
        name: "Darkmatter",
        deprecated: !0,
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "voyager-v2-positron",
        name: "Positron",
        deprecated: !0,
        variantType: "LIGHT",
        description: "",
        imageURL: ""
      },
      {
        id: "voyager-v2-vintage",
        name: "Vintage",
        deprecated: !0,
        variantType: "VINTAGE",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "TONER",
    name: "Toner",
    description: "",
    variants: [
      {
        id: "toner-v2",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "toner-v2-background",
        name: "Background",
        variantType: "BACKGROUND",
        deprecated: !0,
        description: "",
        imageURL: ""
      },
      {
        id: "toner-v2-lite",
        name: "Lite",
        variantType: "LITE",
        description: "",
        imageURL: ""
      },
      {
        id: "toner-v2-lines",
        name: "Lines",
        variantType: "LINES",
        deprecated: !0,
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "DATAVIZ",
    name: "Dataviz",
    description: "",
    variants: [
      {
        id: "dataviz",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "dataviz-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "dataviz-light",
        name: "Light",
        variantType: "LIGHT",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "BACKDROP",
    name: "Backdrop",
    description: "",
    variants: [
      {
        id: "backdrop",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "backdrop-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "backdrop-light",
        name: "Light",
        variantType: "LIGHT",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "OCEAN",
    name: "Ocean",
    description: "",
    variants: [
      {
        id: "ocean",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "AQUARELLE",
    name: "Aquarelle",
    description: "Watercolor map for creative use",
    variants: [
      {
        id: "aquarelle",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "aquarelle-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "aquarelle-vivid",
        name: "Vivid",
        variantType: "VIVID",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "LANDSCAPE",
    name: "Landscape",
    description: "Terrain map for data overlays and visualisations",
    variants: [
      {
        id: "landscape",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "landscape-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "landscape-vivid",
        name: "Vivid",
        variantType: "VIVID",
        description: "",
        imageURL: ""
      }
    ]
  }
];
function O1(d) {
  return new Proxy(d, {
    get(o, m, b) {
      return o.hasVariant(m) ? o.getVariant(m) : m.toString().toUpperCase() === m ? d.getDefaultVariant() : Reflect.get(o, m, b);
    }
  });
}
function B1() {
  const d = {};
  for (let o = 0; o < ym.length; o += 1) {
    const m = ym[o], b = O1(
      new Nv(m.name, m.referenceStyleID)
    );
    for (let M = 0; M < m.variants.length; M += 1) {
      const z = m.variants[M], S = new Bv(
        z.name,
        // name
        z.variantType,
        // variantType
        z.id,
        // id
        b,
        // referenceStyle
        z.description,
        z.imageURL,
        // imageURL
        z.deprecated
        // deprecated
      );
      b.addVariant(S);
    }
    d[m.referenceStyleID] = b;
  }
  return d;
}
const _m = B1();
var zg = { exports: {} }, P0;
function N1() {
  if (P0) return zg.exports;
  P0 = 1;
  var d = typeof Reflect == "object" ? Reflect : null, o = d && typeof d.apply == "function" ? d.apply : function(Re, $e, rt) {
    return Function.prototype.apply.call(Re, $e, rt);
  }, m;
  d && typeof d.ownKeys == "function" ? m = d.ownKeys : Object.getOwnPropertySymbols ? m = function(Re) {
    return Object.getOwnPropertyNames(Re).concat(Object.getOwnPropertySymbols(Re));
  } : m = function(Re) {
    return Object.getOwnPropertyNames(Re);
  };
  function b(De) {
    console && console.warn && console.warn(De);
  }
  var M = Number.isNaN || function(Re) {
    return Re !== Re;
  };
  function z() {
    z.init.call(this);
  }
  zg.exports = z, zg.exports.once = ht, z.EventEmitter = z, z.prototype._events = void 0, z.prototype._eventsCount = 0, z.prototype._maxListeners = void 0;
  var S = 10;
  function u(De) {
    if (typeof De != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof De);
  }
  Object.defineProperty(z, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return S;
    },
    set: function(De) {
      if (typeof De != "number" || De < 0 || M(De))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + De + ".");
      S = De;
    }
  }), z.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, z.prototype.setMaxListeners = function(Re) {
    if (typeof Re != "number" || Re < 0 || M(Re))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Re + ".");
    return this._maxListeners = Re, this;
  };
  function O(De) {
    return De._maxListeners === void 0 ? z.defaultMaxListeners : De._maxListeners;
  }
  z.prototype.getMaxListeners = function() {
    return O(this);
  }, z.prototype.emit = function(Re) {
    for (var $e = [], rt = 1; rt < arguments.length; rt++) $e.push(arguments[rt]);
    var wt = Re === "error", Ht = this._events;
    if (Ht !== void 0)
      wt = wt && Ht.error === void 0;
    else if (!wt)
      return !1;
    if (wt) {
      var Dt;
      if ($e.length > 0 && (Dt = $e[0]), Dt instanceof Error)
        throw Dt;
      var Xt = new Error("Unhandled error." + (Dt ? " (" + Dt.message + ")" : ""));
      throw Xt.context = Dt, Xt;
    }
    var pi = Ht[Re];
    if (pi === void 0)
      return !1;
    if (typeof pi == "function")
      o(pi, this, $e);
    else
      for (var vn = pi.length, Cn = ke(pi, vn), rt = 0; rt < vn; ++rt)
        o(Cn[rt], this, $e);
    return !0;
  };
  function U(De, Re, $e, rt) {
    var wt, Ht, Dt;
    if (u($e), Ht = De._events, Ht === void 0 ? (Ht = De._events = /* @__PURE__ */ Object.create(null), De._eventsCount = 0) : (Ht.newListener !== void 0 && (De.emit(
      "newListener",
      Re,
      $e.listener ? $e.listener : $e
    ), Ht = De._events), Dt = Ht[Re]), Dt === void 0)
      Dt = Ht[Re] = $e, ++De._eventsCount;
    else if (typeof Dt == "function" ? Dt = Ht[Re] = rt ? [$e, Dt] : [Dt, $e] : rt ? Dt.unshift($e) : Dt.push($e), wt = O(De), wt > 0 && Dt.length > wt && !Dt.warned) {
      Dt.warned = !0;
      var Xt = new Error("Possible EventEmitter memory leak detected. " + Dt.length + " " + String(Re) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      Xt.name = "MaxListenersExceededWarning", Xt.emitter = De, Xt.type = Re, Xt.count = Dt.length, b(Xt);
    }
    return De;
  }
  z.prototype.addListener = function(Re, $e) {
    return U(this, Re, $e, !1);
  }, z.prototype.on = z.prototype.addListener, z.prototype.prependListener = function(Re, $e) {
    return U(this, Re, $e, !0);
  };
  function K() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function ae(De, Re, $e) {
    var rt = { fired: !1, wrapFn: void 0, target: De, type: Re, listener: $e }, wt = K.bind(rt);
    return wt.listener = $e, rt.wrapFn = wt, wt;
  }
  z.prototype.once = function(Re, $e) {
    return u($e), this.on(Re, ae(this, Re, $e)), this;
  }, z.prototype.prependOnceListener = function(Re, $e) {
    return u($e), this.prependListener(Re, ae(this, Re, $e)), this;
  }, z.prototype.removeListener = function(Re, $e) {
    var rt, wt, Ht, Dt, Xt;
    if (u($e), wt = this._events, wt === void 0)
      return this;
    if (rt = wt[Re], rt === void 0)
      return this;
    if (rt === $e || rt.listener === $e)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete wt[Re], wt.removeListener && this.emit("removeListener", Re, rt.listener || $e));
    else if (typeof rt != "function") {
      for (Ht = -1, Dt = rt.length - 1; Dt >= 0; Dt--)
        if (rt[Dt] === $e || rt[Dt].listener === $e) {
          Xt = rt[Dt].listener, Ht = Dt;
          break;
        }
      if (Ht < 0)
        return this;
      Ht === 0 ? rt.shift() : qe(rt, Ht), rt.length === 1 && (wt[Re] = rt[0]), wt.removeListener !== void 0 && this.emit("removeListener", Re, Xt || $e);
    }
    return this;
  }, z.prototype.off = z.prototype.removeListener, z.prototype.removeAllListeners = function(Re) {
    var $e, rt, wt;
    if (rt = this._events, rt === void 0)
      return this;
    if (rt.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : rt[Re] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete rt[Re]), this;
    if (arguments.length === 0) {
      var Ht = Object.keys(rt), Dt;
      for (wt = 0; wt < Ht.length; ++wt)
        Dt = Ht[wt], Dt !== "removeListener" && this.removeAllListeners(Dt);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if ($e = rt[Re], typeof $e == "function")
      this.removeListener(Re, $e);
    else if ($e !== void 0)
      for (wt = $e.length - 1; wt >= 0; wt--)
        this.removeListener(Re, $e[wt]);
    return this;
  };
  function he(De, Re, $e) {
    var rt = De._events;
    if (rt === void 0)
      return [];
    var wt = rt[Re];
    return wt === void 0 ? [] : typeof wt == "function" ? $e ? [wt.listener || wt] : [wt] : $e ? ft(wt) : ke(wt, wt.length);
  }
  z.prototype.listeners = function(Re) {
    return he(this, Re, !0);
  }, z.prototype.rawListeners = function(Re) {
    return he(this, Re, !1);
  }, z.listenerCount = function(De, Re) {
    return typeof De.listenerCount == "function" ? De.listenerCount(Re) : J.call(De, Re);
  }, z.prototype.listenerCount = J;
  function J(De) {
    var Re = this._events;
    if (Re !== void 0) {
      var $e = Re[De];
      if (typeof $e == "function")
        return 1;
      if ($e !== void 0)
        return $e.length;
    }
    return 0;
  }
  z.prototype.eventNames = function() {
    return this._eventsCount > 0 ? m(this._events) : [];
  };
  function ke(De, Re) {
    for (var $e = new Array(Re), rt = 0; rt < Re; ++rt)
      $e[rt] = De[rt];
    return $e;
  }
  function qe(De, Re) {
    for (; Re + 1 < De.length; Re++)
      De[Re] = De[Re + 1];
    De.pop();
  }
  function ft(De) {
    for (var Re = new Array(De.length), $e = 0; $e < Re.length; ++$e)
      Re[$e] = De[$e].listener || De[$e];
    return Re;
  }
  function ht(De, Re) {
    return new Promise(function($e, rt) {
      function wt(Dt) {
        De.removeListener(Re, Ht), rt(Dt);
      }
      function Ht() {
        typeof De.removeListener == "function" && De.removeListener("error", wt), $e([].slice.call(arguments));
      }
      nt(De, Re, Ht, { once: !0 }), Re !== "error" && it(De, wt, { once: !0 });
    });
  }
  function it(De, Re, $e) {
    typeof De.on == "function" && nt(De, "error", Re, $e);
  }
  function nt(De, Re, $e, rt) {
    if (typeof De.on == "function")
      rt.once ? De.once(Re, $e) : De.on(Re, $e);
    else if (typeof De.addEventListener == "function")
      De.addEventListener(Re, function wt(Ht) {
        rt.once && De.removeEventListener(Re, wt), $e(Ht);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof De);
  }
  return zg.exports;
}
var j1 = N1();
const U1 = /* @__PURE__ */ iy(j1), Ir = [];
for (let d = 0; d < 256; ++d)
  Ir.push((d + 256).toString(16).slice(1));
function F1(d, o = 0) {
  return (Ir[d[o + 0]] + Ir[d[o + 1]] + Ir[d[o + 2]] + Ir[d[o + 3]] + "-" + Ir[d[o + 4]] + Ir[d[o + 5]] + "-" + Ir[d[o + 6]] + Ir[d[o + 7]] + "-" + Ir[d[o + 8]] + Ir[d[o + 9]] + "-" + Ir[d[o + 10]] + Ir[d[o + 11]] + Ir[d[o + 12]] + Ir[d[o + 13]] + Ir[d[o + 14]] + Ir[d[o + 15]]).toLowerCase();
}
let Wy;
const V1 = new Uint8Array(16);
function q1() {
  if (!Wy) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Wy = crypto.getRandomValues.bind(crypto);
  }
  return Wy(V1);
}
const G1 = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), I0 = { randomUUID: G1 };
function Z1(d, o, m) {
  if (I0.randomUUID && !d)
    return I0.randomUUID();
  d = d || {};
  const b = d.random ?? d.rng?.() ?? q1();
  if (b.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return b[6] = b[6] & 15 | 64, b[8] = b[8] & 63 | 128, F1(b);
}
const jv = "3.7.8", $1 = jv, Qp = typeof Buffer == "function", k0 = typeof TextDecoder == "function" ? new TextDecoder() : void 0, R0 = typeof TextEncoder == "function" ? new TextEncoder() : void 0, H1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", dm = Array.prototype.slice.call(H1), Pg = ((d) => {
  let o = {};
  return d.forEach((m, b) => o[m] = b), o;
})(dm), X1 = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, kr = String.fromCharCode.bind(String), D0 = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : (d) => new Uint8Array(Array.prototype.slice.call(d, 0)), Uv = (d) => d.replace(/=/g, "").replace(/[+\/]/g, (o) => o == "+" ? "-" : "_"), Fv = (d) => d.replace(/[^A-Za-z0-9\+\/]/g, ""), Vv = (d) => {
  let o, m, b, M, z = "";
  const S = d.length % 3;
  for (let u = 0; u < d.length; ) {
    if ((m = d.charCodeAt(u++)) > 255 || (b = d.charCodeAt(u++)) > 255 || (M = d.charCodeAt(u++)) > 255)
      throw new TypeError("invalid character found");
    o = m << 16 | b << 8 | M, z += dm[o >> 18 & 63] + dm[o >> 12 & 63] + dm[o >> 6 & 63] + dm[o & 63];
  }
  return S ? z.slice(0, S - 3) + "===".substring(S) : z;
}, D_ = typeof btoa == "function" ? (d) => btoa(d) : Qp ? (d) => Buffer.from(d, "binary").toString("base64") : Vv, y_ = Qp ? (d) => Buffer.from(d).toString("base64") : (d) => {
  let m = [];
  for (let b = 0, M = d.length; b < M; b += 4096)
    m.push(kr.apply(null, d.subarray(b, b + 4096)));
  return D_(m.join(""));
}, Bg = (d, o = !1) => o ? Uv(y_(d)) : y_(d), Y1 = (d) => {
  if (d.length < 2) {
    var o = d.charCodeAt(0);
    return o < 128 ? d : o < 2048 ? kr(192 | o >>> 6) + kr(128 | o & 63) : kr(224 | o >>> 12 & 15) + kr(128 | o >>> 6 & 63) + kr(128 | o & 63);
  } else {
    var o = 65536 + (d.charCodeAt(0) - 55296) * 1024 + (d.charCodeAt(1) - 56320);
    return kr(240 | o >>> 18 & 7) + kr(128 | o >>> 12 & 63) + kr(128 | o >>> 6 & 63) + kr(128 | o & 63);
  }
}, K1 = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, qv = (d) => d.replace(K1, Y1), L0 = Qp ? (d) => Buffer.from(d, "utf8").toString("base64") : R0 ? (d) => y_(R0.encode(d)) : (d) => D_(qv(d)), Yp = (d, o = !1) => o ? Uv(L0(d)) : L0(d), O0 = (d) => Yp(d, !0), W1 = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, J1 = (d) => {
  switch (d.length) {
    case 4:
      var o = (7 & d.charCodeAt(0)) << 18 | (63 & d.charCodeAt(1)) << 12 | (63 & d.charCodeAt(2)) << 6 | 63 & d.charCodeAt(3), m = o - 65536;
      return kr((m >>> 10) + 55296) + kr((m & 1023) + 56320);
    case 3:
      return kr((15 & d.charCodeAt(0)) << 12 | (63 & d.charCodeAt(1)) << 6 | 63 & d.charCodeAt(2));
    default:
      return kr((31 & d.charCodeAt(0)) << 6 | 63 & d.charCodeAt(1));
  }
}, Gv = (d) => d.replace(W1, J1), Zv = (d) => {
  if (d = d.replace(/\s+/g, ""), !X1.test(d))
    throw new TypeError("malformed base64.");
  d += "==".slice(2 - (d.length & 3));
  let o, m, b, M = [];
  for (let z = 0; z < d.length; )
    o = Pg[d.charAt(z++)] << 18 | Pg[d.charAt(z++)] << 12 | (m = Pg[d.charAt(z++)]) << 6 | (b = Pg[d.charAt(z++)]), m === 64 ? M.push(kr(o >> 16 & 255)) : b === 64 ? M.push(kr(o >> 16 & 255, o >> 8 & 255)) : M.push(kr(o >> 16 & 255, o >> 8 & 255, o & 255));
  return M.join("");
}, L_ = typeof atob == "function" ? (d) => atob(Fv(d)) : Qp ? (d) => Buffer.from(d, "base64").toString("binary") : Zv, $v = Qp ? (d) => D0(Buffer.from(d, "base64")) : (d) => D0(L_(d).split("").map((o) => o.charCodeAt(0))), Hv = (d) => $v(Xv(d)), Q1 = Qp ? (d) => Buffer.from(d, "base64").toString("utf8") : k0 ? (d) => k0.decode($v(d)) : (d) => Gv(L_(d)), Xv = (d) => Fv(d.replace(/[-_]/g, (o) => o == "-" ? "+" : "/")), __ = (d) => Q1(Xv(d)), eb = (d) => {
  if (typeof d != "string")
    return !1;
  const o = d.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(o) || !/[^\s0-9a-zA-Z\-_]/.test(o);
}, Yv = (d) => ({
  value: d,
  enumerable: !1,
  writable: !0,
  configurable: !0
}), Kv = function() {
  const d = (o, m) => Object.defineProperty(String.prototype, o, Yv(m));
  d("fromBase64", function() {
    return __(this);
  }), d("toBase64", function(o) {
    return Yp(this, o);
  }), d("toBase64URI", function() {
    return Yp(this, !0);
  }), d("toBase64URL", function() {
    return Yp(this, !0);
  }), d("toUint8Array", function() {
    return Hv(this);
  });
}, Wv = function() {
  const d = (o, m) => Object.defineProperty(Uint8Array.prototype, o, Yv(m));
  d("toBase64", function(o) {
    return Bg(this, o);
  }), d("toBase64URI", function() {
    return Bg(this, !0);
  }), d("toBase64URL", function() {
    return Bg(this, !0);
  });
}, tb = () => {
  Kv(), Wv();
}, ib = {
  version: jv,
  VERSION: $1,
  atob: L_,
  atobPolyfill: Zv,
  btoa: D_,
  btoaPolyfill: Vv,
  fromBase64: __,
  toBase64: Yp,
  encode: Yp,
  encodeURI: O0,
  encodeURL: O0,
  utob: qv,
  btou: Gv,
  decode: __,
  isValid: eb,
  fromUint8Array: Bg,
  toUint8Array: Hv,
  extendString: Kv,
  extendUint8Array: Wv,
  extendBuiltins: tb
};
var nb = Object.defineProperty, Jv = (d) => {
  throw TypeError(d);
}, ab = (d, o, m) => o in d ? nb(d, o, { enumerable: !0, configurable: !0, writable: !0, value: m }) : d[o] = m, St = (d, o, m) => ab(d, typeof o != "symbol" ? o + "" : o, m), O_ = (d, o, m) => o.has(d) || Jv("Cannot " + m), jt = (d, o, m) => (O_(d, o, "read from private field"), m ? m.call(d) : o.get(d)), Ls = (d, o, m) => o.has(d) ? Jv("Cannot add the same private member more than once") : o instanceof WeakSet ? o.add(d) : o.set(d, m), oo = (d, o, m, b) => (O_(d, o, "write to private field"), o.set(d, m), m), ro = (d, o, m) => (O_(d, o, "access private method"), m);
const Zi = {
  /**
   * Language mode to display labels in both the local language and the language of the visitor's device, concatenated.
   * Note that if those two languages are the same, labels won't be duplicated.
   */
  VISITOR: {
    code: null,
    flag: "visitor",
    name: "Visitor",
    latin: !0,
    isMode: !0,
    geocoding: !1
  },
  /**
   * Language mode to display labels in both the local language and English, concatenated.
   * Note that if those two languages are the same, labels won't be duplicated.
   */
  VISITOR_ENGLISH: {
    code: null,
    flag: "visitor_en",
    name: "Visitor English",
    latin: !0,
    isMode: !0,
    geocoding: !1
  },
  /**
   * Language mode to display labels in a language enforced in the style.
   */
  STYLE: {
    code: null,
    flag: "style",
    name: "Style",
    latin: !1,
    isMode: !0,
    geocoding: !1
  },
  /**
   * Language mode to display labels in a language enforced in the style. The language cannot be further modified.
   */
  STYLE_LOCK: {
    code: null,
    flag: "style_lock",
    name: "Style Lock",
    latin: !1,
    isMode: !0,
    geocoding: !1
  },
  ...Rm
};
function B0() {
  if (typeof navigator > "u") {
    const d = Intl.DateTimeFormat().resolvedOptions().locale.split("-")[0];
    return m_(d) || Zi.ENGLISH;
  }
  return Array.from(new Set(navigator.languages.map((d) => d.split("-")[0]))).map((d) => m_(d)).filter((d) => d)[0] ?? Zi.LOCAL;
}
const rs = {
  maptilerLogoURL: "https://api.maptiler.com/resources/logo.svg",
  maptilerURL: "https://www.maptiler.com/",
  maptilerApiHost: "api.maptiler.com",
  telemetryURL: "https://api.maptiler.com/metrics",
  rtlPluginURL: "https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js",
  primaryLanguage: Zi.STYLE,
  secondaryLanguage: Zi.LOCAL,
  terrainSourceURL: "https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json",
  terrainSourceId: "maptiler-terrain"
};
Object.freeze(rs);
const B_ = Z1();
class rb extends U1 {
  constructor() {
    super(...arguments), St(this, "primaryLanguage", rs.primaryLanguage), St(this, "secondaryLanguage"), St(this, "session", !0), St(this, "caching", !0), St(this, "telemetry", !0), St(this, "_unit", "metric"), St(this, "_apiKey", "");
  }
  /**
   * Set the unit system
   */
  set unit(o) {
    this._unit = o, this.emit("unit", o);
  }
  /**
   * Get the unit system
   */
  get unit() {
    return this._unit;
  }
  /**
   * Set the MapTiler Cloud API key
   */
  set apiKey(o) {
    this._apiKey = o, Xp.apiKey = o, this.emit("apiKey", o);
  }
  /**
   * Get the MapTiler Cloud API key
   */
  get apiKey() {
    return this._apiKey;
  }
  /**
   * Set a the custom fetch function to replace the default one
   */
  set fetch(o) {
    Xp.fetch = o;
  }
  /**
   * Get the fetch fucntion
   */
  get fetch() {
    return Xp.fetch;
  }
}
const Ha = new rb(), v_ = "localcache_source", x_ = "localcache", sb = "maptiler_sdk", ob = 1e3, lb = 100, b_ = typeof caches < "u", { addProtocol: N0 } = Lt;
function ub(d, o) {
  if (b_ && Ha.caching && Ha.session && d.host === rs.maptilerApiHost) {
    if (o === "Source" && d.href.includes("tiles.json"))
      return d.href.replace("https://", `${v_}://`);
    if (o === "Tile" || o === "Glyphs")
      return d.href.replace("https://", `${x_}://`);
  }
  return d.href;
}
let Jy;
async function Qv() {
  return Jy || (Jy = await caches.open(sb)), Jy;
}
let j0 = 0;
async function cb() {
  const d = await Qv(), o = await d.keys(), m = o.slice(0, Math.max(o.length - ob, 0));
  for (const b of m)
    d.delete(b);
}
function hb() {
  N0(
    v_,
    async (d, o) => {
      if (!d.url) throw new Error("");
      d.url = d.url.replace(`${v_}://`, "https://");
      const m = d;
      m.signal = o.signal;
      const b = await fetch(d.url, m), M = await b.json();
      return M.tiles && M.tiles.length > 0 && (M.tiles[0] += `&last-modified=${b.headers.get("Last-Modified")}`), {
        data: M,
        cacheControl: b.headers.get("Cache-Control"),
        expires: b.headers.get("Expires")
      };
    }
  ), N0(x_, async (d, o) => {
    if (!d.url) throw new Error("");
    d.url = d.url.replace(`${x_}://`, "https://");
    const m = new URL(d.url), b = new URL(m);
    b.searchParams.delete("mtsid"), b.searchParams.delete("key");
    const M = b.toString(), z = new URL(m);
    z.searchParams.delete("last-modified");
    const S = z.toString(), u = async (he) => ({
      data: await he.arrayBuffer(),
      cacheControl: he.headers.get("Cache-Control"),
      expires: he.headers.get("Expires")
    }), O = await Qv(), U = await O.match(M);
    if (U)
      return u(U);
    const K = d;
    K.signal = o.signal;
    const ae = await fetch(S, K);
    return ae.status >= 200 && ae.status < 300 && (O.put(M, ae.clone()).catch(() => {
    }), ++j0 > lb && (cb(), j0 = 0)), u(ae);
  });
}
function db() {
  if (typeof window > "u") return;
  const d = Lt.getRTLTextPluginStatus();
  if (d === "unavailable" || d === "requested")
    try {
      Lt.setRTLTextPlugin(rs.rtlPluginURL, !0);
    } catch {
    }
}
function pb(d, o) {
  for (const m of d)
    typeof o[m] == "function" && (o[m] = o[m].bind(o));
}
function U0(d, o) {
  let m = null;
  try {
    m = new URL(d);
  } catch {
    return {
      url: d
    };
  }
  return m.host === rs.maptilerApiHost && (m.searchParams.has("key") || m.searchParams.append("key", Ha.apiKey), Ha.session && m.searchParams.append("mtsid", B_)), {
    url: ub(m, o)
  };
}
function F0(d) {
  return (o, m) => {
    if (d != null) {
      const b = d(o, m), M = U0(b?.url ?? "", m);
      return {
        ...b,
        ...M
      };
    }
    return U0(o, m);
  };
}
function fb() {
  return document.createElement("canvas").getContext("webgl2") ? null : typeof WebGL2RenderingContext < "u" ? "Graphic rendering with WebGL2 has been disabled or is not supported by your graphic card. The map cannot be displayed." : "Your browser does not support graphic rendering with WebGL2. The map cannot be displayed.";
}
function mb(d) {
  const o = fb();
  if (!o) return;
  let m = null;
  if (typeof d == "string" ? m = document.getElementById(d) : d instanceof HTMLElement && (m = d), !m)
    throw new Error("The Map container must be provided.");
  const b = document.createElement("div");
  throw b.innerHTML = o, b.classList.add("webgl-warning-div"), m.appendChild(b), new Error(o);
}
function V0(d, o) {
  return !(!Array.isArray(d) || d.length !== 2 || d[0] !== "get" || typeof d[1] != "string" || o && !d[1].startsWith("name:") || !o && d[1] !== "name");
}
function gb(d, o, m) {
  const b = structuredClone(d), M = (z) => {
    if (typeof z != "string")
      for (let S = 0; S < z.length; S += 1)
        V0(z[S], m) ? z[S] = structuredClone(o) : M(z[S]);
  };
  return V0(b, m) ? o : (M(b), b);
}
function yb(d, o) {
  const m = o ? /\{name:\S+\}/ : /\{name\}/;
  return {
    contains: m.test(d),
    exactMatch: new RegExp(`^${m.source}$`).test(d)
  };
}
function _b(d, o, m) {
  const b = m ? /\{name:\S+\}/ : /\{name\}/, M = d.split(b);
  return ["concat", ...M.flatMap((z, S) => S === M.length - 1 ? [z] : [z, o])];
}
function vb(d) {
  var o;
  const m = /\{name(?::(?<language>\S+))?\}/g, b = [];
  for (; ; ) {
    const M = m.exec(d);
    if (!M) break;
    const z = ((o = M.groups) == null ? void 0 : o.language) ?? null;
    b.push(z);
  }
  return b;
}
function xb(d) {
  return !Array.isArray(d) || d.length !== 2 || d[0] !== "get" || typeof d[1] != "string" ? null : d[1].trim() === "name" ? {
    isLanguage: !0,
    localization: null
  } : d[1].trim().startsWith("name:") ? {
    isLanguage: !0,
    localization: d[1].trim().split(":").pop()
  } : null;
}
function bb(d) {
  const o = [], m = structuredClone(d), b = (M) => {
    if (typeof M != "string")
      for (let z = 0; z < M.length; z += 1) {
        const S = xb(M[z]);
        S ? o.push(S.localization) : b(M[z]);
      }
  };
  return b([m]), o;
}
function wb(d, o) {
  const m = [];
  for (const z of d) {
    if (z.type !== "symbol")
      continue;
    const S = z, { id: u, layout: O } = S;
    if (!O || !("text-field" in O))
      continue;
    const U = o.getLayoutProperty(u, "text-field");
    if (U)
      if (typeof U == "string") {
        const K = vb(U);
        m.push(K);
      } else {
        const K = bb(U);
        m.push(K);
      }
  }
  const b = m.flat(), M = {
    unlocalized: 0,
    localized: {}
  };
  for (const z of b)
    z === null ? M.unlocalized += 1 : (z in M.localized || (M.localized[z] = 0), M.localized[z] += 1);
  return M;
}
let Sb = class extends Lt.Marker {
  addTo(d) {
    return super.addTo(d);
  }
};
class Tb extends Lt.Popup {
  addTo(o) {
    return super.addTo(o);
  }
}
class mT extends Lt.Style {
  constructor(o, m = {}) {
    super(o, m);
  }
}
class gT extends Lt.CanvasSource {
  onAdd(o) {
    super.onAdd(o);
  }
}
class yT extends Lt.GeoJSONSource {
  onAdd(o) {
    super.onAdd(o);
  }
}
class _T extends Lt.ImageSource {
  onAdd(o) {
    super.onAdd(o);
  }
}
class vT extends Lt.RasterTileSource {
  onAdd(o) {
    super.onAdd(o);
  }
}
class xT extends Lt.RasterDEMTileSource {
  onAdd(o) {
    super.onAdd(o);
  }
}
class bT extends Lt.VectorTileSource {
  onAdd(o) {
    super.onAdd(o);
  }
}
class wT extends Lt.VideoSource {
  onAdd(o) {
    super.onAdd(o);
  }
}
class Mb extends Lt.NavigationControl {
  onAdd(o) {
    return super.onAdd(o);
  }
}
class Ab extends Lt.GeolocateControl {
  onAdd(o) {
    return super.onAdd(o);
  }
}
class ST extends Lt.AttributionControl {
  onAdd(o) {
    return super.onAdd(o);
  }
}
class Eb extends Lt.LogoControl {
  onAdd(o) {
    return super.onAdd(o);
  }
}
class Cb extends Lt.ScaleControl {
  onAdd(o) {
    return super.onAdd(o);
  }
}
class zb extends Lt.FullscreenControl {
  onAdd(o) {
    return super.onAdd(o);
  }
}
class TT extends Lt.TerrainControl {
  onAdd(o) {
    return super.onAdd(o);
  }
}
class MT extends Lt.BoxZoomHandler {
  constructor(o, m) {
    super(o, m);
  }
}
class AT extends Lt.ScrollZoomHandler {
  constructor(o, m) {
    super(o, m);
  }
}
class ET extends Lt.CooperativeGesturesHandler {
  constructor(o, m) {
    super(o, m);
  }
}
class CT extends Lt.KeyboardHandler {
  constructor(o) {
    super(o);
  }
}
class zT extends Lt.TwoFingersTouchPitchHandler {
  constructor(o) {
    super(o);
  }
}
class PT extends Lt.MapWheelEvent {
  constructor(o, m, b) {
    super(o, m, b);
  }
}
class IT extends Lt.MapTouchEvent {
  constructor(o, m, b) {
    super(o, m, b);
  }
}
class kT extends Lt.MapMouseEvent {
  constructor(o, m, b, M = {}) {
    super(o, m, b, M);
  }
}
class q0 extends Eb {
  constructor(o = {}) {
    super(o), St(this, "logoURL", ""), St(this, "linkURL", ""), this.logoURL = o.logoURL ?? rs.maptilerLogoURL, this.linkURL = o.linkURL ?? rs.maptilerURL;
  }
  onAdd(o) {
    this._map = o, this._compact = this.options.compact ?? !1, this._container = window.document.createElement("div"), this._container.className = "maplibregl-ctrl";
    const m = window.document.createElement("a");
    return m.style.backgroundRepeat = "no-repeat", m.style.cursor = "pointer", m.style.display = "block", m.style.height = "23px", m.style.margin = "0 0 -4px -4px", m.style.overflow = "hidden", m.style.width = "88px", m.style.backgroundImage = `url(${this.logoURL})`, m.style.backgroundSize = "100px 30px", m.style.width = "100px", m.style.height = "30px", m.target = "_blank", m.rel = "noopener", m.href = this.linkURL, m.setAttribute("aria-label", "MapTiler logo"), m.setAttribute("rel", "noopener"), this._container.appendChild(m), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
  }
}
var Pb = 8, Ib = {
  version: {
    required: !0,
    type: "enum",
    values: [
      8
    ]
  },
  name: {
    type: "string"
  },
  metadata: {
    type: "*"
  },
  center: {
    type: "array",
    value: "number"
  },
  centerAltitude: {
    type: "number"
  },
  zoom: {
    type: "number"
  },
  bearing: {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees"
  },
  pitch: {
    type: "number",
    default: 0,
    units: "degrees"
  },
  roll: {
    type: "number",
    default: 0,
    units: "degrees"
  },
  state: {
    type: "state",
    default: {}
  },
  light: {
    type: "light"
  },
  sky: {
    type: "sky"
  },
  projection: {
    type: "projection"
  },
  terrain: {
    type: "terrain"
  },
  sources: {
    required: !0,
    type: "sources"
  },
  sprite: {
    type: "sprite"
  },
  glyphs: {
    type: "string"
  },
  transition: {
    type: "transition"
  },
  layers: {
    required: !0,
    type: "array",
    value: "layer"
  }
}, kb = {
  "*": {
    type: "source"
  }
}, Rb = [
  "source_vector",
  "source_raster",
  "source_raster_dem",
  "source_geojson",
  "source_video",
  "source_image"
], Db = {
  type: {
    required: !0,
    type: "enum",
    values: {
      vector: {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {},
      tms: {}
    },
    default: "xyz"
  },
  minzoom: {
    type: "number",
    default: 0
  },
  maxzoom: {
    type: "number",
    default: 22
  },
  attribution: {
    type: "string"
  },
  promoteId: {
    type: "promoteId"
  },
  volatile: {
    type: "boolean",
    default: !1
  },
  "*": {
    type: "*"
  }
}, Lb = {
  type: {
    required: !0,
    type: "enum",
    values: {
      raster: {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  minzoom: {
    type: "number",
    default: 0
  },
  maxzoom: {
    type: "number",
    default: 22
  },
  tileSize: {
    type: "number",
    default: 512,
    units: "pixels"
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {},
      tms: {}
    },
    default: "xyz"
  },
  attribution: {
    type: "string"
  },
  volatile: {
    type: "boolean",
    default: !1
  },
  "*": {
    type: "*"
  }
}, Ob = {
  type: {
    required: !0,
    type: "enum",
    values: {
      "raster-dem": {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  minzoom: {
    type: "number",
    default: 0
  },
  maxzoom: {
    type: "number",
    default: 22
  },
  tileSize: {
    type: "number",
    default: 512,
    units: "pixels"
  },
  attribution: {
    type: "string"
  },
  encoding: {
    type: "enum",
    values: {
      terrarium: {},
      mapbox: {},
      custom: {}
    },
    default: "mapbox"
  },
  redFactor: {
    type: "number",
    default: 1
  },
  blueFactor: {
    type: "number",
    default: 1
  },
  greenFactor: {
    type: "number",
    default: 1
  },
  baseShift: {
    type: "number",
    default: 0
  },
  volatile: {
    type: "boolean",
    default: !1
  },
  "*": {
    type: "*"
  }
}, Bb = {
  type: {
    required: !0,
    type: "enum",
    values: {
      geojson: {}
    }
  },
  data: {
    required: !0,
    type: "*"
  },
  maxzoom: {
    type: "number",
    default: 18
  },
  attribution: {
    type: "string"
  },
  buffer: {
    type: "number",
    default: 128,
    maximum: 512,
    minimum: 0
  },
  filter: {
    type: "*"
  },
  tolerance: {
    type: "number",
    default: 0.375
  },
  cluster: {
    type: "boolean",
    default: !1
  },
  clusterRadius: {
    type: "number",
    default: 50,
    minimum: 0
  },
  clusterMaxZoom: {
    type: "number"
  },
  clusterMinPoints: {
    type: "number"
  },
  clusterProperties: {
    type: "*"
  },
  lineMetrics: {
    type: "boolean",
    default: !1
  },
  generateId: {
    type: "boolean",
    default: !1
  },
  promoteId: {
    type: "promoteId"
  }
}, Nb = {
  type: {
    required: !0,
    type: "enum",
    values: {
      video: {}
    }
  },
  urls: {
    required: !0,
    type: "array",
    value: "string"
  },
  coordinates: {
    required: !0,
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number"
    }
  }
}, jb = {
  type: {
    required: !0,
    type: "enum",
    values: {
      image: {}
    }
  },
  url: {
    required: !0,
    type: "string"
  },
  coordinates: {
    required: !0,
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number"
    }
  }
}, Ub = {
  id: {
    type: "string",
    required: !0
  },
  type: {
    type: "enum",
    values: {
      fill: {},
      line: {},
      symbol: {},
      circle: {},
      heatmap: {},
      "fill-extrusion": {},
      raster: {},
      hillshade: {},
      "color-relief": {},
      background: {}
    },
    required: !0
  },
  metadata: {
    type: "*"
  },
  source: {
    type: "string"
  },
  "source-layer": {
    type: "string"
  },
  minzoom: {
    type: "number",
    minimum: 0,
    maximum: 24
  },
  maxzoom: {
    type: "number",
    minimum: 0,
    maximum: 24
  },
  filter: {
    type: "filter"
  },
  layout: {
    type: "layout"
  },
  paint: {
    type: "paint"
  }
}, Fb = [
  "layout_fill",
  "layout_line",
  "layout_circle",
  "layout_heatmap",
  "layout_fill-extrusion",
  "layout_symbol",
  "layout_raster",
  "layout_hillshade",
  "layout_color-relief",
  "layout_background"
], Vb = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, qb = {
  "fill-sort-key": {
    type: "number",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, Gb = {
  "circle-sort-key": {
    type: "number",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, Zb = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, $b = {
  "line-cap": {
    type: "enum",
    values: {
      butt: {},
      round: {},
      square: {}
    },
    default: "butt",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-join": {
    type: "enum",
    values: {
      bevel: {},
      round: {},
      miter: {}
    },
    default: "miter",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "line-miter-limit": {
    type: "number",
    default: 2,
    requires: [
      {
        "line-join": "miter"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-round-limit": {
    type: "number",
    default: 1.05,
    requires: [
      {
        "line-join": "round"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-sort-key": {
    type: "number",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, Hb = {
  "symbol-placement": {
    type: "enum",
    values: {
      point: {},
      line: {},
      "line-center": {}
    },
    default: "point",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-spacing": {
    type: "number",
    default: 250,
    minimum: 1,
    units: "pixels",
    requires: [
      {
        "symbol-placement": "line"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-avoid-edges": {
    type: "boolean",
    default: !1,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-sort-key": {
    type: "number",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "symbol-z-order": {
    type: "enum",
    values: {
      auto: {},
      "viewport-y": {},
      source: {}
    },
    default: "auto",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-allow-overlap": {
    type: "boolean",
    default: !1,
    requires: [
      "icon-image",
      {
        "!": "icon-overlap"
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-overlap": {
    type: "enum",
    values: {
      never: {},
      always: {},
      cooperative: {}
    },
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-ignore-placement": {
    type: "boolean",
    default: !1,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-optional": {
    type: "boolean",
    default: !1,
    requires: [
      "icon-image",
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-rotation-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    default: "auto",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-size": {
    type: "number",
    default: 1,
    minimum: 0,
    units: "factor of the original icon size",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-text-fit": {
    type: "enum",
    values: {
      none: {},
      width: {},
      height: {},
      both: {}
    },
    default: "none",
    requires: [
      "icon-image",
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-text-fit-padding": {
    type: "array",
    value: "number",
    length: 4,
    default: [
      0,
      0,
      0,
      0
    ],
    units: "pixels",
    requires: [
      "icon-image",
      "text-field",
      {
        "icon-text-fit": [
          "both",
          "width",
          "height"
        ]
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-image": {
    type: "resolvedImage",
    tokens: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-rotate": {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-padding": {
    type: "padding",
    default: [
      2
    ],
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-keep-upright": {
    type: "boolean",
    default: !1,
    requires: [
      "icon-image",
      {
        "icon-rotation-alignment": "map"
      },
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-offset": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-anchor": {
    type: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    default: "center",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    default: "auto",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    default: "auto",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-rotation-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      "viewport-glyph": {},
      auto: {}
    },
    default: "auto",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-field": {
    type: "formatted",
    default: "",
    tokens: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-font": {
    type: "array",
    value: "string",
    default: [
      "Open Sans Regular",
      "Arial Unicode MS Regular"
    ],
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-size": {
    type: "number",
    default: 16,
    minimum: 0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-max-width": {
    type: "number",
    default: 10,
    minimum: 0,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-line-height": {
    type: "number",
    default: 1.2,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-letter-spacing": {
    type: "number",
    default: 0,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-justify": {
    type: "enum",
    values: {
      auto: {},
      left: {},
      center: {},
      right: {}
    },
    default: "center",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-radial-offset": {
    type: "number",
    units: "ems",
    default: 0,
    requires: [
      "text-field"
    ],
    "property-type": "data-driven",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    }
  },
  "text-variable-anchor": {
    type: "array",
    value: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-variable-anchor-offset": {
    type: "variableAnchorOffsetCollection",
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-anchor": {
    type: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    default: "center",
    requires: [
      "text-field",
      {
        "!": "text-variable-anchor"
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-max-angle": {
    type: "number",
    default: 45,
    units: "degrees",
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-writing-mode": {
    type: "array",
    value: "enum",
    values: {
      horizontal: {},
      vertical: {}
    },
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-rotate": {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-padding": {
    type: "number",
    default: 2,
    minimum: 0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-keep-upright": {
    type: "boolean",
    default: !0,
    requires: [
      "text-field",
      {
        "text-rotation-alignment": "map"
      },
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-transform": {
    type: "enum",
    values: {
      none: {},
      uppercase: {},
      lowercase: {}
    },
    default: "none",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-offset": {
    type: "array",
    value: "number",
    units: "ems",
    length: 2,
    default: [
      0,
      0
    ],
    requires: [
      "text-field",
      {
        "!": "text-radial-offset"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-allow-overlap": {
    type: "boolean",
    default: !1,
    requires: [
      "text-field",
      {
        "!": "text-overlap"
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-overlap": {
    type: "enum",
    values: {
      never: {},
      always: {},
      cooperative: {}
    },
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-ignore-placement": {
    type: "boolean",
    default: !1,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-optional": {
    type: "boolean",
    default: !1,
    requires: [
      "text-field",
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, Xb = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, Yb = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, Kb = {
  type: "array",
  value: "*"
}, Wb = {
  type: "enum",
  values: {
    "==": {},
    "!=": {},
    ">": {},
    ">=": {},
    "<": {},
    "<=": {},
    in: {},
    "!in": {},
    all: {},
    any: {},
    none: {},
    has: {},
    "!has": {}
  }
}, Jb = {
  type: "enum",
  values: {
    Point: {},
    LineString: {},
    Polygon: {}
  }
}, Qb = {
  type: "array",
  minimum: 0,
  maximum: 24,
  value: [
    "number",
    "color"
  ],
  length: 2
}, e2 = {
  type: "array",
  value: "*",
  minimum: 1
}, t2 = {
  anchor: {
    type: "enum",
    default: "viewport",
    values: {
      map: {},
      viewport: {}
    },
    "property-type": "data-constant",
    transition: !1,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    }
  },
  position: {
    type: "array",
    default: [
      1.15,
      210,
      30
    ],
    length: 3,
    value: "number",
    "property-type": "data-constant",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    }
  },
  color: {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  intensity: {
    type: "number",
    "property-type": "data-constant",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  }
}, i2 = {
  "sky-color": {
    type: "color",
    "property-type": "data-constant",
    default: "#88C6FC",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "horizon-color": {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "fog-color": {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "fog-ground-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "horizon-fog-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "sky-horizon-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "atmosphere-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  }
}, n2 = {
  source: {
    type: "string",
    required: !0
  },
  exaggeration: {
    type: "number",
    minimum: 0,
    default: 1
  }
}, a2 = {
  type: {
    type: "projectionDefinition",
    default: "mercator",
    "property-type": "data-constant",
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    }
  }
}, r2 = [
  "paint_fill",
  "paint_line",
  "paint_circle",
  "paint_heatmap",
  "paint_fill-extrusion",
  "paint_symbol",
  "paint_raster",
  "paint_hillshade",
  "paint_color-relief",
  "paint_background"
], s2 = {
  "fill-antialias": {
    type: "boolean",
    default: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    requires: [
      {
        "!": "fill-pattern"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-outline-color": {
    type: "color",
    transition: !0,
    requires: [
      {
        "!": "fill-pattern"
      },
      {
        "fill-antialias": !0
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "fill-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-pattern": {
    type: "resolvedImage",
    transition: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "cross-faded-data-driven"
  }
}, o2 = {
  "line-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    requires: [
      {
        "!": "line-pattern"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "line-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-width": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-gap-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-offset": {
    type: "number",
    default: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-dasharray": {
    type: "array",
    value: "number",
    minimum: 0,
    transition: !0,
    units: "line widths",
    requires: [
      {
        "!": "line-pattern"
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "cross-faded"
  },
  "line-pattern": {
    type: "resolvedImage",
    transition: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "cross-faded-data-driven"
  },
  "line-gradient": {
    type: "color",
    transition: !1,
    requires: [
      {
        "!": "line-dasharray"
      },
      {
        "!": "line-pattern"
      },
      {
        source: "geojson",
        has: {
          lineMetrics: !0
        }
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "line-progress"
      ]
    },
    "property-type": "color-ramp"
  }
}, l2 = {
  "circle-radius": {
    type: "number",
    default: 5,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-blur": {
    type: "number",
    default: 0,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "circle-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-scale": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "viewport",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-stroke-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  }
}, u2 = {
  "heatmap-radius": {
    type: "number",
    default: 30,
    minimum: 1,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "heatmap-weight": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "heatmap-intensity": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "heatmap-color": {
    type: "color",
    default: [
      "interpolate",
      [
        "linear"
      ],
      [
        "heatmap-density"
      ],
      0,
      "rgba(0, 0, 255, 0)",
      0.1,
      "royalblue",
      0.3,
      "cyan",
      0.5,
      "lime",
      0.7,
      "yellow",
      1,
      "red"
    ],
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "heatmap-density"
      ]
    },
    "property-type": "color-ramp"
  },
  "heatmap-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, c2 = {
  "icon-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-color": {
    type: "color",
    default: "rgba(0, 0, 0, 0)",
    transition: !0,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "icon-image",
      "icon-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    overridable: !0,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-color": {
    type: "color",
    default: "rgba(0, 0, 0, 0)",
    transition: !0,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "text-field",
      "text-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, h2 = {
  "raster-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-hue-rotate": {
    type: "number",
    default: 0,
    period: 360,
    transition: !0,
    units: "degrees",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-min": {
    type: "number",
    default: 0,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-max": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-saturation": {
    type: "number",
    default: 0,
    minimum: -1,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-contrast": {
    type: "number",
    default: 0,
    minimum: -1,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-resampling": {
    type: "enum",
    values: {
      linear: {},
      nearest: {}
    },
    default: "linear",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-fade-duration": {
    type: "number",
    default: 300,
    minimum: 0,
    transition: !1,
    units: "milliseconds",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, d2 = {
  "hillshade-illumination-direction": {
    type: "numberArray",
    default: 335,
    minimum: 0,
    maximum: 359,
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-illumination-altitude": {
    type: "numberArray",
    default: 45,
    minimum: 0,
    maximum: 90,
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-illumination-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "viewport",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-exaggeration": {
    type: "number",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-shadow-color": {
    type: "colorArray",
    default: "#000000",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-highlight-color": {
    type: "colorArray",
    default: "#FFFFFF",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-accent-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-method": {
    type: "enum",
    values: {
      standard: {},
      basic: {},
      combined: {},
      igor: {},
      multidirectional: {}
    },
    default: "standard",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, p2 = {
  "background-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    requires: [
      {
        "!": "background-pattern"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "background-pattern": {
    type: "resolvedImage",
    transition: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "cross-faded"
  },
  "background-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, f2 = {
  duration: {
    type: "number",
    default: 300,
    minimum: 0,
    units: "milliseconds"
  },
  delay: {
    type: "number",
    default: 0,
    minimum: 0,
    units: "milliseconds"
  }
}, m2 = {
  "*": {
    type: "string"
  }
}, g2 = {
  $version: Pb,
  $root: Ib,
  sources: kb,
  source: Rb,
  source_vector: Db,
  source_raster: Lb,
  source_raster_dem: Ob,
  source_geojson: Bb,
  source_video: Nb,
  source_image: jb,
  layer: Ub,
  layout: Fb,
  layout_background: Vb,
  layout_fill: qb,
  layout_circle: Gb,
  layout_heatmap: Zb,
  "layout_fill-extrusion": {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  },
  layout_line: $b,
  layout_symbol: Hb,
  layout_raster: Xb,
  layout_hillshade: Yb,
  "layout_color-relief": {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  },
  filter: Kb,
  filter_operator: Wb,
  geometry_type: Jb,
  function: {
    expression: {
      type: "expression"
    },
    stops: {
      type: "array",
      value: "function_stop"
    },
    base: {
      type: "number",
      default: 1,
      minimum: 0
    },
    property: {
      type: "string",
      default: "$zoom"
    },
    type: {
      type: "enum",
      values: {
        identity: {},
        exponential: {},
        interval: {},
        categorical: {}
      },
      default: "exponential"
    },
    colorSpace: {
      type: "enum",
      values: {
        rgb: {},
        lab: {},
        hcl: {}
      },
      default: "rgb"
    },
    default: {
      type: "*",
      required: !1
    }
  },
  function_stop: Qb,
  expression: e2,
  light: t2,
  sky: i2,
  terrain: n2,
  projection: a2,
  paint: r2,
  paint_fill: s2,
  "paint_fill-extrusion": {
    "fill-extrusion-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-color": {
      type: "color",
      default: "#000000",
      transition: !0,
      requires: [
        {
          "!": "fill-extrusion-pattern"
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-translate": {
      type: "array",
      value: "number",
      length: 2,
      default: [
        0,
        0
      ],
      transition: !0,
      units: "pixels",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-translate-anchor": {
      type: "enum",
      values: {
        map: {},
        viewport: {}
      },
      default: "map",
      requires: [
        "fill-extrusion-translate"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-pattern": {
      type: "resolvedImage",
      transition: !0,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "cross-faded-data-driven"
    },
    "fill-extrusion-height": {
      type: "number",
      default: 0,
      minimum: 0,
      units: "meters",
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-base": {
      type: "number",
      default: 0,
      minimum: 0,
      units: "meters",
      transition: !0,
      requires: [
        "fill-extrusion-height"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-vertical-gradient": {
      type: "boolean",
      default: !0,
      transition: !1,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    }
  },
  paint_line: o2,
  paint_circle: l2,
  paint_heatmap: u2,
  paint_symbol: c2,
  paint_raster: h2,
  paint_hillshade: d2,
  "paint_color-relief": {
    "color-relief-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "color-relief-color": {
      type: "color",
      transition: !1,
      expression: {
        interpolated: !0,
        parameters: [
          "elevation"
        ]
      },
      "property-type": "color-ramp"
    }
  },
  paint_background: p2,
  transition: f2,
  "property-type": {
    "data-driven": {
      type: "property-type"
    },
    "cross-faded": {
      type: "property-type"
    },
    "cross-faded-data-driven": {
      type: "property-type"
    },
    "color-ramp": {
      type: "property-type"
    },
    "data-constant": {
      type: "property-type"
    },
    constant: {
      type: "property-type"
    }
  },
  promoteId: m2
};
class _t {
  constructor(o, m, b, M) {
    this.message = (o ? `${o}: ` : "") + b, M && (this.identifier = M), m != null && m.__line__ && (this.line = m.__line__);
  }
}
function Zg(d, ...o) {
  for (const m of o)
    for (const b in m)
      d[b] = m[b];
  return d;
}
class Au extends Error {
  constructor(o, m) {
    super(m), this.message = m, this.key = o;
  }
}
class N_ {
  constructor(o, m = []) {
    this.parent = o, this.bindings = {};
    for (const [b, M] of m)
      this.bindings[b] = M;
  }
  concat(o) {
    return new N_(this, o);
  }
  get(o) {
    if (this.bindings[o])
      return this.bindings[o];
    if (this.parent)
      return this.parent.get(o);
    throw new Error(`${o} not found in scope.`);
  }
  has(o) {
    return this.bindings[o] ? !0 : this.parent ? this.parent.has(o) : !1;
  }
}
const ny = { kind: "null" }, bt = { kind: "number" }, Ei = { kind: "string" }, vi = { kind: "boolean" }, Cu = { kind: "color" }, ay = { kind: "projectionDefinition" }, Rd = { kind: "object" }, yi = { kind: "value" }, y2 = { kind: "error" }, ry = { kind: "collator" }, sy = { kind: "formatted" }, oy = { kind: "padding" }, Sm = { kind: "colorArray" }, ly = { kind: "numberArray" }, Dm = { kind: "resolvedImage" }, uy = { kind: "variableAnchorOffsetCollection" };
function lo(d, o) {
  return {
    kind: "array",
    itemType: d,
    N: o
  };
}
function Xn(d) {
  if (d.kind === "array") {
    const o = Xn(d.itemType);
    return typeof d.N == "number" ? `array<${o}, ${d.N}>` : d.itemType.kind === "value" ? "array" : `array<${o}>`;
  } else
    return d.kind;
}
const _2 = [
  ny,
  bt,
  Ei,
  vi,
  Cu,
  ay,
  sy,
  Rd,
  lo(yi),
  oy,
  ly,
  Sm,
  Dm,
  uy
];
function Tm(d, o) {
  if (o.kind === "error")
    return null;
  if (d.kind === "array") {
    if (o.kind === "array" && (o.N === 0 && o.itemType.kind === "value" || !Tm(d.itemType, o.itemType)) && (typeof d.N != "number" || d.N === o.N))
      return null;
  } else {
    if (d.kind === o.kind)
      return null;
    if (d.kind === "value") {
      for (const m of _2)
        if (!Tm(m, o))
          return null;
    }
  }
  return `Expected ${Xn(d)} but found ${Xn(o)} instead.`;
}
function j_(d, o) {
  return o.some((m) => m.kind === d.kind);
}
function Dd(d, o) {
  return o.some((m) => m === "null" ? d === null : m === "array" ? Array.isArray(d) : m === "object" ? d && !Array.isArray(d) && typeof d == "object" : m === typeof d);
}
function bh(d, o) {
  return d.kind === "array" && o.kind === "array" ? d.itemType.kind === o.itemType.kind && typeof d.N == "number" : d.kind === o.kind;
}
const ex = 0.96422, tx = 1, ix = 0.82521, nx = 4 / 29, Kp = 6 / 29, ax = 3 * Kp * Kp, v2 = Kp * Kp * Kp, x2 = Math.PI / 180, b2 = 180 / Math.PI;
function rx(d) {
  return d = d % 360, d < 0 && (d += 360), d;
}
function sx([d, o, m, b]) {
  d = Qy(d), o = Qy(o), m = Qy(m);
  let M, z;
  const S = e_((0.2225045 * d + 0.7168786 * o + 0.0606169 * m) / tx);
  d === o && o === m ? M = z = S : (M = e_((0.4360747 * d + 0.3850649 * o + 0.1430804 * m) / ex), z = e_((0.0139322 * d + 0.0971045 * o + 0.7141733 * m) / ix));
  const u = 116 * S - 16;
  return [u < 0 ? 0 : u, 500 * (M - S), 200 * (S - z), b];
}
function Qy(d) {
  return d <= 0.04045 ? d / 12.92 : Math.pow((d + 0.055) / 1.055, 2.4);
}
function e_(d) {
  return d > v2 ? Math.pow(d, 1 / 3) : d / ax + nx;
}
function ox([d, o, m, b]) {
  let M = (d + 16) / 116, z = isNaN(o) ? M : M + o / 500, S = isNaN(m) ? M : M - m / 200;
  return M = tx * i_(M), z = ex * i_(z), S = ix * i_(S), [
    t_(3.1338561 * z - 1.6168667 * M - 0.4906146 * S),
    // D50 -> sRGB
    t_(-0.9787684 * z + 1.9161415 * M + 0.033454 * S),
    t_(0.0719453 * z - 0.2289914 * M + 1.4052427 * S),
    b
  ];
}
function t_(d) {
  return d = d <= 304e-5 ? 12.92 * d : 1.055 * Math.pow(d, 1 / 2.4) - 0.055, d < 0 ? 0 : d > 1 ? 1 : d;
}
function i_(d) {
  return d > Kp ? d * d * d : ax * (d - nx);
}
function w2(d) {
  const [o, m, b, M] = sx(d), z = Math.sqrt(m * m + b * b);
  return [Math.round(z * 1e4) ? rx(Math.atan2(b, m) * b2) : NaN, z, o, M];
}
function S2([d, o, m, b]) {
  return d = isNaN(d) ? 0 : d * x2, ox([m, Math.cos(d) * o, Math.sin(d) * o, b]);
}
function T2([d, o, m, b]) {
  d = rx(d), o /= 100, m /= 100;
  function M(z) {
    const S = (z + d / 30) % 12, u = o * Math.min(m, 1 - m);
    return m - u * Math.max(-1, Math.min(S - 3, 9 - S, 1));
  }
  return [M(0), M(8), M(4), b];
}
const M2 = Object.hasOwn || function(d, o) {
  return Object.prototype.hasOwnProperty.call(d, o);
};
function vm(d, o) {
  return M2(d, o) ? d[o] : void 0;
}
function A2(d) {
  if (d = d.toLowerCase().trim(), d === "transparent")
    return [0, 0, 0, 0];
  const o = vm(E2, d);
  if (o) {
    const [M, z, S] = o;
    return [M / 255, z / 255, S / 255, 1];
  }
  if (d.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(d)) {
    const M = d.length < 6 ? 1 : 2;
    let z = 1;
    return [
      Ig(d.slice(z, z += M)),
      Ig(d.slice(z, z += M)),
      Ig(d.slice(z, z += M)),
      Ig(d.slice(z, z + M) || "ff")
    ];
  }
  if (d.startsWith("rgb")) {
    const M = /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, z = d.match(M);
    if (z) {
      const [
        S,
        // eslint-disable-line @typescript-eslint/no-unused-vars
        u,
        // <numeric>
        O,
        // %         (optional)
        U,
        // ,         (optional)
        K,
        // <numeric>
        ae,
        // %         (optional)
        he,
        // ,         (optional)
        J,
        // <numeric>
        ke,
        // %         (optional)
        qe,
        // ,|/       (optional)
        ft,
        // <numeric> (optional)
        ht
        // %         (optional)
      ] = z, it = [U || " ", he || " ", qe].join("");
      if (it === "  " || it === "  /" || it === ",," || it === ",,,") {
        const nt = [O, ae, ke].join(""), De = nt === "%%%" ? 100 : nt === "" ? 255 : 0;
        if (De) {
          const Re = [
            $p(+u / De, 0, 1),
            $p(+K / De, 0, 1),
            $p(+J / De, 0, 1),
            ft ? G0(+ft, ht) : 1
          ];
          if (Z0(Re))
            return Re;
        }
      }
      return;
    }
  }
  const m = /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, b = d.match(m);
  if (b) {
    const [
      M,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      z,
      // <numeric>
      S,
      // ,         (optional)
      u,
      // <numeric>
      O,
      // ,         (optional)
      U,
      // <numeric>
      K,
      // ,|/       (optional)
      ae,
      // <numeric> (optional)
      he
      // %         (optional)
    ] = b, J = [S || " ", O || " ", K].join("");
    if (J === "  " || J === "  /" || J === ",," || J === ",,,") {
      const ke = [
        +z,
        $p(+u, 0, 100),
        $p(+U, 0, 100),
        ae ? G0(+ae, he) : 1
      ];
      if (Z0(ke))
        return T2(ke);
    }
  }
}
function Ig(d) {
  return parseInt(d.padEnd(2, d), 16) / 255;
}
function G0(d, o) {
  return $p(o ? d / 100 : d, 0, 1);
}
function $p(d, o, m) {
  return Math.min(Math.max(o, d), m);
}
function Z0(d) {
  return !d.some(Number.isNaN);
}
const E2 = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
function Ld(d, o, m) {
  return d + m * (o - d);
}
function Mm(d, o, m) {
  return d.map((b, M) => Ld(b, o[M], m));
}
class on {
  /**
   * @param r Red component premultiplied by `alpha` 0..1
   * @param g Green component premultiplied by `alpha` 0..1
   * @param b Blue component premultiplied by `alpha` 0..1
   * @param [alpha=1] Alpha component 0..1
   * @param [premultiplied=true] Whether the `r`, `g` and `b` values have already
   * been multiplied by alpha. If `true` nothing happens if `false` then they will
   * be multiplied automatically.
   */
  constructor(o, m, b, M = 1, z = !0) {
    this.r = o, this.g = m, this.b = b, this.a = M, z || (this.r *= M, this.g *= M, this.b *= M, M || this.overwriteGetter("rgb", [o, m, b, M]));
  }
  /**
   * Parses CSS color strings and converts colors to sRGB color space if needed.
   * Officially supported color formats:
   * - keyword, e.g. 'aquamarine' or 'steelblue'
   * - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'
   * - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'
   * - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'
   *
   * @param input CSS color string to parse.
   * @returns A `Color` instance, or `undefined` if the input is not a valid color string.
   */
  static parse(o) {
    if (o instanceof on)
      return o;
    if (typeof o != "string")
      return;
    const m = A2(o);
    if (m)
      return new on(...m, !1);
  }
  /**
   * Used in color interpolation and by 'to-rgba' expression.
   *
   * @returns Gien color, with reversed alpha blending, in sRGB color space.
   */
  get rgb() {
    const { r: o, g: m, b, a: M } = this, z = M || 1 / 0;
    return this.overwriteGetter("rgb", [o / z, m / z, b / z, M]);
  }
  /**
   * Used in color interpolation.
   *
   * @returns Gien color, with reversed alpha blending, in HCL color space.
   */
  get hcl() {
    return this.overwriteGetter("hcl", w2(this.rgb));
  }
  /**
   * Used in color interpolation.
   *
   * @returns Gien color, with reversed alpha blending, in LAB color space.
   */
  get lab() {
    return this.overwriteGetter("lab", sx(this.rgb));
  }
  /**
   * Lazy getter pattern. When getter is called for the first time lazy value
   * is calculated and then overwrites getter function in given object instance.
   *
   * @example:
   * const redColor = Color.parse('red');
   * let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate
   * // the value of red in HCL space and invoke this `overwriteGetter` function
   * // which in turn will set a field with a key 'hcl' in the `redColor` object.
   * // In other words it will override `get hcl()` from its `Color` prototype
   * // with its own property: hcl = [calculated red value in hcl].
   * let y = redColor.hcl; // next call will no longer invoke getter but simply
   * // return the previously calculated value
   * x === y; // true - `x` is exactly the same object as `y`
   *
   * @param getterKey Getter key
   * @param lazyValue Lazily calculated value to be memoized by current instance
   * @private
   */
  overwriteGetter(o, m) {
    return Object.defineProperty(this, o, { value: m }), m;
  }
  /**
   * Used by 'to-string' expression.
   *
   * @returns Serialized color in format `rgba(r,g,b,a)`
   * where r,g,b are numbers within 0..255 and alpha is number within 1..0
   *
   * @example
   * var purple = new Color.parse('purple');
   * purple.toString; // = "rgba(128,0,128,1)"
   * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
   * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
   */
  toString() {
    const [o, m, b, M] = this.rgb;
    return `rgba(${[o, m, b].map((z) => Math.round(z * 255)).join(",")},${M})`;
  }
  static interpolate(o, m, b, M = "rgb") {
    switch (M) {
      case "rgb": {
        const [z, S, u, O] = Mm(o.rgb, m.rgb, b);
        return new on(z, S, u, O, !1);
      }
      case "hcl": {
        const [z, S, u, O] = o.hcl, [U, K, ae, he] = m.hcl;
        let J, ke;
        if (!isNaN(z) && !isNaN(U)) {
          let nt = U - z;
          U > z && nt > 180 ? nt -= 360 : U < z && z - U > 180 && (nt += 360), J = z + b * nt;
        } else isNaN(z) ? isNaN(U) ? J = NaN : (J = U, (u === 1 || u === 0) && (ke = K)) : (J = z, (ae === 1 || ae === 0) && (ke = S));
        const [qe, ft, ht, it] = S2([
          J,
          ke ?? Ld(S, K, b),
          Ld(u, ae, b),
          Ld(O, he, b)
        ]);
        return new on(qe, ft, ht, it, !1);
      }
      case "lab": {
        const [z, S, u, O] = ox(Mm(o.lab, m.lab, b));
        return new on(z, S, u, O, !1);
      }
    }
  }
}
on.black = new on(0, 0, 0, 1);
on.white = new on(1, 1, 1, 1);
on.transparent = new on(0, 0, 0, 0);
on.red = new on(1, 0, 0, 1);
class U_ {
  constructor(o, m, b) {
    o ? this.sensitivity = m ? "variant" : "case" : this.sensitivity = m ? "accent" : "base", this.locale = b, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
  }
  compare(o, m) {
    return this.collator.compare(o, m);
  }
  resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
  }
}
const C2 = ["bottom", "center", "top"];
class w_ {
  constructor(o, m, b, M, z, S) {
    this.text = o, this.image = m, this.scale = b, this.fontStack = M, this.textColor = z, this.verticalAlign = S;
  }
}
class Pc {
  constructor(o) {
    this.sections = o;
  }
  static fromString(o) {
    return new Pc([new w_(o, null, null, null, null, null)]);
  }
  isEmpty() {
    return this.sections.length === 0 ? !0 : !this.sections.some((o) => o.text.length !== 0 || o.image && o.image.name.length !== 0);
  }
  static factory(o) {
    return o instanceof Pc ? o : Pc.fromString(o);
  }
  toString() {
    return this.sections.length === 0 ? "" : this.sections.map((o) => o.text).join("");
  }
}
class Ol {
  constructor(o) {
    this.values = o.slice();
  }
  /**
   * Numeric padding values
   * @param input A padding value
   * @returns A `Padding` instance, or `undefined` if the input is not a valid padding value.
   */
  static parse(o) {
    if (o instanceof Ol)
      return o;
    if (typeof o == "number")
      return new Ol([o, o, o, o]);
    if (Array.isArray(o) && !(o.length < 1 || o.length > 4)) {
      for (const m of o)
        if (typeof m != "number")
          return;
      switch (o.length) {
        case 1:
          o = [o[0], o[0], o[0], o[0]];
          break;
        case 2:
          o = [o[0], o[1], o[0], o[1]];
          break;
        case 3:
          o = [o[0], o[1], o[2], o[1]];
          break;
      }
      return new Ol(o);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(o, m, b) {
    return new Ol(Mm(o.values, m.values, b));
  }
}
class Bl {
  constructor(o) {
    this.values = o.slice();
  }
  /**
   * Numeric NumberArray values
   * @param input A NumberArray value
   * @returns A `NumberArray` instance, or `undefined` if the input is not a valid NumberArray value.
   */
  static parse(o) {
    if (o instanceof Bl)
      return o;
    if (typeof o == "number")
      return new Bl([o]);
    if (Array.isArray(o)) {
      for (const m of o)
        if (typeof m != "number")
          return;
      return new Bl(o);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(o, m, b) {
    return new Bl(Mm(o.values, m.values, b));
  }
}
class uo {
  constructor(o) {
    this.values = o.slice();
  }
  /**
   * ColorArray values
   * @param input A ColorArray value
   * @returns A `ColorArray` instance, or `undefined` if the input is not a valid ColorArray value.
   */
  static parse(o) {
    if (o instanceof uo)
      return o;
    if (typeof o == "string") {
      const b = on.parse(o);
      return b ? new uo([b]) : void 0;
    }
    if (!Array.isArray(o))
      return;
    const m = [];
    for (const b of o) {
      if (typeof b != "string")
        return;
      const M = on.parse(b);
      if (!M)
        return;
      m.push(M);
    }
    return new uo(m);
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(o, m, b, M = "rgb") {
    const z = [];
    if (o.values.length != m.values.length)
      throw new Error(`colorArray: Arrays have mismatched length (${o.values.length} vs. ${m.values.length}), cannot interpolate.`);
    for (let S = 0; S < o.values.length; S++)
      z.push(on.interpolate(o.values[S], m.values[S], b, M));
    return new uo(z);
  }
}
class sa extends Error {
  constructor(o) {
    super(o), this.name = "RuntimeError";
  }
  toJSON() {
    return this.message;
  }
}
const z2 = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
class zu {
  constructor(o) {
    this.values = o.slice();
  }
  static parse(o) {
    if (o instanceof zu)
      return o;
    if (!(!Array.isArray(o) || o.length < 1 || o.length % 2 !== 0)) {
      for (let m = 0; m < o.length; m += 2) {
        const b = o[m], M = o[m + 1];
        if (typeof b != "string" || !z2.has(b) || !Array.isArray(M) || M.length !== 2 || typeof M[0] != "number" || typeof M[1] != "number")
          return;
      }
      return new zu(o);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(o, m, b) {
    const M = o.values, z = m.values;
    if (M.length !== z.length)
      throw new sa(`Cannot interpolate values of different length. from: ${o.toString()}, to: ${m.toString()}`);
    const S = [];
    for (let u = 0; u < M.length; u += 2) {
      if (M[u] !== z[u])
        throw new sa(`Cannot interpolate values containing mismatched anchors. from[${u}]: ${M[u]}, to[${u}]: ${z[u]}`);
      S.push(M[u]);
      const [O, U] = M[u + 1], [K, ae] = z[u + 1];
      S.push([Ld(O, K, b), Ld(U, ae, b)]);
    }
    return new zu(S);
  }
}
class Th {
  constructor(o) {
    this.name = o.name, this.available = o.available;
  }
  toString() {
    return this.name;
  }
  static fromString(o) {
    return o ? new Th({ name: o, available: !1 }) : null;
  }
}
class Dl {
  constructor(o, m, b) {
    this.from = o, this.to = m, this.transition = b;
  }
  static interpolate(o, m, b) {
    return new Dl(o, m, b);
  }
  static parse(o) {
    if (o instanceof Dl)
      return o;
    if (Array.isArray(o) && o.length === 3 && typeof o[0] == "string" && typeof o[1] == "string" && typeof o[2] == "number")
      return new Dl(o[0], o[1], o[2]);
    if (typeof o == "object" && typeof o.from == "string" && typeof o.to == "string" && typeof o.transition == "number")
      return new Dl(o.from, o.to, o.transition);
    if (typeof o == "string")
      return new Dl(o, o, 1);
  }
}
function lx(d, o, m, b) {
  return typeof d == "number" && d >= 0 && d <= 255 && typeof o == "number" && o >= 0 && o <= 255 && typeof m == "number" && m >= 0 && m <= 255 ? typeof b > "u" || typeof b == "number" && b >= 0 && b <= 1 ? null : `Invalid rgba value [${[d, o, m, b].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof b == "number" ? [d, o, m, b] : [d, o, m]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
}
function Am(d) {
  if (d === null || typeof d == "string" || typeof d == "boolean" || typeof d == "number" || d instanceof Dl || d instanceof on || d instanceof U_ || d instanceof Pc || d instanceof Ol || d instanceof Bl || d instanceof uo || d instanceof zu || d instanceof Th)
    return !0;
  if (Array.isArray(d)) {
    for (const o of d)
      if (!Am(o))
        return !1;
    return !0;
  } else if (typeof d == "object") {
    for (const o in d)
      if (!Am(d[o]))
        return !1;
    return !0;
  } else
    return !1;
}
function Oa(d) {
  if (d === null)
    return ny;
  if (typeof d == "string")
    return Ei;
  if (typeof d == "boolean")
    return vi;
  if (typeof d == "number")
    return bt;
  if (d instanceof on)
    return Cu;
  if (d instanceof Dl)
    return ay;
  if (d instanceof U_)
    return ry;
  if (d instanceof Pc)
    return sy;
  if (d instanceof Ol)
    return oy;
  if (d instanceof Bl)
    return ly;
  if (d instanceof uo)
    return Sm;
  if (d instanceof zu)
    return uy;
  if (d instanceof Th)
    return Dm;
  if (Array.isArray(d)) {
    const o = d.length;
    let m;
    for (const b of d) {
      const M = Oa(b);
      if (!m)
        m = M;
      else {
        if (m === M)
          continue;
        m = yi;
        break;
      }
    }
    return lo(m || yi, o);
  } else
    return Rd;
}
function xm(d) {
  const o = typeof d;
  return d === null ? "" : o === "string" || o === "number" || o === "boolean" ? String(d) : d instanceof on || d instanceof Dl || d instanceof Pc || d instanceof Ol || d instanceof Bl || d instanceof uo || d instanceof zu || d instanceof Th ? d.toString() : JSON.stringify(d);
}
class Wp {
  constructor(o, m) {
    this.type = o, this.value = m;
  }
  static parse(o, m) {
    if (o.length !== 2)
      return m.error(`'literal' expression requires exactly one argument, but found ${o.length - 1} instead.`);
    if (!Am(o[1]))
      return m.error("invalid value");
    const b = o[1];
    let M = Oa(b);
    const z = m.expectedType;
    return M.kind === "array" && M.N === 0 && z && z.kind === "array" && (typeof z.N != "number" || z.N === 0) && (M = z), new Wp(M, b);
  }
  evaluate() {
    return this.value;
  }
  eachChild() {
  }
  outputDefined() {
    return !0;
  }
}
const kg = {
  string: Ei,
  number: bt,
  boolean: vi,
  object: Rd
};
class Ll {
  constructor(o, m) {
    this.type = o, this.args = m;
  }
  static parse(o, m) {
    if (o.length < 2)
      return m.error("Expected at least one argument.");
    let b = 1, M;
    const z = o[0];
    if (z === "array") {
      let u;
      if (o.length > 2) {
        const U = o[1];
        if (typeof U != "string" || !(U in kg) || U === "object")
          return m.error('The item type argument of "array" must be one of string, number, boolean', 1);
        u = kg[U], b++;
      } else
        u = yi;
      let O;
      if (o.length > 3) {
        if (o[2] !== null && (typeof o[2] != "number" || o[2] < 0 || o[2] !== Math.floor(o[2])))
          return m.error('The length argument to "array" must be a positive integer literal', 2);
        O = o[2], b++;
      }
      M = lo(u, O);
    } else {
      if (!kg[z])
        throw new Error(`Types doesn't contain name = ${z}`);
      M = kg[z];
    }
    const S = [];
    for (; b < o.length; b++) {
      const u = m.parse(o[b], b, yi);
      if (!u)
        return null;
      S.push(u);
    }
    return new Ll(M, S);
  }
  evaluate(o) {
    for (let m = 0; m < this.args.length; m++) {
      const b = this.args[m].evaluate(o);
      if (Tm(this.type, Oa(b))) {
        if (m === this.args.length - 1)
          throw new sa(`Expected value to be of type ${Xn(this.type)}, but found ${Xn(Oa(b))} instead.`);
      } else return b;
    }
    throw new Error();
  }
  eachChild(o) {
    this.args.forEach(o);
  }
  outputDefined() {
    return this.args.every((o) => o.outputDefined());
  }
}
const $0 = {
  "to-boolean": vi,
  "to-color": Cu,
  "to-number": bt,
  "to-string": Ei
};
class wh {
  constructor(o, m) {
    this.type = o, this.args = m;
  }
  static parse(o, m) {
    if (o.length < 2)
      return m.error("Expected at least one argument.");
    const b = o[0];
    if (!$0[b])
      throw new Error(`Can't parse ${b} as it is not part of the known types`);
    if ((b === "to-boolean" || b === "to-string") && o.length !== 2)
      return m.error("Expected one argument.");
    const M = $0[b], z = [];
    for (let S = 1; S < o.length; S++) {
      const u = m.parse(o[S], S, yi);
      if (!u)
        return null;
      z.push(u);
    }
    return new wh(M, z);
  }
  evaluate(o) {
    switch (this.type.kind) {
      case "boolean":
        return !!this.args[0].evaluate(o);
      case "color": {
        let m, b;
        for (const M of this.args) {
          if (m = M.evaluate(o), b = null, m instanceof on)
            return m;
          if (typeof m == "string") {
            const z = o.parseColor(m);
            if (z)
              return z;
          } else if (Array.isArray(m) && (m.length < 3 || m.length > 4 ? b = `Invalid rgba value ${JSON.stringify(m)}: expected an array containing either three or four numeric values.` : b = lx(m[0], m[1], m[2], m[3]), !b))
            return new on(m[0] / 255, m[1] / 255, m[2] / 255, m[3]);
        }
        throw new sa(b || `Could not parse color from value '${typeof m == "string" ? m : JSON.stringify(m)}'`);
      }
      case "padding": {
        let m;
        for (const b of this.args) {
          m = b.evaluate(o);
          const M = Ol.parse(m);
          if (M)
            return M;
        }
        throw new sa(`Could not parse padding from value '${typeof m == "string" ? m : JSON.stringify(m)}'`);
      }
      case "numberArray": {
        let m;
        for (const b of this.args) {
          m = b.evaluate(o);
          const M = Bl.parse(m);
          if (M)
            return M;
        }
        throw new sa(`Could not parse numberArray from value '${typeof m == "string" ? m : JSON.stringify(m)}'`);
      }
      case "colorArray": {
        let m;
        for (const b of this.args) {
          m = b.evaluate(o);
          const M = uo.parse(m);
          if (M)
            return M;
        }
        throw new sa(`Could not parse colorArray from value '${typeof m == "string" ? m : JSON.stringify(m)}'`);
      }
      case "variableAnchorOffsetCollection": {
        let m;
        for (const b of this.args) {
          m = b.evaluate(o);
          const M = zu.parse(m);
          if (M)
            return M;
        }
        throw new sa(`Could not parse variableAnchorOffsetCollection from value '${typeof m == "string" ? m : JSON.stringify(m)}'`);
      }
      case "number": {
        let m = null;
        for (const b of this.args) {
          if (m = b.evaluate(o), m === null)
            return 0;
          const M = Number(m);
          if (!isNaN(M))
            return M;
        }
        throw new sa(`Could not convert ${JSON.stringify(m)} to number.`);
      }
      case "formatted":
        return Pc.fromString(xm(this.args[0].evaluate(o)));
      case "resolvedImage":
        return Th.fromString(xm(this.args[0].evaluate(o)));
      case "projectionDefinition":
        return this.args[0].evaluate(o);
      default:
        return xm(this.args[0].evaluate(o));
    }
  }
  eachChild(o) {
    this.args.forEach(o);
  }
  outputDefined() {
    return this.args.every((o) => o.outputDefined());
  }
}
const P2 = ["Unknown", "Point", "LineString", "Polygon"];
class ux {
  constructor() {
    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
  }
  id() {
    return this.feature && "id" in this.feature ? this.feature.id : null;
  }
  geometryType() {
    return this.feature ? typeof this.feature.type == "number" ? P2[this.feature.type] : this.feature.type : null;
  }
  geometry() {
    return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
  }
  canonicalID() {
    return this.canonical;
  }
  properties() {
    return this.feature && this.feature.properties || {};
  }
  parseColor(o) {
    let m = this._parseColorCache.get(o);
    return m || (m = on.parse(o), this._parseColorCache.set(o, m)), m;
  }
}
class cy {
  constructor(o, m, b = [], M, z = new N_(), S = []) {
    this.registry = o, this.path = b, this.key = b.map((u) => `[${u}]`).join(""), this.scope = z, this.errors = S, this.expectedType = M, this._isConstant = m;
  }
  /**
   * @param expr the JSON expression to parse
   * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
   * @param options
   * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
   * @private
   */
  parse(o, m, b, M, z = {}) {
    return m ? this.concat(m, b, M)._parse(o, z) : this._parse(o, z);
  }
  _parse(o, m) {
    (o === null || typeof o == "string" || typeof o == "boolean" || typeof o == "number") && (o = ["literal", o]);
    function b(M, z, S) {
      return S === "assert" ? new Ll(z, [M]) : S === "coerce" ? new wh(z, [M]) : M;
    }
    if (Array.isArray(o)) {
      if (o.length === 0)
        return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
      const M = o[0];
      if (typeof M != "string")
        return this.error(`Expression name must be a string, but found ${typeof M} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
      const z = this.registry[M];
      if (z) {
        let S = z.parse(o, this);
        if (!S)
          return null;
        if (this.expectedType) {
          const u = this.expectedType, O = S.type;
          if ((u.kind === "string" || u.kind === "number" || u.kind === "boolean" || u.kind === "object" || u.kind === "array") && O.kind === "value")
            S = b(S, u, m.typeAnnotation || "assert");
          else if (u.kind === "projectionDefinition" && ["string", "array"].includes(O.kind) || ["color", "formatted", "resolvedImage"].includes(u.kind) && ["value", "string"].includes(O.kind) || ["padding", "numberArray"].includes(u.kind) && ["value", "number", "array"].includes(O.kind) || u.kind === "colorArray" && ["value", "string", "array"].includes(O.kind) || u.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(O.kind))
            S = b(S, u, m.typeAnnotation || "coerce");
          else if (this.checkSubtype(u, O))
            return null;
        }
        if (!(S instanceof Wp) && S.type.kind !== "resolvedImage" && this._isConstant(S)) {
          const u = new ux();
          try {
            S = new Wp(S.type, S.evaluate(u));
          } catch (O) {
            return this.error(O.message), null;
          }
        }
        return S;
      }
      return this.error(`Unknown expression "${M}". If you wanted a literal array, use ["literal", [...]].`, 0);
    } else return typeof o > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof o == "object" ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error(`Expected an array, but found ${typeof o} instead.`);
  }
  /**
   * Returns a copy of this context suitable for parsing the subexpression at
   * index `index`, optionally appending to 'let' binding map.
   *
   * Note that `errors` property, intended for collecting errors while
   * parsing, is copied by reference rather than cloned.
   * @private
   */
  concat(o, m, b) {
    const M = typeof o == "number" ? this.path.concat(o) : this.path, z = b ? this.scope.concat(b) : this.scope;
    return new cy(this.registry, this._isConstant, M, m || null, z, this.errors);
  }
  /**
   * Push a parsing (or type checking) error into the `this.errors`
   * @param error The message
   * @param keys Optionally specify the source of the error at a child
   * of the current expression at `this.key`.
   * @private
   */
  error(o, ...m) {
    const b = `${this.key}${m.map((M) => `[${M}]`).join("")}`;
    this.errors.push(new Au(b, o));
  }
  /**
   * Returns null if `t` is a subtype of `expected`; otherwise returns an
   * error message and also pushes it to `this.errors`.
   * @param expected The expected type
   * @param t The actual type
   * @returns null if `t` is a subtype of `expected`; otherwise returns an error message
   */
  checkSubtype(o, m) {
    const b = Tm(o, m);
    return b && this.error(b), b;
  }
}
class hy {
  constructor(o, m) {
    this.type = m.type, this.bindings = [].concat(o), this.result = m;
  }
  evaluate(o) {
    return this.result.evaluate(o);
  }
  eachChild(o) {
    for (const m of this.bindings)
      o(m[1]);
    o(this.result);
  }
  static parse(o, m) {
    if (o.length < 4)
      return m.error(`Expected at least 3 arguments, but found ${o.length - 1} instead.`);
    const b = [];
    for (let z = 1; z < o.length - 1; z += 2) {
      const S = o[z];
      if (typeof S != "string")
        return m.error(`Expected string, but found ${typeof S} instead.`, z);
      if (/[^a-zA-Z0-9_]/.test(S))
        return m.error("Variable names must contain only alphanumeric characters or '_'.", z);
      const u = m.parse(o[z + 1], z + 1);
      if (!u)
        return null;
      b.push([S, u]);
    }
    const M = m.parse(o[o.length - 1], o.length - 1, m.expectedType, b);
    return M ? new hy(b, M) : null;
  }
  outputDefined() {
    return this.result.outputDefined();
  }
}
class dy {
  constructor(o, m) {
    this.type = m.type, this.name = o, this.boundExpression = m;
  }
  static parse(o, m) {
    if (o.length !== 2 || typeof o[1] != "string")
      return m.error("'var' expression requires exactly one string literal argument.");
    const b = o[1];
    return m.scope.has(b) ? new dy(b, m.scope.get(b)) : m.error(`Unknown variable "${b}". Make sure "${b}" has been bound in an enclosing "let" expression before using it.`, 1);
  }
  evaluate(o) {
    return this.boundExpression.evaluate(o);
  }
  eachChild() {
  }
  outputDefined() {
    return !1;
  }
}
class F_ {
  constructor(o, m, b) {
    this.type = o, this.index = m, this.input = b;
  }
  static parse(o, m) {
    if (o.length !== 3)
      return m.error(`Expected 2 arguments, but found ${o.length - 1} instead.`);
    const b = m.parse(o[1], 1, bt), M = m.parse(o[2], 2, lo(m.expectedType || yi));
    if (!b || !M)
      return null;
    const z = M.type;
    return new F_(z.itemType, b, M);
  }
  evaluate(o) {
    const m = this.index.evaluate(o), b = this.input.evaluate(o);
    if (m < 0)
      throw new sa(`Array index out of bounds: ${m} < 0.`);
    if (m >= b.length)
      throw new sa(`Array index out of bounds: ${m} > ${b.length - 1}.`);
    if (m !== Math.floor(m))
      throw new sa(`Array index must be an integer, but found ${m} instead.`);
    return b[m];
  }
  eachChild(o) {
    o(this.index), o(this.input);
  }
  outputDefined() {
    return !1;
  }
}
class V_ {
  constructor(o, m) {
    this.type = vi, this.needle = o, this.haystack = m;
  }
  static parse(o, m) {
    if (o.length !== 3)
      return m.error(`Expected 2 arguments, but found ${o.length - 1} instead.`);
    const b = m.parse(o[1], 1, yi), M = m.parse(o[2], 2, yi);
    return !b || !M ? null : j_(b.type, [vi, Ei, bt, ny, yi]) ? new V_(b, M) : m.error(`Expected first argument to be of type boolean, string, number or null, but found ${Xn(b.type)} instead`);
  }
  evaluate(o) {
    const m = this.needle.evaluate(o), b = this.haystack.evaluate(o);
    if (!b)
      return !1;
    if (!Dd(m, ["boolean", "string", "number", "null"]))
      throw new sa(`Expected first argument to be of type boolean, string, number or null, but found ${Xn(Oa(m))} instead.`);
    if (!Dd(b, ["string", "array"]))
      throw new sa(`Expected second argument to be of type array or string, but found ${Xn(Oa(b))} instead.`);
    return b.indexOf(m) >= 0;
  }
  eachChild(o) {
    o(this.needle), o(this.haystack);
  }
  outputDefined() {
    return !0;
  }
}
class $g {
  constructor(o, m, b) {
    this.type = bt, this.needle = o, this.haystack = m, this.fromIndex = b;
  }
  static parse(o, m) {
    if (o.length <= 2 || o.length >= 5)
      return m.error(`Expected 3 or 4 arguments, but found ${o.length - 1} instead.`);
    const b = m.parse(o[1], 1, yi), M = m.parse(o[2], 2, yi);
    if (!b || !M)
      return null;
    if (!j_(b.type, [vi, Ei, bt, ny, yi]))
      return m.error(`Expected first argument to be of type boolean, string, number or null, but found ${Xn(b.type)} instead`);
    if (o.length === 4) {
      const z = m.parse(o[3], 3, bt);
      return z ? new $g(b, M, z) : null;
    } else
      return new $g(b, M);
  }
  evaluate(o) {
    const m = this.needle.evaluate(o), b = this.haystack.evaluate(o);
    if (!Dd(m, ["boolean", "string", "number", "null"]))
      throw new sa(`Expected first argument to be of type boolean, string, number or null, but found ${Xn(Oa(m))} instead.`);
    let M;
    if (this.fromIndex && (M = this.fromIndex.evaluate(o)), Dd(b, ["string"])) {
      const z = b.indexOf(m, M);
      return z === -1 ? -1 : [...b.slice(0, z)].length;
    } else {
      if (Dd(b, ["array"]))
        return b.indexOf(m, M);
      throw new sa(`Expected second argument to be of type array or string, but found ${Xn(Oa(b))} instead.`);
    }
  }
  eachChild(o) {
    o(this.needle), o(this.haystack), this.fromIndex && o(this.fromIndex);
  }
  outputDefined() {
    return !1;
  }
}
class q_ {
  constructor(o, m, b, M, z, S) {
    this.inputType = o, this.type = m, this.input = b, this.cases = M, this.outputs = z, this.otherwise = S;
  }
  static parse(o, m) {
    if (o.length < 5)
      return m.error(`Expected at least 4 arguments, but found only ${o.length - 1}.`);
    if (o.length % 2 !== 1)
      return m.error("Expected an even number of arguments.");
    let b, M;
    m.expectedType && m.expectedType.kind !== "value" && (M = m.expectedType);
    const z = {}, S = [];
    for (let U = 2; U < o.length - 1; U += 2) {
      let K = o[U];
      const ae = o[U + 1];
      Array.isArray(K) || (K = [K]);
      const he = m.concat(U);
      if (K.length === 0)
        return he.error("Expected at least one branch label.");
      for (const ke of K) {
        if (typeof ke != "number" && typeof ke != "string")
          return he.error("Branch labels must be numbers or strings.");
        if (typeof ke == "number" && Math.abs(ke) > Number.MAX_SAFE_INTEGER)
          return he.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
        if (typeof ke == "number" && Math.floor(ke) !== ke)
          return he.error("Numeric branch labels must be integer values.");
        if (!b)
          b = Oa(ke);
        else if (he.checkSubtype(b, Oa(ke)))
          return null;
        if (typeof z[String(ke)] < "u")
          return he.error("Branch labels must be unique.");
        z[String(ke)] = S.length;
      }
      const J = m.parse(ae, U, M);
      if (!J)
        return null;
      M = M || J.type, S.push(J);
    }
    const u = m.parse(o[1], 1, yi);
    if (!u)
      return null;
    const O = m.parse(o[o.length - 1], o.length - 1, M);
    return !O || u.type.kind !== "value" && m.concat(1).checkSubtype(b, u.type) ? null : new q_(b, M, u, z, S, O);
  }
  evaluate(o) {
    const m = this.input.evaluate(o);
    return (Oa(m) === this.inputType && this.outputs[this.cases[m]] || this.otherwise).evaluate(o);
  }
  eachChild(o) {
    o(this.input), this.outputs.forEach(o), o(this.otherwise);
  }
  outputDefined() {
    return this.outputs.every((o) => o.outputDefined()) && this.otherwise.outputDefined();
  }
}
class G_ {
  constructor(o, m, b) {
    this.type = o, this.branches = m, this.otherwise = b;
  }
  static parse(o, m) {
    if (o.length < 4)
      return m.error(`Expected at least 3 arguments, but found only ${o.length - 1}.`);
    if (o.length % 2 !== 0)
      return m.error("Expected an odd number of arguments.");
    let b;
    m.expectedType && m.expectedType.kind !== "value" && (b = m.expectedType);
    const M = [];
    for (let S = 1; S < o.length - 1; S += 2) {
      const u = m.parse(o[S], S, vi);
      if (!u)
        return null;
      const O = m.parse(o[S + 1], S + 1, b);
      if (!O)
        return null;
      M.push([u, O]), b = b || O.type;
    }
    const z = m.parse(o[o.length - 1], o.length - 1, b);
    if (!z)
      return null;
    if (!b)
      throw new Error("Can't infer output type");
    return new G_(b, M, z);
  }
  evaluate(o) {
    for (const [m, b] of this.branches)
      if (m.evaluate(o))
        return b.evaluate(o);
    return this.otherwise.evaluate(o);
  }
  eachChild(o) {
    for (const [m, b] of this.branches)
      o(m), o(b);
    o(this.otherwise);
  }
  outputDefined() {
    return this.branches.every(([o, m]) => m.outputDefined()) && this.otherwise.outputDefined();
  }
}
class Hg {
  constructor(o, m, b, M) {
    this.type = o, this.input = m, this.beginIndex = b, this.endIndex = M;
  }
  static parse(o, m) {
    if (o.length <= 2 || o.length >= 5)
      return m.error(`Expected 3 or 4 arguments, but found ${o.length - 1} instead.`);
    const b = m.parse(o[1], 1, yi), M = m.parse(o[2], 2, bt);
    if (!b || !M)
      return null;
    if (!j_(b.type, [lo(yi), Ei, yi]))
      return m.error(`Expected first argument to be of type array or string, but found ${Xn(b.type)} instead`);
    if (o.length === 4) {
      const z = m.parse(o[3], 3, bt);
      return z ? new Hg(b.type, b, M, z) : null;
    } else
      return new Hg(b.type, b, M);
  }
  evaluate(o) {
    const m = this.input.evaluate(o), b = this.beginIndex.evaluate(o);
    let M;
    if (this.endIndex && (M = this.endIndex.evaluate(o)), Dd(m, ["string"]))
      return [...m].slice(b, M).join("");
    if (Dd(m, ["array"]))
      return m.slice(b, M);
    throw new sa(`Expected first argument to be of type array or string, but found ${Xn(Oa(m))} instead.`);
  }
  eachChild(o) {
    o(this.input), o(this.beginIndex), this.endIndex && o(this.endIndex);
  }
  outputDefined() {
    return !1;
  }
}
function cx(d, o) {
  const m = d.length - 1;
  let b = 0, M = m, z = 0, S, u;
  for (; b <= M; )
    if (z = Math.floor((b + M) / 2), S = d[z], u = d[z + 1], S <= o) {
      if (z === m || o < u)
        return z;
      b = z + 1;
    } else if (S > o)
      M = z - 1;
    else
      throw new sa("Input is not a number.");
  return 0;
}
class py {
  constructor(o, m, b) {
    this.type = o, this.input = m, this.labels = [], this.outputs = [];
    for (const [M, z] of b)
      this.labels.push(M), this.outputs.push(z);
  }
  static parse(o, m) {
    if (o.length - 1 < 4)
      return m.error(`Expected at least 4 arguments, but found only ${o.length - 1}.`);
    if ((o.length - 1) % 2 !== 0)
      return m.error("Expected an even number of arguments.");
    const b = m.parse(o[1], 1, bt);
    if (!b)
      return null;
    const M = [];
    let z = null;
    m.expectedType && m.expectedType.kind !== "value" && (z = m.expectedType);
    for (let S = 1; S < o.length; S += 2) {
      const u = S === 1 ? -1 / 0 : o[S], O = o[S + 1], U = S, K = S + 1;
      if (typeof u != "number")
        return m.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', U);
      if (M.length && M[M.length - 1][0] >= u)
        return m.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', U);
      const ae = m.parse(O, K, z);
      if (!ae)
        return null;
      z = z || ae.type, M.push([u, ae]);
    }
    return new py(z, b, M);
  }
  evaluate(o) {
    const m = this.labels, b = this.outputs;
    if (m.length === 1)
      return b[0].evaluate(o);
    const M = this.input.evaluate(o);
    if (M <= m[0])
      return b[0].evaluate(o);
    const z = m.length;
    if (M >= m[z - 1])
      return b[z - 1].evaluate(o);
    const S = cx(m, M);
    return b[S].evaluate(o);
  }
  eachChild(o) {
    o(this.input);
    for (const m of this.outputs)
      o(m);
  }
  outputDefined() {
    return this.outputs.every((o) => o.outputDefined());
  }
}
function I2(d) {
  return d && d.__esModule && Object.prototype.hasOwnProperty.call(d, "default") ? d.default : d;
}
var n_, H0;
function k2() {
  if (H0) return n_;
  H0 = 1, n_ = d;
  function d(o, m, b, M) {
    this.cx = 3 * o, this.bx = 3 * (b - o) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * m, this.by = 3 * (M - m) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = o, this.p1y = m, this.p2x = b, this.p2y = M;
  }
  return d.prototype = {
    sampleCurveX: function(o) {
      return ((this.ax * o + this.bx) * o + this.cx) * o;
    },
    sampleCurveY: function(o) {
      return ((this.ay * o + this.by) * o + this.cy) * o;
    },
    sampleCurveDerivativeX: function(o) {
      return (3 * this.ax * o + 2 * this.bx) * o + this.cx;
    },
    solveCurveX: function(o, m) {
      if (m === void 0 && (m = 1e-6), o < 0) return 0;
      if (o > 1) return 1;
      for (var b = o, M = 0; M < 8; M++) {
        var z = this.sampleCurveX(b) - o;
        if (Math.abs(z) < m) return b;
        var S = this.sampleCurveDerivativeX(b);
        if (Math.abs(S) < 1e-6) break;
        b = b - z / S;
      }
      var u = 0, O = 1;
      for (b = o, M = 0; M < 20 && (z = this.sampleCurveX(b), !(Math.abs(z - o) < m)); M++)
        o > z ? u = b : O = b, b = (O - u) * 0.5 + u;
      return b;
    },
    solve: function(o, m) {
      return this.sampleCurveY(this.solveCurveX(o, m));
    }
  }, n_;
}
var R2 = k2(), D2 = /* @__PURE__ */ I2(R2);
class Pu {
  constructor(o, m, b, M, z) {
    this.type = o, this.operator = m, this.interpolation = b, this.input = M, this.labels = [], this.outputs = [];
    for (const [S, u] of z)
      this.labels.push(S), this.outputs.push(u);
  }
  static interpolationFactor(o, m, b, M) {
    let z = 0;
    if (o.name === "exponential")
      z = a_(m, o.base, b, M);
    else if (o.name === "linear")
      z = a_(m, 1, b, M);
    else if (o.name === "cubic-bezier") {
      const S = o.controlPoints;
      z = new D2(S[0], S[1], S[2], S[3]).solve(a_(m, 1, b, M));
    }
    return z;
  }
  static parse(o, m) {
    let [b, M, z, ...S] = o;
    if (!Array.isArray(M) || M.length === 0)
      return m.error("Expected an interpolation type expression.", 1);
    if (M[0] === "linear")
      M = { name: "linear" };
    else if (M[0] === "exponential") {
      const U = M[1];
      if (typeof U != "number")
        return m.error("Exponential interpolation requires a numeric base.", 1, 1);
      M = {
        name: "exponential",
        base: U
      };
    } else if (M[0] === "cubic-bezier") {
      const U = M.slice(1);
      if (U.length !== 4 || U.some((K) => typeof K != "number" || K < 0 || K > 1))
        return m.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
      M = {
        name: "cubic-bezier",
        controlPoints: U
      };
    } else
      return m.error(`Unknown interpolation type ${String(M[0])}`, 1, 0);
    if (o.length - 1 < 4)
      return m.error(`Expected at least 4 arguments, but found only ${o.length - 1}.`);
    if ((o.length - 1) % 2 !== 0)
      return m.error("Expected an even number of arguments.");
    if (z = m.parse(z, 2, bt), !z)
      return null;
    const u = [];
    let O = null;
    (b === "interpolate-hcl" || b === "interpolate-lab") && m.expectedType != Sm ? O = Cu : m.expectedType && m.expectedType.kind !== "value" && (O = m.expectedType);
    for (let U = 0; U < S.length; U += 2) {
      const K = S[U], ae = S[U + 1], he = U + 3, J = U + 4;
      if (typeof K != "number")
        return m.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', he);
      if (u.length && u[u.length - 1][0] >= K)
        return m.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', he);
      const ke = m.parse(ae, J, O);
      if (!ke)
        return null;
      O = O || ke.type, u.push([K, ke]);
    }
    return !bh(O, bt) && !bh(O, ay) && !bh(O, Cu) && !bh(O, oy) && !bh(O, ly) && !bh(O, Sm) && !bh(O, uy) && !bh(O, lo(bt)) ? m.error(`Type ${Xn(O)} is not interpolatable.`) : new Pu(O, b, M, z, u);
  }
  evaluate(o) {
    const m = this.labels, b = this.outputs;
    if (m.length === 1)
      return b[0].evaluate(o);
    const M = this.input.evaluate(o);
    if (M <= m[0])
      return b[0].evaluate(o);
    const z = m.length;
    if (M >= m[z - 1])
      return b[z - 1].evaluate(o);
    const S = cx(m, M), u = m[S], O = m[S + 1], U = Pu.interpolationFactor(this.interpolation, M, u, O), K = b[S].evaluate(o), ae = b[S + 1].evaluate(o);
    switch (this.operator) {
      case "interpolate":
        switch (this.type.kind) {
          case "number":
            return Ld(K, ae, U);
          case "color":
            return on.interpolate(K, ae, U);
          case "padding":
            return Ol.interpolate(K, ae, U);
          case "colorArray":
            return uo.interpolate(K, ae, U);
          case "numberArray":
            return Bl.interpolate(K, ae, U);
          case "variableAnchorOffsetCollection":
            return zu.interpolate(K, ae, U);
          case "array":
            return Mm(K, ae, U);
          case "projectionDefinition":
            return Dl.interpolate(K, ae, U);
        }
      case "interpolate-hcl":
        switch (this.type.kind) {
          case "color":
            return on.interpolate(K, ae, U, "hcl");
          case "colorArray":
            return uo.interpolate(K, ae, U, "hcl");
        }
      case "interpolate-lab":
        switch (this.type.kind) {
          case "color":
            return on.interpolate(K, ae, U, "lab");
          case "colorArray":
            return uo.interpolate(K, ae, U, "lab");
        }
    }
  }
  eachChild(o) {
    o(this.input);
    for (const m of this.outputs)
      o(m);
  }
  outputDefined() {
    return this.outputs.every((o) => o.outputDefined());
  }
}
function a_(d, o, m, b) {
  const M = b - m, z = d - m;
  return M === 0 ? 0 : o === 1 ? z / M : (Math.pow(o, z) - 1) / (Math.pow(o, M) - 1);
}
class Em {
  constructor(o, m) {
    this.type = o, this.args = m;
  }
  static parse(o, m) {
    if (o.length < 2)
      return m.error("Expected at least one argument.");
    let b = null;
    const M = m.expectedType;
    M && M.kind !== "value" && (b = M);
    const z = [];
    for (const S of o.slice(1)) {
      const u = m.parse(S, 1 + z.length, b, void 0, { typeAnnotation: "omit" });
      if (!u)
        return null;
      b = b || u.type, z.push(u);
    }
    if (!b)
      throw new Error("No output type");
    return M && z.some((S) => Tm(M, S.type)) ? new Em(yi, z) : new Em(b, z);
  }
  evaluate(o) {
    let m = null, b = 0, M;
    for (const z of this.args)
      if (b++, m = z.evaluate(o), m && m instanceof Th && !m.available && (M || (M = m.name), m = null, b === this.args.length && (m = M)), m !== null)
        break;
    return m;
  }
  eachChild(o) {
    this.args.forEach(o);
  }
  outputDefined() {
    return this.args.every((o) => o.outputDefined());
  }
}
function X0(d, o) {
  return d === "==" || d === "!=" ? o.kind === "boolean" || o.kind === "string" || o.kind === "number" || o.kind === "null" || o.kind === "value" : o.kind === "string" || o.kind === "number" || o.kind === "value";
}
function L2(d, o, m) {
  return o === m;
}
function O2(d, o, m) {
  return o !== m;
}
function B2(d, o, m) {
  return o < m;
}
function N2(d, o, m) {
  return o > m;
}
function j2(d, o, m) {
  return o <= m;
}
function U2(d, o, m) {
  return o >= m;
}
function hx(d, o, m, b) {
  return b.compare(o, m) === 0;
}
function F2(d, o, m, b) {
  return !hx(d, o, m, b);
}
function V2(d, o, m, b) {
  return b.compare(o, m) < 0;
}
function q2(d, o, m, b) {
  return b.compare(o, m) > 0;
}
function G2(d, o, m, b) {
  return b.compare(o, m) <= 0;
}
function Z2(d, o, m, b) {
  return b.compare(o, m) >= 0;
}
function ef(d, o, m) {
  const b = d !== "==" && d !== "!=";
  return class dx {
    constructor(z, S, u) {
      this.type = vi, this.lhs = z, this.rhs = S, this.collator = u, this.hasUntypedArgument = z.type.kind === "value" || S.type.kind === "value";
    }
    static parse(z, S) {
      if (z.length !== 3 && z.length !== 4)
        return S.error("Expected two or three arguments.");
      const u = z[0];
      let O = S.parse(z[1], 1, yi);
      if (!O)
        return null;
      if (!X0(u, O.type))
        return S.concat(1).error(`"${u}" comparisons are not supported for type '${Xn(O.type)}'.`);
      let U = S.parse(z[2], 2, yi);
      if (!U)
        return null;
      if (!X0(u, U.type))
        return S.concat(2).error(`"${u}" comparisons are not supported for type '${Xn(U.type)}'.`);
      if (O.type.kind !== U.type.kind && O.type.kind !== "value" && U.type.kind !== "value")
        return S.error(`Cannot compare types '${Xn(O.type)}' and '${Xn(U.type)}'.`);
      b && (O.type.kind === "value" && U.type.kind !== "value" ? O = new Ll(U.type, [O]) : O.type.kind !== "value" && U.type.kind === "value" && (U = new Ll(O.type, [U])));
      let K = null;
      if (z.length === 4) {
        if (O.type.kind !== "string" && U.type.kind !== "string" && O.type.kind !== "value" && U.type.kind !== "value")
          return S.error("Cannot use collator to compare non-string types.");
        if (K = S.parse(z[3], 3, ry), !K)
          return null;
      }
      return new dx(O, U, K);
    }
    evaluate(z) {
      const S = this.lhs.evaluate(z), u = this.rhs.evaluate(z);
      if (b && this.hasUntypedArgument) {
        const O = Oa(S), U = Oa(u);
        if (O.kind !== U.kind || !(O.kind === "string" || O.kind === "number"))
          throw new sa(`Expected arguments for "${d}" to be (string, string) or (number, number), but found (${O.kind}, ${U.kind}) instead.`);
      }
      if (this.collator && !b && this.hasUntypedArgument) {
        const O = Oa(S), U = Oa(u);
        if (O.kind !== "string" || U.kind !== "string")
          return o(z, S, u);
      }
      return this.collator ? m(z, S, u, this.collator.evaluate(z)) : o(z, S, u);
    }
    eachChild(z) {
      z(this.lhs), z(this.rhs), this.collator && z(this.collator);
    }
    outputDefined() {
      return !0;
    }
  };
}
const $2 = ef("==", L2, hx), H2 = ef("!=", O2, F2), X2 = ef("<", B2, V2), Y2 = ef(">", N2, q2), K2 = ef("<=", j2, G2), W2 = ef(">=", U2, Z2);
class fy {
  constructor(o, m, b) {
    this.type = ry, this.locale = b, this.caseSensitive = o, this.diacriticSensitive = m;
  }
  static parse(o, m) {
    if (o.length !== 2)
      return m.error("Expected one argument.");
    const b = o[1];
    if (typeof b != "object" || Array.isArray(b))
      return m.error("Collator options argument must be an object.");
    const M = m.parse(b["case-sensitive"] === void 0 ? !1 : b["case-sensitive"], 1, vi);
    if (!M)
      return null;
    const z = m.parse(b["diacritic-sensitive"] === void 0 ? !1 : b["diacritic-sensitive"], 1, vi);
    if (!z)
      return null;
    let S = null;
    return b.locale && (S = m.parse(b.locale, 1, Ei), !S) ? null : new fy(M, z, S);
  }
  evaluate(o) {
    return new U_(this.caseSensitive.evaluate(o), this.diacriticSensitive.evaluate(o), this.locale ? this.locale.evaluate(o) : null);
  }
  eachChild(o) {
    o(this.caseSensitive), o(this.diacriticSensitive), this.locale && o(this.locale);
  }
  outputDefined() {
    return !1;
  }
}
class Z_ {
  constructor(o, m, b, M, z) {
    this.type = Ei, this.number = o, this.locale = m, this.currency = b, this.minFractionDigits = M, this.maxFractionDigits = z;
  }
  static parse(o, m) {
    if (o.length !== 3)
      return m.error("Expected two arguments.");
    const b = m.parse(o[1], 1, bt);
    if (!b)
      return null;
    const M = o[2];
    if (typeof M != "object" || Array.isArray(M))
      return m.error("NumberFormat options argument must be an object.");
    let z = null;
    if (M.locale && (z = m.parse(M.locale, 1, Ei), !z))
      return null;
    let S = null;
    if (M.currency && (S = m.parse(M.currency, 1, Ei), !S))
      return null;
    let u = null;
    if (M["min-fraction-digits"] && (u = m.parse(M["min-fraction-digits"], 1, bt), !u))
      return null;
    let O = null;
    return M["max-fraction-digits"] && (O = m.parse(M["max-fraction-digits"], 1, bt), !O) ? null : new Z_(b, z, S, u, O);
  }
  evaluate(o) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(o) : [], {
      style: this.currency ? "currency" : "decimal",
      currency: this.currency ? this.currency.evaluate(o) : void 0,
      minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(o) : void 0,
      maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(o) : void 0
    }).format(this.number.evaluate(o));
  }
  eachChild(o) {
    o(this.number), this.locale && o(this.locale), this.currency && o(this.currency), this.minFractionDigits && o(this.minFractionDigits), this.maxFractionDigits && o(this.maxFractionDigits);
  }
  outputDefined() {
    return !1;
  }
}
class $_ {
  constructor(o) {
    this.type = sy, this.sections = o;
  }
  static parse(o, m) {
    if (o.length < 2)
      return m.error("Expected at least one argument.");
    const b = o[1];
    if (!Array.isArray(b) && typeof b == "object")
      return m.error("First argument must be an image or text section.");
    const M = [];
    let z = !1;
    for (let S = 1; S <= o.length - 1; ++S) {
      const u = o[S];
      if (z && typeof u == "object" && !Array.isArray(u)) {
        z = !1;
        let O = null;
        if (u["font-scale"] && (O = m.parse(u["font-scale"], 1, bt), !O))
          return null;
        let U = null;
        if (u["text-font"] && (U = m.parse(u["text-font"], 1, lo(Ei)), !U))
          return null;
        let K = null;
        if (u["text-color"] && (K = m.parse(u["text-color"], 1, Cu), !K))
          return null;
        let ae = null;
        if (u["vertical-align"]) {
          if (typeof u["vertical-align"] == "string" && !C2.includes(u["vertical-align"]))
            return m.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${u["vertical-align"]}' instead.`);
          if (ae = m.parse(u["vertical-align"], 1, Ei), !ae)
            return null;
        }
        const he = M[M.length - 1];
        he.scale = O, he.font = U, he.textColor = K, he.verticalAlign = ae;
      } else {
        const O = m.parse(o[S], 1, yi);
        if (!O)
          return null;
        const U = O.type.kind;
        if (U !== "string" && U !== "value" && U !== "null" && U !== "resolvedImage")
          return m.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
        z = !0, M.push({ content: O, scale: null, font: null, textColor: null, verticalAlign: null });
      }
    }
    return new $_(M);
  }
  evaluate(o) {
    const m = (b) => {
      const M = b.content.evaluate(o);
      return Oa(M) === Dm ? new w_("", M, null, null, null, b.verticalAlign ? b.verticalAlign.evaluate(o) : null) : new w_(xm(M), null, b.scale ? b.scale.evaluate(o) : null, b.font ? b.font.evaluate(o).join(",") : null, b.textColor ? b.textColor.evaluate(o) : null, b.verticalAlign ? b.verticalAlign.evaluate(o) : null);
    };
    return new Pc(this.sections.map(m));
  }
  eachChild(o) {
    for (const m of this.sections)
      o(m.content), m.scale && o(m.scale), m.font && o(m.font), m.textColor && o(m.textColor), m.verticalAlign && o(m.verticalAlign);
  }
  outputDefined() {
    return !1;
  }
}
class H_ {
  constructor(o) {
    this.type = Dm, this.input = o;
  }
  static parse(o, m) {
    if (o.length !== 2)
      return m.error("Expected two arguments.");
    const b = m.parse(o[1], 1, Ei);
    return b ? new H_(b) : m.error("No image name provided.");
  }
  evaluate(o) {
    const m = this.input.evaluate(o), b = Th.fromString(m);
    return b && o.availableImages && (b.available = o.availableImages.indexOf(m) > -1), b;
  }
  eachChild(o) {
    o(this.input);
  }
  outputDefined() {
    return !1;
  }
}
class X_ {
  constructor(o) {
    this.type = bt, this.input = o;
  }
  static parse(o, m) {
    if (o.length !== 2)
      return m.error(`Expected 1 argument, but found ${o.length - 1} instead.`);
    const b = m.parse(o[1], 1);
    return b ? b.type.kind !== "array" && b.type.kind !== "string" && b.type.kind !== "value" ? m.error(`Expected argument of type string or array, but found ${Xn(b.type)} instead.`) : new X_(b) : null;
  }
  evaluate(o) {
    const m = this.input.evaluate(o);
    if (typeof m == "string")
      return [...m].length;
    if (Array.isArray(m))
      return m.length;
    throw new sa(`Expected value to be of type string or array, but found ${Xn(Oa(m))} instead.`);
  }
  eachChild(o) {
    o(this.input);
  }
  outputDefined() {
    return !1;
  }
}
const Iu = 8192;
function J2(d, o) {
  const m = Q2(d[0]), b = tw(d[1]), M = Math.pow(2, o.z);
  return [Math.round(m * M * Iu), Math.round(b * M * Iu)];
}
function Y_(d, o) {
  const m = Math.pow(2, o.z), b = (d[0] / Iu + o.x) / m, M = (d[1] / Iu + o.y) / m;
  return [ew(b), iw(M)];
}
function Q2(d) {
  return (180 + d) / 360;
}
function ew(d) {
  return d * 360 - 180;
}
function tw(d) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + d * Math.PI / 360))) / 360;
}
function iw(d) {
  return 360 / Math.PI * Math.atan(Math.exp((180 - d * 360) * Math.PI / 180)) - 90;
}
function Lm(d, o) {
  d[0] = Math.min(d[0], o[0]), d[1] = Math.min(d[1], o[1]), d[2] = Math.max(d[2], o[0]), d[3] = Math.max(d[3], o[1]);
}
function Cm(d, o) {
  return !(d[0] <= o[0] || d[2] >= o[2] || d[1] <= o[1] || d[3] >= o[3]);
}
function nw(d, o, m) {
  return o[1] > d[1] != m[1] > d[1] && d[0] < (m[0] - o[0]) * (d[1] - o[1]) / (m[1] - o[1]) + o[0];
}
function aw(d, o, m) {
  const b = d[0] - o[0], M = d[1] - o[1], z = d[0] - m[0], S = d[1] - m[1];
  return b * S - z * M === 0 && b * z <= 0 && M * S <= 0;
}
function my(d, o, m, b) {
  const M = [o[0] - d[0], o[1] - d[1]], z = [b[0] - m[0], b[1] - m[1]];
  return lw(z, M) === 0 ? !1 : !!(Y0(d, o, m, b) && Y0(m, b, d, o));
}
function rw(d, o, m) {
  for (const b of m)
    for (let M = 0; M < b.length - 1; ++M)
      if (my(d, o, b[M], b[M + 1]))
        return !0;
  return !1;
}
function tf(d, o, m = !1) {
  let b = !1;
  for (const M of o)
    for (let z = 0; z < M.length - 1; z++) {
      if (aw(d, M[z], M[z + 1]))
        return m;
      nw(d, M[z], M[z + 1]) && (b = !b);
    }
  return b;
}
function sw(d, o) {
  for (const m of o)
    if (tf(d, m))
      return !0;
  return !1;
}
function px(d, o) {
  for (const m of d)
    if (!tf(m, o))
      return !1;
  for (let m = 0; m < d.length - 1; ++m)
    if (rw(d[m], d[m + 1], o))
      return !1;
  return !0;
}
function ow(d, o) {
  for (const m of o)
    if (px(d, m))
      return !0;
  return !1;
}
function lw(d, o) {
  return d[0] * o[1] - d[1] * o[0];
}
function Y0(d, o, m, b) {
  const M = d[0] - m[0], z = d[1] - m[1], S = o[0] - m[0], u = o[1] - m[1], O = b[0] - m[0], U = b[1] - m[1], K = M * U - O * z, ae = S * U - O * u;
  return K > 0 && ae < 0 || K < 0 && ae > 0;
}
function K_(d, o, m) {
  const b = [];
  for (let M = 0; M < d.length; M++) {
    const z = [];
    for (let S = 0; S < d[M].length; S++) {
      const u = J2(d[M][S], m);
      Lm(o, u), z.push(u);
    }
    b.push(z);
  }
  return b;
}
function fx(d, o, m) {
  const b = [];
  for (let M = 0; M < d.length; M++) {
    const z = K_(d[M], o, m);
    b.push(z);
  }
  return b;
}
function mx(d, o, m, b) {
  if (d[0] < m[0] || d[0] > m[2]) {
    const M = b * 0.5;
    let z = d[0] - m[0] > M ? -b : m[0] - d[0] > M ? b : 0;
    z === 0 && (z = d[0] - m[2] > M ? -b : m[2] - d[0] > M ? b : 0), d[0] += z;
  }
  Lm(o, d);
}
function uw(d) {
  d[0] = d[1] = 1 / 0, d[2] = d[3] = -1 / 0;
}
function K0(d, o, m, b) {
  const M = Math.pow(2, b.z) * Iu, z = [b.x * Iu, b.y * Iu], S = [];
  for (const u of d)
    for (const O of u) {
      const U = [O.x + z[0], O.y + z[1]];
      mx(U, o, m, M), S.push(U);
    }
  return S;
}
function W0(d, o, m, b) {
  const M = Math.pow(2, b.z) * Iu, z = [b.x * Iu, b.y * Iu], S = [];
  for (const u of d) {
    const O = [];
    for (const U of u) {
      const K = [U.x + z[0], U.y + z[1]];
      Lm(o, K), O.push(K);
    }
    S.push(O);
  }
  if (o[2] - o[0] <= M / 2) {
    uw(o);
    for (const u of S)
      for (const O of u)
        mx(O, o, m, M);
  }
  return S;
}
function cw(d, o) {
  const m = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = [1 / 0, 1 / 0, -1 / 0, -1 / 0], M = d.canonicalID();
  if (o.type === "Polygon") {
    const z = K_(o.coordinates, b, M), S = K0(d.geometry(), m, b, M);
    if (!Cm(m, b))
      return !1;
    for (const u of S)
      if (!tf(u, z))
        return !1;
  }
  if (o.type === "MultiPolygon") {
    const z = fx(o.coordinates, b, M), S = K0(d.geometry(), m, b, M);
    if (!Cm(m, b))
      return !1;
    for (const u of S)
      if (!sw(u, z))
        return !1;
  }
  return !0;
}
function hw(d, o) {
  const m = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = [1 / 0, 1 / 0, -1 / 0, -1 / 0], M = d.canonicalID();
  if (o.type === "Polygon") {
    const z = K_(o.coordinates, b, M), S = W0(d.geometry(), m, b, M);
    if (!Cm(m, b))
      return !1;
    for (const u of S)
      if (!px(u, z))
        return !1;
  }
  if (o.type === "MultiPolygon") {
    const z = fx(o.coordinates, b, M), S = W0(d.geometry(), m, b, M);
    if (!Cm(m, b))
      return !1;
    for (const u of S)
      if (!ow(u, z))
        return !1;
  }
  return !0;
}
class Od {
  constructor(o, m) {
    this.type = vi, this.geojson = o, this.geometries = m;
  }
  static parse(o, m) {
    if (o.length !== 2)
      return m.error(`'within' expression requires exactly one argument, but found ${o.length - 1} instead.`);
    if (Am(o[1])) {
      const b = o[1];
      if (b.type === "FeatureCollection") {
        const M = [];
        for (const z of b.features) {
          const { type: S, coordinates: u } = z.geometry;
          S === "Polygon" && M.push(u), S === "MultiPolygon" && M.push(...u);
        }
        if (M.length) {
          const z = {
            type: "MultiPolygon",
            coordinates: M
          };
          return new Od(b, z);
        }
      } else if (b.type === "Feature") {
        const M = b.geometry.type;
        if (M === "Polygon" || M === "MultiPolygon")
          return new Od(b, b.geometry);
      } else if (b.type === "Polygon" || b.type === "MultiPolygon")
        return new Od(b, b);
    }
    return m.error("'within' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(o) {
    if (o.geometry() != null && o.canonicalID() != null) {
      if (o.geometryType() === "Point")
        return cw(o, this.geometries);
      if (o.geometryType() === "LineString")
        return hw(o, this.geometries);
    }
    return !1;
  }
  eachChild() {
  }
  outputDefined() {
    return !0;
  }
}
class gx {
  constructor(o = [], m = (b, M) => b < M ? -1 : b > M ? 1 : 0) {
    if (this.data = o, this.length = this.data.length, this.compare = m, this.length > 0)
      for (let b = (this.length >> 1) - 1; b >= 0; b--) this._down(b);
  }
  push(o) {
    this.data.push(o), this._up(this.length++);
  }
  pop() {
    if (this.length === 0) return;
    const o = this.data[0], m = this.data.pop();
    return --this.length > 0 && (this.data[0] = m, this._down(0)), o;
  }
  peek() {
    return this.data[0];
  }
  _up(o) {
    const { data: m, compare: b } = this, M = m[o];
    for (; o > 0; ) {
      const z = o - 1 >> 1, S = m[z];
      if (b(M, S) >= 0) break;
      m[o] = S, o = z;
    }
    m[o] = M;
  }
  _down(o) {
    const { data: m, compare: b } = this, M = this.length >> 1, z = m[o];
    for (; o < M; ) {
      let S = (o << 1) + 1;
      const u = S + 1;
      if (u < this.length && b(m[u], m[S]) < 0 && (S = u), b(m[S], z) >= 0) break;
      m[o] = m[S], o = S;
    }
    m[o] = z;
  }
}
function dw(d, o) {
  if (d.length <= 1)
    return [d];
  const m = [];
  let b, M;
  for (const z of d) {
    const S = pw(z);
    S !== 0 && (z.area = Math.abs(S), M === void 0 && (M = S < 0), M === S < 0 ? (b && m.push(b), b = [z]) : b.push(z));
  }
  return b && m.push(b), m;
}
function pw(d) {
  let o = 0;
  for (let m = 0, b = d.length, M = b - 1, z, S; m < b; M = m++)
    z = d[m], S = d[M], o += (S.x - z.x) * (z.y + S.y);
  return o;
}
const fw = 6378.137, J0 = 1 / 298.257223563, Q0 = J0 * (2 - J0), ev = Math.PI / 180;
class W_ {
  constructor(o) {
    const m = ev * fw * 1e3, b = Math.cos(o * ev), M = 1 / (1 - Q0 * (1 - b * b)), z = Math.sqrt(M);
    this.kx = m * z * b, this.ky = m * z * M * (1 - Q0);
  }
  /**
   * Given two points of the form [longitude, latitude], returns the distance.
   *
   * @param a - point [longitude, latitude]
   * @param b - point [longitude, latitude]
   * @returns distance
   * @example
   * const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);
   * //=distance
   */
  distance(o, m) {
    const b = this.wrap(o[0] - m[0]) * this.kx, M = (o[1] - m[1]) * this.ky;
    return Math.sqrt(b * b + M * M);
  }
  /**
   * Returns an object of the form {point, index, t}, where point is closest point on the line
   * from the given point, index is the start index of the segment with the closest point,
   * and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.
   *
   * @param line - an array of points that form the line
   * @param p - point [longitude, latitude]
   * @returns the nearest point, its index in the array and the proportion along the line
   * @example
   * const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;
   * //=point
   */
  pointOnLine(o, m) {
    let b = 1 / 0, M, z, S, u;
    for (let O = 0; O < o.length - 1; O++) {
      let U = o[O][0], K = o[O][1], ae = this.wrap(o[O + 1][0] - U) * this.kx, he = (o[O + 1][1] - K) * this.ky, J = 0;
      (ae !== 0 || he !== 0) && (J = (this.wrap(m[0] - U) * this.kx * ae + (m[1] - K) * this.ky * he) / (ae * ae + he * he), J > 1 ? (U = o[O + 1][0], K = o[O + 1][1]) : J > 0 && (U += ae / this.kx * J, K += he / this.ky * J)), ae = this.wrap(m[0] - U) * this.kx, he = (m[1] - K) * this.ky;
      const ke = ae * ae + he * he;
      ke < b && (b = ke, M = U, z = K, S = O, u = J);
    }
    return {
      point: [M, z],
      index: S,
      t: Math.max(0, Math.min(1, u))
    };
  }
  wrap(o) {
    for (; o < -180; )
      o += 360;
    for (; o > 180; )
      o -= 360;
    return o;
  }
}
const S_ = 100, T_ = 50;
function yx(d, o) {
  return o[0] - d[0];
}
function Xg(d) {
  return d[1] - d[0] + 1;
}
function kc(d, o) {
  return d[1] >= d[0] && d[1] < o;
}
function M_(d, o) {
  if (d[0] > d[1])
    return [null, null];
  const m = Xg(d);
  if (o) {
    if (m === 2)
      return [d, null];
    const M = Math.floor(m / 2);
    return [
      [d[0], d[0] + M],
      [d[0] + M, d[1]]
    ];
  }
  if (m === 1)
    return [d, null];
  const b = Math.floor(m / 2) - 1;
  return [
    [d[0], d[0] + b],
    [d[0] + b + 1, d[1]]
  ];
}
function A_(d, o) {
  if (!kc(o, d.length))
    return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  const m = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (let b = o[0]; b <= o[1]; ++b)
    Lm(m, d[b]);
  return m;
}
function E_(d) {
  const o = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (const m of d)
    for (const b of m)
      Lm(o, b);
  return o;
}
function tv(d) {
  return d[0] !== -1 / 0 && d[1] !== -1 / 0 && d[2] !== 1 / 0 && d[3] !== 1 / 0;
}
function J_(d, o, m) {
  if (!tv(d) || !tv(o))
    return NaN;
  let b = 0, M = 0;
  return d[2] < o[0] && (b = o[0] - d[2]), d[0] > o[2] && (b = d[0] - o[2]), d[1] > o[3] && (M = d[1] - o[3]), d[3] < o[1] && (M = o[1] - d[3]), m.distance([0, 0], [b, M]);
}
function kd(d, o, m) {
  const b = m.pointOnLine(o, d);
  return m.distance(d, b.point);
}
function Q_(d, o, m, b, M) {
  const z = Math.min(kd(d, [m, b], M), kd(o, [m, b], M)), S = Math.min(kd(m, [d, o], M), kd(b, [d, o], M));
  return Math.min(z, S);
}
function mw(d, o, m, b, M) {
  if (!(kc(o, d.length) && kc(b, m.length)))
    return 1 / 0;
  let z = 1 / 0;
  for (let S = o[0]; S < o[1]; ++S) {
    const u = d[S], O = d[S + 1];
    for (let U = b[0]; U < b[1]; ++U) {
      const K = m[U], ae = m[U + 1];
      if (my(u, O, K, ae))
        return 0;
      z = Math.min(z, Q_(u, O, K, ae, M));
    }
  }
  return z;
}
function gw(d, o, m, b, M) {
  if (!(kc(o, d.length) && kc(b, m.length)))
    return NaN;
  let z = 1 / 0;
  for (let S = o[0]; S <= o[1]; ++S)
    for (let u = b[0]; u <= b[1]; ++u)
      if (z = Math.min(z, M.distance(d[S], m[u])), z === 0)
        return z;
  return z;
}
function yw(d, o, m) {
  if (tf(d, o, !0))
    return 0;
  let b = 1 / 0;
  for (const M of o) {
    const z = M[0], S = M[M.length - 1];
    if (z !== S && (b = Math.min(b, kd(d, [S, z], m)), b === 0))
      return b;
    const u = m.pointOnLine(M, d);
    if (b = Math.min(b, m.distance(d, u.point)), b === 0)
      return b;
  }
  return b;
}
function _w(d, o, m, b) {
  if (!kc(o, d.length))
    return NaN;
  for (let z = o[0]; z <= o[1]; ++z)
    if (tf(d[z], m, !0))
      return 0;
  let M = 1 / 0;
  for (let z = o[0]; z < o[1]; ++z) {
    const S = d[z], u = d[z + 1];
    for (const O of m)
      for (let U = 0, K = O.length, ae = K - 1; U < K; ae = U++) {
        const he = O[ae], J = O[U];
        if (my(S, u, he, J))
          return 0;
        M = Math.min(M, Q_(S, u, he, J, b));
      }
  }
  return M;
}
function iv(d, o) {
  for (const m of d)
    for (const b of m)
      if (tf(b, o, !0))
        return !0;
  return !1;
}
function vw(d, o, m, b = 1 / 0) {
  const M = E_(d), z = E_(o);
  if (b !== 1 / 0 && J_(M, z, m) >= b)
    return b;
  if (Cm(M, z)) {
    if (iv(d, o))
      return 0;
  } else if (iv(o, d))
    return 0;
  let S = 1 / 0;
  for (const u of d)
    for (let O = 0, U = u.length, K = U - 1; O < U; K = O++) {
      const ae = u[K], he = u[O];
      for (const J of o)
        for (let ke = 0, qe = J.length, ft = qe - 1; ke < qe; ft = ke++) {
          const ht = J[ft], it = J[ke];
          if (my(ae, he, ht, it))
            return 0;
          S = Math.min(S, Q_(ae, he, ht, it, m));
        }
    }
  return S;
}
function nv(d, o, m, b, M, z) {
  if (!z)
    return;
  const S = J_(A_(b, z), M, m);
  S < o && d.push([S, z, [0, 0]]);
}
function Rg(d, o, m, b, M, z, S) {
  if (!z || !S)
    return;
  const u = J_(A_(b, z), A_(M, S), m);
  u < o && d.push([u, z, S]);
}
function Yg(d, o, m, b, M = 1 / 0) {
  let z = Math.min(b.distance(d[0], m[0][0]), M);
  if (z === 0)
    return z;
  const S = new gx([[0, [0, d.length - 1], [0, 0]]], yx), u = E_(m);
  for (; S.length > 0; ) {
    const O = S.pop();
    if (O[0] >= z)
      continue;
    const U = O[1], K = o ? T_ : S_;
    if (Xg(U) <= K) {
      if (!kc(U, d.length))
        return NaN;
      if (o) {
        const ae = _w(d, U, m, b);
        if (isNaN(ae) || ae === 0)
          return ae;
        z = Math.min(z, ae);
      } else
        for (let ae = U[0]; ae <= U[1]; ++ae) {
          const he = yw(d[ae], m, b);
          if (z = Math.min(z, he), z === 0)
            return 0;
        }
    } else {
      const ae = M_(U, o);
      nv(S, z, b, d, u, ae[0]), nv(S, z, b, d, u, ae[1]);
    }
  }
  return z;
}
function Kg(d, o, m, b, M, z = 1 / 0) {
  let S = Math.min(z, M.distance(d[0], m[0]));
  if (S === 0)
    return S;
  const u = new gx([[0, [0, d.length - 1], [0, m.length - 1]]], yx);
  for (; u.length > 0; ) {
    const O = u.pop();
    if (O[0] >= S)
      continue;
    const U = O[1], K = O[2], ae = o ? T_ : S_, he = b ? T_ : S_;
    if (Xg(U) <= ae && Xg(K) <= he) {
      if (!kc(U, d.length) && kc(K, m.length))
        return NaN;
      let J;
      if (o && b)
        J = mw(d, U, m, K, M), S = Math.min(S, J);
      else if (o && !b) {
        const ke = d.slice(U[0], U[1] + 1);
        for (let qe = K[0]; qe <= K[1]; ++qe)
          if (J = kd(m[qe], ke, M), S = Math.min(S, J), S === 0)
            return S;
      } else if (!o && b) {
        const ke = m.slice(K[0], K[1] + 1);
        for (let qe = U[0]; qe <= U[1]; ++qe)
          if (J = kd(d[qe], ke, M), S = Math.min(S, J), S === 0)
            return S;
      } else
        J = gw(d, U, m, K, M), S = Math.min(S, J);
    } else {
      const J = M_(U, o), ke = M_(K, b);
      Rg(u, S, M, d, m, J[0], ke[0]), Rg(u, S, M, d, m, J[0], ke[1]), Rg(u, S, M, d, m, J[1], ke[0]), Rg(u, S, M, d, m, J[1], ke[1]);
    }
  }
  return S;
}
function xw(d, o) {
  const m = d.geometry(), b = m.flat().map((S) => Y_([S.x, S.y], d.canonical));
  if (m.length === 0)
    return NaN;
  const M = new W_(b[0][1]);
  let z = 1 / 0;
  for (const S of o) {
    switch (S.type) {
      case "Point":
        z = Math.min(z, Kg(b, !1, [S.coordinates], !1, M, z));
        break;
      case "LineString":
        z = Math.min(z, Kg(b, !1, S.coordinates, !0, M, z));
        break;
      case "Polygon":
        z = Math.min(z, Yg(b, !1, S.coordinates, M, z));
        break;
    }
    if (z === 0)
      return z;
  }
  return z;
}
function bw(d, o) {
  const m = d.geometry(), b = m.flat().map((S) => Y_([S.x, S.y], d.canonical));
  if (m.length === 0)
    return NaN;
  const M = new W_(b[0][1]);
  let z = 1 / 0;
  for (const S of o) {
    switch (S.type) {
      case "Point":
        z = Math.min(z, Kg(b, !0, [S.coordinates], !1, M, z));
        break;
      case "LineString":
        z = Math.min(z, Kg(b, !0, S.coordinates, !0, M, z));
        break;
      case "Polygon":
        z = Math.min(z, Yg(b, !0, S.coordinates, M, z));
        break;
    }
    if (z === 0)
      return z;
  }
  return z;
}
function ww(d, o) {
  const m = d.geometry();
  if (m.length === 0 || m[0].length === 0)
    return NaN;
  const b = dw(m).map((S) => S.map((u) => u.map((O) => Y_([O.x, O.y], d.canonical)))), M = new W_(b[0][0][0][1]);
  let z = 1 / 0;
  for (const S of o)
    for (const u of b) {
      switch (S.type) {
        case "Point":
          z = Math.min(z, Yg([S.coordinates], !1, u, M, z));
          break;
        case "LineString":
          z = Math.min(z, Yg(S.coordinates, !0, u, M, z));
          break;
        case "Polygon":
          z = Math.min(z, vw(u, S.coordinates, M, z));
          break;
      }
      if (z === 0)
        return z;
    }
  return z;
}
function r_(d) {
  return d.type === "MultiPolygon" ? d.coordinates.map((o) => ({
    type: "Polygon",
    coordinates: o
  })) : d.type === "MultiLineString" ? d.coordinates.map((o) => ({
    type: "LineString",
    coordinates: o
  })) : d.type === "MultiPoint" ? d.coordinates.map((o) => ({
    type: "Point",
    coordinates: o
  })) : [d];
}
class Bd {
  constructor(o, m) {
    this.type = bt, this.geojson = o, this.geometries = m;
  }
  static parse(o, m) {
    if (o.length !== 2)
      return m.error(`'distance' expression requires exactly one argument, but found ${o.length - 1} instead.`);
    if (Am(o[1])) {
      const b = o[1];
      if (b.type === "FeatureCollection")
        return new Bd(b, b.features.map((M) => r_(M.geometry)).flat());
      if (b.type === "Feature")
        return new Bd(b, r_(b.geometry));
      if ("type" in b && "coordinates" in b)
        return new Bd(b, r_(b));
    }
    return m.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(o) {
    if (o.geometry() != null && o.canonicalID() != null) {
      if (o.geometryType() === "Point")
        return xw(o, this.geometries);
      if (o.geometryType() === "LineString")
        return bw(o, this.geometries);
      if (o.geometryType() === "Polygon")
        return ww(o, this.geometries);
    }
    return NaN;
  }
  eachChild() {
  }
  outputDefined() {
    return !0;
  }
}
class Om {
  constructor(o) {
    this.type = yi, this.key = o;
  }
  static parse(o, m) {
    if (o.length !== 2)
      return m.error(`Expected 1 argument, but found ${o.length - 1} instead.`);
    const b = o[1];
    return b == null ? m.error("Global state property must be defined.") : typeof b != "string" ? m.error(`Global state property must be string, but found ${typeof o[1]} instead.`) : new Om(b);
  }
  evaluate(o) {
    var m;
    const b = (m = o.globals) === null || m === void 0 ? void 0 : m.globalState;
    return !b || Object.keys(b).length === 0 ? null : vm(b, this.key);
  }
  eachChild() {
  }
  outputDefined() {
    return !1;
  }
}
const e0 = {
  // special forms
  "==": $2,
  "!=": H2,
  ">": Y2,
  "<": X2,
  ">=": W2,
  "<=": K2,
  array: Ll,
  at: F_,
  boolean: Ll,
  case: G_,
  coalesce: Em,
  collator: fy,
  format: $_,
  image: H_,
  in: V_,
  "index-of": $g,
  interpolate: Pu,
  "interpolate-hcl": Pu,
  "interpolate-lab": Pu,
  length: X_,
  let: hy,
  literal: Wp,
  match: q_,
  number: Ll,
  "number-format": Z_,
  object: Ll,
  slice: Hg,
  step: py,
  string: Ll,
  "to-boolean": wh,
  "to-color": wh,
  "to-number": wh,
  "to-string": wh,
  var: dy,
  within: Od,
  distance: Bd,
  "global-state": Om
};
class Nl {
  constructor(o, m, b, M) {
    this.name = o, this.type = m, this._evaluate = b, this.args = M;
  }
  evaluate(o) {
    return this._evaluate(o, this.args);
  }
  eachChild(o) {
    this.args.forEach(o);
  }
  outputDefined() {
    return !1;
  }
  static parse(o, m) {
    const b = o[0], M = Nl.definitions[b];
    if (!M)
      return m.error(`Unknown expression "${b}". If you wanted a literal array, use ["literal", [...]].`, 0);
    const z = Array.isArray(M) ? M[0] : M.type, S = Array.isArray(M) ? [[M[1], M[2]]] : M.overloads, u = S.filter(([U]) => !Array.isArray(U) || // varags
    U.length === o.length - 1);
    let O = null;
    for (const [U, K] of u) {
      O = new cy(m.registry, Wg, m.path, null, m.scope);
      const ae = [];
      let he = !1;
      for (let J = 1; J < o.length; J++) {
        const ke = o[J], qe = Array.isArray(U) ? U[J - 1] : U.type, ft = O.parse(ke, 1 + ae.length, qe);
        if (!ft) {
          he = !0;
          break;
        }
        ae.push(ft);
      }
      if (!he) {
        if (Array.isArray(U) && U.length !== ae.length) {
          O.error(`Expected ${U.length} arguments, but found ${ae.length} instead.`);
          continue;
        }
        for (let J = 0; J < ae.length; J++) {
          const ke = Array.isArray(U) ? U[J] : U.type, qe = ae[J];
          O.concat(J + 1).checkSubtype(ke, qe.type);
        }
        if (O.errors.length === 0)
          return new Nl(b, z, K, ae);
      }
    }
    if (u.length === 1)
      m.errors.push(...O.errors);
    else {
      const U = (u.length ? u : S).map(([ae]) => Tw(ae)).join(" | "), K = [];
      for (let ae = 1; ae < o.length; ae++) {
        const he = m.parse(o[ae], 1 + K.length);
        if (!he)
          return null;
        K.push(Xn(he.type));
      }
      m.error(`Expected arguments of type ${U}, but found (${K.join(", ")}) instead.`);
    }
    return null;
  }
  static register(o, m) {
    Nl.definitions = m;
    for (const b in m)
      o[b] = Nl;
  }
}
function av(d, [o, m, b, M]) {
  o = o.evaluate(d), m = m.evaluate(d), b = b.evaluate(d);
  const z = M ? M.evaluate(d) : 1, S = lx(o, m, b, z);
  if (S)
    throw new sa(S);
  return new on(o / 255, m / 255, b / 255, z, !1);
}
function rv(d, o) {
  return d in o;
}
function s_(d, o) {
  const m = o[d];
  return typeof m > "u" ? null : m;
}
function Sw(d, o, m, b) {
  for (; m <= b; ) {
    const M = m + b >> 1;
    if (o[M] === d)
      return !0;
    o[M] > d ? b = M - 1 : m = M + 1;
  }
  return !1;
}
function Td(d) {
  return { type: d };
}
Nl.register(e0, {
  error: [
    y2,
    [Ei],
    (d, [o]) => {
      throw new sa(o.evaluate(d));
    }
  ],
  typeof: [
    Ei,
    [yi],
    (d, [o]) => Xn(Oa(o.evaluate(d)))
  ],
  "to-rgba": [
    lo(bt, 4),
    [Cu],
    (d, [o]) => {
      const [m, b, M, z] = o.evaluate(d).rgb;
      return [m * 255, b * 255, M * 255, z];
    }
  ],
  rgb: [
    Cu,
    [bt, bt, bt],
    av
  ],
  rgba: [
    Cu,
    [bt, bt, bt, bt],
    av
  ],
  has: {
    type: vi,
    overloads: [
      [
        [Ei],
        (d, [o]) => rv(o.evaluate(d), d.properties())
      ],
      [
        [Ei, Rd],
        (d, [o, m]) => rv(o.evaluate(d), m.evaluate(d))
      ]
    ]
  },
  get: {
    type: yi,
    overloads: [
      [
        [Ei],
        (d, [o]) => s_(o.evaluate(d), d.properties())
      ],
      [
        [Ei, Rd],
        (d, [o, m]) => s_(o.evaluate(d), m.evaluate(d))
      ]
    ]
  },
  "feature-state": [
    yi,
    [Ei],
    (d, [o]) => s_(o.evaluate(d), d.featureState || {})
  ],
  properties: [
    Rd,
    [],
    (d) => d.properties()
  ],
  "geometry-type": [
    Ei,
    [],
    (d) => d.geometryType()
  ],
  id: [
    yi,
    [],
    (d) => d.id()
  ],
  zoom: [
    bt,
    [],
    (d) => d.globals.zoom
  ],
  "heatmap-density": [
    bt,
    [],
    (d) => d.globals.heatmapDensity || 0
  ],
  elevation: [
    bt,
    [],
    (d) => d.globals.elevation || 0
  ],
  "line-progress": [
    bt,
    [],
    (d) => d.globals.lineProgress || 0
  ],
  accumulated: [
    yi,
    [],
    (d) => d.globals.accumulated === void 0 ? null : d.globals.accumulated
  ],
  "+": [
    bt,
    Td(bt),
    (d, o) => {
      let m = 0;
      for (const b of o)
        m += b.evaluate(d);
      return m;
    }
  ],
  "*": [
    bt,
    Td(bt),
    (d, o) => {
      let m = 1;
      for (const b of o)
        m *= b.evaluate(d);
      return m;
    }
  ],
  "-": {
    type: bt,
    overloads: [
      [
        [bt, bt],
        (d, [o, m]) => o.evaluate(d) - m.evaluate(d)
      ],
      [
        [bt],
        (d, [o]) => -o.evaluate(d)
      ]
    ]
  },
  "/": [
    bt,
    [bt, bt],
    (d, [o, m]) => o.evaluate(d) / m.evaluate(d)
  ],
  "%": [
    bt,
    [bt, bt],
    (d, [o, m]) => o.evaluate(d) % m.evaluate(d)
  ],
  ln2: [
    bt,
    [],
    () => Math.LN2
  ],
  pi: [
    bt,
    [],
    () => Math.PI
  ],
  e: [
    bt,
    [],
    () => Math.E
  ],
  "^": [
    bt,
    [bt, bt],
    (d, [o, m]) => Math.pow(o.evaluate(d), m.evaluate(d))
  ],
  sqrt: [
    bt,
    [bt],
    (d, [o]) => Math.sqrt(o.evaluate(d))
  ],
  log10: [
    bt,
    [bt],
    (d, [o]) => Math.log(o.evaluate(d)) / Math.LN10
  ],
  ln: [
    bt,
    [bt],
    (d, [o]) => Math.log(o.evaluate(d))
  ],
  log2: [
    bt,
    [bt],
    (d, [o]) => Math.log(o.evaluate(d)) / Math.LN2
  ],
  sin: [
    bt,
    [bt],
    (d, [o]) => Math.sin(o.evaluate(d))
  ],
  cos: [
    bt,
    [bt],
    (d, [o]) => Math.cos(o.evaluate(d))
  ],
  tan: [
    bt,
    [bt],
    (d, [o]) => Math.tan(o.evaluate(d))
  ],
  asin: [
    bt,
    [bt],
    (d, [o]) => Math.asin(o.evaluate(d))
  ],
  acos: [
    bt,
    [bt],
    (d, [o]) => Math.acos(o.evaluate(d))
  ],
  atan: [
    bt,
    [bt],
    (d, [o]) => Math.atan(o.evaluate(d))
  ],
  min: [
    bt,
    Td(bt),
    (d, o) => Math.min(...o.map((m) => m.evaluate(d)))
  ],
  max: [
    bt,
    Td(bt),
    (d, o) => Math.max(...o.map((m) => m.evaluate(d)))
  ],
  abs: [
    bt,
    [bt],
    (d, [o]) => Math.abs(o.evaluate(d))
  ],
  round: [
    bt,
    [bt],
    (d, [o]) => {
      const m = o.evaluate(d);
      return m < 0 ? -Math.round(-m) : Math.round(m);
    }
  ],
  floor: [
    bt,
    [bt],
    (d, [o]) => Math.floor(o.evaluate(d))
  ],
  ceil: [
    bt,
    [bt],
    (d, [o]) => Math.ceil(o.evaluate(d))
  ],
  "filter-==": [
    vi,
    [Ei, yi],
    (d, [o, m]) => d.properties()[o.value] === m.value
  ],
  "filter-id-==": [
    vi,
    [yi],
    (d, [o]) => d.id() === o.value
  ],
  "filter-type-==": [
    vi,
    [Ei],
    (d, [o]) => d.geometryType() === o.value
  ],
  "filter-<": [
    vi,
    [Ei, yi],
    (d, [o, m]) => {
      const b = d.properties()[o.value], M = m.value;
      return typeof b == typeof M && b < M;
    }
  ],
  "filter-id-<": [
    vi,
    [yi],
    (d, [o]) => {
      const m = d.id(), b = o.value;
      return typeof m == typeof b && m < b;
    }
  ],
  "filter->": [
    vi,
    [Ei, yi],
    (d, [o, m]) => {
      const b = d.properties()[o.value], M = m.value;
      return typeof b == typeof M && b > M;
    }
  ],
  "filter-id->": [
    vi,
    [yi],
    (d, [o]) => {
      const m = d.id(), b = o.value;
      return typeof m == typeof b && m > b;
    }
  ],
  "filter-<=": [
    vi,
    [Ei, yi],
    (d, [o, m]) => {
      const b = d.properties()[o.value], M = m.value;
      return typeof b == typeof M && b <= M;
    }
  ],
  "filter-id-<=": [
    vi,
    [yi],
    (d, [o]) => {
      const m = d.id(), b = o.value;
      return typeof m == typeof b && m <= b;
    }
  ],
  "filter->=": [
    vi,
    [Ei, yi],
    (d, [o, m]) => {
      const b = d.properties()[o.value], M = m.value;
      return typeof b == typeof M && b >= M;
    }
  ],
  "filter-id->=": [
    vi,
    [yi],
    (d, [o]) => {
      const m = d.id(), b = o.value;
      return typeof m == typeof b && m >= b;
    }
  ],
  "filter-has": [
    vi,
    [yi],
    (d, [o]) => o.value in d.properties()
  ],
  "filter-has-id": [
    vi,
    [],
    (d) => d.id() !== null && d.id() !== void 0
  ],
  "filter-type-in": [
    vi,
    [lo(Ei)],
    (d, [o]) => o.value.indexOf(d.geometryType()) >= 0
  ],
  "filter-id-in": [
    vi,
    [lo(yi)],
    (d, [o]) => o.value.indexOf(d.id()) >= 0
  ],
  "filter-in-small": [
    vi,
    [Ei, lo(yi)],
    // assumes v is an array literal
    (d, [o, m]) => m.value.indexOf(d.properties()[o.value]) >= 0
  ],
  "filter-in-large": [
    vi,
    [Ei, lo(yi)],
    // assumes v is a array literal with values sorted in ascending order and of a single type
    (d, [o, m]) => Sw(d.properties()[o.value], m.value, 0, m.value.length - 1)
  ],
  all: {
    type: vi,
    overloads: [
      [
        [vi, vi],
        (d, [o, m]) => o.evaluate(d) && m.evaluate(d)
      ],
      [
        Td(vi),
        (d, o) => {
          for (const m of o)
            if (!m.evaluate(d))
              return !1;
          return !0;
        }
      ]
    ]
  },
  any: {
    type: vi,
    overloads: [
      [
        [vi, vi],
        (d, [o, m]) => o.evaluate(d) || m.evaluate(d)
      ],
      [
        Td(vi),
        (d, o) => {
          for (const m of o)
            if (m.evaluate(d))
              return !0;
          return !1;
        }
      ]
    ]
  },
  "!": [
    vi,
    [vi],
    (d, [o]) => !o.evaluate(d)
  ],
  "is-supported-script": [
    vi,
    [Ei],
    // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
    (d, [o]) => {
      const m = d.globals && d.globals.isSupportedScript;
      return m ? m(o.evaluate(d)) : !0;
    }
  ],
  upcase: [
    Ei,
    [Ei],
    (d, [o]) => o.evaluate(d).toUpperCase()
  ],
  downcase: [
    Ei,
    [Ei],
    (d, [o]) => o.evaluate(d).toLowerCase()
  ],
  concat: [
    Ei,
    Td(yi),
    (d, o) => o.map((m) => xm(m.evaluate(d))).join("")
  ],
  "resolved-locale": [
    Ei,
    [ry],
    (d, [o]) => o.evaluate(d).resolvedLocale()
  ]
});
function Tw(d) {
  return Array.isArray(d) ? `(${d.map(Xn).join(", ")})` : `(${Xn(d.type)}...)`;
}
function Wg(d) {
  if (d instanceof dy)
    return Wg(d.boundExpression);
  if (d instanceof Nl && d.name === "error" || d instanceof fy || d instanceof Od || d instanceof Bd || d instanceof Om)
    return !1;
  const o = d instanceof wh || d instanceof Ll;
  let m = !0;
  return d.eachChild((b) => {
    o ? m = m && Wg(b) : m = m && b instanceof Wp;
  }), m ? gy(d) && yy(d, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]) : !1;
}
function gy(d) {
  if (d instanceof Nl && (d.name === "get" && d.args.length === 1 || d.name === "feature-state" || d.name === "has" && d.args.length === 1 || d.name === "properties" || d.name === "geometry-type" || d.name === "id" || /^filter-/.test(d.name)) || d instanceof Od || d instanceof Bd)
    return !1;
  let o = !0;
  return d.eachChild((m) => {
    o && !gy(m) && (o = !1);
  }), o;
}
function zm(d) {
  if (d instanceof Nl && d.name === "feature-state")
    return !1;
  let o = !0;
  return d.eachChild((m) => {
    o && !zm(m) && (o = !1);
  }), o;
}
function yy(d, o) {
  if (d instanceof Nl && o.indexOf(d.name) >= 0)
    return !1;
  let m = !0;
  return d.eachChild((b) => {
    m && !yy(b, o) && (m = !1);
  }), m;
}
function C_(d) {
  return { result: "success", value: d };
}
function Hp(d) {
  return { result: "error", value: d };
}
function Jg(d) {
  return d["property-type"] === "data-driven" || d["property-type"] === "cross-faded-data-driven";
}
function _x(d) {
  return !!d.expression && d.expression.parameters.indexOf("zoom") > -1;
}
function vx(d) {
  return !!d.expression && d.expression.interpolated;
}
function Di(d) {
  return d instanceof Number ? "number" : d instanceof String ? "string" : d instanceof Boolean ? "boolean" : Array.isArray(d) ? "array" : d === null ? "null" : typeof d;
}
function t0(d) {
  return typeof d == "object" && d !== null && !Array.isArray(d) && Oa(d) === Rd;
}
class Mw {
  constructor(o, m) {
    this.expression = o, this._warningHistory = {}, this._evaluator = new ux(), this._defaultValue = m ? Cw(m) : null, this._enumValues = m && m.type === "enum" ? m.values : null;
  }
  evaluateWithoutErrorHandling(o, m, b, M, z, S) {
    return this._evaluator.globals = o, this._evaluator.feature = m, this._evaluator.featureState = b, this._evaluator.canonical = M, this._evaluator.availableImages = z || null, this._evaluator.formattedSection = S, this.expression.evaluate(this._evaluator);
  }
  evaluate(o, m, b, M, z, S) {
    this._evaluator.globals = o, this._evaluator.feature = m || null, this._evaluator.featureState = b || null, this._evaluator.canonical = M, this._evaluator.availableImages = z || null, this._evaluator.formattedSection = S || null;
    try {
      const u = this.expression.evaluate(this._evaluator);
      if (u == null || typeof u == "number" && u !== u)
        return this._defaultValue;
      if (this._enumValues && !(u in this._enumValues))
        throw new sa(`Expected value to be one of ${Object.keys(this._enumValues).map((O) => JSON.stringify(O)).join(", ")}, but found ${JSON.stringify(u)} instead.`);
      return u;
    } catch (u) {
      return this._warningHistory[u.message] || (this._warningHistory[u.message] = !0, typeof console < "u" && console.warn(u.message)), this._defaultValue;
    }
  }
}
function xx(d) {
  return Array.isArray(d) && d.length > 0 && typeof d[0] == "string" && d[0] in e0;
}
function bx(d, o) {
  const m = new cy(e0, Wg, [], o ? Ew(o) : void 0), b = m.parse(d, void 0, void 0, void 0, o && o.type === "string" ? { typeAnnotation: "coerce" } : void 0);
  return b ? C_(new Mw(b, o)) : Hp(m.errors);
}
class sv {
  constructor(o, m) {
    this.kind = o, this._styleExpression = m, this.isStateDependent = o !== "constant" && !zm(m.expression), this.globalStateRefs = i0(m.expression);
  }
  evaluateWithoutErrorHandling(o, m, b, M, z, S) {
    return this._styleExpression.evaluateWithoutErrorHandling(o, m, b, M, z, S);
  }
  evaluate(o, m, b, M, z, S) {
    return this._styleExpression.evaluate(o, m, b, M, z, S);
  }
}
class ov {
  constructor(o, m, b, M) {
    this.kind = o, this.zoomStops = b, this._styleExpression = m, this.isStateDependent = o !== "camera" && !zm(m.expression), this.globalStateRefs = i0(m.expression), this.interpolationType = M;
  }
  evaluateWithoutErrorHandling(o, m, b, M, z, S) {
    return this._styleExpression.evaluateWithoutErrorHandling(o, m, b, M, z, S);
  }
  evaluate(o, m, b, M, z, S) {
    return this._styleExpression.evaluate(o, m, b, M, z, S);
  }
  interpolationFactor(o, m, b) {
    return this.interpolationType ? Pu.interpolationFactor(this.interpolationType, o, m, b) : 0;
  }
}
function Aw(d, o) {
  const m = bx(d, o);
  if (m.result === "error")
    return m;
  const b = m.value.expression, M = gy(b);
  if (!M && !Jg(o))
    return Hp([new Au("", "data expressions not supported")]);
  const z = yy(b, ["zoom"]);
  if (!z && !_x(o))
    return Hp([new Au("", "zoom expressions not supported")]);
  const S = Ng(b);
  if (!S && !z)
    return Hp([new Au("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  if (S instanceof Au)
    return Hp([S]);
  if (S instanceof Pu && !vx(o))
    return Hp([new Au("", '"interpolate" expressions cannot be used with this property')]);
  if (!S)
    return C_(M ? new sv("constant", m.value) : new sv("source", m.value));
  const u = S instanceof Pu ? S.interpolation : void 0;
  return C_(M ? new ov("camera", m.value, S.labels, u) : new ov("composite", m.value, S.labels, u));
}
function Ng(d) {
  let o = null;
  if (d instanceof hy)
    o = Ng(d.result);
  else if (d instanceof Em) {
    for (const m of d.args)
      if (o = Ng(m), o)
        break;
  } else (d instanceof py || d instanceof Pu) && d.input instanceof Nl && d.input.name === "zoom" && (o = d);
  return o instanceof Au || d.eachChild((m) => {
    const b = Ng(m);
    b instanceof Au ? o = b : !o && b ? o = new Au("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : o && b && o !== b && (o = new Au("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
  }), o;
}
function i0(d, o = /* @__PURE__ */ new Set()) {
  return d instanceof Om && o.add(d.key), d.eachChild((m) => {
    i0(m, o);
  }), o;
}
function Ew(d) {
  const o = {
    color: Cu,
    string: Ei,
    number: bt,
    enum: Ei,
    boolean: vi,
    formatted: sy,
    padding: oy,
    numberArray: ly,
    colorArray: Sm,
    projectionDefinition: ay,
    resolvedImage: Dm,
    variableAnchorOffsetCollection: uy
  };
  return d.type === "array" ? lo(o[d.value] || yi, d.length) : o[d.type];
}
function Cw(d) {
  if (d.type === "color" && t0(d.default))
    return new on(0, 0, 0, 0);
  switch (d.type) {
    case "color":
      return on.parse(d.default) || null;
    case "padding":
      return Ol.parse(d.default) || null;
    case "numberArray":
      return Bl.parse(d.default) || null;
    case "colorArray":
      return uo.parse(d.default) || null;
    case "variableAnchorOffsetCollection":
      return zu.parse(d.default) || null;
    case "projectionDefinition":
      return Dl.parse(d.default) || null;
    default:
      return d.default === void 0 ? null : d.default;
  }
}
function wx(d) {
  if (d === !0 || d === !1)
    return !0;
  if (!Array.isArray(d) || d.length === 0)
    return !1;
  switch (d[0]) {
    case "has":
      return d.length >= 2 && d[1] !== "$id" && d[1] !== "$type";
    case "in":
      return d.length >= 3 && (typeof d[1] != "string" || Array.isArray(d[2]));
    case "!in":
    case "!has":
    case "none":
      return !1;
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return d.length !== 3 || Array.isArray(d[1]) || Array.isArray(d[2]);
    case "any":
    case "all":
      for (const o of d.slice(1))
        if (!wx(o) && typeof o != "boolean")
          return !1;
      return !0;
    default:
      return !0;
  }
}
function Sx(d) {
  const o = d.key, m = d.value;
  return m ? [new _t(o, m, "constants have been deprecated as of v8")] : [];
}
function fa(d) {
  return d instanceof Number || d instanceof String || d instanceof Boolean ? d.valueOf() : d;
}
function Ud(d) {
  if (Array.isArray(d))
    return d.map(Ud);
  if (d instanceof Object && !(d instanceof Number || d instanceof String || d instanceof Boolean)) {
    const o = {};
    for (const m in d)
      o[m] = Ud(d[m]);
    return o;
  }
  return fa(d);
}
function Qo(d) {
  const o = d.key, m = d.value, b = d.valueSpec || {}, M = d.objectElementValidators || {}, z = d.style, S = d.styleSpec, u = d.validateSpec;
  let O = [];
  const U = Di(m);
  if (U !== "object")
    return [new _t(o, m, `object expected, ${U} found`)];
  for (const K in m) {
    const ae = K.split(".")[0], he = vm(b, ae) || b["*"];
    let J;
    if (vm(M, ae))
      J = M[ae];
    else if (vm(b, ae))
      J = u;
    else if (M["*"])
      J = M["*"];
    else if (b["*"])
      J = u;
    else {
      O.push(new _t(o, m[K], `unknown property "${K}"`));
      continue;
    }
    O = O.concat(J({
      key: (o && `${o}.`) + K,
      value: m[K],
      valueSpec: he,
      style: z,
      styleSpec: S,
      object: m,
      objectKey: K,
      validateSpec: u
    }, m));
  }
  for (const K in b)
    M[K] || b[K].required && b[K].default === void 0 && m[K] === void 0 && O.push(new _t(o, m, `missing required property "${K}"`));
  return O;
}
function n0(d) {
  const o = d.value, m = d.valueSpec, b = d.validateSpec, M = d.style, z = d.styleSpec, S = d.key, u = d.arrayElementValidator || b;
  if (Di(o) !== "array")
    return [new _t(S, o, `array expected, ${Di(o)} found`)];
  if (m.length && o.length !== m.length)
    return [new _t(S, o, `array length ${m.length} expected, length ${o.length} found`)];
  if (m["min-length"] && o.length < m["min-length"])
    return [new _t(S, o, `array length at least ${m["min-length"]} expected, length ${o.length} found`)];
  let O = {
    type: m.value,
    values: m.values
  };
  z.$version < 7 && (O.function = m.function), Di(m.value) === "object" && (O = m.value);
  let U = [];
  for (let K = 0; K < o.length; K++)
    U = U.concat(u({
      array: o,
      arrayIndex: K,
      value: o[K],
      valueSpec: O,
      validateSpec: d.validateSpec,
      style: M,
      styleSpec: z,
      key: `${S}[${K}]`
    }));
  return U;
}
function _y(d) {
  const o = d.key, m = d.value, b = d.valueSpec;
  let M = Di(m);
  return M === "number" && m !== m && (M = "NaN"), M !== "number" ? [new _t(o, m, `number expected, ${M} found`)] : "minimum" in b && m < b.minimum ? [new _t(o, m, `${m} is less than the minimum value ${b.minimum}`)] : "maximum" in b && m > b.maximum ? [new _t(o, m, `${m} is greater than the maximum value ${b.maximum}`)] : [];
}
function Tx(d) {
  const o = d.valueSpec, m = fa(d.value.type);
  let b, M = {}, z, S;
  const u = m !== "categorical" && d.value.property === void 0, O = !u, U = Di(d.value.stops) === "array" && Di(d.value.stops[0]) === "array" && Di(d.value.stops[0][0]) === "object", K = Qo({
    key: d.key,
    value: d.value,
    valueSpec: d.styleSpec.function,
    validateSpec: d.validateSpec,
    style: d.style,
    styleSpec: d.styleSpec,
    objectElementValidators: {
      stops: ae,
      default: ke
    }
  });
  return m === "identity" && u && K.push(new _t(d.key, d.value, 'missing required property "property"')), m !== "identity" && !d.value.stops && K.push(new _t(d.key, d.value, 'missing required property "stops"')), m === "exponential" && d.valueSpec.expression && !vx(d.valueSpec) && K.push(new _t(d.key, d.value, "exponential functions not supported")), d.styleSpec.$version >= 8 && (O && !Jg(d.valueSpec) ? K.push(new _t(d.key, d.value, "property functions not supported")) : u && !_x(d.valueSpec) && K.push(new _t(d.key, d.value, "zoom functions not supported"))), (m === "categorical" || U) && d.value.property === void 0 && K.push(new _t(d.key, d.value, '"property" property is required')), K;
  function ae(qe) {
    if (m === "identity")
      return [new _t(qe.key, qe.value, 'identity function may not have a "stops" property')];
    let ft = [];
    const ht = qe.value;
    return ft = ft.concat(n0({
      key: qe.key,
      value: ht,
      valueSpec: qe.valueSpec,
      validateSpec: qe.validateSpec,
      style: qe.style,
      styleSpec: qe.styleSpec,
      arrayElementValidator: he
    })), Di(ht) === "array" && ht.length === 0 && ft.push(new _t(qe.key, ht, "array must have at least one stop")), ft;
  }
  function he(qe) {
    let ft = [];
    const ht = qe.value, it = qe.key;
    if (Di(ht) !== "array")
      return [new _t(it, ht, `array expected, ${Di(ht)} found`)];
    if (ht.length !== 2)
      return [new _t(it, ht, `array length 2 expected, length ${ht.length} found`)];
    if (U) {
      if (Di(ht[0]) !== "object")
        return [new _t(it, ht, `object expected, ${Di(ht[0])} found`)];
      if (ht[0].zoom === void 0)
        return [new _t(it, ht, "object stop key must have zoom")];
      if (ht[0].value === void 0)
        return [new _t(it, ht, "object stop key must have value")];
      if (S && S > fa(ht[0].zoom))
        return [new _t(it, ht[0].zoom, "stop zoom values must appear in ascending order")];
      fa(ht[0].zoom) !== S && (S = fa(ht[0].zoom), z = void 0, M = {}), ft = ft.concat(Qo({
        key: `${it}[0]`,
        value: ht[0],
        valueSpec: { zoom: {} },
        validateSpec: qe.validateSpec,
        style: qe.style,
        styleSpec: qe.styleSpec,
        objectElementValidators: { zoom: _y, value: J }
      }));
    } else
      ft = ft.concat(J({
        key: `${it}[0]`,
        value: ht[0],
        validateSpec: qe.validateSpec,
        style: qe.style,
        styleSpec: qe.styleSpec
      }, ht));
    return xx(Ud(ht[1])) ? ft.concat([new _t(`${it}[1]`, ht[1], "expressions are not allowed in function stops.")]) : ft.concat(qe.validateSpec({
      key: `${it}[1]`,
      value: ht[1],
      valueSpec: o,
      validateSpec: qe.validateSpec,
      style: qe.style,
      styleSpec: qe.styleSpec
    }));
  }
  function J(qe, ft) {
    const ht = Di(qe.value), it = fa(qe.value), nt = qe.value !== null ? qe.value : ft;
    if (!b)
      b = ht;
    else if (ht !== b)
      return [new _t(qe.key, nt, `${ht} stop domain type must match previous stop domain type ${b}`)];
    if (ht !== "number" && ht !== "string" && ht !== "boolean")
      return [new _t(qe.key, nt, "stop domain value must be a number, string, or boolean")];
    if (ht !== "number" && m !== "categorical") {
      let De = `number expected, ${ht} found`;
      return Jg(o) && m === void 0 && (De += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new _t(qe.key, nt, De)];
    }
    return m === "categorical" && ht === "number" && (!isFinite(it) || Math.floor(it) !== it) ? [new _t(qe.key, nt, `integer expected, found ${it}`)] : m !== "categorical" && ht === "number" && z !== void 0 && it < z ? [new _t(qe.key, nt, "stop domain values must appear in ascending order")] : (z = it, m === "categorical" && it in M ? [new _t(qe.key, nt, "stop domain values must be unique")] : (M[it] = !0, []));
  }
  function ke(qe) {
    return qe.validateSpec({
      key: qe.key,
      value: qe.value,
      valueSpec: o,
      validateSpec: qe.validateSpec,
      style: qe.style,
      styleSpec: qe.styleSpec
    });
  }
}
function Jp(d) {
  const o = (d.expressionContext === "property" ? Aw : bx)(Ud(d.value), d.valueSpec);
  if (o.result === "error")
    return o.value.map((b) => new _t(`${d.key}${b.key}`, d.value, b.message));
  const m = o.value.expression || o.value._styleExpression.expression;
  if (d.expressionContext === "property" && d.propertyKey === "text-font" && !m.outputDefined())
    return [new _t(d.key, d.value, `Invalid data expression for "${d.propertyKey}". Output values must be contained as literals within the expression.`)];
  if (d.expressionContext === "property" && d.propertyType === "layout" && !zm(m))
    return [new _t(d.key, d.value, '"feature-state" data expressions are not supported with layout properties.')];
  if (d.expressionContext === "filter" && !zm(m))
    return [new _t(d.key, d.value, '"feature-state" data expressions are not supported with filters.')];
  if (d.expressionContext && d.expressionContext.indexOf("cluster") === 0) {
    if (!yy(m, ["zoom", "feature-state"]))
      return [new _t(d.key, d.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
    if (d.expressionContext === "cluster-initial" && !gy(m))
      return [new _t(d.key, d.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
  }
  return [];
}
function zw(d) {
  const o = d.value, m = d.key, b = Di(o);
  return b !== "boolean" ? [new _t(m, o, `boolean expected, ${b} found`)] : [];
}
function z_(d) {
  const o = d.key, m = d.value, b = Di(m);
  return b !== "string" ? [new _t(o, m, `color expected, ${b} found`)] : on.parse(String(m)) ? [] : [new _t(o, m, `color expected, "${m}" found`)];
}
function Pm(d) {
  const o = d.key, m = d.value, b = d.valueSpec, M = [];
  return Array.isArray(b.values) ? b.values.indexOf(fa(m)) === -1 && M.push(new _t(o, m, `expected one of [${b.values.join(", ")}], ${JSON.stringify(m)} found`)) : Object.keys(b.values).indexOf(fa(m)) === -1 && M.push(new _t(o, m, `expected one of [${Object.keys(b.values).join(", ")}], ${JSON.stringify(m)} found`)), M;
}
function a0(d) {
  return wx(Ud(d.value)) ? Jp(Zg({}, d, {
    expressionContext: "filter",
    valueSpec: { value: "boolean" }
  })) : Mx(d);
}
function Mx(d) {
  const o = d.value, m = d.key;
  if (Di(o) !== "array")
    return [new _t(m, o, `array expected, ${Di(o)} found`)];
  const b = d.styleSpec;
  let M, z = [];
  if (o.length < 1)
    return [new _t(m, o, "filter array must have at least 1 element")];
  switch (z = z.concat(Pm({
    key: `${m}[0]`,
    value: o[0],
    valueSpec: b.filter_operator,
    style: d.style,
    styleSpec: d.styleSpec
  })), fa(o[0])) {
    case "<":
    case "<=":
    case ">":
    case ">=":
      o.length >= 2 && fa(o[1]) === "$type" && z.push(new _t(m, o, `"$type" cannot be use with operator "${o[0]}"`));
    /* falls through */
    case "==":
    case "!=":
      o.length !== 3 && z.push(new _t(m, o, `filter array for operator "${o[0]}" must have 3 elements`));
    /* falls through */
    case "in":
    case "!in":
      o.length >= 2 && (M = Di(o[1]), M !== "string" && z.push(new _t(`${m}[1]`, o[1], `string expected, ${M} found`)));
      for (let S = 2; S < o.length; S++)
        M = Di(o[S]), fa(o[1]) === "$type" ? z = z.concat(Pm({
          key: `${m}[${S}]`,
          value: o[S],
          valueSpec: b.geometry_type,
          style: d.style,
          styleSpec: d.styleSpec
        })) : M !== "string" && M !== "number" && M !== "boolean" && z.push(new _t(`${m}[${S}]`, o[S], `string, number, or boolean expected, ${M} found`));
      break;
    case "any":
    case "all":
    case "none":
      for (let S = 1; S < o.length; S++)
        z = z.concat(Mx({
          key: `${m}[${S}]`,
          value: o[S],
          style: d.style,
          styleSpec: d.styleSpec
        }));
      break;
    case "has":
    case "!has":
      M = Di(o[1]), o.length !== 2 ? z.push(new _t(m, o, `filter array for "${o[0]}" operator must have 2 elements`)) : M !== "string" && z.push(new _t(`${m}[1]`, o[1], `string expected, ${M} found`));
      break;
  }
  return z;
}
function Ax(d, o) {
  const m = d.key, b = d.validateSpec, M = d.style, z = d.styleSpec, S = d.value, u = d.objectKey, O = z[`${o}_${d.layerType}`];
  if (!O)
    return [];
  const U = u.match(/^(.*)-transition$/);
  if (o === "paint" && U && O[U[1]] && O[U[1]].transition)
    return b({
      key: m,
      value: S,
      valueSpec: z.transition,
      style: M,
      styleSpec: z
    });
  const K = d.valueSpec || O[u];
  if (!K)
    return [new _t(m, S, `unknown property "${u}"`)];
  let ae;
  if (Di(S) === "string" && Jg(K) && !K.tokens && (ae = /^{([^}]+)}$/.exec(S)))
    return [new _t(m, S, `"${u}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(ae[1])} }\`.`)];
  const he = [];
  return d.layerType === "symbol" && (u === "text-field" && M && !M.glyphs && he.push(new _t(m, S, 'use of "text-field" requires a style "glyphs" property')), u === "text-font" && t0(Ud(S)) && fa(S.type) === "identity" && he.push(new _t(m, S, '"text-font" does not support identity functions'))), he.concat(b({
    key: d.key,
    value: S,
    valueSpec: K,
    style: M,
    styleSpec: z,
    expressionContext: "property",
    propertyType: o,
    propertyKey: u
  }));
}
function Ex(d) {
  return Ax(d, "paint");
}
function Cx(d) {
  return Ax(d, "layout");
}
function zx(d) {
  let o = [];
  const m = d.value, b = d.key, M = d.style, z = d.styleSpec;
  if (Di(m) !== "object")
    return [new _t(b, m, `object expected, ${Di(m)} found`)];
  !m.type && !m.ref && o.push(new _t(b, m, 'either "type" or "ref" is required'));
  let S = fa(m.type);
  const u = fa(m.ref);
  if (m.id) {
    const O = fa(m.id);
    for (let U = 0; U < d.arrayIndex; U++) {
      const K = M.layers[U];
      fa(K.id) === O && o.push(new _t(b, m.id, `duplicate layer id "${m.id}", previously used at line ${K.id.__line__}`));
    }
  }
  if ("ref" in m) {
    ["type", "source", "source-layer", "filter", "layout"].forEach((U) => {
      U in m && o.push(new _t(b, m[U], `"${U}" is prohibited for ref layers`));
    });
    let O;
    M.layers.forEach((U) => {
      fa(U.id) === u && (O = U);
    }), O ? O.ref ? o.push(new _t(b, m.ref, "ref cannot reference another ref layer")) : S = fa(O.type) : o.push(new _t(b, m.ref, `ref layer "${u}" not found`));
  } else if (S !== "background")
    if (!m.source)
      o.push(new _t(b, m, 'missing required property "source"'));
    else {
      const O = M.sources && M.sources[m.source], U = O && fa(O.type);
      O ? U === "vector" && S === "raster" ? o.push(new _t(b, m.source, `layer "${m.id}" requires a raster source`)) : U !== "raster-dem" && S === "hillshade" ? o.push(new _t(b, m.source, `layer "${m.id}" requires a raster-dem source`)) : U !== "raster-dem" && S === "color-relief" ? o.push(new _t(b, m.source, `layer "${m.id}" requires a raster-dem source`)) : U === "raster" && S !== "raster" ? o.push(new _t(b, m.source, `layer "${m.id}" requires a vector source`)) : U === "vector" && !m["source-layer"] ? o.push(new _t(b, m, `layer "${m.id}" must specify a "source-layer"`)) : U === "raster-dem" && S !== "hillshade" && S !== "color-relief" ? o.push(new _t(b, m.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : S === "line" && m.paint && m.paint["line-gradient"] && (U !== "geojson" || !O.lineMetrics) && o.push(new _t(b, m, `layer "${m.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : o.push(new _t(b, m.source, `source "${m.source}" not found`));
    }
  return o = o.concat(Qo({
    key: b,
    value: m,
    valueSpec: z.layer,
    style: d.style,
    styleSpec: d.styleSpec,
    validateSpec: d.validateSpec,
    objectElementValidators: {
      "*"() {
        return [];
      },
      // We don't want to enforce the spec's `"requires": true` for backward compatibility with refs;
      // the actual requirement is validated above. See https://github.com/mapbox/mapbox-gl-js/issues/5772.
      type() {
        return d.validateSpec({
          key: `${b}.type`,
          value: m.type,
          valueSpec: z.layer.type,
          style: d.style,
          styleSpec: d.styleSpec,
          validateSpec: d.validateSpec,
          object: m,
          objectKey: "type"
        });
      },
      filter: a0,
      layout(O) {
        return Qo({
          layer: m,
          key: O.key,
          value: O.value,
          style: O.style,
          styleSpec: O.styleSpec,
          validateSpec: O.validateSpec,
          objectElementValidators: {
            "*"(U) {
              return Cx(Zg({ layerType: S }, U));
            }
          }
        });
      },
      paint(O) {
        return Qo({
          layer: m,
          key: O.key,
          value: O.value,
          style: O.style,
          styleSpec: O.styleSpec,
          validateSpec: O.validateSpec,
          objectElementValidators: {
            "*"(U) {
              return Ex(Zg({ layerType: S }, U));
            }
          }
        });
      }
    }
  })), o;
}
function Fd(d) {
  const o = d.value, m = d.key, b = Di(o);
  return b !== "string" ? [new _t(m, o, `string expected, ${b} found`)] : [];
}
function Pw(d) {
  var o;
  const m = (o = d.sourceName) !== null && o !== void 0 ? o : "", b = d.value, M = d.styleSpec, z = M.source_raster_dem, S = d.style;
  let u = [];
  const O = Di(b);
  if (b === void 0)
    return u;
  if (O !== "object")
    return u.push(new _t("source_raster_dem", b, `object expected, ${O} found`)), u;
  const U = fa(b.encoding) === "custom", K = ["redFactor", "greenFactor", "blueFactor", "baseShift"], ae = d.value.encoding ? `"${d.value.encoding}"` : "Default";
  for (const he in b)
    !U && K.includes(he) ? u.push(new _t(he, b[he], `In "${m}": "${he}" is only valid when "encoding" is set to "custom". ${ae} encoding found`)) : z[he] ? u = u.concat(d.validateSpec({
      key: he,
      value: b[he],
      valueSpec: z[he],
      validateSpec: d.validateSpec,
      style: S,
      styleSpec: M
    })) : u.push(new _t(he, b[he], `unknown property "${he}"`));
  return u;
}
const lv = {
  promoteId: Iw
};
function Px(d) {
  const o = d.value, m = d.key, b = d.styleSpec, M = d.style, z = d.validateSpec;
  if (!o.type)
    return [new _t(m, o, '"type" is required')];
  const S = fa(o.type);
  let u;
  switch (S) {
    case "vector":
    case "raster":
      return u = Qo({
        key: m,
        value: o,
        valueSpec: b[`source_${S.replace("-", "_")}`],
        style: d.style,
        styleSpec: b,
        objectElementValidators: lv,
        validateSpec: z
      }), u;
    case "raster-dem":
      return u = Pw({
        sourceName: m,
        value: o,
        style: d.style,
        styleSpec: b,
        validateSpec: z
      }), u;
    case "geojson":
      if (u = Qo({
        key: m,
        value: o,
        valueSpec: b.source_geojson,
        style: M,
        styleSpec: b,
        validateSpec: z,
        objectElementValidators: lv
      }), o.cluster)
        for (const O in o.clusterProperties) {
          const [U, K] = o.clusterProperties[O], ae = typeof U == "string" ? [U, ["accumulated"], ["get", O]] : U;
          u.push(...Jp({
            key: `${m}.${O}.map`,
            value: K,
            expressionContext: "cluster-map"
          })), u.push(...Jp({
            key: `${m}.${O}.reduce`,
            value: ae,
            expressionContext: "cluster-reduce"
          }));
        }
      return u;
    case "video":
      return Qo({
        key: m,
        value: o,
        valueSpec: b.source_video,
        style: M,
        validateSpec: z,
        styleSpec: b
      });
    case "image":
      return Qo({
        key: m,
        value: o,
        valueSpec: b.source_image,
        style: M,
        validateSpec: z,
        styleSpec: b
      });
    case "canvas":
      return [new _t(m, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
    default:
      return Pm({
        key: `${m}.type`,
        value: o.type,
        valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }
      });
  }
}
function Iw({ key: d, value: o }) {
  if (Di(o) === "string")
    return Fd({ key: d, value: o });
  {
    const m = [];
    for (const b in o)
      m.push(...Fd({ key: `${d}.${b}`, value: o[b] }));
    return m;
  }
}
function Ix(d) {
  const o = d.value, m = d.styleSpec, b = m.light, M = d.style;
  let z = [];
  const S = Di(o);
  if (o === void 0)
    return z;
  if (S !== "object")
    return z = z.concat([new _t("light", o, `object expected, ${S} found`)]), z;
  for (const u in o) {
    const O = u.match(/^(.*)-transition$/);
    O && b[O[1]] && b[O[1]].transition ? z = z.concat(d.validateSpec({
      key: u,
      value: o[u],
      valueSpec: m.transition,
      validateSpec: d.validateSpec,
      style: M,
      styleSpec: m
    })) : b[u] ? z = z.concat(d.validateSpec({
      key: u,
      value: o[u],
      valueSpec: b[u],
      validateSpec: d.validateSpec,
      style: M,
      styleSpec: m
    })) : z = z.concat([new _t(u, o[u], `unknown property "${u}"`)]);
  }
  return z;
}
function kx(d) {
  const o = d.value, m = d.styleSpec, b = m.sky, M = d.style, z = Di(o);
  if (o === void 0)
    return [];
  if (z !== "object")
    return [new _t("sky", o, `object expected, ${z} found`)];
  let S = [];
  for (const u in o)
    b[u] ? S = S.concat(d.validateSpec({
      key: u,
      value: o[u],
      valueSpec: b[u],
      style: M,
      styleSpec: m
    })) : S = S.concat([new _t(u, o[u], `unknown property "${u}"`)]);
  return S;
}
function Rx(d) {
  const o = d.value, m = d.styleSpec, b = m.terrain, M = d.style;
  let z = [];
  const S = Di(o);
  if (o === void 0)
    return z;
  if (S !== "object")
    return z = z.concat([new _t("terrain", o, `object expected, ${S} found`)]), z;
  for (const u in o)
    b[u] ? z = z.concat(d.validateSpec({
      key: u,
      value: o[u],
      valueSpec: b[u],
      validateSpec: d.validateSpec,
      style: M,
      styleSpec: m
    })) : z = z.concat([new _t(u, o[u], `unknown property "${u}"`)]);
  return z;
}
function kw(d) {
  return Fd(d).length === 0 ? [] : Jp(d);
}
function Rw(d) {
  return Fd(d).length === 0 ? [] : Jp(d);
}
function Dw(d) {
  const o = d.key, m = d.value;
  if (Di(m) === "array") {
    if (m.length < 1 || m.length > 4)
      return [new _t(o, m, `padding requires 1 to 4 values; ${m.length} values found`)];
    const b = {
      type: "number"
    };
    let M = [];
    for (let z = 0; z < m.length; z++)
      M = M.concat(d.validateSpec({
        key: `${o}[${z}]`,
        value: m[z],
        validateSpec: d.validateSpec,
        valueSpec: b
      }));
    return M;
  } else
    return _y({
      key: o,
      value: m,
      valueSpec: {}
    });
}
function Lw(d) {
  const o = d.key, m = d.value;
  if (Di(m) === "array") {
    const b = {
      type: "number"
    };
    if (m.length < 1)
      return [new _t(o, m, "array length at least 1 expected, length 0 found")];
    let M = [];
    for (let z = 0; z < m.length; z++)
      M = M.concat(d.validateSpec({
        key: `${o}[${z}]`,
        value: m[z],
        validateSpec: d.validateSpec,
        valueSpec: b
      }));
    return M;
  } else
    return _y({
      key: o,
      value: m,
      valueSpec: {}
    });
}
function Ow(d) {
  const o = d.key, m = d.value;
  if (Di(m) === "array") {
    if (m.length < 1)
      return [new _t(o, m, "array length at least 1 expected, length 0 found")];
    let b = [];
    for (let M = 0; M < m.length; M++)
      b = b.concat(z_({
        key: `${o}[${M}]`,
        value: m[M]
      }));
    return b;
  } else
    return z_({
      key: o,
      value: m
    });
}
function Bw(d) {
  const o = d.key, m = d.value, b = Di(m), M = d.styleSpec;
  if (b !== "array" || m.length < 1 || m.length % 2 !== 0)
    return [new _t(o, m, "variableAnchorOffsetCollection requires a non-empty array of even length")];
  let z = [];
  for (let S = 0; S < m.length; S += 2)
    z = z.concat(Pm({
      key: `${o}[${S}]`,
      value: m[S],
      valueSpec: M.layout_symbol["text-anchor"]
    })), z = z.concat(n0({
      key: `${o}[${S + 1}]`,
      value: m[S + 1],
      valueSpec: {
        length: 2,
        value: "number"
      },
      validateSpec: d.validateSpec,
      style: d.style,
      styleSpec: M
    }));
  return z;
}
function Dx(d) {
  let o = [];
  const m = d.value, b = d.key;
  if (Array.isArray(m)) {
    const M = [], z = [];
    for (const S in m) {
      m[S].id && M.includes(m[S].id) && o.push(new _t(b, m, `all the sprites' ids must be unique, but ${m[S].id} is duplicated`)), M.push(m[S].id), m[S].url && z.includes(m[S].url) && o.push(new _t(b, m, `all the sprites' URLs must be unique, but ${m[S].url} is duplicated`)), z.push(m[S].url);
      const u = {
        id: {
          type: "string",
          required: !0
        },
        url: {
          type: "string",
          required: !0
        }
      };
      o = o.concat(Qo({
        key: `${b}[${S}]`,
        value: m[S],
        valueSpec: u,
        validateSpec: d.validateSpec
      }));
    }
    return o;
  } else
    return Fd({
      key: b,
      value: m
    });
}
function Nw(d) {
  const o = d.value, m = d.styleSpec, b = m.projection, M = d.style, z = Di(o);
  if (o === void 0)
    return [];
  if (z !== "object")
    return [new _t("projection", o, `object expected, ${z} found`)];
  let S = [];
  for (const u in o)
    b[u] ? S = S.concat(d.validateSpec({
      key: u,
      value: o[u],
      valueSpec: b[u],
      style: M,
      styleSpec: m
    })) : S = S.concat([new _t(u, o[u], `unknown property "${u}"`)]);
  return S;
}
function jw(d) {
  const o = d.key;
  let m = d.value;
  m = m instanceof String ? m.valueOf() : m;
  const b = Di(m);
  return b === "array" && !Fw(m) && !Uw(m) ? [new _t(o, m, `projection expected, invalid array ${JSON.stringify(m)} found`)] : ["array", "string"].includes(b) ? [] : [new _t(o, m, `projection expected, invalid type "${b}" found`)];
}
function Uw(d) {
  return !!["interpolate", "step", "literal"].includes(d[0]);
}
function Fw(d) {
  return Array.isArray(d) && d.length === 3 && typeof d[0] == "string" && typeof d[1] == "string" && typeof d[2] == "number";
}
function Vw(d) {
  return !!d && d.constructor === Object;
}
function Lx(d) {
  return Vw(d.value) ? [] : [
    new _t(d.key, d.value, `object expected, ${Di(d.value)} found`)
  ];
}
const uv = {
  "*"() {
    return [];
  },
  array: n0,
  boolean: zw,
  number: _y,
  color: z_,
  constants: Sx,
  enum: Pm,
  filter: a0,
  function: Tx,
  layer: zx,
  object: Qo,
  source: Px,
  light: Ix,
  sky: kx,
  terrain: Rx,
  projection: Nw,
  projectionDefinition: jw,
  string: Fd,
  formatted: kw,
  resolvedImage: Rw,
  padding: Dw,
  numberArray: Lw,
  colorArray: Ow,
  variableAnchorOffsetCollection: Bw,
  sprite: Dx,
  state: Lx
};
function Qg(d) {
  const o = d.value, m = d.valueSpec, b = d.styleSpec;
  return d.validateSpec = Qg, m.expression && t0(fa(o)) ? Tx(d) : m.expression && xx(Ud(o)) ? Jp(d) : m.type && uv[m.type] ? uv[m.type](d) : Qo(Zg({}, d, {
    valueSpec: m.type ? b[m.type] : m
  }));
}
function Ox(d) {
  const o = d.value, m = d.key, b = Fd(d);
  return b.length || (o.indexOf("{fontstack}") === -1 && b.push(new _t(m, o, '"glyphs" url must include a "{fontstack}" token')), o.indexOf("{range}") === -1 && b.push(new _t(m, o, '"glyphs" url must include a "{range}" token'))), b;
}
function co(d, o = g2) {
  let m = [];
  return m = m.concat(Qg({
    key: "",
    value: d,
    valueSpec: o.$root,
    styleSpec: o,
    style: d,
    validateSpec: Qg,
    objectElementValidators: {
      glyphs: Ox,
      "*"() {
        return [];
      }
    }
  })), d.constants && (m = m.concat(Sx({
    key: "constants",
    value: d.constants
  }))), Bx(m);
}
co.source = Ul(jl(Px));
co.sprite = Ul(jl(Dx));
co.glyphs = Ul(jl(Ox));
co.light = Ul(jl(Ix));
co.sky = Ul(jl(kx));
co.terrain = Ul(jl(Rx));
co.state = Ul(jl(Lx));
co.layer = Ul(jl(zx));
co.filter = Ul(jl(a0));
co.paintProperty = Ul(jl(Ex));
co.layoutProperty = Ul(jl(Cx));
function jl(d) {
  return function(o) {
    return d({
      ...o,
      validateSpec: Qg
    });
  };
}
function Bx(d) {
  return [].concat(d).sort((o, m) => o.line - m.line);
}
function Ul(d) {
  return function(...o) {
    return Bx(d.apply(this, o));
  };
}
function cv(d) {
  if (!d)
    return {
      style: _m[ym[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
      requiresUrlMonitoring: !1,
      // default styles don't require URL monitoring
      isFallback: !0
    };
  if (typeof d == "string") {
    const o = Gw(d);
    return o.isValidStyle ? {
      style: o.styleObject,
      requiresUrlMonitoring: !1,
      isFallback: !1
    } : o.isValidJSON ? {
      style: _m[ym[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
      requiresUrlMonitoring: !1,
      // default styles don't require URL monitoring
      isFallback: !0
    } : d.startsWith("http") ? { style: d, requiresUrlMonitoring: !0, isFallback: !1 } : d.toLowerCase().includes(".json") ? {
      style: qw(d),
      requiresUrlMonitoring: !0,
      isFallback: !1
    } : {
      style: Ov(d),
      requiresUrlMonitoring: !0,
      isFallback: !1
    };
  }
  return d instanceof Bv ? {
    style: d.getExpandedStyleURL(),
    requiresUrlMonitoring: !1,
    isFallback: !1
  } : d instanceof Nv ? {
    style: d.getDefaultVariant().getExpandedStyleURL(),
    requiresUrlMonitoring: !1,
    isFallback: !1
  } : co(d).length === 0 ? {
    style: d,
    requiresUrlMonitoring: !1,
    isFallback: !1
  } : {
    style: _m[ym[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
    requiresUrlMonitoring: !1,
    // default styles don't require URL monitoring
    isFallback: !0
  };
}
function qw(d) {
  try {
    return new URL(d).href;
  } catch {
  }
  return new URL(d, location.origin).href;
}
function Gw(d) {
  try {
    const o = JSON.parse(d), m = co(o);
    return {
      isValidJSON: !0,
      isValidStyle: m.length === 0,
      styleObject: m.length === 0 ? o : null
    };
  } catch {
    return {
      isValidJSON: !1,
      isValidStyle: !1,
      styleObject: null
    };
  }
}
function Ic(d, o, m) {
  const b = window.document.createElement(d);
  return o !== void 0 && (b.className = o), m && m.appendChild(b), b;
}
function Im(d) {
  d.parentNode && d.parentNode.removeChild(d);
}
class Zw {
  constructor() {
    St(this, "_map"), St(this, "_container"), St(this, "_terrainButton"), pb(["_toggleTerrain", "_updateTerrainIcon"], this);
  }
  onAdd(o) {
    return this._map = o, this._container = Ic("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = Ic("button", "maplibregl-ctrl-terrain", this._container), Ic("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
  }
  onRemove() {
    Im(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
  }
  _toggleTerrain() {
    Nx(this._map), this._updateTerrainIcon();
  }
  _updateTerrainIcon() {
    this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.hasTerrain() ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
  }
}
function Nx(d) {
  d.hasTerrain() ? d.disableTerrain() : d.enableTerrain();
}
class jx extends Mb {
  constructor(o = {}) {
    super({
      showCompass: o.showCompass ?? !0,
      showZoom: o.showZoom ?? !0,
      visualizePitch: o.visualizePitch ?? !0
    }), St(this, "_rotateCompassArrow", () => {
      const m = this._map.getBearing(), b = this._map.getPitch(), M = this.options.visualizePitch ? `scale(${Math.min(1.5, 1 / Math.cos(b * (Math.PI / 180)) ** 0.5)}) rotateX(${Math.min(70, b)}deg) rotateZ(${-m}deg)` : `rotate(${-m}deg)`;
      this._compassIcon.style.transform = M;
    }), this._compass && (this._compass.removeEventListener("click", this._compass.clickFunction), this._compass.addEventListener("click", (m) => {
      this._map.getPitch() === 0 ? this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) }) : this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: m }) : this._map.resetNorth({}, { originalEvent: m });
    }));
  }
  /**
   * Overloading: the button now stores its click callback so that we can later on delete it and replace it
   */
  _createButton(o, m) {
    const b = super._createButton(o, m);
    return b.clickFunction = m, b;
  }
}
const hv = Lt.Marker, dv = Lt.LngLat, $w = Lt.LngLatBounds;
class Ux extends Ab {
  constructor() {
    super(...arguments), St(this, "lastUpdatedCenter", new dv(0, 0)), St(this, "_updateCamera", (o) => {
      var m;
      const b = new dv(o.coords.longitude, o.coords.latitude), M = o.coords.accuracy, z = {
        bearing: this._map.getBearing(),
        ...this.options.fitBoundsOptions,
        linear: !0
      }, S = this._map.getZoom();
      S > (((m = this.options.fitBoundsOptions) == null ? void 0 : m.maxZoom) ?? 30) && (z.zoom = S), this._map.fitBounds($w.fromLngLat(b, M), z, {
        geolocateSource: !0
        // tag this camera change so it won't cause the control to change to background state
      });
      let u = !1;
      const O = () => {
        u = !0;
      };
      this._map.once("click", O), this._map.once("dblclick", O), this._map.once("dragstart", O), this._map.once("mousedown", O), this._map.once("touchstart", O), this._map.once("wheel", O), this._map.once("moveend", () => {
        this._map.off("click", O), this._map.off("dblclick", O), this._map.off("dragstart", O), this._map.off("mousedown", O), this._map.off("touchstart", O), this._map.off("wheel", O), !u && (this.lastUpdatedCenter = this._map.getCenter());
      });
    }), St(this, "_finishSetupUI", (o) => {
      if (this._map) {
        if (o === !1) {
          const m = this._map._getUIString("GeolocateControl.LocationNotAvailable");
          this._geolocateButton.disabled = !0, this._geolocateButton.title = m, this._geolocateButton.setAttribute("aria-label", m);
        } else {
          const m = this._map._getUIString("GeolocateControl.FindMyLocation");
          this._geolocateButton.disabled = !1, this._geolocateButton.title = m, this._geolocateButton.setAttribute("aria-label", m);
        }
        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = Ic("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new hv({ element: this._dotElement }), this._circleElement = Ic("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new hv({
          element: this._circleElement,
          pitchAlignment: "map"
        }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("move", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("moveend", (m) => {
          const b = m.originalEvent && m.originalEvent.type === "resize", M = this.lastUpdatedCenter.distanceTo(this._map.getCenter());
          !m.geolocateSource && this._watchState === "ACTIVE_LOCK" && !b && M > 1 && (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new Event("trackuserlocationend")));
        });
      }
    }), St(this, "_onZoom", () => {
      this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
    });
  }
  _updateCircleRadius() {
    if (this._watchState !== "BACKGROUND" && this._watchState !== "ACTIVE_LOCK")
      return;
    const o = [this._lastKnownPosition.coords.longitude, this._lastKnownPosition.coords.latitude], m = this._map.project(o), b = this._map.unproject([m.x, m.y]), M = this._map.unproject([m.x + 20, m.y]), z = b.distanceTo(M) / 20, S = Math.ceil(2 * this._accuracy / z);
    this._circleElement.style.width = `${S}px`, this._circleElement.style.height = `${S}px`;
  }
  // We are overwriting the method _setErrorState from Maplibre's GeolocateControl because the
  // case BACKGROUND_ERROR is not dealt with in the original function and yields an error.
  // Related issue: https://github.com/maplibre/maplibre-gl-js/issues/2294
  _setErrorState() {
    switch (this._watchState) {
      case "WAITING_ACTIVE":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
        break;
      case "ACTIVE_LOCK":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "BACKGROUND":
        this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "ACTIVE_ERROR":
        break;
      case "BACKGROUND_ERROR":
        break;
      default:
        throw new Error(`Unexpected watchState ${this._watchState}`);
    }
  }
}
var Ad, ao, Ed, Cd, pm;
class Fx {
  /**
   * @param selectorOrElement Element to be used as control, specified as either reference to element itself or a CSS selector to find the element in DOM
   * @param onClick Function called when the element is clicked
   * @param onRender Function called every time the underlying map renders a new state
   */
  constructor(o, m, b) {
    if (Ls(this, Ad), Ls(this, ao), Ls(this, Ed), Ls(this, Cd), Ls(this, pm), typeof o == "string") {
      const M = document.querySelector(o);
      if (!M) throw new Error(`No element has been found with selector "${o}" when creating an external control.`);
      oo(this, ao, M);
    } else
      oo(this, ao, o);
    m && oo(this, Ed, (M) => {
      m(jt(this, Ad), jt(this, ao), M);
    }), b && oo(this, Cd, (M) => {
      b(jt(this, Ad), jt(this, ao), M);
    }), oo(this, pm, jt(this, ao).parentElement);
  }
  onAdd(o) {
    return oo(this, Ad, o), jt(this, Ed) && jt(this, ao).addEventListener("click", jt(this, Ed)), jt(this, Cd) && jt(this, Ad).on("render", jt(this, Cd)), Im(jt(this, ao)), jt(this, ao);
  }
  onRemove() {
    jt(this, Ed) && jt(this, ao).removeEventListener("click", jt(this, Ed)), jt(this, Cd) && jt(this, Ad).off("render", jt(this, Cd)), jt(this, pm) ? jt(this, pm).appendChild(jt(this, ao)) : Im(jt(this, ao));
  }
}
Ad = /* @__PURE__ */ new WeakMap(), ao = /* @__PURE__ */ new WeakMap(), Ed = /* @__PURE__ */ new WeakMap(), Cd = /* @__PURE__ */ new WeakMap(), pm = /* @__PURE__ */ new WeakMap();
class Hw {
  constructor() {
    St(this, "map"), St(this, "container"), St(this, "projectionButton");
  }
  onAdd(o) {
    return this.map = o, this.container = Ic("div", "maplibregl-ctrl maplibregl-ctrl-group"), this.projectionButton = Ic("button", "maplibregl-ctrl-projection", this.container), Ic("span", "maplibregl-ctrl-icon", this.projectionButton).setAttribute("aria-hidden", "true"), this.projectionButton.type = "button", this.projectionButton.addEventListener("click", this.toggleProjection.bind(this)), o.on("projectiontransition", this.updateProjectionIcon.bind(this)), this.updateProjectionIcon(), this.container;
  }
  onRemove() {
    Im(this.container), this.map.off("projectiontransition", this.updateProjectionIcon), this.map = void 0;
  }
  toggleProjection() {
    Vx(this.map), this.updateProjectionIcon();
  }
  updateProjectionIcon() {
    this.projectionButton.classList.remove("maplibregl-ctrl-projection-globe"), this.projectionButton.classList.remove("maplibregl-ctrl-projection-mercator"), this.map.isGlobeProjection() ? (this.projectionButton.classList.add("maplibregl-ctrl-projection-mercator"), this.projectionButton.title = "Enable Mercator projection") : (this.projectionButton.classList.add("maplibregl-ctrl-projection-globe"), this.projectionButton.title = "Enable Globe projection");
  }
}
function Vx(d) {
  d.getProjection() === void 0 && d.setProjection({ type: "mercator" }), d.isGlobeProjection() ? d.enableMercatorProjection() : d.enableGlobeProjection();
}
const fm = {
  "zoom-in": (d) => d.zoomIn(),
  "zoom-out": (d) => d.zoomOut(),
  "toggle-projection": Vx,
  "toggle-terrain": Nx,
  "reset-view": (d) => {
    d.getPitch() === 0 ? d.easeTo({ pitch: Math.min(d.getMaxPitch(), 80) }) : d.resetNorthPitch();
  },
  "reset-bearing": (d) => {
    d.rotateTo(0);
  },
  "reset-pitch": (d) => {
    d.setPitch(0);
  },
  "reset-roll": (d) => {
    d.setRoll(0);
  }
};
var jg, mm;
class P_ extends Fx {
  /**
   * Constructs an instance of External Control to have a predefined functionality
   * @param controlElement Element to be used as control, specified as reference to element itself
   * @param controlType One of the predefined types of functionality
   */
  constructor(o, m) {
    if (m && !(m in fm)) throw new Error(`data-maptiler-control value "${m}" is invalid.`);
    super(o, m && fm[m]), Ls(this, jg), Ls(this, mm, /* @__PURE__ */ new Map());
  }
  onAdd(o) {
    return oo(this, jg, o), super.onAdd(o);
  }
  onRemove() {
    for (const [o, m] of jt(this, mm)) {
      const b = o.deref();
      b && b.removeEventListener("click", m);
    }
    jt(this, mm).clear(), super.onRemove();
  }
  /**
   * Configure a child element to be part of this control and to have a predefined functionality added
   * @param controlElement Element that is a descendant of the control element and that optionally should have some functionality
   * @param controlType One of the predefined types of functionality
   */
  configureGroupItem(o, m) {
    if (!m) return;
    if (!(m in fm)) throw new Error(`data-maptiler-control value "${m}" is invalid.`);
    const b = (M) => {
      fm[m](jt(this, jg), o, M);
    };
    o.addEventListener("click", b), jt(this, mm).set(new WeakRef(o), b);
  }
}
jg = /* @__PURE__ */ new WeakMap(), mm = /* @__PURE__ */ new WeakMap(), St(P_, "controlCallbacks", fm);
var so, Mu, zd, Pd, Wo, Ug, as, qx, Jo, Gx;
class o_ {
  constructor(o, m) {
    Ls(this, as), Ls(this, so), St(this, "map"), Ls(this, Mu), Ls(this, zd), Ls(this, Pd), Ls(this, Wo, !1), Ls(this, Ug), o.style !== void 0 && oo(this, Wo, !0), oo(this, so, {
      // set defaults
      zoomAdjust: -4,
      position: "top-right",
      // inherit map options
      ...m,
      // override any lingering control options
      forceNoAttributionControl: !0,
      attributionControl: !1,
      navigationControl: !1,
      geolocateControl: !1,
      maptilerLogo: !1,
      minimap: !1,
      hash: !1,
      pitchAdjust: !1,
      // override map options with new user defined minimap options
      ...o,
      containerStyle: {
        border: "1px solid #000",
        width: "400px",
        height: "300px",
        ...o.containerStyle ?? {}
      }
    }), o.lockZoom !== void 0 && (jt(this, so).minZoom = o.lockZoom, jt(this, so).maxZoom = o.lockZoom);
  }
  setStyle(o, m) {
    jt(this, Wo) || this.map.setStyle(o, m), ro(this, as, Jo).call(this);
  }
  addLayer(o, m) {
    return jt(this, Wo) || this.map.addLayer(o, m), ro(this, as, Jo).call(this), this.map;
  }
  moveLayer(o, m) {
    return jt(this, Wo) || this.map.moveLayer(o, m), ro(this, as, Jo).call(this), this.map;
  }
  removeLayer(o) {
    return jt(this, Wo) || this.map.removeLayer(o), ro(this, as, Jo).call(this), this;
  }
  setLayerZoomRange(o, m, b) {
    return jt(this, Wo) || this.map.setLayerZoomRange(o, m, b), ro(this, as, Jo).call(this), this;
  }
  setFilter(o, m, b) {
    return jt(this, Wo) || this.map.setFilter(o, m, b), ro(this, as, Jo).call(this), this;
  }
  setPaintProperty(o, m, b, M) {
    return jt(this, Wo) || this.map.setPaintProperty(o, m, b, M), ro(this, as, Jo).call(this), this;
  }
  setLayoutProperty(o, m, b, M) {
    return jt(this, Wo) || this.map.setLayoutProperty(o, m, b, M), ro(this, as, Jo).call(this), this;
  }
  setGlyphs(o, m) {
    return jt(this, Wo) || this.map.setGlyphs(o, m), ro(this, as, Jo).call(this), this;
  }
  onAdd(o) {
    oo(this, Mu, o), oo(this, zd, Ic("div", "maplibregl-ctrl maplibregl-ctrl-group"));
    for (const [m, b] of Object.entries(jt(this, so).containerStyle))
      jt(this, zd).style.setProperty(m, b);
    return jt(this, so).container = jt(this, zd), jt(this, so).zoom = o.getZoom() + jt(this, so).zoomAdjust, this.map = new Xx(jt(this, so)), this.map.once("style.load", () => {
      this.map.resize();
    }), this.map.once("load", () => {
      ro(this, as, qx).call(this, jt(this, so).parentRect), oo(this, Ug, ro(this, as, Gx).call(this));
    }), jt(this, zd);
  }
  onRemove() {
    var o;
    (o = jt(this, Ug)) == null || o.call(this), Im(jt(this, zd));
  }
}
so = /* @__PURE__ */ new WeakMap(), Mu = /* @__PURE__ */ new WeakMap(), zd = /* @__PURE__ */ new WeakMap(), Pd = /* @__PURE__ */ new WeakMap(), Wo = /* @__PURE__ */ new WeakMap(), Ug = /* @__PURE__ */ new WeakMap(), as = /* @__PURE__ */ new WeakSet(), qx = function(d) {
  d === void 0 || d.linePaint === void 0 && d.fillPaint === void 0 || (oo(this, Pd, {
    type: "Feature",
    properties: {
      name: "parentRect"
    },
    geometry: {
      type: "Polygon",
      coordinates: [[[], [], [], [], []]]
    }
  }), this.map.addSource("parentRect", {
    type: "geojson",
    data: jt(this, Pd)
  }), (d.lineLayout !== void 0 || d.linePaint !== void 0) && this.map.addLayer({
    id: "parentRectOutline",
    type: "line",
    source: "parentRect",
    layout: {
      ...d.lineLayout
    },
    paint: {
      "line-color": "#FFF",
      "line-width": 1,
      "line-opacity": 0.85,
      ...d.linePaint
    }
  }), d.fillPaint !== void 0 && this.map.addLayer({
    id: "parentRectFill",
    type: "fill",
    source: "parentRect",
    layout: {},
    paint: {
      "fill-color": "#08F",
      "fill-opacity": 0.135,
      ...d.fillPaint
    }
  }), ro(this, as, Jo).call(this));
}, Jo = function() {
  if (jt(this, Pd) === void 0) return;
  const { devicePixelRatio: d } = window, o = jt(this, Mu).getCanvas(), m = o.width / d, b = o.height / d, M = jt(this, Mu).unproject.bind(jt(this, Mu)), z = M([0, 0]), S = M([m, 0]), u = M([0, b]), O = M([m, b]);
  jt(this, Pd).geometry.coordinates = [[u.toArray(), O.toArray(), S.toArray(), z.toArray(), u.toArray()]];
  const U = this.map.getSource("parentRect");
  U !== void 0 && U.setData(jt(this, Pd));
}, Gx = function() {
  const { pitchAdjust: d } = jt(this, so), o = () => {
    z("parent");
  }, m = () => {
    z("minimap");
  }, b = () => {
    jt(this, Mu).on("move", o), this.map.on("move", m);
  }, M = () => {
    jt(this, Mu).off("move", o), this.map.off("move", m);
  }, z = (S) => {
    M();
    const u = S === "parent" ? jt(this, Mu) : this.map, O = S === "parent" ? this.map : jt(this, Mu), U = u.getCenter(), K = u.getZoom() + jt(this, so).zoomAdjust * (S === "parent" ? 1 : -1), ae = u.getBearing(), he = u.getPitch();
    O.jumpTo({
      center: U,
      zoom: K,
      bearing: ae,
      pitch: d ? he : 0
    }), ro(this, as, Jo).call(this), b();
  };
  return b(), () => {
    M();
  };
};
class Xw {
  /**
   *
   * @param map : a Map instance
   * @param delay : a delay in milliseconds after which the payload is sent to MapTiler cloud (cannot be less than 1000ms)
   */
  constructor(o, m = 2e3) {
    St(this, "map"), St(this, "registeredModules", /* @__PURE__ */ new Set()), St(this, "viewerType"), this.map = o, this.viewerType = "Map", setTimeout(
      async () => {
        if (!Ha.telemetry)
          return;
        const b = this.preparePayload();
        try {
          (await fetch(b, { method: "POST" })).ok || console.warn("The metrics could not be sent to MapTiler Cloud");
        } catch (M) {
          console.warn("The metrics could not be sent to MapTiler Cloud", M);
        }
      },
      Math.max(1e3, m)
    );
  }
  /**
   * Register a module to the telemetry system of the SDK.
   * The arguments `name` and `version` likely come from the package.json
   * of each module.
   */
  registerModule(o, m) {
    this.registeredModules.add(`${o}:${m}`);
  }
  registerViewerType(o = "Map") {
    this.viewerType = o;
  }
  preparePayload() {
    const o = new URL(rs.telemetryURL);
    return o.searchParams.append("sdk", LS()), o.searchParams.append("key", Ha.apiKey), o.searchParams.append("mtsid", B_), o.searchParams.append("session", Ha.session ? "1" : "0"), o.searchParams.append("caching", Ha.caching ? "1" : "0"), o.searchParams.append("lang-updated", this.map.isLanguageUpdated() ? "1" : "0"), o.searchParams.append("terrain", this.map.getTerrain() ? "1" : "0"), o.searchParams.append("globe", this.map.isGlobeProjection() ? "1" : "0"), o.searchParams.append("viewerType", this.viewerType), this.registeredModules.size > 0 && o.searchParams.append("modules", Array.from(this.registeredModules).join("|")), o.href;
  }
}
var km = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var d = 0, o = arguments.length; o--; )
    d += arguments[o] * arguments[o];
  return Math.sqrt(d);
});
function bm() {
  var d = new km(16);
  return km != Float32Array && (d[1] = 0, d[2] = 0, d[3] = 0, d[4] = 0, d[6] = 0, d[7] = 0, d[8] = 0, d[9] = 0, d[11] = 0, d[12] = 0, d[13] = 0, d[14] = 0), d[0] = 1, d[5] = 1, d[10] = 1, d[15] = 1, d;
}
function Yw(d, o, m, b, M, z, S, u, O, U, K, ae, he, J, ke, qe, ft) {
  return d[0] = o, d[1] = m, d[2] = b, d[3] = M, d[4] = z, d[5] = S, d[6] = u, d[7] = O, d[8] = U, d[9] = K, d[10] = ae, d[11] = he, d[12] = J, d[13] = ke, d[14] = qe, d[15] = ft, d;
}
function Kw(d, o, m) {
  var b = o[0], M = o[1], z = o[2], S = o[3], u = o[4], O = o[5], U = o[6], K = o[7], ae = o[8], he = o[9], J = o[10], ke = o[11], qe = o[12], ft = o[13], ht = o[14], it = o[15], nt = m[0], De = m[1], Re = m[2], $e = m[3];
  return d[0] = nt * b + De * u + Re * ae + $e * qe, d[1] = nt * M + De * O + Re * he + $e * ft, d[2] = nt * z + De * U + Re * J + $e * ht, d[3] = nt * S + De * K + Re * ke + $e * it, nt = m[4], De = m[5], Re = m[6], $e = m[7], d[4] = nt * b + De * u + Re * ae + $e * qe, d[5] = nt * M + De * O + Re * he + $e * ft, d[6] = nt * z + De * U + Re * J + $e * ht, d[7] = nt * S + De * K + Re * ke + $e * it, nt = m[8], De = m[9], Re = m[10], $e = m[11], d[8] = nt * b + De * u + Re * ae + $e * qe, d[9] = nt * M + De * O + Re * he + $e * ft, d[10] = nt * z + De * U + Re * J + $e * ht, d[11] = nt * S + De * K + Re * ke + $e * it, nt = m[12], De = m[13], Re = m[14], $e = m[15], d[12] = nt * b + De * u + Re * ae + $e * qe, d[13] = nt * M + De * O + Re * he + $e * ft, d[14] = nt * z + De * U + Re * J + $e * ht, d[15] = nt * S + De * K + Re * ke + $e * it, d;
}
function Ww(d, o, m) {
  var b = m[0], M = m[1], z = m[2];
  return d[0] = o[0] * b, d[1] = o[1] * b, d[2] = o[2] * b, d[3] = o[3] * b, d[4] = o[4] * M, d[5] = o[5] * M, d[6] = o[6] * M, d[7] = o[7] * M, d[8] = o[8] * z, d[9] = o[9] * z, d[10] = o[10] * z, d[11] = o[11] * z, d[12] = o[12], d[13] = o[13], d[14] = o[14], d[15] = o[15], d;
}
function pv(d, o, m) {
  var b = Math.sin(m), M = Math.cos(m), z = o[4], S = o[5], u = o[6], O = o[7], U = o[8], K = o[9], ae = o[10], he = o[11];
  return o !== d && (d[0] = o[0], d[1] = o[1], d[2] = o[2], d[3] = o[3], d[12] = o[12], d[13] = o[13], d[14] = o[14], d[15] = o[15]), d[4] = z * M + U * b, d[5] = S * M + K * b, d[6] = u * M + ae * b, d[7] = O * M + he * b, d[8] = U * M - z * b, d[9] = K * M - S * b, d[10] = ae * M - u * b, d[11] = he * M - O * b, d;
}
function Jw(d, o, m) {
  var b = Math.sin(m), M = Math.cos(m), z = o[0], S = o[1], u = o[2], O = o[3], U = o[8], K = o[9], ae = o[10], he = o[11];
  return o !== d && (d[4] = o[4], d[5] = o[5], d[6] = o[6], d[7] = o[7], d[12] = o[12], d[13] = o[13], d[14] = o[14], d[15] = o[15]), d[0] = z * M - U * b, d[1] = S * M - K * b, d[2] = u * M - ae * b, d[3] = O * M - he * b, d[8] = z * b + U * M, d[9] = S * b + K * M, d[10] = u * b + ae * M, d[11] = O * b + he * M, d;
}
function fv(d, o, m) {
  var b = Math.sin(m), M = Math.cos(m), z = o[0], S = o[1], u = o[2], O = o[3], U = o[4], K = o[5], ae = o[6], he = o[7];
  return o !== d && (d[8] = o[8], d[9] = o[9], d[10] = o[10], d[11] = o[11], d[12] = o[12], d[13] = o[13], d[14] = o[14], d[15] = o[15]), d[0] = z * M + U * b, d[1] = S * M + K * b, d[2] = u * M + ae * b, d[3] = O * M + he * b, d[4] = U * M - z * b, d[5] = K * M - S * b, d[6] = ae * M - u * b, d[7] = he * M - O * b, d;
}
function Qw(d, o, m, b, M) {
  var z = 1 / Math.tan(o / 2), S;
  return d[0] = z / m, d[1] = 0, d[2] = 0, d[3] = 0, d[4] = 0, d[5] = z, d[6] = 0, d[7] = 0, d[8] = 0, d[9] = 0, d[11] = -1, d[12] = 0, d[13] = 0, d[15] = 0, M != null && M !== 1 / 0 ? (S = 1 / (b - M), d[10] = (M + b) * S, d[14] = 2 * M * b * S) : (d[10] = -1, d[14] = -2 * b), d;
}
var eS = Qw;
function Fg() {
  var d = new km(3);
  return km != Float32Array && (d[0] = 0, d[1] = 0, d[2] = 0), d;
}
function tS(d, o, m) {
  var b = new km(3);
  return b[0] = d, b[1] = o, b[2] = m, b;
}
function l_(d, o) {
  var m = o[0], b = o[1], M = o[2], z = m * m + b * b + M * M;
  return z > 0 && (z = 1 / Math.sqrt(z)), d[0] = o[0] * z, d[1] = o[1] * z, d[2] = o[2] * z, d;
}
function mv(d, o, m) {
  var b = o[0], M = o[1], z = o[2], S = m[0], u = m[1], O = m[2];
  return d[0] = M * O - z * u, d[1] = z * S - b * O, d[2] = b * u - M * S, d;
}
(function() {
  var d = Fg();
  return function(o, m, b, M, z, S) {
    var u, O;
    for (m || (m = 3), b || (b = 0), M ? O = Math.min(M * m + b, o.length) : O = o.length, u = b; u < O; u += m)
      d[0] = o[u], d[1] = o[u + 1], d[2] = o[u + 2], z(d, d, S), o[u] = d[0], o[u + 1] = d[1], o[u + 2] = d[2];
    return o;
  };
})();
function iS(d) {
  return d && d.__esModule && Object.prototype.hasOwnProperty.call(d, "default") ? d.default : d;
}
var gv, yv;
function nS() {
  return yv || (yv = 1, gv = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }), gv;
}
var u_, _v;
function Zx() {
  if (_v) return u_;
  _v = 1;
  const d = nS(), o = {};
  for (const M of Object.keys(d))
    o[d[M]] = M;
  const m = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  u_ = m;
  for (const M of Object.keys(m)) {
    if (!("channels" in m[M]))
      throw new Error("missing channels property: " + M);
    if (!("labels" in m[M]))
      throw new Error("missing channel labels property: " + M);
    if (m[M].labels.length !== m[M].channels)
      throw new Error("channel and label counts mismatch: " + M);
    const { channels: z, labels: S } = m[M];
    delete m[M].channels, delete m[M].labels, Object.defineProperty(m[M], "channels", { value: z }), Object.defineProperty(m[M], "labels", { value: S });
  }
  m.rgb.hsl = function(M) {
    const z = M[0] / 255, S = M[1] / 255, u = M[2] / 255, O = Math.min(z, S, u), U = Math.max(z, S, u), K = U - O;
    let ae, he;
    U === O ? ae = 0 : z === U ? ae = (S - u) / K : S === U ? ae = 2 + (u - z) / K : u === U && (ae = 4 + (z - S) / K), ae = Math.min(ae * 60, 360), ae < 0 && (ae += 360);
    const J = (O + U) / 2;
    return U === O ? he = 0 : J <= 0.5 ? he = K / (U + O) : he = K / (2 - U - O), [ae, he * 100, J * 100];
  }, m.rgb.hsv = function(M) {
    let z, S, u, O, U;
    const K = M[0] / 255, ae = M[1] / 255, he = M[2] / 255, J = Math.max(K, ae, he), ke = J - Math.min(K, ae, he), qe = function(ft) {
      return (J - ft) / 6 / ke + 1 / 2;
    };
    return ke === 0 ? (O = 0, U = 0) : (U = ke / J, z = qe(K), S = qe(ae), u = qe(he), K === J ? O = u - S : ae === J ? O = 1 / 3 + z - u : he === J && (O = 2 / 3 + S - z), O < 0 ? O += 1 : O > 1 && (O -= 1)), [
      O * 360,
      U * 100,
      J * 100
    ];
  }, m.rgb.hwb = function(M) {
    const z = M[0], S = M[1];
    let u = M[2];
    const O = m.rgb.hsl(M)[0], U = 1 / 255 * Math.min(z, Math.min(S, u));
    return u = 1 - 1 / 255 * Math.max(z, Math.max(S, u)), [O, U * 100, u * 100];
  }, m.rgb.cmyk = function(M) {
    const z = M[0] / 255, S = M[1] / 255, u = M[2] / 255, O = Math.min(1 - z, 1 - S, 1 - u), U = (1 - z - O) / (1 - O) || 0, K = (1 - S - O) / (1 - O) || 0, ae = (1 - u - O) / (1 - O) || 0;
    return [U * 100, K * 100, ae * 100, O * 100];
  };
  function b(M, z) {
    return (M[0] - z[0]) ** 2 + (M[1] - z[1]) ** 2 + (M[2] - z[2]) ** 2;
  }
  return m.rgb.keyword = function(M) {
    const z = o[M];
    if (z)
      return z;
    let S = 1 / 0, u;
    for (const O of Object.keys(d)) {
      const U = d[O], K = b(M, U);
      K < S && (S = K, u = O);
    }
    return u;
  }, m.keyword.rgb = function(M) {
    return d[M];
  }, m.rgb.xyz = function(M) {
    let z = M[0] / 255, S = M[1] / 255, u = M[2] / 255;
    z = z > 0.04045 ? ((z + 0.055) / 1.055) ** 2.4 : z / 12.92, S = S > 0.04045 ? ((S + 0.055) / 1.055) ** 2.4 : S / 12.92, u = u > 0.04045 ? ((u + 0.055) / 1.055) ** 2.4 : u / 12.92;
    const O = z * 0.4124 + S * 0.3576 + u * 0.1805, U = z * 0.2126 + S * 0.7152 + u * 0.0722, K = z * 0.0193 + S * 0.1192 + u * 0.9505;
    return [O * 100, U * 100, K * 100];
  }, m.rgb.lab = function(M) {
    const z = m.rgb.xyz(M);
    let S = z[0], u = z[1], O = z[2];
    S /= 95.047, u /= 100, O /= 108.883, S = S > 8856e-6 ? S ** (1 / 3) : 7.787 * S + 16 / 116, u = u > 8856e-6 ? u ** (1 / 3) : 7.787 * u + 16 / 116, O = O > 8856e-6 ? O ** (1 / 3) : 7.787 * O + 16 / 116;
    const U = 116 * u - 16, K = 500 * (S - u), ae = 200 * (u - O);
    return [U, K, ae];
  }, m.hsl.rgb = function(M) {
    const z = M[0] / 360, S = M[1] / 100, u = M[2] / 100;
    let O, U, K;
    if (S === 0)
      return K = u * 255, [K, K, K];
    u < 0.5 ? O = u * (1 + S) : O = u + S - u * S;
    const ae = 2 * u - O, he = [0, 0, 0];
    for (let J = 0; J < 3; J++)
      U = z + 1 / 3 * -(J - 1), U < 0 && U++, U > 1 && U--, 6 * U < 1 ? K = ae + (O - ae) * 6 * U : 2 * U < 1 ? K = O : 3 * U < 2 ? K = ae + (O - ae) * (2 / 3 - U) * 6 : K = ae, he[J] = K * 255;
    return he;
  }, m.hsl.hsv = function(M) {
    const z = M[0];
    let S = M[1] / 100, u = M[2] / 100, O = S;
    const U = Math.max(u, 0.01);
    u *= 2, S *= u <= 1 ? u : 2 - u, O *= U <= 1 ? U : 2 - U;
    const K = (u + S) / 2, ae = u === 0 ? 2 * O / (U + O) : 2 * S / (u + S);
    return [z, ae * 100, K * 100];
  }, m.hsv.rgb = function(M) {
    const z = M[0] / 60, S = M[1] / 100;
    let u = M[2] / 100;
    const O = Math.floor(z) % 6, U = z - Math.floor(z), K = 255 * u * (1 - S), ae = 255 * u * (1 - S * U), he = 255 * u * (1 - S * (1 - U));
    switch (u *= 255, O) {
      case 0:
        return [u, he, K];
      case 1:
        return [ae, u, K];
      case 2:
        return [K, u, he];
      case 3:
        return [K, ae, u];
      case 4:
        return [he, K, u];
      case 5:
        return [u, K, ae];
    }
  }, m.hsv.hsl = function(M) {
    const z = M[0], S = M[1] / 100, u = M[2] / 100, O = Math.max(u, 0.01);
    let U, K;
    K = (2 - S) * u;
    const ae = (2 - S) * O;
    return U = S * O, U /= ae <= 1 ? ae : 2 - ae, U = U || 0, K /= 2, [z, U * 100, K * 100];
  }, m.hwb.rgb = function(M) {
    const z = M[0] / 360;
    let S = M[1] / 100, u = M[2] / 100;
    const O = S + u;
    let U;
    O > 1 && (S /= O, u /= O);
    const K = Math.floor(6 * z), ae = 1 - u;
    U = 6 * z - K, K & 1 && (U = 1 - U);
    const he = S + U * (ae - S);
    let J, ke, qe;
    switch (K) {
      default:
      case 6:
      case 0:
        J = ae, ke = he, qe = S;
        break;
      case 1:
        J = he, ke = ae, qe = S;
        break;
      case 2:
        J = S, ke = ae, qe = he;
        break;
      case 3:
        J = S, ke = he, qe = ae;
        break;
      case 4:
        J = he, ke = S, qe = ae;
        break;
      case 5:
        J = ae, ke = S, qe = he;
        break;
    }
    return [J * 255, ke * 255, qe * 255];
  }, m.cmyk.rgb = function(M) {
    const z = M[0] / 100, S = M[1] / 100, u = M[2] / 100, O = M[3] / 100, U = 1 - Math.min(1, z * (1 - O) + O), K = 1 - Math.min(1, S * (1 - O) + O), ae = 1 - Math.min(1, u * (1 - O) + O);
    return [U * 255, K * 255, ae * 255];
  }, m.xyz.rgb = function(M) {
    const z = M[0] / 100, S = M[1] / 100, u = M[2] / 100;
    let O, U, K;
    return O = z * 3.2406 + S * -1.5372 + u * -0.4986, U = z * -0.9689 + S * 1.8758 + u * 0.0415, K = z * 0.0557 + S * -0.204 + u * 1.057, O = O > 31308e-7 ? 1.055 * O ** (1 / 2.4) - 0.055 : O * 12.92, U = U > 31308e-7 ? 1.055 * U ** (1 / 2.4) - 0.055 : U * 12.92, K = K > 31308e-7 ? 1.055 * K ** (1 / 2.4) - 0.055 : K * 12.92, O = Math.min(Math.max(0, O), 1), U = Math.min(Math.max(0, U), 1), K = Math.min(Math.max(0, K), 1), [O * 255, U * 255, K * 255];
  }, m.xyz.lab = function(M) {
    let z = M[0], S = M[1], u = M[2];
    z /= 95.047, S /= 100, u /= 108.883, z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116, S = S > 8856e-6 ? S ** (1 / 3) : 7.787 * S + 16 / 116, u = u > 8856e-6 ? u ** (1 / 3) : 7.787 * u + 16 / 116;
    const O = 116 * S - 16, U = 500 * (z - S), K = 200 * (S - u);
    return [O, U, K];
  }, m.lab.xyz = function(M) {
    const z = M[0], S = M[1], u = M[2];
    let O, U, K;
    U = (z + 16) / 116, O = S / 500 + U, K = U - u / 200;
    const ae = U ** 3, he = O ** 3, J = K ** 3;
    return U = ae > 8856e-6 ? ae : (U - 16 / 116) / 7.787, O = he > 8856e-6 ? he : (O - 16 / 116) / 7.787, K = J > 8856e-6 ? J : (K - 16 / 116) / 7.787, O *= 95.047, U *= 100, K *= 108.883, [O, U, K];
  }, m.lab.lch = function(M) {
    const z = M[0], S = M[1], u = M[2];
    let O;
    O = Math.atan2(u, S) * 360 / 2 / Math.PI, O < 0 && (O += 360);
    const U = Math.sqrt(S * S + u * u);
    return [z, U, O];
  }, m.lch.lab = function(M) {
    const z = M[0], S = M[1], u = M[2] / 360 * 2 * Math.PI, O = S * Math.cos(u), U = S * Math.sin(u);
    return [z, O, U];
  }, m.rgb.ansi16 = function(M, z = null) {
    const [S, u, O] = M;
    let U = z === null ? m.rgb.hsv(M)[2] : z;
    if (U = Math.round(U / 50), U === 0)
      return 30;
    let K = 30 + (Math.round(O / 255) << 2 | Math.round(u / 255) << 1 | Math.round(S / 255));
    return U === 2 && (K += 60), K;
  }, m.hsv.ansi16 = function(M) {
    return m.rgb.ansi16(m.hsv.rgb(M), M[2]);
  }, m.rgb.ansi256 = function(M) {
    const z = M[0], S = M[1], u = M[2];
    return z === S && S === u ? z < 8 ? 16 : z > 248 ? 231 : Math.round((z - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(z / 255 * 5) + 6 * Math.round(S / 255 * 5) + Math.round(u / 255 * 5);
  }, m.ansi16.rgb = function(M) {
    let z = M % 10;
    if (z === 0 || z === 7)
      return M > 50 && (z += 3.5), z = z / 10.5 * 255, [z, z, z];
    const S = (~~(M > 50) + 1) * 0.5, u = (z & 1) * S * 255, O = (z >> 1 & 1) * S * 255, U = (z >> 2 & 1) * S * 255;
    return [u, O, U];
  }, m.ansi256.rgb = function(M) {
    if (M >= 232) {
      const U = (M - 232) * 10 + 8;
      return [U, U, U];
    }
    M -= 16;
    let z;
    const S = Math.floor(M / 36) / 5 * 255, u = Math.floor((z = M % 36) / 6) / 5 * 255, O = z % 6 / 5 * 255;
    return [S, u, O];
  }, m.rgb.hex = function(M) {
    const z = (((Math.round(M[0]) & 255) << 16) + ((Math.round(M[1]) & 255) << 8) + (Math.round(M[2]) & 255)).toString(16).toUpperCase();
    return "000000".substring(z.length) + z;
  }, m.hex.rgb = function(M) {
    const z = M.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!z)
      return [0, 0, 0];
    let S = z[0];
    z[0].length === 3 && (S = S.split("").map((ae) => ae + ae).join(""));
    const u = parseInt(S, 16), O = u >> 16 & 255, U = u >> 8 & 255, K = u & 255;
    return [O, U, K];
  }, m.rgb.hcg = function(M) {
    const z = M[0] / 255, S = M[1] / 255, u = M[2] / 255, O = Math.max(Math.max(z, S), u), U = Math.min(Math.min(z, S), u), K = O - U;
    let ae, he;
    return K < 1 ? ae = U / (1 - K) : ae = 0, K <= 0 ? he = 0 : O === z ? he = (S - u) / K % 6 : O === S ? he = 2 + (u - z) / K : he = 4 + (z - S) / K, he /= 6, he %= 1, [he * 360, K * 100, ae * 100];
  }, m.hsl.hcg = function(M) {
    const z = M[1] / 100, S = M[2] / 100, u = S < 0.5 ? 2 * z * S : 2 * z * (1 - S);
    let O = 0;
    return u < 1 && (O = (S - 0.5 * u) / (1 - u)), [M[0], u * 100, O * 100];
  }, m.hsv.hcg = function(M) {
    const z = M[1] / 100, S = M[2] / 100, u = z * S;
    let O = 0;
    return u < 1 && (O = (S - u) / (1 - u)), [M[0], u * 100, O * 100];
  }, m.hcg.rgb = function(M) {
    const z = M[0] / 360, S = M[1] / 100, u = M[2] / 100;
    if (S === 0)
      return [u * 255, u * 255, u * 255];
    const O = [0, 0, 0], U = z % 1 * 6, K = U % 1, ae = 1 - K;
    let he = 0;
    switch (Math.floor(U)) {
      case 0:
        O[0] = 1, O[1] = K, O[2] = 0;
        break;
      case 1:
        O[0] = ae, O[1] = 1, O[2] = 0;
        break;
      case 2:
        O[0] = 0, O[1] = 1, O[2] = K;
        break;
      case 3:
        O[0] = 0, O[1] = ae, O[2] = 1;
        break;
      case 4:
        O[0] = K, O[1] = 0, O[2] = 1;
        break;
      default:
        O[0] = 1, O[1] = 0, O[2] = ae;
    }
    return he = (1 - S) * u, [
      (S * O[0] + he) * 255,
      (S * O[1] + he) * 255,
      (S * O[2] + he) * 255
    ];
  }, m.hcg.hsv = function(M) {
    const z = M[1] / 100, S = M[2] / 100, u = z + S * (1 - z);
    let O = 0;
    return u > 0 && (O = z / u), [M[0], O * 100, u * 100];
  }, m.hcg.hsl = function(M) {
    const z = M[1] / 100, S = M[2] / 100 * (1 - z) + 0.5 * z;
    let u = 0;
    return S > 0 && S < 0.5 ? u = z / (2 * S) : S >= 0.5 && S < 1 && (u = z / (2 * (1 - S))), [M[0], u * 100, S * 100];
  }, m.hcg.hwb = function(M) {
    const z = M[1] / 100, S = M[2] / 100, u = z + S * (1 - z);
    return [M[0], (u - z) * 100, (1 - u) * 100];
  }, m.hwb.hcg = function(M) {
    const z = M[1] / 100, S = 1 - M[2] / 100, u = S - z;
    let O = 0;
    return u < 1 && (O = (S - u) / (1 - u)), [M[0], u * 100, O * 100];
  }, m.apple.rgb = function(M) {
    return [M[0] / 65535 * 255, M[1] / 65535 * 255, M[2] / 65535 * 255];
  }, m.rgb.apple = function(M) {
    return [M[0] / 255 * 65535, M[1] / 255 * 65535, M[2] / 255 * 65535];
  }, m.gray.rgb = function(M) {
    return [M[0] / 100 * 255, M[0] / 100 * 255, M[0] / 100 * 255];
  }, m.gray.hsl = function(M) {
    return [0, 0, M[0]];
  }, m.gray.hsv = m.gray.hsl, m.gray.hwb = function(M) {
    return [0, 100, M[0]];
  }, m.gray.cmyk = function(M) {
    return [0, 0, 0, M[0]];
  }, m.gray.lab = function(M) {
    return [M[0], 0, 0];
  }, m.gray.hex = function(M) {
    const z = Math.round(M[0] / 100 * 255) & 255, S = ((z << 16) + (z << 8) + z).toString(16).toUpperCase();
    return "000000".substring(S.length) + S;
  }, m.rgb.gray = function(M) {
    return [(M[0] + M[1] + M[2]) / 3 / 255 * 100];
  }, u_;
}
var c_, vv;
function aS() {
  if (vv) return c_;
  vv = 1;
  const d = Zx();
  function o() {
    const z = {}, S = Object.keys(d);
    for (let u = S.length, O = 0; O < u; O++)
      z[S[O]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return z;
  }
  function m(z) {
    const S = o(), u = [z];
    for (S[z].distance = 0; u.length; ) {
      const O = u.pop(), U = Object.keys(d[O]);
      for (let K = U.length, ae = 0; ae < K; ae++) {
        const he = U[ae], J = S[he];
        J.distance === -1 && (J.distance = S[O].distance + 1, J.parent = O, u.unshift(he));
      }
    }
    return S;
  }
  function b(z, S) {
    return function(u) {
      return S(z(u));
    };
  }
  function M(z, S) {
    const u = [S[z].parent, z];
    let O = d[S[z].parent][z], U = S[z].parent;
    for (; S[U].parent; )
      u.unshift(S[U].parent), O = b(d[S[U].parent][U], O), U = S[U].parent;
    return O.conversion = u, O;
  }
  return c_ = function(z) {
    const S = m(z), u = {}, O = Object.keys(S);
    for (let U = O.length, K = 0; K < U; K++) {
      const ae = O[K];
      S[ae].parent !== null && (u[ae] = M(ae, S));
    }
    return u;
  }, c_;
}
var h_, xv;
function rS() {
  if (xv) return h_;
  xv = 1;
  const d = Zx(), o = aS(), m = {}, b = Object.keys(d);
  function M(S) {
    const u = function(...O) {
      const U = O[0];
      return U == null ? U : (U.length > 1 && (O = U), S(O));
    };
    return "conversion" in S && (u.conversion = S.conversion), u;
  }
  function z(S) {
    const u = function(...O) {
      const U = O[0];
      if (U == null)
        return U;
      U.length > 1 && (O = U);
      const K = S(O);
      if (typeof K == "object")
        for (let ae = K.length, he = 0; he < ae; he++)
          K[he] = Math.round(K[he]);
      return K;
    };
    return "conversion" in S && (u.conversion = S.conversion), u;
  }
  return b.forEach((S) => {
    m[S] = {}, Object.defineProperty(m[S], "channels", { value: d[S].channels }), Object.defineProperty(m[S], "labels", { value: d[S].labels });
    const u = o(S);
    Object.keys(u).forEach((O) => {
      const U = u[O];
      m[S][O] = z(U), m[S][O].raw = M(U);
    });
  }), h_ = m, h_;
}
var sS = rS();
const oS = /* @__PURE__ */ iS(sS);
function bv({ gl: d, type: o, source: m }) {
  const b = d.createShader(o);
  if (b === null)
    throw new Error("Cannot create shader");
  if (d.shaderSource(b, m), d.compileShader(b), !d.getShaderParameter(b, d.COMPILE_STATUS))
    throw console.error("Shader compilation error:", d.getShaderInfoLog(b)), d.deleteShader(b), new Error("Cannot compile shader");
  return b;
}
function lS({ gl: d, vertexShaderSource: o, fragmentShaderSource: m }) {
  const b = bv({
    gl: d,
    type: d.VERTEX_SHADER,
    source: o
  }), M = bv({ gl: d, type: d.FRAGMENT_SHADER, source: m }), z = d.createProgram();
  if (d.attachShader(z, b), d.attachShader(z, M), d.linkProgram(z), !d.getProgramParameter(z, d.LINK_STATUS))
    throw console.error("Error: ", d.getProgramInfoLog(z)), new Error("Cannot link shader program");
  return z;
}
function uS(d, o, m) {
  const b = d.getUniformLocation(o, m);
  if (b === null)
    throw new Error(`Cannot get uniform location for ${m}`);
  return b;
}
function $x({
  gl: d,
  vertexShaderSource: o,
  fragmentShaderSource: m,
  attributesKeys: b,
  uniformsKeys: M,
  vertices: z,
  indices: S
}) {
  const u = lS({ gl: d, vertexShaderSource: o, fragmentShaderSource: m }), O = b.reduce((J, ke) => (J[ke] = d.getAttribLocation(u, `a_${ke}`), J), {}), U = M.reduce((J, ke) => (J[ke] = uS(d, u, `u_${ke}`), J), {}), K = d.createBuffer();
  d.bindBuffer(d.ARRAY_BUFFER, K), d.bufferData(d.ARRAY_BUFFER, new Float32Array(z), d.STATIC_DRAW);
  let ae, he;
  return S !== void 0 && (ae = d.createBuffer(), he = S.length, d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, ae), d.bufferData(d.ELEMENT_ARRAY_BUFFER, new Uint16Array(S), d.STATIC_DRAW)), {
    shaderProgram: u,
    programInfo: {
      attributesLocations: O,
      uniformsLocations: U
    },
    positionBuffer: K,
    indexBuffer: ae,
    indexBufferLength: he
  };
}
function Vg(d) {
  if (!d)
    return [1, 1, 1, 0];
  if (d === "transparent")
    return [1, 1, 1, 0];
  try {
    const o = cS(d), m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(o);
    if (m != null && m.length) {
      const M = !!m[4];
      return [...oS.hex.rgb(o).map((z) => z / 255), M ? parseInt(m[4], 16) / 255 : 1];
    }
    const b = o.match(/(\d\.\d(\d+)?|\d{3}|\d{2}|\d{1})/gi) ?? ["0", "0", "0"];
    if (o.includes("rgb")) {
      const M = o.includes("rgba"), z = [
        ...b.map((S) => parseFloat(S)).map((S, u) => u < 3 ? S / 255 : S)
        // because alpha is in the range 0 - 1, not 0 - 255
      ];
      return M || z.push(1), z;
    }
  } catch {
  }
  return console.warn([`[parseColorStringToVec4]: Color ${d} is either not a valid color or its type is not supported, defaulting to black`]), [0, 0, 0, 1];
}
let hm;
function cS(d) {
  return hm = hm ?? document.createElement("canvas").getContext("2d"), hm ? (hm.fillStyle = d, hm.fillStyle) : "#000000";
}
const r0 = 1, el = r0 / 2, tl = r0 / 2, il = r0 / 2, hS = [-0.5, -0.5, il, el, -0.5, il, el, tl, il, -0.5, tl, il], dS = [-0.5, -0.5, -0.5, -0.5, tl, -0.5, el, tl, -0.5, el, -0.5, -0.5], pS = [-0.5, tl, -0.5, -0.5, tl, il, el, tl, il, el, tl, -0.5], fS = [-0.5, -0.5, -0.5, el, -0.5, -0.5, el, -0.5, il, -0.5, -0.5, il], mS = [el, -0.5, -0.5, el, tl, -0.5, el, tl, il, el, -0.5, il], gS = [-0.5, -0.5, -0.5, -0.5, -0.5, il, -0.5, tl, il, -0.5, tl, -0.5], yS = [...hS, ...dS, ...pS, ...fS, ...mS, ...gS], _S = [
  // Front
  0,
  1,
  2,
  0,
  2,
  3,
  // Back
  4,
  5,
  6,
  4,
  6,
  7,
  // Left
  8,
  9,
  10,
  8,
  10,
  11,
  // Right
  12,
  13,
  14,
  12,
  14,
  15,
  // Up
  16,
  17,
  18,
  16,
  18,
  19,
  // Down
  20,
  21,
  22,
  20,
  22,
  23
], vS = `attribute vec3 a_vertexPosition;
varying vec3 vTextureCoord;

uniform mat4 u_projectionMatrix;
uniform mat4 u_modelViewMatrix;
  
void main(void) {
  vTextureCoord = vec3(-a_vertexPosition.x, a_vertexPosition.y, a_vertexPosition.z);
  gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_vertexPosition, 1.0);
}
`, wv = `precision mediump float;

varying vec3 vTextureCoord;

%USE_TEXTURE_MACRO_MARKER%

# ifdef USE_TEXTURE
uniform samplerCube u_cubeSampler;
uniform float u_fadeOpacity;
# endif

uniform vec4 u_bgColor;

void main(void) {
  #ifdef USE_TEXTURE
  vec4 texColor = textureCube(u_cubeSampler, vTextureCoord);

    gl_FragColor = mix(
      u_bgColor,
      texColor,
      min(texColor.a, u_fadeOpacity)
    );

    gl_FragColor.a = max(gl_FragColor.a, u_fadeOpacity);

  #else
  gl_FragColor = u_bgColor;
  #endif
}
`, Nd = {
  stars: {
    color: "hsl(233,100%,92%)",
    preset: "stars"
  },
  space: {
    color: "hsl(210, 100%, 4%)",
    preset: "space"
  },
  milkyway: {
    color: "hsl(233,100%,92%)",
    preset: "milkyway"
  },
  "milkyway-subtle": {
    color: "hsl(233,100%,92%)",
    preset: "milkyway-subtle"
  },
  "milkyway-bright": {
    color: "hsl(233,100%,92%)",
    preset: "milkyway-bright"
  },
  "milkyway-colored": {
    color: "black",
    preset: "milkyway-colored"
  }
};
var Id = /* @__PURE__ */ ((d) => (d.POSITIVE_X = "pX", d.NEGATIVE_X = "nX", d.POSITIVE_Y = "pY", d.NEGATIVE_Y = "nY", d.POSITIVE_Z = "pZ", d.NEGATIVE_Z = "nZ", d))(Id || {});
let Dg, Sv, Tv;
function xS({ gl: d, faces: o, onReady: m, forceRefresh: b }) {
  Dg && !b && Tv === JSON.stringify(o) && m(Dg, Sv), Tv = JSON.stringify(o);
  const M = Dg ?? d.createTexture();
  if (d.bindTexture(d.TEXTURE_CUBE_MAP, M), !o) {
    console.warn("[CubemapLayer][loadCubemapTexture]: Faces are null");
    return;
  }
  const z = Object.keys(o).length;
  if (z !== 6) {
    console.warn(`[CubemapLayer][loadCubemapTexture]: Faces should contain exactly 6 images, but found ${z}`);
    return;
  }
  const S = Object.entries(o).map(([u, O]) => new Promise((U, K) => {
    const ae = u;
    if (O === void 0) {
      K(new Error(`[CubemapLayer][loadCubemapTexture]: Face ${u} is undefined`));
      return;
    }
    const he = new Image();
    he.crossOrigin = "anonymous";
    const J = () => {
      U({ image: he, key: ae });
    };
    he.src = O, he.complete && he.naturalWidth > 0 ? J() : he.onload = J, he.onerror = () => {
      K(new Error(`[CubemapLayer][loadCubemapTexture]: Error loading image ${O}`));
    };
  }));
  Promise.all(S).then((u) => {
    for (let U = 0; U < u.length; U++) {
      const K = d.RGBA, ae = d.RGBA, he = d.UNSIGNED_BYTE, { image: J, key: ke } = u[U] ?? {};
      if (!J || !ke) {
        console.warn("[CubemapLayer][loadCubemapTexture]: Image or key is null");
        continue;
      }
      const qe = bS(d, ke);
      d.bindTexture(d.TEXTURE_CUBE_MAP, M), d.texParameteri(d.TEXTURE_CUBE_MAP, d.TEXTURE_MAG_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_CUBE_MAP, d.TEXTURE_MIN_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_CUBE_MAP, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_CUBE_MAP, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texImage2D(qe, 0, K, ae, he, J);
    }
    d.bindTexture(d.TEXTURE_CUBE_MAP, M), d.generateMipmap(d.TEXTURE_CUBE_MAP), d.texParameteri(d.TEXTURE_CUBE_MAP, d.TEXTURE_MIN_FILTER, d.LINEAR_MIPMAP_LINEAR), d.texParameteri(d.TEXTURE_CUBE_MAP, d.TEXTURE_MAG_FILTER, d.LINEAR);
    const O = u.map((U) => U.image);
    m(M, O), Sv = O, Dg = M;
  }).catch((u) => {
    console.error("[CubemapLayer][loadCubemapTexture]: Error loading cubemap texture", u);
  });
}
function bS(d, o) {
  if (o === Id.POSITIVE_X)
    return d.TEXTURE_CUBE_MAP_POSITIVE_X;
  if (o === Id.NEGATIVE_X)
    return d.TEXTURE_CUBE_MAP_NEGATIVE_X;
  if (o === Id.POSITIVE_Y)
    return d.TEXTURE_CUBE_MAP_POSITIVE_Y;
  if (o === Id.NEGATIVE_Y)
    return d.TEXTURE_CUBE_MAP_NEGATIVE_Y;
  if (o === Id.POSITIVE_Z)
    return d.TEXTURE_CUBE_MAP_POSITIVE_Z;
  if (o === Id.NEGATIVE_Z)
    return d.TEXTURE_CUBE_MAP_NEGATIVE_Z;
  throw new Error(`[CubemapLayer][loadCubemapTexture]: Invalid key ${o}`);
}
function wS(d, o, m) {
  return [
    Sh(d[0], o[0], m),
    Sh(d[1], o[1], m),
    Sh(d[2], o[2], m),
    Sh(d[3], o[3], m)
  ];
}
function Sh(d, o, m) {
  return d + (o - d) * m;
}
const Zp = "https://api.maptiler.com/resources/space", SS = ["vertexPosition"], TS = ["projectionMatrix", "modelViewMatrix", "cubeSampler", "bgColor", "fadeOpacity"], Mv = "%USE_TEXTURE_MACRO_MARKER%", MS = "#define USE_TEXTURE", Av = Nd.stars;
function AS(d, o) {
  if (!Hx(d))
    return {
      color: "transparent"
    };
  if (d === !0)
    return o;
  const m = {
    ...d
  };
  if (d.faces || d.path)
    return delete m.preset, m;
  const b = d.preset;
  if (b !== void 0 && !(b in Nd))
    throw new Error(`[CubemapLayer]: Invalid preset "${b}". Available presets: ${Object.keys(Nd).join(", ")}`);
  return {
    ...m,
    // this _could_ be nullish_
    color: m.color ?? Nd[b].color ?? "hsl(233,100%,92%)"
  };
}
class d_ {
  /**
   * Creates a new instance of CubemapLayer
   *
   * @param {CubemapLayerConstructorOptions | true} cubemapConfig - Configuration options for the cubemap layer or `true` to use default options.
   * Can specify faces, preset, path, and color properties to configure the cubemap.
   *
   * @remarks You shouldn't have to use this class directly.
   * Instead, use the `Map.setHalo` method to create and add a halo layer to the map.
   * The constructor initializes the cubemap with the provided configuration.
   * It processes the faces definition, sets up background colors, and determines
   * whether to use a cubemap texture based on the provided options.
   */
  constructor(o) {
    St(this, "id", "Cubemap Layer"), St(this, "type", "custom"), St(this, "renderingMode", "3d"), St(this, "map"), St(this, "faces"), St(this, "useCubemapTexture", !0), St(this, "currentFadeOpacity", 0), St(this, "cubeMapNeedsUpdate", !1), St(this, "bgColor"), St(this, "previousBgColor", [0, 0, 0, 0]), St(this, "targetBgColor", [0, 0, 0, 0]), St(this, "transitionDelta", 0), St(this, "gl"), St(this, "cubemap"), St(this, "texture"), St(this, "currentFacesDefinitionKey", ""), St(this, "options"), St(this, "animationActive", !0), St(this, "imageIsAnimating", !1), St(this, "imageFadeInDelta", 0);
    const m = AS(o, Av);
    this.options = m, this.currentFacesDefinitionKey = JSON.stringify(m.faces ?? m.preset ?? m.path), this.bgColor = [0, 0, 0, 0], this.targetBgColor = Vg(m.color), this.faces = Ev(m), this.useCubemapTexture = this.faces !== null;
  }
  /**
   * Updates the cubemap object with the current faces and shader configuration.
   * This method is called when the cubemap faces change or when the layer is initialized.
   * @returns {void}
   * @remarks
   * It creates a new Object3D instance with the specified vertex and fragment shaders,
   * attributes, and uniforms. The cubemap will be rendered using this configuration.
   */
  updateCubemap({ facesNeedUpdate: o } = { facesNeedUpdate: !0 }) {
    this.useCubemapTexture = this.faces !== null;
    const m = TS.filter((b) => b === "cubeSampler" || b === "fadeOpacity" ? this.useCubemapTexture : !0);
    this.cubemap = $x({
      gl: this.gl,
      vertexShaderSource: vS,
      // Because we only want to use the read the texture in gl if we're supposed to
      fragmentShaderSource: this.useCubemapTexture ? wv.replace(Mv, MS) : wv.replace(Mv, ""),
      attributesKeys: SS,
      uniformsKeys: m,
      vertices: yS,
      indices: _S
    }), this.cubeMapNeedsUpdate = o, this.useCubemapTexture && this.updateTexture(this.gl, this.faces), this.animateColorChange();
  }
  /**
   * Called when the layer is added to the map.
   * Initializes the cubemap and sets up the WebGL context.
   *
   * @param {MapSDK} map - The map instance to which this layer is added.
   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
   */
  onAdd(o, m) {
    this.map = o, this.gl = m, this.updateCubemap();
  }
  /**
   * Called when the layer is removed from the map.
   * Cleans up the cubemap resources and WebGL buffers.
   *
   * @param {MapSDK} _map - The map instance from which this layer is removed.
   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
   */
  onRemove(o, m) {
    this.cubemap && (m.deleteProgram(this.cubemap.shaderProgram), m.deleteBuffer(this.cubemap.positionBuffer));
  }
  /**
   * Updates the cubemap texture with the provided faces.
   * This method is called when the cubemap faces change or when the layer is initialized.
   *
   * @param {WebGLContext} gl - The WebGL context used for rendering.
   * @param {CubemapFaces} faces - The cubemap faces to be loaded into the texture.
   */
  updateTexture(o, m) {
    if (this.cubeMapNeedsUpdate === !0 && !this.imageIsAnimating) {
      if (this.cubeMapNeedsUpdate = !1, !this.useCubemapTexture)
        return;
      xS({
        gl: o,
        faces: m,
        onReady: (b) => {
          this.texture = b, this.animateIn();
        }
      });
    }
  }
  /**
   * Called before the layer is rendered.
   * Updates the cubemap texture with the current faces.
   *
   * @param {WebGLContext} gl - The WebGL context used for rendering.
   * @param {CustomRenderMethodInput} _options - Additional options for the render method.
   */
  prerender(o, m) {
    this.faces && this.updateTexture(this.gl, this.faces);
  }
  /**
   * Lerps the background color transition of the cubemap layer.
   * This method smoothly transitions the background color from the previous color to the target color.
   *
   * @private
   */
  animateColorChange() {
    const o = () => {
      this.transitionDelta < 1 && (requestAnimationFrame(o), this.bgColor = wS(this.previousBgColor, this.targetBgColor, this.transitionDelta), this.transitionDelta += 0.075, this.map.triggerRepaint());
    };
    requestAnimationFrame(o);
  }
  /**
   * Animates the cubemap image fading in.
   * This method gradually increases the opacity of the cubemap image to create a fade-in effect.
   * @private
   */
  async animateIn() {
    if (!this.imageIsAnimating) {
      if (!this.animationActive) {
        this.currentFadeOpacity = 1, this.imageFadeInDelta = 1, this.map.triggerRepaint();
        return;
      }
      return new Promise((o) => {
        this.imageIsAnimating = !0;
        const m = () => {
          if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + 0.05, 1), this.currentFadeOpacity = Sh(0, 1, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta < 1) {
            requestAnimationFrame(m);
            return;
          }
          this.imageIsAnimating = !1, this.imageFadeInDelta = 0, o();
        };
        requestAnimationFrame(m);
      });
    }
  }
  /**
   * Animates the cubemap image fading out.
   * This method gradually decreases the opacity of the cubemap image to create a fade-out effect.
   * @returns {Promise<void>} A promise that resolves when the animation is complete.
   * @private
   */
  async animateOut() {
    if (!(this.imageIsAnimating || !this.animationActive))
      return new Promise((o) => {
        const m = () => {
          if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + 0.05, 1), this.currentFadeOpacity = Sh(1, 0, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta >= 1) {
            this.imageIsAnimating = !1, this.imageFadeInDelta = 0, o();
            return;
          }
          requestAnimationFrame(m);
        };
        requestAnimationFrame(m);
      });
  }
  setAnimationActive(o) {
    this.animationActive = o;
  }
  /**
   * Renders the cubemap layer to the WebGL context.
   * This method is called internally during the rendering phase of the map.
   *
   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
   * @param {CustomRenderMethodInput} _options - Additional options for the render method.
   * @throws Error if the map, cubemap, or texture is undefined.
   */
  render(o, m) {
    if (!this.map.isGlobeProjection())
      return;
    if (this.map === void 0)
      throw new Error("[CubemapLayer]: Map is undefined");
    if (this.cubemap === void 0)
      throw new Error("[CubemapLayer]: Cubemap is undefined");
    this.texture, o.disable(o.DEPTH_TEST), o.enable(o.BLEND), o.blendFunc(o.SRC_ALPHA, o.DST_ALPHA), o.useProgram(this.cubemap.shaderProgram), o.bindBuffer(o.ARRAY_BUFFER, this.cubemap.positionBuffer), o.vertexAttribPointer(this.cubemap.programInfo.attributesLocations.vertexPosition, 3, o.FLOAT, !1, 0, 0), o.enableVertexAttribArray(this.cubemap.programInfo.attributesLocations.vertexPosition);
    const b = 0.1, M = 1e4, z = o.canvas, S = z.clientWidth / z.clientHeight, u = this.map.transform, O = u.fov * (Math.PI / 180), U = bm();
    eS(U, O, S, b, M), fv(U, U, u.rollInRadians), pv(U, U, -u.pitchInRadians), fv(U, U, u.bearingInRadians);
    const K = u.center.lat * Math.PI / 180, ae = u.center.lng * Math.PI / 180;
    pv(U, U, K), Jw(U, U, -ae), o.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.projectionMatrix, !1, U);
    const he = bm();
    if (o.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.modelViewMatrix, !1, he), o.uniform4fv(this.cubemap.programInfo.uniformsLocations.bgColor, new Float32Array(this.bgColor)), o.uniform1f(this.cubemap.programInfo.uniformsLocations.fadeOpacity, this.currentFadeOpacity), this.useCubemapTexture && this.texture && (o.activeTexture(o.TEXTURE0), o.bindTexture(o.TEXTURE_CUBE_MAP, this.texture), o.uniform1i(this.cubemap.programInfo.uniformsLocations.cubeSampler, 0)), this.cubemap.indexBuffer === void 0)
      throw new Error("Index buffer is undefined");
    if (this.cubemap.indexBufferLength === void 0)
      throw new Error("Index buffer length is undefined");
    o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, this.cubemap.indexBuffer), o.drawElements(o.TRIANGLES, this.cubemap.indexBufferLength, o.UNSIGNED_SHORT, 0);
  }
  setBgColor(o) {
    this.targetBgColor = o, this.previousBgColor = this.bgColor, this.transitionDelta = 0;
  }
  /**
   * Returns the current configuration options for the cubemap layer.
   * @returns {CubemapLayerConstructorOptions} The current configuration options.
   */
  getConfig() {
    return this.options;
  }
  async setCubemapFaces(o) {
    if (await this.animateOut(), !o.faces && !o.preset && !o.path) {
      this.faces = null, this.useCubemapTexture = !1, this.currentFacesDefinitionKey = "empty", await this.animateIn();
      return;
    }
    this.faces = Ev(o), this.currentFacesDefinitionKey = JSON.stringify(o.faces ?? o.preset ?? o.path);
  }
  /**
   * Sets the cubemap for the layer based on the provided definition.
   * This method updates the cubemap faces, background color, and triggers a repaint of the map.
   *
   * @param {CubemapDefinition} cubemap - The cubemap definition containing faces, preset, path, or color.
   * @returns {Promise<void>} A promise that resolves when the cubemap is set and the map is updated.
   * @remarks
   * This method checks if the provided cubemap definition has a color, and if so, it updates the background color.
   * It also checks if the faces definition has changed compared to the current one,
   * and if so, it updates the cubemap faces.
   * Finally, it calls `updateCubemap` to apply the changes and trigger a repaint of the map.
   */
  async setCubemap(o) {
    const m = typeof o == "boolean" ? Av : o;
    this.options = m;
    const b = JSON.stringify(m.faces ?? m.preset ?? m.path), M = this.currentFacesDefinitionKey !== b;
    M && (await this.setCubemapFaces(m), this.cubeMapNeedsUpdate = !0);
    const z = Vg(m.color);
    if (m.color && this.targetBgColor.toString() !== z.toString())
      this.setBgColor(z);
    else if (!m.color && m.preset && m.preset in Nd) {
      const S = Nd[m.preset];
      this.setBgColor(Vg(S.color));
    }
    this.updateCubemap({ facesNeedUpdate: M });
  }
  /**
   * Shows the cubemap layer by setting its visibility to "visible".
   * This method is used to make the cubemap layer visible on the map.
   */
  show() {
    this.map.setLayoutProperty(this.id, "visibility", "visible");
  }
  /**
   * Hides the cubemap layer by setting its visibility to "none".
   * This method is used to remove the cubemap layer from the map without deleting it.
   */
  hide() {
    this.map.setLayoutProperty(this.id, "visibility", "none");
  }
}
function Hx(d) {
  return d ? typeof d == "boolean" ? !0 : !(!d.path && !d.preset && !d.faces && !d.color || d.preset && !(d.preset in Nd) || d.faces && (!d.faces.pX || !d.faces.nX || !d.faces.pY || !d.faces.nY || !d.faces.pZ || !d.faces.nZ)) : !1;
}
function Ev(d) {
  if (d.faces)
    return d.faces;
  if (d.preset)
    return {
      pX: `${Zp}/${d.preset}/px.webp`,
      nX: `${Zp}/${d.preset}/nx.webp`,
      pY: `${Zp}/${d.preset}/py.webp`,
      nY: `${Zp}/${d.preset}/ny.webp`,
      pZ: `${Zp}/${d.preset}/pz.webp`,
      nZ: `${Zp}/${d.preset}/nz.webp`
    };
  if (d.path) {
    const o = d.path.baseUrl, m = d.path.format ?? "png";
    return {
      pX: `${o}/px.${m}`,
      nX: `${o}/nx.${m}`,
      pY: `${o}/py.${m}`,
      nY: `${o}/ny.${m}`,
      pZ: `${o}/pz.${m}`,
      nZ: `${o}/nz.${m}`
    };
  }
  return null;
}
const ES = `attribute vec3 a_position;

uniform mat4 u_matrix;
uniform mat4 u_rotationMatrix;

uniform float u_scale;

varying vec2 v_pos;
varying float v_scale;

void main() {
  v_scale = u_scale;
  v_pos = a_position.xy * u_scale;
  gl_Position = u_matrix * u_rotationMatrix * vec4(a_position, 1.0);
}
`, CS = `precision mediump float;
varying vec2 v_pos;
      
uniform int u_stopsNumber;
uniform float u_stops[100];
uniform vec4 u_colors[100];
uniform float u_maxDistance;

varying float v_scale;

const float EPSILON = 0.000001;

vec2 center = vec2(0.0, 0.0);
void main() {
  float rawDistance = distance(center, v_pos);
  float distanceFromGlobeEdge = rawDistance - 1.0;

    vec4 color = u_colors[0];

  // if we're further than the max distance, we should not render anything.
  // This is to always render a circle, otherwise we end up rendering
  // to the corners of the plane.
  if (distance(center, v_pos) > u_maxDistance * v_scale) {
    discard;
  }

  for (int i = 1; i < 100; i++) {
    // if we're past the last stop
    // we should fill to the end with the last stop color
    if (i >= u_stopsNumber) {
      color = u_colors[i - 1];
      break;
    }

    float scaledStopPosition = u_stops[i] * pow(v_scale, 1.6);
    float lastStopValue = u_stops[i - 1];
    float thisStopValue = u_stops[i];

    // this is to avoid blending errors when the stops are the same
    // eg when you would want a sharp edge between two stops.
    // \`numbersAreEqual\` will be 1.0 if the numbers are equal, 0.0 if they are not.
    // We then subtract EPSILON from the last stop making the stop value _almost_ equal
    // to the next stop but not enough to cause blending issues.
    // It's more efficient to do this than an if / else statement.
    float numbersAreEqual = 1.0 - step(EPSILON, abs(lastStopValue - thisStopValue));
    lastStopValue = lastStopValue - numbersAreEqual * EPSILON;

    float lastScaledStopPosition = lastStopValue * pow(v_scale, 1.6);

    if (distanceFromGlobeEdge <= scaledStopPosition) {
      float stopBlendFactor = (distanceFromGlobeEdge - lastScaledStopPosition) / (scaledStopPosition - lastScaledStopPosition);
      color = mix(u_colors[i - 1], u_colors[i], stopBlendFactor);
      break;
    }
  }
  
  // gl_FragColor = color;
  gl_FragColor = vec4(color.rgb * color.a, color.a);
}
`, gm = 2, zS = ["position"], PS = ["matrix", "rotationMatrix", "stopsNumber", "stops", "colors", "maxDistance", "scale"], IS = [
  -2,
  -2,
  0,
  gm,
  -2,
  0,
  -2,
  gm,
  0,
  gm,
  gm,
  0
], Md = {
  scale: 0.9,
  stops: [
    [0, "rgba(176, 208, 240, 1)"],
    [0.1, "rgba(98, 168, 229, 0.3)"],
    [0.2, "rgba(98, 168, 229, 0.0)"]
  ]
}, Cv = 0.06;
class p_ {
  /**
   * Creates a new RadialGradientLayer instance.
   *
   * @param {RadialGradientLayerConstructorOptions | boolean} gradient - Configuration options for the radial gradient or a boolean value.
   * If a boolean is provided, default configuration options will be used.
   * If an `RadialGradientLayerConstructorOptions` is provided, it will be merged with default options.
   */
  constructor(o) {
    if (St(this, "id", "Halo Layer"), St(this, "type", "custom"), St(this, "renderingMode", "3d"), St(this, "gradient"), St(this, "scale", 0), St(this, "animationDelta", 0), St(this, "map"), St(this, "plane"), St(this, "animationActive", !0), typeof o == "boolean") {
      this.gradient = Md;
      return;
    }
    this.gradient = {
      ...Md,
      ...o
    };
  }
  /**
   * Adds the radial gradient layer to the specified map.
   * This method is called by the map when the layer is added to it.
   *
   * @param {MapSDK} map - The MapSDK instance to which this layer is being added
   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL rendering context used for rendering the layer
   * @returns void
   */
  onAdd(o, m) {
    this.map = o, this.plane = $x({
      gl: m,
      vertexShaderSource: ES,
      fragmentShaderSource: CS,
      attributesKeys: zS,
      uniformsKeys: PS,
      vertices: IS
    }), this.animateIn();
  }
  /**
   * Returns the current gradient configuration of the radial gradient layer.
   *
   * @returns {GradientDefinition} The current gradient configuration.
   */
  getConfig() {
    return this.gradient;
  }
  /**
   * Animates the radial gradient into view by gradually scaling from 0 to the target scale.
   *
   * This method uses requestAnimationFrame to create a smooth scaling animation effect.
   * During each frame, it:
   *   1. Interpolates the scale value between 0 and the target scale
   *   2. Increments the animation progress (animationDelta)
   *   3. Triggers a map repaint
   *
   * @private
   * @returns {Promise<void>} A promise that resolves when the animation completes
   */
  async animateIn() {
    if (!this.animationActive) {
      this.scale = this.gradient.scale, this.animationDelta = 1, this.map.triggerRepaint();
      return;
    }
    return new Promise((o) => {
      this.animationDelta = 0;
      const m = () => {
        if (this.animationDelta < 1) {
          this.scale = Sh(0, this.gradient.scale, this.animationDelta), this.animationDelta += Cv, this.map.triggerRepaint(), requestAnimationFrame(m);
          return;
        }
        o();
      };
      requestAnimationFrame(m);
    });
  }
  /**
   * Animates the radial gradient layer out by gradually reducing its scale to zero.
   *
   * This method creates a smooth transition effect by linearly interpolating the scale
   * from its current value to zero over multiple animation frames. During each frame,
   * the animation progresses by incrementing the internal animation delta value.
   *
   * The map is repainted after each animation step to reflect the updated scale.
   *
   * @private
   * @returns A Promise that resolves when the animation is complete.
   */
  async animateOut() {
    if (this.animationActive)
      return this.animationDelta = 0, new Promise((o) => {
        const m = () => {
          if (this.animationDelta < 1) {
            this.scale = Sh(this.gradient.scale, 0, this.animationDelta), this.animationDelta += Cv, this.map.triggerRepaint(), requestAnimationFrame(m);
            return;
          }
          o();
        };
        m();
      });
  }
  onRemove(o, m) {
    this.plane !== void 0 && (m.deleteProgram(this.plane.shaderProgram), m.deleteBuffer(this.plane.positionBuffer));
  }
  prerender(o, m) {
  }
  render(o, m) {
    if (this.map === void 0)
      throw new Error("[RadialGradientLayer]: Map is undefined");
    if (!this.map.isGlobeProjection())
      return;
    if (this.plane === void 0)
      throw new Error("[RadialGradientLayer]: Plane is undefined");
    o.disable(o.DEPTH_TEST), o.enable(o.BLEND), o.useProgram(this.plane.shaderProgram), o.bindBuffer(o.ARRAY_BUFFER, this.plane.positionBuffer);
    const b = this.plane.programInfo.attributesLocations.position;
    o.enableVertexAttribArray(b), o.vertexAttribPointer(b, 3, o.FLOAT, !1, 0, 0);
    const M = bm(), z = this.scale;
    Ww(M, M, [z, z, z]);
    const S = bm();
    Kw(S, m.defaultProjectionData.mainMatrix, M);
    const u = this.plane.programInfo.uniformsLocations.matrix;
    o.uniformMatrix4fv(u, !1, S);
    const O = bm(), U = this.map.transform.cameraPosition, K = l_(Fg(), U), ae = tS(0, 1, 0), he = Fg();
    mv(he, ae, K), l_(he, he);
    const J = Fg();
    mv(J, K, he), l_(J, J), Yw(O, he[0], he[1], he[2], 0, J[0], J[1], J[2], 0, K[0], K[1], K[2], 0, 0, 0, 0, 1);
    const ke = this.plane.programInfo.uniformsLocations.rotationMatrix;
    o.uniformMatrix4fv(ke, !1, O);
    const qe = this.gradient.stops.length, ft = [], ht = [];
    for (let it = 0; it <= qe; it++)
      if (it < qe) {
        ft[it] = this.gradient.stops[it][0];
        const nt = Vg(this.gradient.stops[it][1]);
        ht.push(...nt);
      }
    o.uniform1i(this.plane.programInfo.uniformsLocations.stopsNumber, qe), o.uniform1fv(this.plane.programInfo.uniformsLocations.stops, new Float32Array(ft)), o.uniform4fv(this.plane.programInfo.uniformsLocations.colors, new Float32Array(ht)), o.uniform1f(this.plane.programInfo.uniformsLocations.maxDistance, gm), o.uniform1f(this.plane.programInfo.uniformsLocations.scale, z), o.drawArrays(o.TRIANGLE_STRIP, 0, 4);
  }
  /**
   * Sets a new gradient for the radial gradient layer and animates the transition.
   *
   * This method first animates the current gradient out, then updates the gradient
   * property with the new gradient definition, and finally animates the new gradient in.
   *
   * @param {GradientDefinition} gradient - The new gradient definition to set for this layer.
   * @returns {Promise<void>} A promise that resolves when the new gradient is set and animated in.
   */
  async setGradient(o) {
    if (o === !1) {
      await this.animateOut();
      return;
    }
    if (await this.animateOut(), !kS(o)) {
      this.gradient.scale = Md.scale, this.gradient.stops = [
        [0, "transparent"],
        [1, "transparent"]
      ];
      return;
    }
    o === !0 ? (this.gradient.scale = Md.scale, this.gradient.stops = Md.stops) : (this.gradient.scale = o.scale ?? Md.scale, this.gradient.stops = o.stops ?? Md.stops), await this.animateIn();
  }
  setAnimationActive(o) {
    this.animationActive = o;
  }
  show() {
    this.map.setLayoutProperty(this.id, "visibility", "visible");
  }
  hide() {
    this.map.setLayoutProperty(this.id, "visibility", "none");
  }
}
function kS(d) {
  return typeof d == "boolean" ? !0 : !(typeof d.scale != "number" || !d.stops || d.stops.length === 0 || d.stops.some((o) => typeof o[0] != "number" || typeof o[1] != "string"));
}
const RS = {
  POINT: "POINT",
  COUNTRY: "COUNTRY"
};
let Xx = class Yx extends Lt.Map {
  constructor(o) {
    mb(o.container), o.apiKey && (Ha.apiKey = o.apiKey);
    const { style: m, requiresUrlMonitoring: b, isFallback: M } = cv(o.style);
    M && console.warn(
      "Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style."
    ), Ha.apiKey || console.warn("MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!");
    const z = location.hash;
    let S = {
      compact: !1
    };
    o.customAttribution ? S.customAttribution = o.customAttribution : o.attributionControl && typeof o.attributionControl == "object" && (S = {
      ...S,
      ...o.attributionControl
    });
    const u = {
      ...o,
      style: m,
      maplibreLogo: !1,
      transformRequest: F0(o.transformRequest),
      attributionControl: o.forceNoAttributionControl === !0 ? !1 : S
    };
    delete u.style, super(u), St(this, "telemetry"), St(this, "space"), St(this, "halo"), St(this, "options"), St(this, "isTerrainEnabled", !1), St(this, "terrainExaggeration", 1), St(this, "primaryLanguage"), St(this, "terrainGrowing", !1), St(this, "terrainFlattening", !1), St(this, "minimap"), St(this, "forceLanguageUpdate"), St(this, "languageAlwaysBeenStyle"), St(this, "isReady", !1), St(this, "terrainAnimationDuration", 1e3), St(this, "monitoredStyleUrls"), St(this, "styleInProcess", !1), St(this, "curentProjection"), St(this, "originalLabelStyle", new window.Map()), St(this, "isStyleLocalized", !1), St(this, "languageIsUpdated", !1), St(this, "spaceboxLoadingState", {
      styleLoadCallbackSet: !1
    }), this.options = o, this.setStyle(m), b && this.monitorStyleUrl(m);
    const O = () => {
      let J = "The distant style could not be loaded.";
      this.getStyle() ? J += "Leaving the style as is." : (this.setStyle(_m.STREETS), J += `Loading default MapTiler Cloud style "${_m.STREETS.getDefaultVariant().getId()}" as a fallback.`), console.warn(J);
    };
    if (this.on("style.load", () => {
      this.styleInProcess = !1;
    }), this.on("error", (J) => {
      if (J.error instanceof Lt.AJAXError) {
        const ke = J.error.url, qe = new URL(ke);
        qe.search = "";
        const ft = qe.href;
        this.monitoredStyleUrls && this.monitoredStyleUrls.has(ft) && (this.monitoredStyleUrls.delete(ft), O());
        return;
      }
      if (this.styleInProcess) {
        O();
        return;
      }
    }), Ha.caching && !b_ && console.warn("The cache API is only available in secure contexts. More info at https://developer.mozilla.org/en-US/docs/Web/API/Cache"), Ha.caching && b_ && hb(), typeof o.language > "u")
      this.primaryLanguage = Ha.primaryLanguage;
    else {
      const J = E0(o.language, Zi);
      this.primaryLanguage = J ?? Ha.primaryLanguage;
    }
    this.forceLanguageUpdate = !(this.primaryLanguage === Zi.STYLE || this.primaryLanguage === Zi.STYLE_LOCK), this.languageAlwaysBeenStyle = this.primaryLanguage === Zi.STYLE, this.terrainExaggeration = o.terrainExaggeration ?? this.terrainExaggeration, this.curentProjection = o.projection, this.on("styledata", () => {
      this.curentProjection === "mercator" ? this.setProjection({ type: "mercator" }) : this.curentProjection === "globe" && this.setProjection({ type: "globe" });
    }), this.once("styledata", async () => {
      if (!o.geolocate || o.center || o.hash && z)
        return;
      try {
        if (o.geolocate === RS.COUNTRY) {
          await this.fitToIpBounds();
          return;
        }
      } catch (ke) {
        console.warn(ke.message);
      }
      let J;
      try {
        await this.centerOnIpPoint(o.zoom), J = this.getCameraHash();
      } catch (ke) {
        console.warn(ke.message);
      }
      (await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted" && navigator.geolocation.getCurrentPosition(
        // success callback
        (ke) => {
          J === this.getCameraHash() && (this.terrain ? this.easeTo({
            center: [ke.coords.longitude, ke.coords.latitude],
            zoom: o.zoom || 12,
            duration: 2e3
          }) : this.once("terrain", () => {
            this.easeTo({
              center: [ke.coords.longitude, ke.coords.latitude],
              zoom: o.zoom || 12,
              duration: 2e3
            });
          }));
        },
        // error callback
        null,
        // options
        {
          maximumAge: 24 * 3600 * 1e3,
          // a day in millisec
          timeout: 5e3,
          // milliseconds
          enableHighAccuracy: !1
        }
      );
    }), this.on("styledata", () => {
      this.setPrimaryLanguage(this.primaryLanguage);
    }), this.on("styledata", () => {
      this.getTerrain() === null && this.isTerrainEnabled && this.enableTerrain(this.terrainExaggeration);
    }), this.once("load", async () => {
      let J = { logo: null };
      try {
        const ke = Object.keys(this.style.sourceCaches).map((ft) => this.getSource(ft)).filter((ft) => ft && "url" in ft && typeof ft.url == "string" && ft.url.includes("tiles.json")), qe = new URL(ke[0].url);
        qe.searchParams.has("key") || qe.searchParams.append("key", Ha.apiKey), J = await (await fetch(qe.href)).json();
      } catch {
      }
      if (o.customControls) {
        const ke = "[data-maptiler-control-group]", qe = "[data-maptiler-control]", ft = (Re) => {
          let $e = Re.dataset.maptilerControl;
          return ($e === "true" || $e === "") && ($e = void 0), $e;
        }, ht = (Re) => Re.dataset.maptilerPosition;
        let it = [...this._container.ownerDocument.querySelectorAll(ke)], nt = [...this._container.ownerDocument.querySelectorAll(qe)].filter(
          (Re) => Re.closest(ke) === null
        );
        if (typeof o.customControls == "string") {
          const Re = o.customControls;
          it = it.filter(($e) => $e.matches(Re) || $e.closest(Re) !== null), nt = nt.filter(($e) => $e.matches(Re) || $e.closest(Re) !== null);
        }
        for (const Re of it) {
          const $e = new P_(Re);
          this.addControl($e, ht(Re));
          for (const rt of Re.querySelectorAll(qe))
            $e.configureGroupItem(rt, ft(rt));
        }
        for (const Re of nt)
          this.addControl(new P_(Re, ft(Re)), ht(Re));
        const De = () => {
          const { lng: Re, lat: $e } = this.getCenter();
          this._container.style.setProperty("--maptiler-center-lng", String(Re)), this._container.style.setProperty("--maptiler-center-lat", String($e)), this._container.style.setProperty("--maptiler-zoom", String(this.getZoom())), this._container.style.setProperty("--maptiler-bearing", String(this.getBearing())), this._container.style.setProperty("--maptiler-pitch", String(this.getPitch())), this._container.style.setProperty("--maptiler-roll", String(this.getRoll())), this._container.style.setProperty("--maptiler-is-globe-projection", String(this.isGlobeProjection())), this._container.style.setProperty("--maptiler-has-terrain", String(this.hasTerrain()));
        };
        De(), this.on("render", De);
      }
      if (o.forceNoAttributionControl !== !0)
        if ("logo" in J && J.logo) {
          const ke = J.logo;
          this.addControl(new q0({ logoURL: ke }), o.logoPosition);
        } else o.maptilerLogo && this.addControl(new q0(), o.logoPosition);
      if (o.scaleControl) {
        const ke = o.scaleControl === !0 || o.scaleControl === void 0 ? "bottom-right" : o.scaleControl, qe = new Cb({ unit: Ha.unit });
        this.addControl(qe, ke), Ha.on("unit", (ft) => {
          qe.setUnit(ft);
        });
      }
      if (o.navigationControl !== !1) {
        const ke = o.navigationControl === !0 || o.navigationControl === void 0 ? "top-right" : o.navigationControl;
        this.addControl(new jx(), ke);
      }
      if (o.geolocateControl !== !1) {
        const ke = o.geolocateControl === !0 || o.geolocateControl === void 0 ? "top-right" : o.geolocateControl;
        this.addControl(
          // new maplibregl.GeolocateControl({
          new Ux({
            positionOptions: {
              enableHighAccuracy: !0,
              maximumAge: 0,
              timeout: 6e3
            },
            fitBoundsOptions: {
              maxZoom: 15
            },
            trackUserLocation: !0,
            showAccuracyCircle: !0,
            showUserLocation: !0
          }),
          ke
        );
      }
      if (o.terrainControl) {
        const ke = o.terrainControl === !0 || o.terrainControl === void 0 ? "top-right" : o.terrainControl;
        this.addControl(new Zw(), ke);
      }
      if (o.projectionControl) {
        const ke = o.projectionControl === !0 || o.projectionControl === void 0 ? "top-right" : o.projectionControl;
        this.addControl(new Hw(), ke);
      }
      if (o.fullscreenControl) {
        const ke = o.fullscreenControl === !0 || o.fullscreenControl === void 0 ? "top-right" : o.fullscreenControl;
        this.addControl(new zb({}), ke);
      }
      this.isReady = !0, this.fire("ready", { target: this });
    });
    let U = !1, K = !1, ae;
    this.once("ready", () => {
      U = !0, K && this.fire("loadWithTerrain", ae);
    }), this.once("style.load", () => {
      const { minimap: J } = o;
      if (typeof J == "object") {
        const {
          zoom: ke,
          center: qe,
          style: ft,
          language: ht,
          apiKey: it,
          maptilerLogo: nt,
          canvasContextAttributes: De,
          refreshExpiredTiles: Re,
          maxBounds: $e,
          scrollZoom: rt,
          minZoom: wt,
          maxZoom: Ht,
          boxZoom: Dt,
          locale: Xt,
          fadeDuration: pi,
          crossSourceCollisions: vn,
          clickTolerance: Cn,
          bounds: zn,
          fitBoundsOptions: He,
          pixelRatio: vt,
          validateStyle: Gt
        } = o;
        this.minimap = new o_(J, {
          zoom: ke,
          center: qe,
          style: ft,
          language: ht,
          apiKey: it,
          container: "null",
          maptilerLogo: nt,
          canvasContextAttributes: De,
          refreshExpiredTiles: Re,
          maxBounds: $e,
          scrollZoom: rt,
          minZoom: wt,
          maxZoom: Ht,
          boxZoom: Dt,
          locale: Xt,
          fadeDuration: pi,
          crossSourceCollisions: vn,
          clickTolerance: Cn,
          bounds: zn,
          fitBoundsOptions: He,
          pixelRatio: vt,
          validateStyle: Gt
        }), this.addControl(this.minimap, J.position ?? "bottom-left");
      } else J === !0 ? (this.minimap = new o_({}, o), this.addControl(this.minimap, "bottom-left")) : J !== void 0 && J !== !1 && (this.minimap = new o_({}, o), this.addControl(this.minimap, J));
    });
    const he = (J) => {
      J.terrain && (K = !0, ae = {
        type: "loadWithTerrain",
        target: this,
        terrain: J.terrain
      }, this.off("terrain", he), U && this.fire("loadWithTerrain", ae));
    };
    this.on("terrain", he), o.terrain && this.enableTerrain(o.terrainExaggeration ?? this.terrainExaggeration), this.once("load", () => {
      this.getCanvas().addEventListener("webglcontextlost", (ke) => {
        if (this._removed === !0) {
          console.warn("[webglcontextlost]", "WebGL context lost after map removal. This is harmless.");
          return;
        }
        console.warn("[webglcontextlost]", "Unexpected loss of WebGL context!"), this.fire("webglContextLost", ke);
      });
      const J = this.getLayersOrder()[0];
      o.space && this.initSpace({ options: o, before: J }), o.halo && this.initHalo({ options: o, before: J });
    }), this.telemetry = new Xw(this);
  }
  getSpace() {
    return this.space;
  }
  /**
   * Sets the space for the map.
   * @param {CubemapDefinition} space the `CubemapDefinition` options to set.
   * @remarks This method, at present, ** overwrites ** the current config.
   * If an option is not set it will internally revert to the default option
   * unless explicitly set when calling.
   */
  setSpace(o) {
    if (o === !1) {
      this.space = void 0;
      return;
    }
    if (this.isGlobeProjection()) {
      if (this.space) {
        this.space.setCubemap(o), this.getLayer(this.space.id) || this.addLayer(this.space, this.getLayersOrder()[0]);
        return;
      }
      this.space = new d_(o), this.once("load", () => {
        const m = this.getLayersOrder()[0];
        this.space && this.addLayer(this.space, m);
      });
    }
  }
  /**
   * Enables the animations for the space layer.
   */
  enableSpaceAnimations() {
    this.setSpaceAnimationActive(!0);
  }
  /**
   * Disables the animations for the space layer.
   */
  disableSpaceAnimations() {
    this.setSpaceAnimationActive(!1);
  }
  /**
   * Enables the animations for the halo layer.
   */
  enableHaloAnimations() {
    this.setHaloAnimationActive(!0);
  }
  /**
   * Disables the animations for the halo layer.
   */
  disableHaloAnimations() {
    this.setHaloAnimationActive(!1);
  }
  /**
   * Sets whether the halo layer should be animated in and out.
   * @param active - Whether the animation should be active.
   */
  setHaloAnimationActive(o) {
    this.halo ? this.halo.setAnimationActive(o) : this.once("load", () => {
      var m;
      (m = this.halo) == null || m.setAnimationActive(o);
    });
  }
  /**
   * Sets whether the space layer should be animated in and out.
   * @param active - Whether the animation should be active.
   */
  setSpaceAnimationActive(o) {
    this.space ? this.space.setAnimationActive(o) : this.once("load", () => {
      var m;
      (m = this.space) == null || m.setAnimationActive(o);
    });
  }
  setSpaceFromStyle({ style: o }) {
    var m, b, M;
    if (this.options.space) {
      this.setSpace(this.options.space);
      return;
    }
    const z = (b = (m = o.metadata) == null ? void 0 : m.maptiler) == null ? void 0 : b.space;
    if (!z) {
      this.setSpace({
        color: "transparent"
      });
      return;
    }
    if (!Hx(z)) {
      this.setSpace({
        color: "transparent"
      });
      return;
    }
    if (JSON.stringify((M = this.space) == null ? void 0 : M.getConfig()) === JSON.stringify(z)) {
      if (this.space && !this.getLayer(this.space.id)) {
        const S = this.getLayersOrder()[0];
        this.addLayer(this.space, S);
      }
      return;
    }
    (() => {
      if (this.space && this.isGlobeProjection()) {
        if (!this.getLayer(this.space.id)) {
          const S = this.getLayersOrder()[0];
          this.addLayer(this.space, S);
        }
        this.space.setCubemap(z);
      }
    })();
  }
  setHaloFromStyle({ style: o }) {
    var m, b, M;
    const z = (m = o.metadata) == null ? void 0 : m.maptiler;
    if (JSON.stringify((b = this.halo) == null ? void 0 : b.getConfig()) === JSON.stringify(z?.halo)) {
      if (this.halo && !this.getLayer(this.halo.id)) {
        const S = this.getLayersOrder().indexOf(((M = this.space) == null ? void 0 : M.id) ?? "") + 1, u = this.getLayersOrder()[S];
        this.addLayer(this.halo, u);
      }
      return;
    }
    if (!(z != null && z.halo) && !this.options.halo) {
      this.setHalo({
        stops: [
          [0, "transparent"],
          [1, "transparent"]
        ],
        scale: 1
      });
      return;
    }
    (() => {
      var S;
      if (this.halo) {
        if (!this.getLayer(this.halo.id)) {
          const O = this.getLayersOrder().indexOf(((S = this.space) == null ? void 0 : S.id) ?? "") + 1, U = this.getLayersOrder()[O];
          this.addLayer(this.halo, U);
        }
        const u = z?.halo ?? this.options.halo;
        u && this.halo.setGradient(u);
      }
    })();
  }
  initSpace({ options: o = this.options, before: m, spec: b }) {
    if (this.space) {
      this.getLayer(this.space.id) || this.addLayer(this.space, m);
      return;
    }
    if (o.space === !1) return;
    const M = b;
    if (o.space) {
      this.space = new d_(o.space), this.addLayer(this.space, m);
      return;
    }
    M && (this.space = new d_(M), this.addLayer(this.space, m));
  }
  initHalo({ options: o = this.options, before: m, spec: b }) {
    if (this.halo && this.getLayer(this.halo.id) || o.halo === !1) return;
    const M = b;
    if (o.halo) {
      this.halo = new p_(o.halo), this.addLayer(this.halo, m);
      return;
    }
    M && (this.halo = new p_(M), this.addLayer(this.halo, m));
  }
  getHalo() {
    return this.halo;
  }
  setHalo(o) {
    if (this.isGlobeProjection()) {
      if (this.halo) {
        this.halo.setGradient(o);
        return;
      }
      this.halo = new p_(o), this.once("load", () => {
        var m;
        const b = this.getLayersOrder(), M = b[0], z = b.indexOf(((m = this.space) == null ? void 0 : m.id) ?? "") + 2, S = b[z];
        this.halo && this.addLayer(this.halo, this.space ? S : M);
      });
    }
  }
  /**
   * Recreates the map instance with the same options.
   * Useful for WebGL context loss.
   */
  recreate() {
    const o = {
      center: this.getCenter(),
      zoom: this.getZoom(),
      bearing: this.getBearing(),
      pitch: this.getPitch()
    };
    this.remove(), Object.assign(this, new Yx({ ...this.options })), this.once("load", () => {
      this.jumpTo(o);
    });
  }
  /**
   * Set the duration (millisec) of the terrain animation for growing or flattening.
   * Must be positive. (Built-in default: `1000` milliseconds)
   */
  setTerrainAnimationDuration(o) {
    this.terrainAnimationDuration = Math.max(o, 0);
  }
  /**
   * Awaits for _this_ Map instance to be "loaded" and returns a Promise to the Map.
   * If _this_ Map instance is already loaded, the Promise is resolved directly,
   * otherwise, it is resolved as a result of the "load" event.
   * @returns
   */
  async onLoadAsync() {
    return new Promise((o) => {
      if (this.loaded()) {
        o(this);
        return;
      }
      this.once("load", () => {
        o(this);
      });
    });
  }
  /**
   * Awaits for _this_ Map instance to be "ready" and returns a Promise to the Map.
   * If _this_ Map instance is already ready, the Promise is resolved directly,
   * otherwise, it is resolved as a result of the "ready" event.
   * A map instance is "ready" when all the controls that can be managed by the contructor are
   * dealt with. This happens after the "load" event, due to the asynchronous nature
   * of some built-in controls.
   */
  async onReadyAsync() {
    return new Promise((o) => {
      if (this.isReady) {
        o(this);
        return;
      }
      this.once("ready", () => {
        o(this);
      });
    });
  }
  /**
   * Awaits for _this_ Map instance to be "loaded" as well as with terrain being non-null for the first time
   * and returns a Promise to the Map.
   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,
   * otherwise, it is resolved as a result of the "loadWithTerrain" event.
   * @returns
   */
  async onLoadWithTerrainAsync() {
    return new Promise((o) => {
      if (this.isReady && this.terrain) {
        o(this);
        return;
      }
      this.once("loadWithTerrain", () => {
        o(this);
      });
    });
  }
  monitorStyleUrl(o) {
    typeof this.monitoredStyleUrls > "u" && (this.monitoredStyleUrls = /* @__PURE__ */ new Set());
    const m = new URL(o);
    m.search = "", this.monitoredStyleUrls.add(m.href);
  }
  /**
   * Update the style of the map.
   * Can be:
   * - a full style URL (possibly with API key)
   * - a shorthand with only the MapTIler style name (eg. `"streets-v2"`)
   * - a longer form with the prefix `"maptiler://"` (eg. `"maptiler://streets-v2"`)
   */
  setStyle(o, m) {
    var b, M, z, S, u;
    this.originalLabelStyle.clear(), (b = this.minimap) == null || b.setStyle(o), this.forceLanguageUpdate = !0, this.once("idle", () => {
      this.forceLanguageUpdate = !1;
    });
    const O = cv(o);
    if (O.requiresUrlMonitoring && this.monitorStyleUrl(O.style), O.isFallback) {
      if (this.getStyle())
        return console.warn(
          "[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Keeping the curent style instead."
        ), this;
      console.warn(
        "[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style."
      );
    }
    const U = this.getStyle(), K = O.style;
    try {
      super.setStyle(O.style, m), this.styleInProcess = !0;
    } catch (J) {
      this.styleInProcess = !1, console.error("[Map.setStyle]: Error while setting style:", J);
    }
    const ae = () => {
      const J = O.style;
      if (!J.projection || J.projection.type === "mercator") {
        console.warn("[Map.setStyle]: Neither space nor halo is supported for mercator projection. Ignoring...");
        return;
      }
      this.setSpaceFromStyle({ style: O.style }), this.setHaloFromStyle({ style: O.style });
    }, he = (J) => {
      var ke, qe, ft, ht;
      const it = J?.target.getStyle() ?? O.style, nt = this.getLayersOrder()[0];
      this.space ? this.setSpaceFromStyle({ style: it }) : this.initSpace({ before: nt, spec: (qe = (ke = it.metadata) == null ? void 0 : ke.maptiler) == null ? void 0 : qe.space }), this.halo ? this.setHaloFromStyle({ style: it }) : this.initHalo({ before: nt, spec: (ht = (ft = it.metadata) == null ? void 0 : ft.maptiler) == null ? void 0 : ht.halo });
    };
    if (typeof O.style == "string" || O.requiresUrlMonitoring)
      return this.on("styledata", he), this;
    if (this.styleInProcess && !this.spaceboxLoadingState.styleLoadCallbackSet)
      return this.once("style.load", he), this.once("styledata", he), this.spaceboxLoadingState.styleLoadCallbackSet = !0, this;
    if (((M = U?.terrain) == null ? void 0 : M.source) !== ((z = K?.terrain) == null ? void 0 : z.source) || ((S = U?.terrain) == null ? void 0 : S.exaggeration) !== ((u = K?.terrain) == null ? void 0 : u.exaggeration))
      return this.once("terrain", ae), this;
    try {
      he();
    } catch {
    }
    return this;
  }
  /**
   * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)
   * to the map's style.
   *
   * A layer defines how data from a specified source will be styled. Read more about layer types
   * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).
   *
   * @param layer - The layer to add,
   * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,
   * less commonly, the {@link CustomLayerInterface} specification.
   * The MapLibre Style Specification's layer definition is appropriate for most layers.
   *
   * @param beforeId - The ID of an existing layer to insert the new layer before,
   * resulting in the new layer appearing visually beneath the existing layer.
   * If this argument is not specified, the layer will be appended to the end of the layers array
   * and appear visually above all other layers.
   *
   * @returns `this`
   */
  addLayer(o, m) {
    var b;
    return (b = this.minimap) == null || b.addLayer(o, m), super.addLayer(o, m);
  }
  /**
   * Moves a layer to a different z-position.
   *
   * @param id - The ID of the layer to move.
   * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.
   * @returns `this`
   *
   * @example
   * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.
   * ```ts
   * map.moveLayer('polygon', 'country-label');
   * ```
   */
  moveLayer(o, m) {
    var b;
    return (b = this.minimap) == null || b.moveLayer(o, m), super.moveLayer(o, m);
  }
  /**
   * Removes the layer with the given ID from the map's style.
   *
   * An {@link ErrorEvent} will be fired if the image parameter is invald.
   *
   * @param id - The ID of the layer to remove
   * @returns `this`
   *
   * @example
   * If a layer with ID 'state-data' exists, remove it.
   * ```ts
   * if (map.getLayer('state-data')) map.removeLayer('state-data');
   * ```
   */
  removeLayer(o) {
    var m;
    return (m = this.minimap) == null || m.removeLayer(o), super.removeLayer(o);
  }
  /**
   * Sets the zoom extent for the specified style layer. The zoom extent includes the
   * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)
   * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))
   * at which the layer will be rendered.
   *
   * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the
   * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum
   * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style
   * layer will not be rendered at all zoom levels in the zoom range.
   */
  setLayerZoomRange(o, m, b) {
    var M;
    return (M = this.minimap) == null || M.setLayerZoomRange(o, m, b), super.setLayerZoomRange(o, m, b);
  }
  /**
   * Sets the filter for the specified style layer.
   *
   * Filters control which features a style layer renders from its source.
   * Any feature for which the filter expression evaluates to `true` will be
   * rendered on the map. Those that are false will be hidden.
   *
   * Use `setFilter` to show a subset of your source data.
   *
   * To clear the filter, pass `null` or `undefined` as the second parameter.
   */
  setFilter(o, m, b) {
    var M;
    return (M = this.minimap) == null || M.setFilter(o, m, b), super.setFilter(o, m, b);
  }
  /**
   * Sets the value of a paint property in the specified style layer.
   *
   * @param layerId - The ID of the layer to set the paint property in.
   * @param name - The name of the paint property to set.
   * @param value - The value of the paint property to set.
   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
   * @param options - Options object.
   * @returns `this`
   * @example
   * ```ts
   * map.setPaintProperty('my-layer', 'fill-color', '#faafee');
   * ```
   */
  setPaintProperty(o, m, b, M) {
    var z;
    return (z = this.minimap) == null || z.setPaintProperty(o, m, b, M), super.setPaintProperty(o, m, b, M);
  }
  /**
   * Sets the value of a layout property in the specified style layer.
   * Layout properties define how the layer is styled.
   * Layout properties for layers of the same type are documented together.
   * Layers of different types have different layout properties.
   * See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.
   * @param layerId - The ID of the layer to set the layout property in.
   * @param name - The name of the layout property to set.
   * @param value - The value of the layout property to set.
   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
   * @param options - Options object.
   * @returns `this`
   */
  setLayoutProperty(o, m, b, M) {
    var z;
    return (z = this.minimap) == null || z.setLayoutProperty(o, m, b, M), super.setLayoutProperty(o, m, b, M);
  }
  /**
   * Sets the value of the style's glyphs property.
   *
   * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).
   * @param options - Options object.
   * @returns `this`
   * @example
   * ```ts
   * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');
   * ```
   */
  setGlyphs(o, m) {
    var b;
    return (b = this.minimap) == null || b.setGlyphs(o, m), super.setGlyphs(o, m);
  }
  getStyleLanguage() {
    return !this.style || !this.style.stylesheet || !this.style.stylesheet.metadata || typeof this.style.stylesheet.metadata != "object" ? null : "maptiler:language" in this.style.stylesheet.metadata && typeof this.style.stylesheet.metadata["maptiler:language"] == "string" ? g_(this.style.stylesheet.metadata["maptiler:language"]) : null;
  }
  /**
   * Define the primary language of the map. Note that not all the languages shorthands provided are available.
   */
  setLanguage(o) {
    var m;
    (m = this.minimap) == null || m.map.setLanguage(o), this.onStyleReady(() => {
      this.setPrimaryLanguage(o);
    });
  }
  /**
   * Define the primary language of the map. Note that not all the languages shorthands provided are available.
   */
  setPrimaryLanguage(o) {
    const m = this.getStyleLanguage(), b = E0(o, Zi);
    if (!b) {
      console.warn(`The language "${b}" is not supported.`);
      return;
    }
    if (!(b.flag === Zi.STYLE.flag && m && (m.flag === Zi.AUTO.flag || m.flag === Zi.VISITOR.flag)) && (b.flag !== Zi.STYLE.flag && (this.languageAlwaysBeenStyle = !1), this.languageAlwaysBeenStyle || this.primaryLanguage === b && !this.forceLanguageUpdate))
      return;
    if (this.primaryLanguage.flag === Zi.STYLE_LOCK.flag) {
      console.warn("The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.");
      return;
    }
    this.primaryLanguage = b;
    let M = b;
    if (b.flag === Zi.STYLE.flag) {
      if (!m) {
        console.warn("The style has no default languages or has an invalid one.");
        return;
      }
      M = m;
    }
    let z = Zi.LOCAL.flag, S = ["get", z];
    M.flag === Zi.VISITOR.flag ? (z = B0().flag, S = [
      "case",
      ["all", ["has", z], ["has", Zi.LOCAL.flag]],
      [
        "case",
        ["==", ["get", z], ["get", Zi.LOCAL.flag]],
        ["get", Zi.LOCAL.flag],
        ["format", ["get", z], { "font-scale": 0.8 }, `
`, ["get", Zi.LOCAL.flag], { "font-scale": 1.1 }]
      ],
      ["get", Zi.LOCAL.flag]
    ]) : M.flag === Zi.VISITOR_ENGLISH.flag ? (z = Zi.ENGLISH.flag, S = [
      "case",
      ["all", ["has", z], ["has", Zi.LOCAL.flag]],
      [
        "case",
        ["==", ["get", z], ["get", Zi.LOCAL.flag]],
        ["get", Zi.LOCAL.flag],
        ["format", ["get", z], { "font-scale": 0.8 }, `
`, ["get", Zi.LOCAL.flag], { "font-scale": 1.1 }]
      ],
      ["get", Zi.LOCAL.flag]
    ]) : M.flag === Zi.AUTO.flag ? (z = B0().flag, S = ["coalesce", ["get", z], ["get", Zi.LOCAL.flag]]) : M === Zi.LOCAL ? (z = Zi.LOCAL.flag, S = ["get", z]) : (z = M.flag, S = ["coalesce", ["get", z], ["get", Zi.LOCAL.flag]]);
    const { layers: u } = this.getStyle(), O = this.originalLabelStyle.size === 0;
    if (O) {
      const U = wb(u, this);
      this.isStyleLocalized = Object.keys(U.localized).length > 0;
    }
    for (const U of u) {
      if (U.type !== "symbol")
        continue;
      const K = U, ae = this.getSource(K.source);
      if (!ae || !("url" in ae && typeof ae.url == "string") || new URL(ae.url).host !== rs.maptilerApiHost)
        continue;
      const { id: he, layout: J } = K;
      if (!J || !("text-field" in J))
        continue;
      let ke;
      if (O ? (ke = this.getLayoutProperty(he, "text-field"), this.originalLabelStyle.set(he, ke)) : ke = this.originalLabelStyle.get(he), typeof ke == "string") {
        const { contains: qe, exactMatch: ft } = yb(ke, this.isStyleLocalized);
        if (!qe) continue;
        if (ft)
          this.setLayoutProperty(he, "text-field", S);
        else {
          const ht = _b(ke, S, this.isStyleLocalized);
          this.setLayoutProperty(he, "text-field", ht);
        }
      } else {
        const qe = gb(ke, S, this.isStyleLocalized);
        this.setLayoutProperty(he, "text-field", qe);
      }
    }
    this.languageIsUpdated = !0;
  }
  /**
   * Get the primary language
   * @returns
   */
  getPrimaryLanguage() {
    return this.primaryLanguage;
  }
  /**
   * Get the exaggeration factor applied to the terrain
   * @returns
   */
  getTerrainExaggeration() {
    return this.terrainExaggeration;
  }
  /**
   * Know if terrian is enabled or not
   * @returns
   */
  hasTerrain() {
    return this.isTerrainEnabled;
  }
  growTerrain(o) {
    if (!this.terrain)
      return;
    const m = performance.now(), b = this.terrain.exaggeration, M = o - b, z = () => {
      if (!this.terrain || this.terrainFlattening)
        return;
      const S = (performance.now() - m) / this.terrainAnimationDuration;
      if (S < 0.99) {
        const u = 1 - (1 - S) ** 4, O = b + u * M;
        this.terrain.exaggeration = O, requestAnimationFrame(z);
      } else
        this.terrainGrowing = !1, this.terrainFlattening = !1, this.terrain.exaggeration = o, this.fire("terrainAnimationStop", { terrain: this.terrain });
      this._elevationFreeze = !1, this.triggerRepaint();
    };
    !this.terrainGrowing && !this.terrainFlattening && this.fire("terrainAnimationStart", { terrain: this.terrain }), this.terrainGrowing = !0, this.terrainFlattening = !1, requestAnimationFrame(z);
  }
  /**
   * Enables the 3D terrain visualization
   */
  enableTerrain(o = this.terrainExaggeration) {
    if (o < 0) {
      console.warn("Terrain exaggeration cannot be negative.");
      return;
    }
    const m = (M) => {
      !this.terrain || M.type !== "data" || M.dataType !== "source" || !("source" in M) || M.sourceId !== "maptiler-terrain" || M.source.type !== "raster-dem" || M.isSourceLoaded && (this.off("data", m), this.growTerrain(o));
    }, b = () => {
      this.isTerrainEnabled = !0, this.terrainExaggeration = o, this.on("data", m), this.addSource(rs.terrainSourceId, {
        type: "raster-dem",
        url: rs.terrainSourceURL
      }), this.setTerrain({
        source: rs.terrainSourceId,
        exaggeration: 0
      });
    };
    if (this.getTerrain()) {
      this.isTerrainEnabled = !0, this.growTerrain(o);
      return;
    }
    if (this.loaded() || this.isTerrainEnabled)
      b();
    else {
      const M = () => {
        this.getTerrain() && this.getSource(rs.terrainSourceId) || b();
      };
      this.once("load", () => {
        M();
      }), this.once("moveend", () => {
        M();
      });
    }
  }
  /**
   * Disable the 3D terrain visualization
   */
  disableTerrain() {
    if (!this.terrain)
      return;
    this.isTerrainEnabled = !1;
    const o = performance.now(), m = this.terrain.exaggeration, b = () => {
      if (!this.terrain || this.terrainGrowing)
        return;
      const M = (performance.now() - o) / this.terrainAnimationDuration;
      if (this._elevationFreeze = !1, M < 0.99) {
        const z = (1 - M) ** 4, S = m * z;
        this.terrain.exaggeration = S, requestAnimationFrame(b);
      } else
        this.terrain.exaggeration = 0, this.terrainGrowing = !1, this.terrainFlattening = !1, this.setTerrain(), this.getSource(rs.terrainSourceId) && this.removeSource(rs.terrainSourceId), this.fire("terrainAnimationStop", { terrain: null });
      this.triggerRepaint();
    };
    !this.terrainGrowing && !this.terrainFlattening && this.fire("terrainAnimationStart", { terrain: this.terrain }), this.terrainGrowing = !1, this.terrainFlattening = !0, requestAnimationFrame(b);
  }
  /**
   * Sets the 3D terrain exageration factor.
   * If the terrain was not enabled prior to the call of this method,
   * the method `.enableTerrain()` will be called.
   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.
   * If `animate` is `false`, no animated transition to the newly defined exaggeration.
   */
  setTerrainExaggeration(o, m = !0) {
    !m && this.terrain ? (this.terrainExaggeration = o, this.terrain.exaggeration = o, this.triggerRepaint()) : this.enableTerrain(o);
  }
  /**
   * Perform an action when the style is ready. It could be at the moment of calling this method
   * or later.
   */
  onStyleReady(o) {
    this.isStyleLoaded() ? o() : this.once("styledata", () => {
      o();
    });
  }
  async fitToIpBounds() {
    const o = await z0.info();
    this.fitBounds(o.country_bounds, {
      duration: 0,
      padding: 100
    });
  }
  async centerOnIpPoint(o) {
    const m = await z0.info();
    this.jumpTo({
      center: [m.longitude ?? 0, m.latitude ?? 0],
      zoom: o || 11
    });
  }
  getCameraHash() {
    const o = new Float32Array(5), m = this.getCenter();
    return o[0] = m.lng, o[1] = m.lat, o[2] = this.getZoom(), o[3] = this.getPitch(), o[4] = this.getBearing(), ib.fromUint8Array(new Uint8Array(o.buffer));
  }
  /**
   * Get the SDK config object.
   * This is convenient to dispatch the SDK configuration to externally built layers
   * that do not directly have access to the SDK configuration but do have access to a Map instance.
   */
  getSdkConfig() {
    return Ha;
  }
  /**
   * Get the MapTiler session ID. Convenient to dispatch to externaly built component
   * that do not directly have access to the SDK configuration but do have access to a Map instance.
   * @returns
   */
  getMaptilerSessionId() {
    return B_;
  }
  /**
   *  Updates the requestManager's transform request with a new function.
   *
   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.
   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties
   *
   * @returns {Map} `this`
   *
   *  @example
   *  map.setTransformRequest((url: string, resourceType: string) => {});
   */
  setTransformRequest(o) {
    return super.setTransformRequest(F0(o)), this;
  }
  /**
   * Returns whether a globe projection is currently being used
   */
  isGlobeProjection() {
    const o = this.getProjection();
    return o ? o.type === "globe" : !1;
  }
  /**
   * Activate the globe projection.
   */
  enableGlobeProjection() {
    this.isGlobeProjection() !== !0 && (this.setProjection({ type: "globe" }), this.curentProjection = "globe");
  }
  /**
   * Activate the mercator projection.
   */
  enableMercatorProjection() {
    this.isGlobeProjection() !== !1 && (this.setProjection({ type: "mercator" }), this.curentProjection = "mercator");
  }
  /**
   * Returns `true` is the language was ever updated, meaning changed
   * from what is delivered in the style.
   * Returns `false` if language in use is the language from the style
   * and has never been changed.
   */
  isLanguageUpdated() {
    return this.languageIsUpdated;
  }
};
Lt.Evented;
function Lg(d) {
  const o = d.toString(16);
  return o.length === 1 ? `0${o}` : o;
}
function DS(d) {
  return `#${Lg(d[0])}${Lg(d[1])}${Lg(d[2])}${d.length === 4 ? Lg(d[3]) : ""}`;
}
class Kt extends Array {
  constructor(o = {}) {
    super(), St(this, "min", 0), St(this, "max", 1), "min" in o && (this.min = o.min), "max" in o && (this.max = o.max), "stops" in o && this.setStops(o.stops, { clone: !1 });
  }
  /**
   * Converts a array-definition color ramp definition into a usable ColorRamp instance.
   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)
   * @param cr
   * @returns
   */
  static fromArrayDefinition(o) {
    return new Kt({
      stops: o.map((m) => ({
        value: m[0],
        color: m[1]
      }))
    });
  }
  setStops(o, m = { clone: !0 }) {
    const b = m.clone ? this.clone() : this;
    b.length = 0;
    let M = Number.POSITIVE_INFINITY, z = Number.NEGATIVE_INFINITY;
    for (let S = 0; S < o.length; S += 1)
      M = Math.min(M, o[S].value), z = Math.max(z, o[S].value), b.push({
        value: o[S].value,
        color: o[S].color.slice()
        // we want to make sure we do a deep copy and not a reference
      });
    return b.sort((S, u) => S.value < u.value ? -1 : 1), this.min = M, this.max = z, b;
  }
  scale(o, m, b = { clone: !0 }) {
    const M = b.clone, z = this[0].value, S = this.at(-1).value - z, u = m - o, O = [];
    for (let U = 0; U < this.length; U += 1) {
      const K = (this[U].value - z) / S * u + o;
      M ? O.push({
        value: K,
        color: this[U].color.slice()
      }) : this[U].value = K;
    }
    return M ? new Kt({ stops: O }) : this;
  }
  // for some reason, I had to reimplement this
  at(o) {
    return o < 0 ? this[this.length + o] : this[o];
  }
  clone() {
    return new Kt({ stops: this.getRawColorStops() });
  }
  getRawColorStops() {
    const o = [];
    for (let m = 0; m < this.length; m += 1)
      o.push({ value: this[m].value, color: this[m].color });
    return o;
  }
  reverse(o = { clone: !0 }) {
    const m = o.clone ? this.clone() : this;
    for (let b = 0; b < ~~(m.length / 2); b += 1) {
      const M = m[b].color;
      m[b].color = m.at(-(b + 1)).color, m.at(-(b + 1)).color = M;
    }
    return m;
  }
  getBounds() {
    return { min: this.min, max: this.max };
  }
  getColor(o, m = { smooth: !0 }) {
    if (o <= this[0].value)
      return this[0].color;
    if (o >= this.at(-1).value)
      return this.at(-1).color;
    for (let b = 0; b < this.length - 1; b += 1) {
      if (o > this[b + 1].value)
        continue;
      const M = this[b].color;
      if (!m.smooth)
        return M.slice();
      const z = this[b].value, S = this[b + 1].value, u = this[b + 1].color, O = (S - o) / (S - z);
      return M.map((U, K) => Math.round(U * O + u[K] * (1 - O)));
    }
    return [0, 0, 0];
  }
  /**
   * Get the color as an hexadecimal string
   */
  getColorHex(o, m = {
    smooth: !0,
    withAlpha: !1
  }) {
    return DS(this.getColor(o, m));
  }
  /**
   * Get the color of the color ramp at a relative position in [0, 1]
   */
  getColorRelative(o, m = { smooth: !0 }) {
    const b = this.getBounds();
    return this.getColor(b.min + o * (b.max - b.min), m);
  }
  getCanvasStrip(o = {
    horizontal: !0,
    size: 512,
    smooth: !0
  }) {
    const m = document.createElement("canvas");
    m.width = o.horizontal ? o.size : 1, m.height = o.horizontal ? 1 : o.size;
    const b = m.getContext("2d");
    if (!b) throw new Error("Canvs context is missing");
    const M = b.getImageData(0, 0, m.width, m.height), z = M.data, S = o.size, u = this[0].value, O = (this.at(-1).value - u) / S;
    for (let U = 0; U < S; U += 1) {
      const K = this.getColor(u + U * O, {
        smooth: o.smooth
      });
      z[U * 4] = K[0], z[U * 4 + 1] = K[1], z[U * 4 + 2] = K[2], z[U * 4 + 3] = K.length > 3 ? K[3] : 255;
    }
    return b.putImageData(M, 0, 0), m;
  }
  /**
   * Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.
   */
  resample(o, m = 15) {
    const b = this.getBounds(), M = this.scale(0, 1), z = 1 / (m - 1);
    let S;
    if (o === "ease-in-square")
      S = Array.from({ length: m }, (u, O) => {
        const U = O * z, K = U ** 2, ae = M.getColor(K);
        return { value: U, color: ae };
      });
    else if (o === "ease-out-square")
      S = Array.from({ length: m }, (u, O) => {
        const U = O * z, K = 1 - (1 - U) ** 2, ae = M.getColor(K);
        return { value: U, color: ae };
      });
    else if (o === "ease-out-sqrt")
      S = Array.from({ length: m }, (u, O) => {
        const U = O * z, K = U ** 0.5, ae = M.getColor(K);
        return { value: U, color: ae };
      });
    else if (o === "ease-in-sqrt")
      S = Array.from({ length: m }, (u, O) => {
        const U = O * z, K = 1 - (1 - U) ** 0.5, ae = M.getColor(K);
        return { value: U, color: ae };
      });
    else if (o === "ease-out-exp")
      S = Array.from({ length: m }, (u, O) => {
        const U = O * z, K = 1 - 2 ** (-10 * U), ae = M.getColor(K);
        return { value: U, color: ae };
      });
    else if (o === "ease-in-exp")
      S = Array.from({ length: m }, (u, O) => {
        const U = O * z, K = 2 ** (10 * U - 10), ae = M.getColor(K);
        return { value: U, color: ae };
      });
    else
      throw new Error("Invalid ressampling method.");
    return new Kt({ stops: S }).scale(b.min, b.max);
  }
  /**
   * Makes a clone of this color ramp that is fully transparant at the begining of their range
   */
  transparentStart() {
    const o = this.getRawColorStops();
    o.unshift({
      value: o[0].value,
      color: o[0].color.slice()
    }), o[1].value += 1e-3;
    for (const m of o)
      m.color.length === 3 && m.color.push(255);
    return o[0].color[3] = 0, new Kt({ stops: o });
  }
  /**
   * Check if this color ramp has a transparent start
   */
  hasTransparentStart() {
    return this[0].color.length === 4 && this[0].color[3] === 0;
  }
}
new Kt({
  stops: [
    { value: 0, color: [0, 0, 0, 0] },
    { value: 1, color: [0, 0, 0, 0] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 0] },
    { value: 1, color: [255, 255, 255] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 131] },
    { value: 0.125, color: [0, 60, 170] },
    { value: 0.375, color: [5, 255, 255] },
    { value: 0.625, color: [255, 255, 0] },
    { value: 0.875, color: [250, 0, 0] },
    { value: 1, color: [128, 0, 0] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [255, 0, 0] },
    { value: 0.169, color: [253, 255, 2] },
    { value: 0.173, color: [247, 255, 2] },
    { value: 0.337, color: [0, 252, 4] },
    { value: 0.341, color: [0, 252, 10] },
    { value: 0.506, color: [1, 249, 255] },
    { value: 0.671, color: [2, 0, 253] },
    { value: 0.675, color: [8, 0, 253] },
    { value: 0.839, color: [255, 0, 251] },
    { value: 0.843, color: [255, 0, 245] },
    { value: 1, color: [255, 0, 6] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 0] },
    { value: 0.3, color: [230, 0, 0] },
    { value: 0.6, color: [255, 210, 0] },
    { value: 1, color: [255, 255, 255] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [255, 0, 255] },
    { value: 1, color: [255, 255, 0] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 128, 102] },
    { value: 1, color: [255, 255, 102] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [255, 0, 0] },
    { value: 1, color: [255, 255, 0] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 255] },
    { value: 1, color: [0, 255, 128] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 0] },
    { value: 0.376, color: [84, 84, 116] },
    { value: 0.753, color: [169, 200, 200] },
    { value: 1, color: [255, 255, 255] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 0] },
    { value: 0.804, color: [255, 160, 102] },
    { value: 1, color: [255, 199, 127] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 0] },
    { value: 1, color: [255, 255, 255] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [8, 29, 88] },
    { value: 0.125, color: [37, 52, 148] },
    { value: 0.25, color: [34, 94, 168] },
    { value: 0.375, color: [29, 145, 192] },
    { value: 0.5, color: [65, 182, 196] },
    { value: 0.625, color: [127, 205, 187] },
    { value: 0.75, color: [199, 233, 180] },
    { value: 0.875, color: [237, 248, 217] },
    { value: 1, color: [255, 255, 217] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 68, 27] },
    { value: 0.125, color: [0, 109, 44] },
    { value: 0.25, color: [35, 139, 69] },
    { value: 0.375, color: [65, 171, 93] },
    { value: 0.5, color: [116, 196, 118] },
    { value: 0.625, color: [161, 217, 155] },
    { value: 0.75, color: [199, 233, 192] },
    { value: 0.875, color: [229, 245, 224] },
    { value: 1, color: [247, 252, 245] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [128, 0, 38] },
    { value: 0.125, color: [189, 0, 38] },
    { value: 0.25, color: [227, 26, 28] },
    { value: 0.375, color: [252, 78, 42] },
    { value: 0.5, color: [253, 141, 60] },
    { value: 0.625, color: [254, 178, 76] },
    { value: 0.75, color: [254, 217, 118] },
    { value: 0.875, color: [255, 237, 160] },
    { value: 1, color: [255, 255, 204] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 255] },
    { value: 1, color: [255, 0, 0] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [5, 10, 172] },
    { value: 0.35, color: [106, 137, 247] },
    { value: 0.5, color: [190, 190, 190] },
    { value: 0.6, color: [220, 170, 132] },
    { value: 0.7, color: [230, 145, 90] },
    { value: 1, color: [178, 10, 28] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 255] },
    { value: 0.1, color: [51, 153, 255] },
    { value: 0.2, color: [102, 204, 255] },
    { value: 0.3, color: [153, 204, 255] },
    { value: 0.4, color: [204, 204, 255] },
    { value: 0.5, color: [255, 255, 255] },
    { value: 0.6, color: [255, 204, 255] },
    { value: 0.7, color: [255, 153, 255] },
    { value: 0.8, color: [255, 102, 204] },
    { value: 0.9, color: [255, 102, 102] },
    { value: 1, color: [255, 0, 0] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [150, 0, 90] },
    { value: 0.125, color: [0, 0, 200] },
    { value: 0.25, color: [0, 25, 255] },
    { value: 0.375, color: [0, 152, 255] },
    { value: 0.5, color: [44, 255, 150] },
    { value: 0.625, color: [151, 255, 0] },
    { value: 0.75, color: [255, 234, 0] },
    { value: 0.875, color: [255, 111, 0] },
    { value: 1, color: [255, 0, 0] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [12, 51, 131] },
    { value: 0.25, color: [10, 136, 186] },
    { value: 0.5, color: [242, 211, 56] },
    { value: 0.75, color: [242, 143, 56] },
    { value: 1, color: [217, 30, 30] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 0] },
    { value: 0.2, color: [230, 0, 0] },
    { value: 0.4, color: [230, 210, 0] },
    { value: 0.7, color: [255, 255, 255] },
    { value: 1, color: [160, 200, 255] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 130] },
    { value: 0.1, color: [0, 180, 180] },
    { value: 0.2, color: [40, 210, 40] },
    { value: 0.4, color: [230, 230, 50] },
    { value: 0.6, color: [120, 70, 20] },
    { value: 1, color: [255, 255, 255] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 0] },
    { value: 0.15, color: [30, 0, 100] },
    { value: 0.4, color: [120, 0, 100] },
    { value: 0.6, color: [160, 90, 0] },
    { value: 0.8, color: [230, 200, 0] },
    { value: 1, color: [255, 250, 220] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [68, 1, 84] },
    { value: 0.13, color: [71, 44, 122] },
    { value: 0.25, color: [59, 81, 139] },
    { value: 0.38, color: [44, 113, 142] },
    { value: 0.5, color: [33, 144, 141] },
    { value: 0.63, color: [39, 173, 129] },
    { value: 0.75, color: [92, 200, 99] },
    { value: 0.88, color: [170, 220, 50] },
    { value: 1, color: [253, 231, 37] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 4] },
    { value: 0.13, color: [31, 12, 72] },
    { value: 0.25, color: [85, 15, 109] },
    { value: 0.38, color: [136, 34, 106] },
    { value: 0.5, color: [186, 54, 85] },
    { value: 0.63, color: [227, 89, 51] },
    { value: 0.75, color: [249, 140, 10] },
    { value: 0.88, color: [249, 201, 50] },
    { value: 1, color: [252, 255, 164] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 4] },
    { value: 0.13, color: [28, 16, 68] },
    { value: 0.25, color: [79, 18, 123] },
    { value: 0.38, color: [129, 37, 129] },
    { value: 0.5, color: [181, 54, 122] },
    { value: 0.63, color: [229, 80, 100] },
    { value: 0.75, color: [251, 135, 97] },
    { value: 0.88, color: [254, 194, 135] },
    { value: 1, color: [252, 253, 191] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [13, 8, 135] },
    { value: 0.13, color: [75, 3, 161] },
    { value: 0.25, color: [125, 3, 168] },
    { value: 0.38, color: [168, 34, 150] },
    { value: 0.5, color: [203, 70, 121] },
    { value: 0.63, color: [229, 107, 93] },
    { value: 0.75, color: [248, 148, 65] },
    { value: 0.88, color: [253, 195, 40] },
    { value: 1, color: [240, 249, 33] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [125, 0, 179] },
    { value: 0.13, color: [172, 0, 187] },
    { value: 0.25, color: [219, 0, 170] },
    { value: 0.38, color: [255, 0, 130] },
    { value: 0.5, color: [255, 63, 74] },
    { value: 0.63, color: [255, 123, 0] },
    { value: 0.75, color: [234, 176, 0] },
    { value: 0.88, color: [190, 228, 0] },
    { value: 1, color: [147, 255, 0] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [125, 0, 179] },
    { value: 0.13, color: [116, 0, 218] },
    { value: 0.25, color: [98, 74, 237] },
    { value: 0.38, color: [68, 146, 231] },
    { value: 0.5, color: [0, 204, 197] },
    { value: 0.63, color: [0, 247, 146] },
    { value: 0.75, color: [0, 255, 88] },
    { value: 0.88, color: [40, 255, 8] },
    { value: 1, color: [147, 255, 0] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [125, 0, 179] },
    { value: 0.1, color: [199, 0, 180] },
    { value: 0.2, color: [255, 0, 121] },
    { value: 0.3, color: [255, 108, 0] },
    { value: 0.4, color: [222, 194, 0] },
    { value: 0.5, color: [150, 255, 0] },
    { value: 0.6, color: [0, 255, 55] },
    { value: 0.7, color: [0, 246, 150] },
    { value: 0.8, color: [50, 167, 222] },
    { value: 0.9, color: [103, 51, 235] },
    { value: 1, color: [124, 0, 186] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [40, 26, 44] },
    { value: 0.13, color: [59, 49, 90] },
    { value: 0.25, color: [64, 76, 139] },
    { value: 0.38, color: [63, 110, 151] },
    { value: 0.5, color: [72, 142, 158] },
    { value: 0.63, color: [85, 174, 163] },
    { value: 0.75, color: [120, 206, 163] },
    { value: 0.88, color: [187, 230, 172] },
    { value: 1, color: [253, 254, 204] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [47, 15, 62] },
    { value: 0.13, color: [87, 23, 86] },
    { value: 0.25, color: [130, 28, 99] },
    { value: 0.38, color: [171, 41, 96] },
    { value: 0.5, color: [206, 67, 86] },
    { value: 0.63, color: [230, 106, 84] },
    { value: 0.75, color: [242, 149, 103] },
    { value: 0.88, color: [249, 193, 135] },
    { value: 1, color: [254, 237, 176] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [18, 36, 20] },
    { value: 0.13, color: [25, 63, 41] },
    { value: 0.25, color: [24, 91, 59] },
    { value: 0.38, color: [13, 119, 72] },
    { value: 0.5, color: [18, 148, 80] },
    { value: 0.63, color: [80, 173, 89] },
    { value: 0.75, color: [132, 196, 122] },
    { value: 0.88, color: [175, 221, 162] },
    { value: 1, color: [215, 249, 208] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [54, 14, 36] },
    { value: 0.13, color: [89, 23, 80] },
    { value: 0.25, color: [110, 45, 132] },
    { value: 0.38, color: [120, 77, 178] },
    { value: 0.5, color: [120, 113, 213] },
    { value: 0.63, color: [115, 151, 228] },
    { value: 0.75, color: [134, 185, 227] },
    { value: 0.88, color: [177, 214, 227] },
    { value: 1, color: [230, 241, 241] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [30, 4, 110] },
    { value: 0.13, color: [47, 14, 176] },
    { value: 0.25, color: [41, 45, 236] },
    { value: 0.38, color: [25, 99, 212] },
    { value: 0.5, color: [68, 131, 200] },
    { value: 0.63, color: [114, 156, 197] },
    { value: 0.75, color: [157, 181, 203] },
    { value: 0.88, color: [200, 208, 216] },
    { value: 1, color: [241, 237, 236] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [60, 9, 18] },
    { value: 0.13, color: [100, 17, 27] },
    { value: 0.25, color: [142, 20, 29] },
    { value: 0.38, color: [177, 43, 27] },
    { value: 0.5, color: [192, 87, 63] },
    { value: 0.63, color: [205, 125, 105] },
    { value: 0.75, color: [216, 162, 148] },
    { value: 0.88, color: [227, 199, 193] },
    { value: 1, color: [241, 237, 236] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [64, 5, 5] },
    { value: 0.13, color: [106, 6, 15] },
    { value: 0.25, color: [144, 26, 7] },
    { value: 0.38, color: [168, 64, 3] },
    { value: 0.5, color: [188, 100, 4] },
    { value: 0.63, color: [206, 136, 11] },
    { value: 0.75, color: [220, 174, 25] },
    { value: 0.88, color: [231, 215, 44] },
    { value: 1, color: [248, 254, 105] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [51, 20, 24] },
    { value: 0.13, color: [90, 32, 35] },
    { value: 0.25, color: [129, 44, 34] },
    { value: 0.38, color: [159, 68, 25] },
    { value: 0.5, color: [182, 99, 19] },
    { value: 0.63, color: [199, 134, 22] },
    { value: 0.75, color: [212, 171, 35] },
    { value: 0.88, color: [221, 210, 54] },
    { value: 1, color: [225, 253, 75] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [145, 105, 18] },
    { value: 0.13, color: [184, 71, 38] },
    { value: 0.25, color: [186, 58, 115] },
    { value: 0.38, color: [160, 71, 185] },
    { value: 0.5, color: [110, 97, 218] },
    { value: 0.63, color: [50, 123, 164] },
    { value: 0.75, color: [31, 131, 110] },
    { value: 0.88, color: [77, 129, 34] },
    { value: 1, color: [145, 105, 18] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [42, 24, 108] },
    { value: 0.13, color: [33, 50, 162] },
    { value: 0.25, color: [15, 90, 145] },
    { value: 0.38, color: [40, 118, 137] },
    { value: 0.5, color: [59, 146, 135] },
    { value: 0.63, color: [79, 175, 126] },
    { value: 0.75, color: [120, 203, 104] },
    { value: 0.88, color: [193, 221, 100] },
    { value: 1, color: [253, 239, 154] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [4, 35, 51] },
    { value: 0.13, color: [23, 51, 122] },
    { value: 0.25, color: [85, 59, 157] },
    { value: 0.38, color: [129, 79, 143] },
    { value: 0.5, color: [175, 95, 130] },
    { value: 0.63, color: [222, 112, 101] },
    { value: 0.75, color: [249, 146, 66] },
    { value: 0.88, color: [249, 196, 65] },
    { value: 1, color: [232, 250, 91] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [34, 31, 27] },
    { value: 0.13, color: [65, 50, 41] },
    { value: 0.25, color: [98, 69, 52] },
    { value: 0.38, color: [131, 89, 57] },
    { value: 0.5, color: [161, 112, 59] },
    { value: 0.63, color: [185, 140, 66] },
    { value: 0.75, color: [202, 174, 88] },
    { value: 0.88, color: [216, 209, 126] },
    { value: 1, color: [233, 246, 171] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [17, 32, 64] },
    { value: 0.13, color: [35, 52, 116] },
    { value: 0.25, color: [29, 81, 156] },
    { value: 0.38, color: [31, 113, 162] },
    { value: 0.5, color: [50, 144, 169] },
    { value: 0.63, color: [87, 173, 176] },
    { value: 0.75, color: [149, 196, 189] },
    { value: 0.88, color: [203, 221, 211] },
    { value: 1, color: [254, 251, 230] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [23, 35, 19] },
    { value: 0.13, color: [24, 64, 38] },
    { value: 0.25, color: [11, 95, 45] },
    { value: 0.38, color: [39, 123, 35] },
    { value: 0.5, color: [95, 146, 12] },
    { value: 0.63, color: [152, 165, 18] },
    { value: 0.75, color: [201, 186, 69] },
    { value: 0.88, color: [233, 216, 137] },
    { value: 1, color: [255, 253, 205] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 0, 0] },
    { value: 0.07, color: [22, 5, 59] },
    { value: 0.13, color: [60, 4, 105] },
    { value: 0.2, color: [109, 1, 135] },
    { value: 0.27, color: [161, 0, 147] },
    { value: 0.33, color: [210, 2, 142] },
    { value: 0.4, color: [251, 11, 123] },
    { value: 0.47, color: [255, 29, 97] },
    { value: 0.53, color: [255, 54, 69] },
    { value: 0.6, color: [255, 85, 46] },
    { value: 0.67, color: [255, 120, 34] },
    { value: 0.73, color: [255, 157, 37] },
    { value: 0.8, color: [241, 191, 57] },
    { value: 0.87, color: [224, 220, 93] },
    { value: 0.93, color: [218, 241, 142] },
    { value: 1, color: [227, 253, 198] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [0, 32, 77, 255] },
    { value: 0.125, color: [5, 54, 110, 255] },
    { value: 0.25, color: [65, 77, 108, 255] },
    { value: 0.375, color: [97, 100, 111, 255] },
    { value: 0.5, color: [125, 124, 121, 255] },
    { value: 0.625, color: [156, 149, 120, 255] },
    { value: 0.75, color: [190, 175, 111, 255] },
    { value: 0.875, color: [225, 204, 94, 255] },
    { value: 1, color: [255, 235, 70, 255] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [48, 18, 59, 255] },
    { value: 0.125, color: [70, 107, 227, 255] },
    { value: 0.25, color: [40, 187, 236, 255] },
    { value: 0.375, color: [49, 242, 153, 255] },
    { value: 0.5, color: [162, 252, 60, 255] },
    { value: 0.625, color: [237, 208, 58, 255] },
    { value: 0.75, color: [251, 128, 34, 255] },
    { value: 0.875, color: [210, 49, 5, 255] },
    { value: 1, color: [122, 4, 3, 255] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [250, 235, 221, 0] },
    { value: 0.133, color: [250, 235, 221, 255] },
    { value: 0.266, color: [246, 170, 130, 255] },
    { value: 0.4, color: [240, 96, 67, 255] },
    { value: 0.533, color: [203, 27, 79, 255] },
    { value: 0.666, color: [132, 30, 90, 255] },
    { value: 0.8, color: [63, 27, 68, 255] },
    { value: 1, color: [3, 5, 26, 255] }
  ]
}), new Kt({
  stops: [
    { value: 0, color: [11, 4, 5, 255] },
    { value: 0.125, color: [43, 28, 53, 255] },
    { value: 0.25, color: [62, 53, 107, 255] },
    { value: 0.375, color: [59, 86, 152, 255] },
    { value: 0.5, color: [53, 123, 162, 255] },
    { value: 0.625, color: [53, 158, 170, 255] },
    { value: 0.75, color: [73, 193, 173, 255] },
    { value: 0.875, color: [150, 221, 181, 255] },
    { value: 1, color: [222, 245, 229, 255] }
  ]
});
db();
function LS() {
  return "3.8.0";
}
Lt.Map;
Lt.Marker;
Lt.Popup;
Lt.Style;
Lt.CanvasSource;
Lt.GeoJSONSource;
Lt.ImageSource;
Lt.RasterTileSource;
Lt.RasterDEMTileSource;
Lt.VectorTileSource;
Lt.VideoSource;
Lt.NavigationControl;
Lt.GeolocateControl;
Lt.AttributionControl;
Lt.LogoControl;
Lt.ScaleControl;
Lt.FullscreenControl;
Lt.TerrainControl;
Lt.BoxZoomHandler;
Lt.ScrollZoomHandler;
Lt.CooperativeGesturesHandler;
Lt.KeyboardHandler;
Lt.TwoFingersTouchPitchHandler;
Lt.MapWheelEvent;
Lt.MapTouchEvent;
Lt.MapMouseEvent;
Lt.config;
Lt.getVersion;
const {
  setRTLTextPlugin: RT,
  getRTLTextPluginStatus: DT,
  LngLat: LT,
  LngLatBounds: OS,
  MercatorCoordinate: OT,
  Evented: BT,
  AJAXError: NT,
  prewarm: jT,
  clearPrewarmedResources: UT,
  Hash: FT,
  Point: VT,
  EdgeInsets: qT,
  DragRotateHandler: GT,
  DragPanHandler: ZT,
  TwoFingersTouchZoomRotateHandler: $T,
  DoubleClickZoomHandler: HT,
  TwoFingersTouchZoomHandler: XT,
  TwoFingersTouchRotateHandler: YT,
  getWorkerCount: KT,
  setWorkerCount: WT,
  getMaxParallelImageRequests: JT,
  setMaxParallelImageRequests: QT,
  getWorkerUrl: eM,
  setWorkerUrl: tM,
  addSourceType: iM,
  importScriptInWorkers: nM,
  addProtocol: aM,
  removeProtocol: rM
} = Lt, BS = ({ locations: d, onClose: o }) => {
  const m = ei.useRef(null), b = ei.useRef(null), M = ei.useRef([]);
  return Ha.apiKey = "0FajRzKAPn5mPalBVFd6", ei.useEffect(() => {
    if (b.current) return;
    b.current = new Xx({
      container: m.current,
      style: "019a1736-e944-74a8-83cb-629deaf97cb8",
      zoom: 12,
      navigationControl: !1,
      geolocateControl: !1
    }), b.current.addControl(
      new jx(),
      "top-right"
    ), b.current.addControl(
      new Ux(),
      "top-right"
    );
    const z = document.createElement("div");
    z.className = "maplibregl-ctrl maplibregl-ctrl-group";
    const S = document.createElement("button");
    S.className = "maplibregl-ctrl-button text-black hover:text-blue-500", S.title = "Close map", S.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" 
           viewBox="0 0 24 24" 
           width="24" 
           height="24" 
           fill="none" 
           stroke="currentColor" 
           stroke-width="2" 
           stroke-linecap="round" 
           stroke-linejoin="round" 
           aria-hidden="true">
        <line x1="18" y1="6" x2="6" y2="18" />
        <line x1="6" y1="6" x2="18" y2="18" />
      </svg>
    `, S.style.display = "flex", S.style.justifyContent = "center", S.style.alignItems = "center", S.style.padding = "0", S.addEventListener("click", o), z.appendChild(S), b.current.addControl(
      new Fx(
        z
      ),
      "top-left"
    );
  }, [d]), ei.useEffect(() => {
    if (!b.current || (M.current.forEach((S) => S.remove()), M.current = [], d.length === 0)) return;
    const z = new OS();
    d.forEach(({ lat: S, lng: u, name: O, address: U, homepage: K, callLetters: ae, telephone: he, email: J, thumbnail: ke }) => {
      if (S == null || S == "" || u == null || u == "")
        return;
      const qe = new Sb({ color: "#FF0000" }).setLngLat([u, S]).addTo(b.current), ft = document.createElement("div");
      Iv.createRoot(ft).render(
        /* @__PURE__ */ Se.jsxs("div", { className: "flex justify-center items-center gap-1 h-32", children: [
          /* @__PURE__ */ Se.jsx(
            "img",
            {
              className: "w-20 h-20 rounded-full",
              src: `https://listen.eternityready.com/${ke}`
            }
          ),
          /* @__PURE__ */ Se.jsx("div", { className: "bg-gray-500 w-px h-full" }),
          /* @__PURE__ */ Se.jsxs("div", { className: "flex flex-col", children: [
            /* @__PURE__ */ Se.jsx("h1", { className: "text-black font-bold text-lg", children: O }),
            /* @__PURE__ */ Se.jsx("h2", { className: "text-gray-500 font-bold", children: ae }),
            /* @__PURE__ */ Se.jsx("h2", { className: "text-gray-500", children: U }),
            /* @__PURE__ */ Se.jsx("a", { href: K, className: "text-red-500", children: K })
          ] })
        ] })
      );
      const it = new Tb({ maxWidth: "none" }).setDOMContent(ft);
      qe.setPopup(it), M.current.push(qe), z.extend([u, S]);
    }), b.current.setCenter([-98.583333, 39.833333]), b.current.setZoom(2.5);
  }, [d]), /* @__PURE__ */ Se.jsx("div", { ref: m, style: { width: "100%", height: "100%" } });
};
var Kx = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, zv = Eu.createContext && /* @__PURE__ */ Eu.createContext(Kx), NS = ["attr", "size", "title"];
function jS(d, o) {
  if (d == null) return {};
  var m = US(d, o), b, M;
  if (Object.getOwnPropertySymbols) {
    var z = Object.getOwnPropertySymbols(d);
    for (M = 0; M < z.length; M++)
      b = z[M], !(o.indexOf(b) >= 0) && Object.prototype.propertyIsEnumerable.call(d, b) && (m[b] = d[b]);
  }
  return m;
}
function US(d, o) {
  if (d == null) return {};
  var m = {};
  for (var b in d)
    if (Object.prototype.hasOwnProperty.call(d, b)) {
      if (o.indexOf(b) >= 0) continue;
      m[b] = d[b];
    }
  return m;
}
function ey() {
  return ey = Object.assign ? Object.assign.bind() : function(d) {
    for (var o = 1; o < arguments.length; o++) {
      var m = arguments[o];
      for (var b in m)
        Object.prototype.hasOwnProperty.call(m, b) && (d[b] = m[b]);
    }
    return d;
  }, ey.apply(this, arguments);
}
function Pv(d, o) {
  var m = Object.keys(d);
  if (Object.getOwnPropertySymbols) {
    var b = Object.getOwnPropertySymbols(d);
    o && (b = b.filter(function(M) {
      return Object.getOwnPropertyDescriptor(d, M).enumerable;
    })), m.push.apply(m, b);
  }
  return m;
}
function ty(d) {
  for (var o = 1; o < arguments.length; o++) {
    var m = arguments[o] != null ? arguments[o] : {};
    o % 2 ? Pv(Object(m), !0).forEach(function(b) {
      FS(d, b, m[b]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(d, Object.getOwnPropertyDescriptors(m)) : Pv(Object(m)).forEach(function(b) {
      Object.defineProperty(d, b, Object.getOwnPropertyDescriptor(m, b));
    });
  }
  return d;
}
function FS(d, o, m) {
  return o = VS(o), o in d ? Object.defineProperty(d, o, { value: m, enumerable: !0, configurable: !0, writable: !0 }) : d[o] = m, d;
}
function VS(d) {
  var o = qS(d, "string");
  return typeof o == "symbol" ? o : o + "";
}
function qS(d, o) {
  if (typeof d != "object" || !d) return d;
  var m = d[Symbol.toPrimitive];
  if (m !== void 0) {
    var b = m.call(d, o);
    if (typeof b != "object") return b;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (o === "string" ? String : Number)(d);
}
function Wx(d) {
  return d && d.map((o, m) => /* @__PURE__ */ Eu.createElement(o.tag, ty({
    key: m
  }, o.attr), Wx(o.child)));
}
function nl(d) {
  return (o) => /* @__PURE__ */ Eu.createElement(GS, ey({
    attr: ty({}, d.attr)
  }, o), Wx(d.child));
}
function GS(d) {
  var o = (m) => {
    var {
      attr: b,
      size: M,
      title: z
    } = d, S = jS(d, NS), u = M || m.size || "1em", O;
    return m.className && (O = m.className), d.className && (O = (O ? O + " " : "") + d.className), /* @__PURE__ */ Eu.createElement("svg", ey({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, m.attr, b, S, {
      className: O,
      style: ty(ty({
        color: d.color || m.color
      }, m.style), d.style),
      height: u,
      width: u,
      xmlns: "http://www.w3.org/2000/svg"
    }), z && /* @__PURE__ */ Eu.createElement("title", null, z), d.children);
  };
  return zv !== void 0 ? /* @__PURE__ */ Eu.createElement(zv.Consumer, null, (m) => o(m)) : o(Kx);
}
function ZS(d) {
  return nl({ attr: { viewBox: "0 0 256 512" }, child: [{ tag: "path", attr: { d: "M9.4 278.6c-12.5-12.5-12.5-32.8 0-45.3l128-128c9.2-9.2 22.9-11.9 34.9-6.9s19.8 16.6 19.8 29.6l0 256c0 12.9-7.8 24.6-19.8 29.6s-25.7 2.2-34.9-6.9l-128-128z" }, child: [] }] })(d);
}
function Jx(d) {
  return nl({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z" }, child: [] }] })(d);
}
function $S(d) {
  return nl({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M233.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L256 173.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z" }, child: [] }] })(d);
}
function HS(d) {
  return nl({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256 0a256 256 0 1 0 0 512A256 256 0 1 0 256 0zM127 297c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l71 71L232 120c0-13.3 10.7-24 24-24s24 10.7 24 24l0 214.1 71-71c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9L273 409c-9.4 9.4-24.6 9.4-33.9 0L127 297z" }, child: [] }] })(d);
}
function XS(d) {
  return nl({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM385 215c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-71-71L280 392c0 13.3-10.7 24-24 24s-24-10.7-24-24l0-214.1-71 71c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9L239 103c9.4-9.4 24.6-9.4 33.9 0L385 215z" }, child: [] }] })(d);
}
function YS(d) {
  return nl({ attr: { viewBox: "0 0 384 512" }, child: [{ tag: "path", attr: { d: "M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80L0 432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z" }, child: [] }] })(d);
}
function KS(d) {
  return nl({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M304 48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zm0 416a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM48 304a48 48 0 1 0 0-96 48 48 0 1 0 0 96zm464-48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM142.9 437A48 48 0 1 0 75 369.1 48 48 0 1 0 142.9 437zm0-294.2A48 48 0 1 0 75 75a48 48 0 1 0 67.9 67.9zM369.1 437A48 48 0 1 0 437 369.1 48 48 0 1 0 369.1 437z" }, child: [] }] })(d);
}
function WS(d) {
  return nl({ attr: { viewBox: "0 0 384 512" }, child: [{ tag: "path", attr: { d: "M0 128C0 92.7 28.7 64 64 64H320c35.3 0 64 28.7 64 64V384c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V128z" }, child: [] }] })(d);
}
function JS(d) {
  return nl({ attr: { viewBox: "0 0 640 512" }, child: [{ tag: "path", attr: { d: "M533.6 32.5C598.5 85.2 640 165.8 640 256s-41.5 170.7-106.4 223.5c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C557.5 398.2 592 331.2 592 256s-34.5-142.2-88.7-186.3c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5zM473.1 107c43.2 35.2 70.9 88.9 70.9 149s-27.7 113.8-70.9 149c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C475.3 341.3 496 301.1 496 256s-20.7-85.3-53.2-111.8c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5zm-60.5 74.5C434.1 199.1 448 225.9 448 256s-13.9 56.9-35.4 74.5c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C393.1 284.4 400 271 400 256s-6.9-28.4-17.7-37.3c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5zM301.1 34.8C312.6 40 320 51.4 320 64l0 384c0 12.6-7.4 24-18.9 29.2s-25 3.1-34.4-5.3L131.8 352 64 352c-35.3 0-64-28.7-64-64l0-64c0-35.3 28.7-64 64-64l67.8 0L266.7 40.1c9.4-8.4 22.9-10.4 34.4-5.3z" }, child: [] }] })(d);
}
function QS(d) {
  return nl({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M301.1 34.8C312.6 40 320 51.4 320 64l0 384c0 12.6-7.4 24-18.9 29.2s-25 3.1-34.4-5.3L131.8 352 64 352c-35.3 0-64-28.7-64-64l0-64c0-35.3 28.7-64 64-64l67.8 0L266.7 40.1c9.4-8.4 22.9-10.4 34.4-5.3zM412.6 181.5C434.1 199.1 448 225.9 448 256s-13.9 56.9-35.4 74.5c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C393.1 284.4 400 271 400 256s-6.9-28.4-17.7-37.3c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5z" }, child: [] }] })(d);
}
function eT(d) {
  return nl({ attr: { viewBox: "0 0 320 512" }, child: [{ tag: "path", attr: { d: "M320 64c0-12.6-7.4-24-18.9-29.2s-25-3.1-34.4 5.3L131.8 160 64 160c-35.3 0-64 28.7-64 64l0 64c0 35.3 28.7 64 64 64l67.8 0L266.7 471.9c9.4 8.4 22.9 10.4 34.4 5.3S320 460.6 320 448l0-384z" }, child: [] }] })(d);
}
function Qx(d) {
  return nl({ attr: { viewBox: "0 0 384 512" }, child: [{ tag: "path", attr: { d: "M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z" }, child: [] }] })(d);
}
const f_ = {
  PLAY: /* @__PURE__ */ Se.jsx(YS, { className: "h-5 w-5 text-xl" }),
  STOP: /* @__PURE__ */ Se.jsx(WS, { className: "h-5 w-5 text-xl" }),
  SPINNER: /* @__PURE__ */ Se.jsx(KS, { className: "h-5 w-5 animate-spin" })
};
function Vd() {
  function d() {
    const { innerWidth: b, innerHeight: M } = window;
    return {
      width: b,
      height: M
    };
  }
  const [o, m] = ei.useState(d);
  return ei.useEffect(() => {
    function b() {
      m(d());
    }
    return window.addEventListener("resize", b), () => window.removeEventListener("resize", b);
  }, []), o;
}
function tT(d) {
  const { height: o, width: m } = Vd();
  return m != null && m < 1280 ? /* @__PURE__ */ Se.jsxs("div", { className: "flex items-center gap-2", children: [
    /* @__PURE__ */ Se.jsx(
      "img",
      {
        alt: d.track?.trackName,
        loading: "lazy",
        width: 56,
        height: 56,
        decoding: "async",
        "data-nimg": 1,
        className: "h-16 w-16 rounded-sm object-cover",
        src: (d.track?.artworkURL?.startsWith("/api/public/stations") ? d.track?.artworkURL?.replace("/api/public/stations", "https://listen.eternityready.com/api/public/stations") : d.track?.artworkURL) || d.track?.artistImage
      }
    ),
    /* @__PURE__ */ Se.jsxs("div", { className: "flex flex-col", children: [
      /* @__PURE__ */ Se.jsx("p", { className: "mb-px line-clamp-1 text-sm font-bold text-white", children: d.track?.trackName }),
      /* @__PURE__ */ Se.jsx("p", { className: "line-clamp-1 text-sm font-medium text-white/60", children: d.track?.artistName })
    ] })
  ] }) : /* @__PURE__ */ Se.jsxs("div", { className: "flex max-w-80 xl:min-w-80 items-center rounded-lg border border-white/10 bg-white/10 p-1", children: [
    /* @__PURE__ */ Se.jsx("div", { className: "aspect-square w-14 h-14", children: /* @__PURE__ */ Se.jsx(
      "img",
      {
        className: "aspect-square h-full w-full rounded-md border border-white/10 object-cover",
        src: (d.track?.artworkURL?.startsWith("/api/public/stations") ? d.track?.artworkURL?.replace("/api/public/stations", "https://listen.eternityready.com/api/public/stations") : d.track?.artworkURL) || d.track?.artistImage
      }
    ) }),
    /* @__PURE__ */ Se.jsxs("div", { className: "ml-2 flex flex-col justify-center", children: [
      /* @__PURE__ */ Se.jsx("p", { className: "line-clamp-1 text-[10px] font-bold text-white/40 uppercase", children: "Now Playing:" }),
      /* @__PURE__ */ Se.jsx("div", { className: "line-clamp-1 text-sm font-extrabold text-white hover:underline", children: d.track?.trackName }),
      /* @__PURE__ */ Se.jsx("div", { className: "line-clamp-1 text-xs font-medium text-white hover:underline", children: d.track?.artistName })
    ] })
  ] });
}
function iT(d) {
  const { height: o, width: m } = Vd();
  let b, M = d.playerState;
  return M === "playing" ? b = f_.STOP : M === "stopped" || M === "ready" ? b = f_.PLAY : b = f_.SPINNER, /* @__PURE__ */ Se.jsxs("div", { className: "flex flex-row gap-2 xl:gap-4 items-center justify-center", children: [
    /* @__PURE__ */ Se.jsx(
      "div",
      {
        className: "flex flex-col justify-center",
        onClick: d.onExpand,
        children: m != null && m < 1280 ? d.expand ? /* @__PURE__ */ Se.jsx(HS, { className: "group-hover:text-primary text-2xl text-white transition-all" }) : /* @__PURE__ */ Se.jsx(XS, { className: "group-hover:text-primary text-2xl text-white transition-all" }) : /* @__PURE__ */ Se.jsx(
          "div",
          {
            className: "group relative flex items-center justify-between rounded-full border border-neutral-50/30 text-sm font-medium whitespace-nowrap text-white transition-all hover:cursor-pointer hover:bg-neutral-50/10 p-3",
            children: d.expand ? /* @__PURE__ */ Se.jsx(Jx, { className: "fill-current group-hover:text-red-500 text-white transition-all" }) : /* @__PURE__ */ Se.jsx($S, { className: "fill-current group-hover:text-red-500 text-white transition-all" })
          }
        )
      }
    ),
    /* @__PURE__ */ Se.jsx(
      "button",
      {
        disabled: d.playerState === "loading",
        className: "bg-red-500 flex items-center justify-center rounded-full text-black transition-all hover:cursor-pointer hover:brightness-125 disabled:opacity-50 h-12 w-12 xl:h-16 xl:w-16",
        onClick: () => d.onTogglePlayer(),
        children: b
      }
    )
  ] });
}
function nT(d) {
  const [o, m] = ei.useState(!1), b = ei.useRef();
  ei.useEffect(() => {
    function z(S) {
      b.current && !b.current.contains(S.target) && m(!1);
    }
    return document.addEventListener("mousedown", z), () => document.removeEventListener("mousedown", z);
  }, []);
  let M;
  return d.volume.currentVolume == 0 ? M = /* @__PURE__ */ Se.jsx(eT, { className: "fill-current w-8 text-white font-medium" }) : d.volume.currentVolume < d.volume.maxVolume / 2 ? M = /* @__PURE__ */ Se.jsx(QS, { className: "fill-current w-8 text-white transition-all" }) : M = /* @__PURE__ */ Se.jsx(JS, { className: "fill-current w-8 text-white transition-all" }), /* @__PURE__ */ Se.jsxs(
    "div",
    {
      className: "relative",
      children: [
        /* @__PURE__ */ Se.jsxs(
          "div",
          {
            className: "absolute bottom-full left-0 mb-2 flex items-center justify-center rounded-full border border-neutral-600 bg-black py-3 px-1.5 shadow-lg transition-all duration-300",
            style: {
              opacity: o ? 1 : 0,
              transform: o ? "translateY(0)" : "translateY(10px)"
            },
            ref: b,
            children: [
              M,
              /* @__PURE__ */ Se.jsx(
                "input",
                {
                  type: "range",
                  id: "volume",
                  name: "volume",
                  onChange: (z) => d.volume.onVolume(z.target.value),
                  value: d.volume.currentVolume,
                  min: d.volume.minVolume,
                  max: d.volume.maxVolume,
                  className: "w-48 h-2 bg-red-500 appearance-none rounded-lg cursor-pointer",
                  style: {
                    background: `linear-gradient(to right, rgb(255, 0, 0) 0%, rgb(255, 0, 0) ${d.volume.currentVolume * 100}%, rgb(64, 64, 64) ${d.volume.currentVolume * 100}%, rgb(64, 64, 64) 100%)`,
                    appearance: "none",
                    "--thumb-color": "white"
                  },
                  step: d.volume.step
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ Se.jsx(
          "div",
          {
            className: "group flex items-center justify-between rounded-full border border-neutral-50/30 px-4 py-3 text-sm font-medium whitespace-nowrap text-white transition-all hover:cursor-pointer hover:bg-neutral-50/10",
            onClick: () => m(!o),
            children: o ? /* @__PURE__ */ Se.jsx(Qx, { className: "fill-current w-8 text-white transition-all" }) : M
          }
        )
      ]
    }
  );
}
function aT(d) {
  const [o, m] = ei.useState(!1);
  return /* @__PURE__ */ Se.jsxs(
    "div",
    {
      className: "relative",
      children: [
        /* @__PURE__ */ Se.jsx(
          "div",
          {
            className: "absolute bottom-full left-0 mb-0 min-w-64 rounded-2xl border border-neutral-600 bg-black p-2 shadow-lg flex flex-col gap-y-1 transition-all",
            style: {
              opacity: o ? 1 : 0,
              transform: o ? "translateY(0)" : "translateY(10px)",
              pointerEvents: o ? "auto" : "none"
            },
            children: d.stations.map(
              (b, M) => /* @__PURE__ */ Se.jsx(
                "div",
                {
                  className: (
                    // -- Tailwind merge for future update
                    M == d.stationToListen ? "w-full rounded-full px-3 py-1 text-left text-sm transition-all hover:cursor-pointer bg-white/20 font-semibold text-white" : "w-full rounded-full px-3 py-1 text-left text-sm transition-all hover:cursor-pointer text-white/70 hover:bg-white/20 hover:text-white"
                  ),
                  onClick: () => o && d.onStationSelected(M),
                  children: b
                }
              )
            )
          }
        ),
        /* @__PURE__ */ Se.jsxs(
          "div",
          {
            className: "group flex items-center justify-between rounded-full border border-neutral-50/30 px-4 py-2 text-sm font-medium whitespace-nowrap text-white transition-all hover:cursor-pointer hover:bg-neutral-50/10",
            onClick: () => m(!o),
            children: [
              d.stations[d.stationToListen],
              /* @__PURE__ */ Se.jsx(Jx, { className: "ml-3 text-white/50 transition-all group-hover:text-white" })
            ]
          }
        )
      ]
    }
  );
}
function rT(d) {
  return /* @__PURE__ */ Se.jsxs(
    "a",
    {
      className: " group flex justify-between items-center border border-neutral-50/30 hover:cursor-pointer hover:bg-neutral-50/10 transition-all rounded-full text-sm text-white font-medium py-2 px-4 gap-x-2 whitespace-nowrap",
      onClick: d.onClick,
      children: [
        /* @__PURE__ */ Se.jsx(
          "svg",
          {
            className: "fill-current w-6 h-6 text-white/50",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 -960 960 960",
            children: /* @__PURE__ */ Se.jsx(
              "path",
              {
                d: "M480-480q33 0 56.5-23.5T560-560q0-33-23.5-56.5T480-640q-33 0-56.5 23.5T400-560q0 33 23.5 56.5T480-480Zm0 400Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"
              }
            )
          }
        ),
        "Go to  Station Finder"
      ]
    }
  );
}
function sT(d) {
  const { height: o, width: m } = Vd();
  return /* @__PURE__ */ Se.jsxs("div", { className: "col-span-1", children: [
    /* @__PURE__ */ Se.jsx("h3", { className: "mt-5 xl:mt-0 mb-2 text-lg xl:text-2xl font-bold xl:font-extrabold text-white", children: m != null && m < 1280 ? "The Artist" : "About the artist" }),
    m != null && m < 1280 ? /* @__PURE__ */ Se.jsx("a", { href: d.track?.artistViewUrl, children: /* @__PURE__ */ Se.jsxs("div", { className: "relative max-h-64 overflow-clip rounded-xl", children: [
      /* @__PURE__ */ Se.jsx(
        "img",
        {
          alt: d.track?.artistName,
          loading: "lazy",
          width: 600,
          height: 300,
          decoding: "async",
          "data-nimg": 1,
          className: "relative w-full rounded-xl object-cover",
          style: { color: "transparent" },
          src: (d.track?.artistImage?.startsWith("/api/public/stations") ? d.track?.artistImage?.replace("/api/public/stations", "https://listen.eternityready.com/api/public/stations") : d.track?.artistImage) || (d.track?.artworkURL?.startsWith("/api/public/stations") ? d.track?.artworkURL?.replace("/api/public/stations", "https://listen.eternityready.com/api/public/stations") : d.track?.artworkURL)
        }
      ),
      /* @__PURE__ */ Se.jsx("div", { className: "absolute inset-0 h-full w-full bg-gradient-to-t from-black/80 via-black/20 to-transparent" }),
      /* @__PURE__ */ Se.jsx("h3", { className: "absolute bottom-2 left-4 text-lg font-bold text-white drop-shadow-sm", children: d.track?.artistName })
    ] }) }) : /* @__PURE__ */ Se.jsxs(Se.Fragment, { children: [
      /* @__PURE__ */ Se.jsx("a", { href: d.track?.artistViewUrl, children: /* @__PURE__ */ Se.jsx(
        "img",
        {
          alt: d.track?.artistName,
          loading: "lazy",
          width: 600,
          height: 300,
          decoding: "async",
          "data-nimg": 1,
          className: "mb-2 rounded-2xl object-cover transition-all hover:brightness-90 aspect-video max-h-64",
          style: { color: "transparent" },
          src: (d.track?.artistImage?.startsWith("/api/public/stations") ? d.track?.artistImage?.replace("/api/public/stations", "https://listen.eternityready.com/api/public/stations") : d.track?.artistImage) || (d.track?.artworkURL?.startsWith("/api/public/stations") ? d.track?.artworkURL?.replace("/api/public/stations", "https://listen.eternityready.com/api/public/stations") : d.track?.artworkURL)
        }
      ) }),
      /* @__PURE__ */ Se.jsx("h4", { className: "mb-2 text-xl font-extrabold text-white", children: d.track?.artistName }),
      /* @__PURE__ */ Se.jsx("p", { className: "line-clamp-5 font-medium text-neutral-300", children: d.track?.aboutDescription }),
      /* @__PURE__ */ Se.jsx("div", { className: "mt-6 flex", children: /* @__PURE__ */ Se.jsx("div", { className: "", children: /* @__PURE__ */ Se.jsx(
        "a",
        {
          target: "_self",
          className: "group flex items-center justify-center gap-2 rounded-full border-2 px-4 py-2 text-sm font-bold whitespace-nowrap backdrop-blur-2xl transition-all xl:px-5 xl:py-3 border-white text-white hover:bg-white hover:text-black ",
          href: d.track?.artistViewUrl,
          children: "Visit Artist Page"
        }
      ) }) })
    ] })
  ] });
}
function oT(d) {
  const { height: o, width: m } = Vd();
  if (d.track?.relatedSongs)
    return console.log(d.track?.relatedSongs), /* @__PURE__ */ Se.jsxs(Se.Fragment, { children: [
      /* @__PURE__ */ Se.jsx("h3", { className: "mb-2 text-2xl font-extrabold text-white", children: "Related content" }),
      d.track?.relatedSongs?.slice(0, 3)?.map((b) => /* @__PURE__ */ Se.jsx("div", { className: "", children: /* @__PURE__ */ Se.jsxs(
        "a",
        {
          className: "group hidden items-center rounded-xl border p-1 transition-all hover:shadow-xl xl:flex xl:rounded-2xl xl:p-2 undefined border-neutral-800 bg-neutral-800 hover:border-neutral-600 hover:bg-neutral-700",
          href: b?.trackViewUrl ?? b.external_urls?.spotify,
          children: [
            /* @__PURE__ */ Se.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ Se.jsx("div", { className: "overflow-clip rounded-lg xl:rounded-md aspect-video h-16 w-28 xl:h-24 xl:w-40", children: /* @__PURE__ */ Se.jsx(
              "img",
              {
                alt: b?.trackName ?? b?.name,
                loading: "lazy",
                width: 1366,
                height: 768,
                decoding: "async",
                "data-nimg": 1,
                className: "h-full w-full object-cover transition-all duration-500 group-hover:scale-110",
                style: { color: "transparent" },
                src: b?.artworkURL ?? b?.artworkUrl100 ?? b?.album.images[0].url
              }
            ) }) }),
            /* @__PURE__ */ Se.jsxs("div", { className: "flex flex-col px-2 xl:px-4", children: [
              /* @__PURE__ */ Se.jsx("h3", { className: "line-clamp-2 leading-tight font-bold xl:text-lg text-white ", children: b?.trackName ?? b?.name }),
              /* @__PURE__ */ Se.jsxs("div", { className: "mt-1 flex xl:mt-2", children: [
                /* @__PURE__ */ Se.jsx("p", { className: "flex text-sm font-medium transition-all xl:hidden text-neutral-400", children: "Music" }),
                /* @__PURE__ */ Se.jsx("p", { className: "hidden rounded-full px-3 py-1 text-xs font-bold transition-all xl:mt-0 xl:flex bg-neutral-700 text-white group-hover:bg-neutral-600", children: "Music" })
              ] })
            ] })
          ]
        }
      ) }))
    ] });
}
function lT(d) {
  return /* @__PURE__ */ Se.jsx(Se.Fragment, { children: (d.loadingUpcomingTracks || d.upcomingTracks?.length) && /* @__PURE__ */ Se.jsxs(Se.Fragment, { children: [
    /* @__PURE__ */ Se.jsx("h3", { className: "mb-2 text-2xl font-extrabold text-white", children: "On-Air" }),
    /* @__PURE__ */ Se.jsx("div", { className: "", children: /* @__PURE__ */ Se.jsxs(
      "a",
      {
        className: "group flex items-center rounded-full border border-neutral-800 bg-neutral-800 p-2 transition-all hover:border-neutral-600 hover:bg-neutral-700 hover:shadow-xl",
        href: d.station?.homepage,
        children: [
          /* @__PURE__ */ Se.jsx("div", { className: "relative aspect-square w-16 overflow-clip rounded-full xl:h-28 xl:w-28", children: /* @__PURE__ */ Se.jsx(
            "img",
            {
              alt: d.upcomingTracks?.[0]?.artistName,
              loading: "lazy",
              decoding: "async",
              "data-nimg": "fill",
              className: "absolute inset-0 z-10 h-full w-full object-cover",
              style: {
                position: "absolute",
                height: "100%",
                width: "100%",
                inset: 0,
                color: "transparent"
              },
              sizes: "100vw",
              src: `https://listen.eternityready.com/${d.upcomingTracks?.[0]?.artworkURL}`
            }
          ) }),
          /* @__PURE__ */ Se.jsxs("div", { className: "flex flex-1 flex-col px-4", children: [
            /* @__PURE__ */ Se.jsx("h3", { className: "line-clamp-1 leading-tight font-extrabold text-white xl:line-clamp-2 xl:text-lg", children: d.upcomingTracks?.[0]?.artistName }),
            /* @__PURE__ */ Se.jsx("p", { className: "mt-1 text-sm font-medium text-neutral-400", children: d.upcomingTracks?.[0]?.dateScheduled ? (/* @__PURE__ */ new Date(
              d.upcomingTracks?.[0]?.dateScheduled?.replace(" ", "T") + "Z"
            )).toLocaleString(void 0, {
              year: "numeric",
              month: "short",
              day: "numeric",
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
              hour12: !0
            }) : "Invalid date" }),
            /* @__PURE__ */ Se.jsx("p", { className: "mb-1 text-sm font-medium text-neutral-400 xl:mb-3", children: d.upcomingTracks?.[0]?.trackName }),
            /* @__PURE__ */ Se.jsx("div", { className: "flex", children: /* @__PURE__ */ Se.jsx("p", { className: "rounded-full bg-neutral-700 px-3 py-1 text-xs font-bold text-white transition-all group-hover:bg-neutral-600", children: "Visit Station Page" }) })
          ] })
        ]
      }
    ) })
  ] }) });
}
function uT(d) {
  const { height: o, width: m } = Vd();
  return /* @__PURE__ */ Se.jsxs("div", { className: "mt-4", children: [
    /* @__PURE__ */ Se.jsx("h3", { className: "mb-2 text-2xl font-extrabold text-white", children: "Stations" }),
    m != null && m < 1280 ? /* @__PURE__ */ Se.jsx("div", { className: "flex w-full snap-x snap-mandatory gap-4 overflow-x-auto overscroll-x-contain pb-4", children: d.stationsList.map((b, M) => /* @__PURE__ */ Se.jsxs(
      "div",
      {
        className: "group w-24 flex-none shrink-0 snap-center hover:cursor-pointer",
        onClick: () => d.onStationSelected(M),
        children: [
          /* @__PURE__ */ Se.jsx(
            "img",
            {
              alt: b.name,
              loading: "lazy",
              width: 300,
              height: 300,
              decoding: "async",
              "data-nimg": 1,
              className: "aspect-square w-full rounded-xl border border-neutral-50/20 object-cover transition-all hover:brightness-75",
              style: { color: "transparent" },
              src: `https://listen.eternityready.com/${b.logo}`
            }
          ),
          /* @__PURE__ */ Se.jsx("p", { className: "mt-1 text-center text-xs font-medium text-white/70 transition-all group-hover:text-white", children: b.name })
        ]
      }
    )) }) : /* @__PURE__ */ Se.jsx("div", { className: "mb-4 grid grid-cols-5 gap-4", children: d.stationsList.map((b, M) => /* @__PURE__ */ Se.jsxs(
      "div",
      {
        className: "group hover:cursor-pointer",
        onClick: () => d.onStationSelected(M),
        children: [
          /* @__PURE__ */ Se.jsx(
            "img",
            {
              alt: b.name,
              loading: "lazy",
              width: 300,
              height: 300,
              decoding: "async",
              "data-nimg": 1,
              className: "aspect-square w-full rounded-xl border border-neutral-50/20 object-cover transition-all hover:brightness-75",
              style: { color: "transparent" },
              src: `https://listen.eternityready.com/${b.logo}`
            }
          ),
          /* @__PURE__ */ Se.jsx("p", { className: "mt-1 text-center text-xs font-medium text-white/70 transition-all group-hover:text-white", children: b.name })
        ]
      }
    )) })
  ] });
}
function cT(d) {
  const { height: o, width: m } = Vd();
  return /* @__PURE__ */ Se.jsxs("div", { className: "mt-4 pb-20", children: [
    /* @__PURE__ */ Se.jsx("h3", { className: "mb-2 text-lg xl:text-2xl font-bold xl: font-extrabold text-white", children: "Last Played" }),
    m != null && m < 1280 ? /* @__PURE__ */ Se.jsx(
      "div",
      {
        className: "flex w-full snap-x snap-mandatory gap-4 overflow-x-auto overscroll-x-contain pb-4",
        children: d.tracks?.map((b, M) => /* @__PURE__ */ Se.jsxs("div", { className: "w-[85vw] flex-none shrink-0 snap-center", children: [
          /* @__PURE__ */ Se.jsxs(
            "a",
            {
              className: "builder-ignore group hidden items-center rounded-xl border p-1 transition-all hover:shadow-xl lg:flex lg:rounded-2xl lg:p-2 undefined border-neutral-800 bg-neutral-800 hover:border-neutral-600 hover:bg-neutral-700",
              href: b.trackViewUrl,
              children: [
                /* @__PURE__ */ Se.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ Se.jsx("div", { className: "overflow-clip rounded-lg lg:rounded-md aspect-square h-16 w-16 lg:h-24 lg:w-24", children: /* @__PURE__ */ Se.jsx(
                  "img",
                  {
                    alt: b?.trackName || "Last Played",
                    loading: "lazy",
                    width: 1366,
                    height: 768,
                    decoding: "async",
                    "data-nimg": 1,
                    className: "h-full w-full object-cover transition-all duration-500 group-hover:scale-110",
                    style: { color: "transparent" },
                    src: b.artworkURL || b.artistImage
                  }
                ) }) }),
                /* @__PURE__ */ Se.jsxs("div", { className: "flex flex-col px-2 lg:px-4", children: [
                  /* @__PURE__ */ Se.jsx("h3", { className: "line-clamp-2 leading-tight font-bold lg:text-lg text-white builder-ignore", children: b.trackName }),
                  /* @__PURE__ */ Se.jsxs("div", { className: "mt-1 flex lg:mt-2", children: [
                    /* @__PURE__ */ Se.jsx("p", { className: "flex text-sm font-medium transition-all lg:hidden text-neutral-400", children: b.artistName }),
                    /* @__PURE__ */ Se.jsx("p", { className: "hidden rounded-full px-3 py-1 text-xs font-bold transition-all lg:mt-0 lg:flex bg-neutral-700 text-white group-hover:bg-neutral-600", children: b.artistName })
                  ] })
                ] })
              ]
            }
          ),
          /* @__PURE__ */ Se.jsx(
            "a",
            {
              className: "lg:hidden",
              href: b.trackViewUrl,
              children: /* @__PURE__ */ Se.jsxs("div", { className: "flex w-full flex-row items-center rounded-xl border border-neutral-800 bg-neutral-900 text-white", children: [
                /* @__PURE__ */ Se.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ Se.jsx(
                  "img",
                  {
                    alt: b?.trackName || "Last Played",
                    loading: "lazy",
                    width: 1366,
                    height: 768,
                    decoding: "async",
                    "data-nimg": 1,
                    className: "aspect-square w-24 h-auto rounded-xl object-cover p-1",
                    style: { color: "transparent" },
                    src: b.artworkURL || b.artistImage
                  }
                ) }),
                /* @__PURE__ */ Se.jsxs("div", { className: "min-w-0 flex-1 space-y-1 px-2", children: [
                  /* @__PURE__ */ Se.jsx("h3", { className: "line-clamp-2 text-sm leading-tight font-bold text-white builder-ignore", children: b.trackName }),
                  /* @__PURE__ */ Se.jsx("p", { className: "line-clamp-1 text-xs font-medium text-neutral-400", children: b.artistName })
                ] })
              ] })
            }
          )
        ] }))
      }
    ) : /* @__PURE__ */ Se.jsx("div", { className: "grid grid-cols-4 gap-4", children: d.tracks?.map((b, M) => {
      if (M !== 0)
        return /* @__PURE__ */ Se.jsx("a", { href: b.trackViewUrl, target: "_blank", children: /* @__PURE__ */ Se.jsxs("div", { className: "group hover:cursor-pointer", children: [
          /* @__PURE__ */ Se.jsx(
            "img",
            {
              alt: b?.trackName || "Last Played",
              loading: "lazy",
              width: 100,
              height: 100,
              decoding: "async",
              "data-nimg": 1,
              className: "aspect-square w-full rounded-xl border border-neutral-50/20 object-cover transition-all hover:brightness-75",
              style: { color: "transparent" },
              src: b.artworkURL || b.artistImage
            }
          ),
          /* @__PURE__ */ Se.jsx("p", { className: "mt-2 line-clamp-1 text-center text-sm font-bold text-white transition-all", children: b.trackName }),
          /* @__PURE__ */ Se.jsx("p", { className: "line-clamp-1 text-center text-sm font-medium text-white/70 transition-all", children: b.artistName })
        ] }) });
    }) })
  ] });
}
function hT(d) {
  const [o, m] = ei.useState(null);
  return ei.useEffect(() => {
    async function b() {
      const z = await (await fetch("https://azura.eternityready.com/api/nowplaying")).json();
      m(z[0].playing_next.song);
    }
    d.station.name === "Eternity Ready Radio" ? b() : m(null);
  }, [d.station]), o && /* @__PURE__ */ Se.jsxs(Se.Fragment, { children: [
    /* @__PURE__ */ Se.jsx(ZS, { className: "hidden xl:flex h-6 w-6 px-2 text-white/30" }),
    /* @__PURE__ */ Se.jsxs("div", { className: "hidden my-1 xl:flex max-w-80 items-center", children: [
      /* @__PURE__ */ Se.jsx(
        "img",
        {
          alt: o.text,
          loading: "lazy",
          width: "200",
          height: "200",
          decoding: "async",
          "data-nimg": "1",
          className: "mr-2 h-10 w-10 rounded-xs object-cover opacity-60",
          src: o.art,
          style: {
            color: "transparent"
          }
        }
      ),
      /* @__PURE__ */ Se.jsxs("div", { children: [
        /* @__PURE__ */ Se.jsx("p", { className: "line-clamp-1 text-[0.625rem] font-bold tracking-wide text-white/40 uppercase", children: "Up Next:" }),
        /* @__PURE__ */ Se.jsx("p", { className: "line-clamp-1 text-xs font-medium text-white/60", children: `${o.artist} - ${o.title}` })
      ] })
    ] })
  ] });
}
function dT(d) {
  if (!(!(d.loadingUpcomingTracks || d.upcomingTracks?.length) && !d.track?.relatedSongs))
    return /* @__PURE__ */ Se.jsxs("div", { className: "mt-6", children: [
      /* @__PURE__ */ Se.jsxs(
        "h3",
        {
          className: "mb-2 text-lg font-bold text-white",
          children: [
            d.loadingUpcomingTracks || d.upcomingTracks?.length ? "On-Air" : "",
            (d.loadingUpcomingTracks || d.upcomingTracks?.length) && d.track?.relatedSongs ? " & " : "",
            d.track?.relatedSongs ? "Related Content" : ""
          ]
        }
      ),
      /* @__PURE__ */ Se.jsxs("div", { className: "flex w-full snap-x snap-mandatory gap-4 overflow-x-auto overscroll-x-contain pb-4", children: [
        (d.loadingUpcomingTracks || d.upcomingTracks?.length) && /* @__PURE__ */ Se.jsx("div", { className: "w-full flex-none shrink-0 snap-center", children: /* @__PURE__ */ Se.jsxs(
          "a",
          {
            className: "group flex items-center rounded-full border p-2 transition-all hover:shadow-xl border-neutral-800 bg-neutral-800 hover:border-neutral-600 hover:bg-neutral-700",
            href: d.station?.homepage,
            children: [
              /* @__PURE__ */ Se.jsx("div", { className: "relative aspect-square w-16 overflow-clip rounded-full lg:h-28 lg:w-28", children: /* @__PURE__ */ Se.jsx(
                "img",
                {
                  alt: d.upcomingTracks?.[0]?.artistName,
                  loading: "lazy",
                  decoding: "async",
                  "data-nimg": "fill",
                  className: "absolute inset-0 z-10 h-full w-full object-cover",
                  style: {
                    position: "absolute",
                    height: "100%",
                    width: "100%",
                    inset: 0,
                    color: "transparent"
                  },
                  sizes: "100vw",
                  src: `https://listen.eternityready.com/${d.upcomingTracks?.[0]?.artworkURL}`
                }
              ) }),
              /* @__PURE__ */ Se.jsxs("div", { className: "flex flex-1 flex-col px-4", children: [
                /* @__PURE__ */ Se.jsx("h3", { className: "line-clamp-1 leading-tight font-extrabold lg:line-clamp-2 lg:text-lg text-white", children: d.upcomingTracks?.[0]?.artistName }),
                /* @__PURE__ */ Se.jsx("p", { className: "mb-1 text-sm font-medium lg:mb-3 text-neutral-400", children: d.upcomingTracks?.[0]?.dateScheduled ? (/* @__PURE__ */ new Date(
                  d.upcomingTracks?.[0]?.dateScheduled?.replace(" ", "T") + "Z"
                )).toLocaleString(void 0, {
                  year: "numeric",
                  month: "short",
                  day: "numeric",
                  hour: "2-digit",
                  minute: "2-digit",
                  second: "2-digit",
                  hour12: !0
                }) : "Invalid date" }),
                /* @__PURE__ */ Se.jsx("div", { className: "flex", children: /* @__PURE__ */ Se.jsx("p", { className: "rounded-full px-3 py-1 text-xs font-bold transition-all bg-neutral-700 text-white group-hover:bg-neutral-600", children: d.upcomingTracks?.[0]?.trackName }) })
              ] })
            ]
          }
        ) }),
        d.track?.relatedSongs?.slice(0, 3)?.map((o) => /* @__PURE__ */ Se.jsxs("div", { className: "w-full flex-none shrink-0 snap-center", children: [
          /* @__PURE__ */ Se.jsxs(
            "a",
            {
              className: "builder-ignore group hidden items-center rounded-xl border p-1 transition-all hover:shadow-xl lg:flex lg:rounded-2xl lg:p-2 undefined border-neutral-800 bg-neutral-800 hover:border-neutral-600 hover:bg-neutral-700",
              href: o?.trackViewUrl ?? o.external_urls?.spotify,
              children: [
                /* @__PURE__ */ Se.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ Se.jsx("div", { className: "overflow-clip rounded-lg lg:rounded-md aspect-video h-16 w-28 lg:h-24 lg:w-40", children: /* @__PURE__ */ Se.jsx(
                  "img",
                  {
                    alt: o?.trackName ?? o?.name,
                    loading: "lazy",
                    width: 1366,
                    height: 768,
                    decoding: "async",
                    "data-nimg": 1,
                    className: "h-full w-full object-cover transition-all duration-500 group-hover:scale-110",
                    style: { color: "transparent" },
                    src: o?.artworkURL ?? o?.artworkUrl100 ?? o?.album.images[0].url
                  }
                ) }) }),
                /* @__PURE__ */ Se.jsxs("div", { className: "flex flex-col px-2 lg:px-4", children: [
                  /* @__PURE__ */ Se.jsx("h3", { className: "line-clamp-2 leading-tight font-bold lg:text-lg text-white builder-ignore", children: o?.trackName ?? o?.name }),
                  /* @__PURE__ */ Se.jsxs("div", { className: "mt-1 flex lg:mt-2", children: [
                    /* @__PURE__ */ Se.jsxs("p", { className: "flex text-sm font-medium transition-all lg:hidden text-neutral-400", children: [
                      "By ",
                      o?.artistName ?? o?.artists?.[0]?.name
                    ] }),
                    /* @__PURE__ */ Se.jsxs("p", { className: "hidden rounded-full px-3 py-1 text-xs font-bold transition-all lg:mt-0 lg:flex bg-neutral-700 text-white group-hover:bg-neutral-600", children: [
                      "By ",
                      o?.artistName ?? o?.artists?.[0]?.name
                    ] })
                  ] })
                ] })
              ]
            }
          ),
          /* @__PURE__ */ Se.jsx(
            "a",
            {
              className: "lg:hidden",
              href: o?.trackViewUrl ?? o.external_urls?.spotify,
              children: /* @__PURE__ */ Se.jsxs("div", { className: "flex w-full flex-row items-center rounded-xl border border-neutral-800 bg-neutral-900 text-white", children: [
                /* @__PURE__ */ Se.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ Se.jsx(
                  "img",
                  {
                    alt: o?.trackName ?? o?.name,
                    loading: "lazy",
                    width: 1366,
                    height: 768,
                    decoding: "async",
                    "data-nimg": 1,
                    className: "aspect-video w-32 h-auto rounded-xl object-cover p-1",
                    style: { color: "transparent" },
                    src: o?.artworkURL ?? o?.artworkUrl100 ?? o?.album.images[0].url
                  }
                ) }),
                /* @__PURE__ */ Se.jsxs("div", { className: "min-w-0 flex-1 space-y-1 px-2", children: [
                  /* @__PURE__ */ Se.jsx("h3", { className: "line-clamp-2 text-sm leading-tight font-bold text-white builder-ignore", children: o?.trackName ?? o?.name }),
                  /* @__PURE__ */ Se.jsxs("p", { className: "line-clamp-1 text-xs font-medium text-neutral-400", children: [
                    "By ",
                    o?.artistName ?? o?.artists?.[0]?.name
                  ] })
                ] })
              ] })
            }
          )
        ] }))
      ] })
    ] });
}
function pT(d) {
  const { station: o, setStation: m, currentPlaying: b, stationsList: M, tracks: z, loadingTracks: S, loadingUpcomingTracks: u, upcomingTracks: O } = ei.useContext(R_), { player: U, playerState: K, externalStation: ae, setExternalStation: he, playerVolume: J, setPlayerIsLoaded: ke, changeVolume: qe, currentTrack: ft } = ei.useContext(Rv), [ht, it] = ei.useState(!1), [nt, De] = ei.useState(!1), [Re, $e] = ei.useState(null), { height: rt, width: wt } = Vd();
  let Ht = {
    minVolume: 0,
    maxVolume: 1,
    step: 0.02,
    currentVolume: J,
    onVolume: (Xt) => {
      qe(Xt);
    }
  };
  function Dt() {
    K === "playing" ? U.stop() : (ke(!0), U.play());
  }
  if (o)
    return /* @__PURE__ */ Se.jsxs(
      "div",
      {
        className: "font-inter fixed right-0 bottom-16 xl:bottom-0 left-0 z-[100] flex-col border-t border-neutral-700 xl:flex",
        children: [
          nt && /* @__PURE__ */ Se.jsxs(
            "div",
            {
              className: "relative overflow-y-auto z-1 flex flex-col items-center justify-center bg-black/80 backdrop-blur-3xl text-white p-8",
              style: { height: "calc(100vh - 4rem)" },
              children: [
                /* @__PURE__ */ Se.jsx("h1", { className: "text-3xl font-semibold mb-4", children: "Stations" }),
                /* @__PURE__ */ Se.jsx("div", { className: "w-[80vw] h-[80vh] border border-neutral-700 flex items-center justify-center rounded-xl", children: /* @__PURE__ */ Se.jsx(
                  BS,
                  {
                    onClose: () => De(!1),
                    locations: M.map((Xt) => {
                      const pi = Xt.location?.split(", "), vn = pi?.[0] ? Number(pi[0]) : null, Cn = pi?.[1] ? Number(pi[1]) : null;
                      return {
                        ...Xt,
                        lat: vn,
                        lng: Cn
                      };
                    })
                  }
                ) })
              ]
            }
          ),
          ht && /* @__PURE__ */ Se.jsxs(Se.Fragment, { children: [
            wt != null && wt >= 1280 && /* @__PURE__ */ Se.jsx("div", { className: "fixed left-[5vw] z-[200]", children: /* @__PURE__ */ Se.jsx(
              "button",
              {
                className: "group hover:z-[200] -mt-8 flex h-16 w-16 items-center justify-center rounded-full border border-neutral-700 bg-black/80 font-medium text-white transition-all hover:cursor-pointer hover:border-neutral-600 hover:bg-neutral-600",
                onClick: () => it(!1),
                children: /* @__PURE__ */ Se.jsx(Qx, { className: "text-white transition-all group-hover:text-xl" })
              }
            ) }),
            /* @__PURE__ */ Se.jsx(
              "div",
              {
                className: "relative z-[100] w-full bg-black/80 backdrop-blur-3xl overflow-y-auto",
                style: {
                  height: wt != null && wt >= 1280 ? "750px" : "100dvh",
                  maxHeight: wt != null && wt >= 1280 ? "calc(100vh - 4rem)" : "calc(100dvh - 8rem)"
                },
                children: /* @__PURE__ */ Se.jsx("div", { className: "mx-auto xl:max-w-[90vw]", children: /* @__PURE__ */ Se.jsxs("div", { className: "grid grid-cols-1 xl:grid-cols-3 gap-0 xl:gap-20 p-4 xl:p-12", children: [
                  /* @__PURE__ */ Se.jsx(sT, { track: ft }),
                  /* @__PURE__ */ Se.jsx("div", { className: "col-span-1 space-y-4", children: wt != null && wt < 1280 ? /* @__PURE__ */ Se.jsx(
                    dT,
                    {
                      track: ft,
                      loadingUpcomingTracks: u,
                      upcomingTracks: O,
                      station: o
                    }
                  ) : /* @__PURE__ */ Se.jsxs(Se.Fragment, { children: [
                    /* @__PURE__ */ Se.jsx(oT, { track: ft }),
                    /* @__PURE__ */ Se.jsx(
                      lT,
                      {
                        loadingUpcomingTracks: u,
                        upcomingTracks: O,
                        station: o
                      }
                    )
                  ] }) }),
                  /* @__PURE__ */ Se.jsxs("div", { className: "col-span-1", children: [
                    /* @__PURE__ */ Se.jsx(
                      uT,
                      {
                        stationsList: M,
                        onStationSelected: async (Xt) => {
                          await U.switchEndpoint(), m(M[Xt]), he(null);
                        }
                      }
                    ),
                    /* @__PURE__ */ Se.jsx(cT, { tracks: z })
                  ] })
                ] }) })
              }
            )
          ] }),
          /* @__PURE__ */ Se.jsxs(
            "div",
            {
              className: "flex h-20 w-full cursor-pointer justify-between border-t border-white/20 bg-black/90 px-3 py-1.5 shadow-lg backdrop-blur-3xl transition-all hover:bg-black/80",
              onClick: (Xt) => {
                Xt.target === Xt.currentTarget && (De(!1), it((pi) => !pi));
              },
              children: [
                /* @__PURE__ */ Se.jsxs("div", { className: "flex items-center", children: [
                  /* @__PURE__ */ Se.jsx(tT, { track: ft }),
                  /* @__PURE__ */ Se.jsx(hT, { station: o })
                ] }),
                /* @__PURE__ */ Se.jsx(
                  iT,
                  {
                    onTogglePlayer: Dt,
                    playerState: K,
                    onExpand: () => {
                      De(!1), it(!ht);
                    },
                    expand: ht
                  }
                ),
                /* @__PURE__ */ Se.jsxs("div", { className: "hidden xl:flex flex-row gap-x-4 items-center", children: [
                  /* @__PURE__ */ Se.jsx(nT, { volume: Ht }),
                  /* @__PURE__ */ Se.jsx(
                    aT,
                    {
                      stations: M.map((Xt) => Xt.name),
                      stationToListen: M.findIndex(
                        (Xt) => Xt.name === o.name
                      ),
                      onStationSelected: async (Xt) => {
                        await U.switchEndpoint(), m(M[Xt]), he(null);
                      }
                    }
                  ),
                  /* @__PURE__ */ Se.jsx(rT, { onClick: () => {
                    it(!1), De((Xt) => !Xt);
                  } })
                ] })
              ]
            }
          )
        ]
      }
    );
}
const fT = ei.forwardRef((d, o) => {
  const [m, b] = ei.useState(null);
  return ei.useImperativeHandle(o, () => ({
    changeExternalStation: (M) => {
      b(M);
    }
  })), /* @__PURE__ */ Se.jsx(h1, { children: /* @__PURE__ */ Se.jsx(S1, { externalStation: m, setExternalStation: b, children: /* @__PURE__ */ Se.jsx(pT, {}) }) });
});
let I_ = null;
async function sM(d, o, m) {
  const b = document.getElementById(d);
  b.shadowRoot || b.attachShadow({ mode: "open" });
  const M = b.shadowRoot;
  try {
    const u = await (await fetch(o)).text();
    let O = M.querySelector("style[data-shadow-tailwind]");
    O || (O = document.createElement("style"), O.setAttribute("data-shadow-tailwind", ""), M.appendChild(O)), O.textContent = u;
  } catch (S) {
    console.error("Failed to load Tailwind CSS into Shadow DOM:", S);
  }
  try {
    const u = await (await fetch(m)).text();
    let O = M.querySelector("style[data-shadow-leaflet]");
    O || (O = document.createElement("style"), O.setAttribute("data-shadow-leaflet", ""), M.appendChild(O)), O.textContent = u;
  } catch (S) {
    console.error("Failed to load Leaflet CSS into Shadow DOM:", S);
  }
  let z = M.querySelector("#react-root");
  z || (z = document.createElement("div"), z.id = "react-root", M.appendChild(z)), I_ = Eu.createRef(), Iv.createRoot(z).render(
    /* @__PURE__ */ Se.jsx(fT, { ref: I_ })
  );
}
function oM() {
  return I_;
}
export {
  fT as E,
  qg as I,
  sM as a,
  oM as b,
  iy as g
};
